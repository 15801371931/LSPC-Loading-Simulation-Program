// LSPCMODEL.cpp: implementation of the CLSPCMODEL class.
//
//////////////////////////////////////////////////////////////////////

#include <stdlib.h>
#include "stdafx.h"
#include "LSPCMODEL.h"
#include "StringToken.h"
#include <math.h>
#include "MainFrm.h"
#include "RecordsetEx.h"
#include <afxtempl.h>
#include <direct.h>
#include <afxdao.h>
#include "LSPC.h"
#include "eta.h"
#include <float.h>
#include <io.h>
#include "INCLUDE/DBFRecordset.h"
#include "ProgressWnd.h"
#include "DirDialog.h"
#include "Windows.h"
#include "Winbase.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

int nPageOrder[]=
{
	0,
	10,
	15,
	20,
	30,
	40,
	45,
	50,
	60,
	70,
	80,
	90,
	32,
	92, 
	93, 
	94, 
	96,
	100,
	110,
	120,
	130,
	140,
	150,
	160,
	170,
	180,
	190,
	200,
	201,	
	202,	
	203,
	204,
	205,
	250,
	255,
	260,
	270,
	271,	
	272,	
	273,	
	274,	
	275,
	276,
	280,
	281,
	282,
	283,
	285,
	286,
	287,
	288,
	289,
	400,
	401,
	405,	
	435,
	410,
	420,
	425,
	430,
	440,
	445,
	446,
	450,
	451,
	452,
	453,
	454,
	455,
	456,
	457,
	460,
	461,
	462,
	463,
	464,
	465,
	466,
	467,
	470,
	475,
	480,
	485,
	500,
	501,
	502,	
	503,	
	504,	
	505,	
	506,	
	507,	
	510,	
	511,
	512,
	513,
	514,
	520,
	521,
	522,
	523,
	524,
	530,
	531,
	532,
	533,
	534,
	535,
	540,
	541,
	542,
	543,
	544,
	600,
	605,
	610,
	660,
	670,
	680,
	685,
	690
};

CString strGComments[]=
{
	"0   general control \n"
	"\n"
	"snowfg   if = 1 run snow module\n"
	"pwafgt   if = 1 run pwater\n"
	"sedfg    if = 1 run sediment\n"
	"pqalfg   if = 1 run general quality\n"
	"tempfg   if = 1 run temperature module\n"
	"oxfg     if = 1 run DO-BOD module\n"				
	"nutfg    if = 1 run nutrients module\n"
	"plkfg    if = 1 run plankton module\n"
	"phfg     if = 1 run pH-CO2 module\n"
	"\n",
	"10  weather file definition (name and parameters)\n"
	"\n"
	"wfileid    weather file id\n"
	"wfilename  weather file name\n"
	"wparamnum  number of parameters in the weather file\n"
	"wparamid   weather paramter id\n"
	"           1-precipitation (in/ivl)\n"
	"           2-potential evaporation (in/ivl)\n"
	"           3-air temperature (degree F)\n"
	"           4-wind speed (mile/ivl)\n"
	"           5-solar radiation (ly/ivl)\n"
	"           6-dew point (degree F)\n"
	"           7-cloud cover (tenth)\n"
	"\n",
	"15  weather station definition (station id and associated weather files)\n"
	"\n"
	"wstationid  weather station id\n"
	"wfilenum  	number of files for the weather station\n"
	"wfileid   	weather file id (card 10)\n"
	"\n",
	"20  weather parameter multiplier\n"
	"\n"
	"station_id  weather station id (card 15)\n"
	"parm_mult   multiplier for each weather parameter\n"
	"            multiplier_1 for precipitation\n"
	"            multiplier_2 for potential evapotranspiration\n"
	"            multiplier_3 for air temperature\n"
	"            multiplier_4 for wind speed\n"
	"            multiplier_5 for solar radiation\n"
	"            multiplier_6 for dew point\n"
	"            multiplier_7 for cloud cover\n" 
	"\n",
	"30  weather stations file path\n"
	"\n"
	"weather station data location:   input (weather) file path\n"
	"\n",
	"40  general watershed controls\n"
	"\n"
	"nsubbasin     number of subbasins\n"
	"nrchid        number of stream channels (corresponds with number of subbasins)\n"
	"nrgid         number of stream groups to assign parameters\n"
	"ndefid        number of land groups to assign parameters\n"
	"ndeluid       maximum number of land use types\n"
	"\n",
	"45 output manager:\n"
	"\n"
	"  standard parameter output: LSPC default output\n"
	"  calibration output: user can choose parameter groups\n"
	"  custom Model Output: user can choose individual parameter for output (card 46)\n"
	"\n"
	"  output landuse summary: average annual or yearly or monthly\n"
	"                          (default is average annual)\n"		
	"  output stream summary: average annual or yearly or monthly\n"
	"                         (default is average annual)\n"		
	"  output point source summary: average annual or yearly or monthly\n"
	"                               (default is average annual)\n"		
	"  SUSTAIN external timeseries: unit-area land timeseries for SUSTAIN external option\n"
	"\n"
	"  model results location: the directory(folder) for model results (card 30)\n"
	"\n",
	"50  model simulation and output time period\n"
	"\n"
	"model input control:\n"
	"start time:      model start day.\n"
	"end time:        model end day.\n"
	"time step        time step (min) \n"
	"\n"
	"model output control:\n"
	"start time:      model output start day.\n"
	"end time:        model output end day.\n"
	"output interval: daily or time interval in minutes\n"
	"                 (default is daily)\n"		
	"\n",
	"60  group information\n"
	"\n"
	"subbasin    subbasin id\n"
	"defid       group parameter id\n"
	"nwst        number of weather stations assigned to the watershed\n"
	"            for i = 1 to n\n"
	"                wst_i  = station id\n"
	"                wt_i   = weighting to calculate input\n"
	"\n",
	"70  modeled land use names\n"
	"\n"
	"deluid      landuse id\n"
	"deluname    landuse name\n"
	"premult     multiplier for Precipitation\n"
	"petmult     multiplier for potential evapotranspiration\n"
	"\n",
	"80  land use to stream routing\n"
	"\n"
	"defid       landuse group parameter id\n"
	"deluid      landuse id\n"
	"route_suro  fraction of surface runoff that routes to the stream (0-1) (default=1)\n"
	"			 if negative (<0) value then that fraction will be lost from the system\n"
	"route_ifwo  fraction of interflow outflow that routes to the stream (0-1) (default=1)\n"
	"			 if negative (<0) value then that fraction will be lost from the system\n"
	"route_agwo  fraction of groundwater outflow that routes to the stream (0-1) (default=1)\n"
	"			 if negative (<0) value then that fraction will be lost from the system\n"
	"\n"
	"Example: 0.3 means 30% of outflow routes to the stream and 70% bypasses to the next downstream in the reach network\n"
	"        -0.3 means 30% of outflow is permanently lost from the system and 70% routes to the stream\n"
	"         Enter a value of -1 to permanently lose all water from the respective layer\n"
	"		  This convention applies to all three parameters (route_suro, route_ifwo, and route_agwo)\n"
	"\n",
	"90  land use information\n"
	"\n"
	"subbasin    subbasin id\n"
	"deluid      land use id\n"
	"deluname    land use name\n"
	"perimp      1 imperivous land (subsurface processes disabled)\n"
	"            2 pervious  land (subsurface processes activated)\n"
	"area_ac     area (acres)\n"
	"slsur       slope of overland flow plane (none)\n"
	"lsur        length of overland flow plane (feet)\n"
	"\n",
	"32  landuse-chnage information\n"
	"\n"
	"LUChangeFlag      flag to use landuse-change file (0=off, 1=on)\n"
	"LUChangeFilePath  landuse-change file path\n"
	"\n",
	"92 snow-settings\n"
	"\n"
	"defid     parameter group id\n"
	"deluid    landuse id\n"
	"iceflag   0 = Ice formation in the snow pack is not simulated\n"
	"          1 = Ice formation is simulated\n"
	"forest    0.0 - 1.0  Fraction of LAND covered by Forest (winter transpiration)\n"
	"fzg       parameter that adjusts for the effect of ice (in the snow pack) on infiltration when iceflag is 1 (/in.)\n"
	"fzgl      lower limit of inffac as adjusted by ice in the snow pack when iceflag is 1\n"
	"\n",
	"93 snow-parm1\n"
	"\n"
	"   defid    parameter group id\n"
	"   deluid   landuse id\n"
	"   lat      latitude of the pervious land segment (PLS) - ENERGY BALANCE METHOD ONLY\n"
	"            positive for the northern hemisphere, negative for southern\n"
	"   melev    mean elevation of LAND above sea level - ENERGY BALANCE METHOD ONLY\n"
	"   shade    fraction of LAND shaded from solar radiation (i.e. by trees) - ENERGY BALANCE METHOD ONLY\n"
	"   snowcf   precipitation-to-snow multiplier (accounts for poor gage-catch efficiency during snow)\n"
	"   covind   maximum snowpack (water equivalent) at which the entire LAND is covered with snow\n"
	"\n",
	"94 snow-parm2\n"
	"\n"
	"   defid    parameter group id\n"
	"   deluid   landuse id\n"
	"   rdcsn    density of cold, new snow relative to water (For snow falling at temps below freezing.\n"
	"            at higher temperatures the density of snow is adjusted)\n"
	"   tsnow    air temperature below which precipitation will be snow, under saturated conditions.\n"
	"            under non-saturated conditions the temperature is adjusted slightly.\n"
	"   snoevp   adapts sublimation equation to field conditions - ENERGY BALANCE METHOD ONLY\n"
	"   ccfact   adapts snow condensation/convection melt equation to field conditions - ENERGY BALANCE METHOD ONLY\n"
	"   mwater   maximum water content of the snow pack, in depth of water per depth of water.\n"
	"   mgmelt   maximum rate of snowmelt by ground heat, in depth of water per day.\n"
	"            this is the value which applies when the pack temperature is at the freezing point.\n"
	"\n",
	"96 snow-init\n"
	"\n"
	"   defid       parameter group id\n"
	"   deluid      panduse id\n"
	"   pack-snow   pnitial quantity of snow in the pack (water equivalent).\n"
	"   pack-ice    pnitial quantity of ice in the pack (water equivalent).\n"
	"   pack-watr   pnitial quantity of liquid water in the pack.\n"
	"   rdenpf      density of the frozen contents (snow and ice) of the pack, relative to water.\n"
	"   dull        index of the dullness of the snow pack surface, from which albedo is estimated - ENERGY BALANCE METHOD ONLY\n"
	"   paktmp      mean temperature of the frozen contents of the snow pack.\n"
	"   covinx      current snow pack depth (water equivalent) required to obtain complete areal coverage of LAND.\n"
	"               if the pack is less than this amount, areal coverage is prorated (PACKF/COVINX).\n"
	"   xlnmlt      current remaining possible increment to ice storage in the pack.\n"
	"               relevant when Ice formation is simulated (iceflag = 1)\n"
	"   skyclr      fraction of sky which is assumed to be clear at the present time.\n"
	"\n",
	"100 pwat-parm1\n"
	"\n"
	"pervious and impervious land hydrology control\n"
	"(value of 0 = use constant pwat-parm4; 1 = use corresponding monthly variable card)\n"
	"\n"
	"vcsfg    interception storage capacity					(card 150)\n"
	"vuzfg    upper zone nominal storage					(card 160)\n"
	"vnnfg    manning's n for the overland flow plane		(card 170)\n"
	"vifwfg   interflow inflow parameter					(card 180)\n"
	"vircfg   interflow recession constant					(card 190)\n"
	"vlefg    lower zone evapotranspiration (e-t) parameter	(card 200)\n"
	"\n",
	"110 pwat-parm2\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"lzsn    lower zone nominal soil moisture storage (inches)\n"
	"infilt  infiltration capacity of the soil (in/hr)\n"
	"kvary   variable groundwater recession (1/inches)\n"
	"agwrc   base groundwater recession (none)\n"
	"\n",
	"120 pwat-parm3\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"petmax  air temperature below which e-t will is reduced (deg F)\n"
	"petmin  air temperature below which e-t is set to zero (deg F)\n"
	"infexp  exponent in the infiltration equation (none)\n"
	"INFILD  ratio between the maximum and mean infiltration capacities over the PLS (none)\n"
	"deepfr  fraction of groundwater inflow that will enter deep groundwater (none)\n"
	"basetp  fraction of remaining potential e-t that can be satisfied from baseflow (none)\n"
	"agwetp  fraction of remaining potential e-t that can be satisfied from active groundwater (none)\n"
	"\n",
	"130 pwat-parm4\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"cepsc   interception storage capacity (inches)\n"
	"uzsn    upper zone nominal storage (inches)\n"
	"nsur    Manning's n for the assumed overland flow plane (none)\n"
	"intfw   interflow inflow parameter (none)\n"
	"irc     interflow recession parameter (none)\n"
	"lzetp   lower zone e-t parameter (none)\n"
	"\n",
	"140 pwat-state1\n"
	"\n"
	"initial conditions for the simulation\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"ceps    initial interception storage.\n"
	"surs    initial surface (overland flow) storage.\n"
	"uzs     initial upper zone storage.\n"
	"ifws    initial interflow storage.\n"
	"lzs     initial lower zone storage.\n"
	"agws    initial active groundwater storage.\n"
	"gwvs    initial index to groundwater slope.\n"
	"\n",
	"150 mon-interception storage (cepscm)\n"
	"\n"
	"only required if vcsfg=1 in pwat-parm1 (see card 100)\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec interception storage capacity at start of each month (inches)\n"
	"\n",
	"160 mon-upper zone nominal storage (uzsnm)\n"
	"\n"
	"only required if vuzfg=1 in pwat-parm1 (see card 100)\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec upper zone nominal storage at start of each month (inches)\n"
	"\n",
	"170 mon-Manning's roughness coefficient (nsurm)\n"
	"\n"
	"only required if vnnfg=1 in pwat-parm1 (see card 100)\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec Manning's roughness coefficient at start of each month (none)\n"
	"\n",
	"180 mon-interflow inflow parameter (intfwm)\n"
	"\n"
	"only required if vifwfg=1 in pwat-parm1 (see card 100)\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec interflow inflow parameter at start of each month (none)\n"
	"\n",
	"190 mon-interflow recession constant (ircm)\n"
	"\n"
	"only required if vircfg=1 in pwat-parm1 (see card 100)\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec interflow recession constant at start of each month (none)\n"
	"\n",
	"200 mon-lower zone evapotranspiration parameter (lzetpm)\n"
	"\n"
	"only required if vlefg=1 in pwat-parm1 (see card 100)\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec lower zone evapotranspiration parameter at start of each month (none)\n"
	"\n",
    "201 irrigation application option flags\n"  //Irrigation option
	"\n"
    "irrigation flag decides whether to run irrigation\n"
    "constant pet flag decides whether to use constant pet or time series from air file\n"
	"monthly-variable ET coefficient flag decides whether to use monthly-variable ET coefficients or constant values\n"
	"\n"
    "irrigfg       if = 1 run irrigation option\n"
    "petfg         if = 1 use constant pet value (card 202)\n"
	"monVaryIrrig  if = 1 use monthly varying ET coefficient\n"
	"\n",
    "202 irrigation PET Values\n"  
	"\n"
    "irrigation PET values for each group and landuse (only if petfg = 1)\n"
	"\n"
    "defid        parameter group id\n"
	"petval       constant pet value to calculate irrigation demand (in/hr)\n"
	"\n",
    "203 irrigation application options\n"  
	"\n"
    "irrigation information for each group and landuse\n"
	"\n"
    "defid        parameter group id\n"
    "deluid       landuse id\n"
    "startmonth   startmonth of irrigation requirement\n"
    "endmonth     endmonth of irrigation requirement\n"
    "fraction1    fraction of irrigation requirement applied over the canopy.\n"
    "fraction2    fraction of irrigation water applied directly to the soil surface.\n"
    "fraction3    fraction of irrigation water applied to the upper soil zone via buried systems.\n"
    "fraction4    fraction of irrigation water likewise applied to the lower soil zone.\n"
    "fraction5    fraction of irrigation water entering directly into the local groundwater, such as seepage irrigation.\n"
    "etcoeff      coefficient to calculate actual ET, based on PET.\n"
	"etdays       number of threshold days to calculate irrigation demand (pet*etcoeff - precip)\n"
	"             (if etdays = 0 then irrigation demand = pet * etcoeff)\n"
	"\n",
	"204  monthly-variable ET coefficients\n"
	"\n"
    "defid      parameter group id\n"
    "deluid     landuse id\n"
    "monetcs    monthly-variable coefficient to calculate actual ET for Jan..Dec\n"
	"\n",
	"205 irrigation withdrawal options\n"  
	"\n"
    "irrigation withdrawal information for each watershed\n"
	"\n"
    "subbasin   subbasin id\n"
    "rchid      reach id from where water is withdrawn (if reach does not exist then\n" 
	"           etdemand is assumed to be satisfied from an external source)\n"
    "irrigdep   depth of irrigation withdrawal pipe (ft)\n" 
	"\n",
	"250 general quality constituent control\n"
	"\n"
	"defid      parameter group id\n"
	"dwqid      general quality id\n"
	"qname      name of qual (must be a continuous string)\n"
	"qunit      units for quality constituent output (mg/l), (ug/l), or (#/100ml)\n"
	"qsdfg      if = 0 no sediment associated qual\n"
	"           if = 1 sediment associated in pervious/impervious land (qsdfg should be > 0 in card 281)\n"
	"           if = 2 sediment associated in pervious/impervious land\n"
	"                  and sediment associated qual is added to the dissolved part\n"
	"gqsdfg     if = 0 general quality constituent\n"
	"           if = 1 general quality constituent simulated as a sediment (only one qual can be simulated as a sediment in each group)\n"
	"qsofg      if = 1 then accumulation and removal occur daily\n"
	"           if = 2 then accumulation and removal occur every interval\n"
	"potfcfg    if = 1 then apply background concentration potency factor (card 260) to only surface output\n"
	"           if = 2 then apply background concentration potency factor (card 260) to total land output\n"
	"\n",
	"255 subsurface quality control\n"
	"\n"
	"(value of 0 = use constant qual-input; 1 = use corresponding monthly variable card)\n"
	"\n"
	"vqofg       if = 1 the accumulation rate and limiting storage of QUALOF varies monthly   (cards 270, 271)\n"
	"qsowfg      if = 1 the constituent is a QUALSURO (surface flow associated).\n"
	"vsqcfg      if = 1 the concentration of this constituent in surface outflow varies monthly   (card 272)= 1 read table 272\n"
	"qifwfg      if = 1 the constituent is a QUALIF (interflow associated).\n"
	"viqcfg      if = 1 the concentration of this constituent in interflow outflow varies monthly   (card 273)= 1 read table 273\n"
	"qagwfg      if = 1 the constituent is a QUALGW (groundwater associated).\n"
	"vaqcfg      if = 1 the concentration of this constituent in groundwater outflow varies monthly (card 274)\n"
	"adfglnd     if = 1 atmosperic deposition on land (0 for no atmospheric deposition)\n"
	"maddfglnd   if = 1 atmosperic dry deposition varies monthly on land (card 275)\n"
	"mawdfglnd   if = 1 atmosperic wet deposition varies monthly on land (card 276)\n"
	"\n",
	"260  qual-input\n"
	"\n"
	"storage on surface and nonseasonal parameters\n"
	"\n"
	"defid   parameter group id\n"
	"dwqid   general quality id\n"
	"deluid  landuse id\n"
	"sqo     initial storage of QUALOF on surface (lb or #)\n"
	"potfw   washoff potency factor if qsdfg > 0, card 250 (lb or #)/ton-sediment\n"
	"potfs   scour potency pactor if qsdfg > 0, card 250 (lb or #)/ton-sediment\n"
	"potfc   background concentration potency pactor if qsdfg > 0, card 250 (lb or #)/ton-sediment\n"
	"acqop   accumulation rate of QUALOF on surface (lb or #)/acre/day\n"
	"sqolim  maximum storage of QUALOF on surface (lb or #)/acre\n"
	"wsqop   rate of surface runoff that removes 90% of stored QUALOF per hour (in/hr)\n"
	"soqc    concentration of constituent in surface outflow (mg/l), (ug/l), or (#/100ml)\n"
	"ioqc    concentration of constituent in interflow outflow (mg/l), (ug/l), or (#/100ml)\n"
	"aoqc    concentration of constituent in groundwater outflow (mg/l), (ug/l), or (#/100ml)\n"
	"addc    atmospheric dry deposition flux (lb or #)/acre/day\n"
	"awdc    atmospheric wet deposition conc (mg/l), (ug/l), or (#/100ml)\n"
	"\n"
	"the units of the following parameters are as follow:\n"
	"if in card 250, the unit is mg/l or ug/l, then M is lbs\n"
	"if in card 250, the unit is #/100ml, then M is #, in this case the unit for\n"
	"soqc, ioqc and aoqc should be #/100ml instead of mg/l\n"
	"\n",
	"270 mon-accumulation rate (monaccum)\n"
	"\n"
	"only required if vqofg =1 (see card 255)\n"
	"\n"
	"defid   parameter group id\n"
	"dwqid   general quality id\n"
	"deluid  landuse id\n"
	"jan-dec accumulation rate at start of each month (lb/acre/day)\n"
	"\n"
	"if in card 250, the unit is #/100ml, the above unit should be #/acre/day\n"
	"\n",
	"271 mon-storage limit of quality constituent (monsqolim)\n"
	"\n"
	"only required if vqofg = 1 (see card 255)\n"
	"\n"
	"defid   parameter group id\n"
	"dwqid   general quality id\n"
	"deluid  landuse id\n"
	"jan-dec maximum storage at start of each month (lb/acre)\n"
	"\n"
	"if in card 250, the unit is #/100ml, the above unit should be #/acre\n"
	"\n",
	"272 mon-surfaceflow concentration (monsuroconc)\n"
	"\n"
	"only required if vsqcfg = 1 (see card 255)\n"
	"\n"
	"defid   parameter group id\n"
	"dwqid   general quality id\n"
	"deluid  landuse id\n"
	"jan-dec concentration of constituent in surface flow at start of each month (mg/l), (ug/l), or (#/100ml)\n"
	"\n"
	"if in card 250, the unit is #/100ml, the above unit should be #/100ml\n"
	"\n",
	"273 mon-interflow concentration (moninterconc)\n"
	"\n"
	"only required if viqcfg = 1 (see card 255)\n"
	"\n"
	"defid   parameter group id\n"
	"dwqid   general quality id\n"
	"deluid  landuse id\n"
	"jan-dec concentration of constituent in interflow at start of each month (mg/l), (ug/l), or (#/100ml)\n"
	"\n"
	"if in card 250, the unit is #/100ml, the above unit should be #/100ml\n"
	"\n",
	"274 mon-groundwater concentration (mongrndconc)\n"
	"\n"
	"only required if vaqcfg = 1 (see card 255)\n"
	"\n"
	"defid   parameter group id\n"
	"dwqid   general quality id\n"
	"deluid  landuse id\n"
	"jan-dec concentration of constituent in groundwater at start of each month (mg/l), (ug/l), or (#/100ml)\n"
	"\n"
	"if in card 250, the unit is #/100ml, the above unit should be #/100ml\n"
	"\n",
	"275 mon-atmospheric dry deposition flux\n"
	"\n"
	"only required if maddfglnd = 1 (see card 255)\n"
	"\n"
	"defid   parameter group id\n"
	"dwqid   general quality id\n"
	"deluid  landuse id\n"
	"jan-dec flux of constituent in atmospheric dry deposition at start of each month (lb/acre/day or #/acre/day)\n"
	"\n",
	"276 mon-atmospheric wet deposition concentration\n"
	"\n"
	"only required if mawdfglnd = 1 (see card 255)\n"
	"\n"
	"defid   parameter group id\n"
	"dwqid   general quality id\n"
	"deluid  landuse id\n"
	"jan-dec concentration of constituent in atmospheric wet deposition at start of each month (mg/l), (ug/l), or (#/100ml)\n"
	"\n",
	"280 stream water quality control\n"
	"\n"
	"adfgrch     if = 1 atmosperic deposition on reach (0 for no atmospheric deposition)\n"
	"maddfgrch   if = 1 atmosperic dry deposition varies monthly on reach (card 282)\n"
	"mawdfgrch   if = 1 atmosperic wet deposition varies monthly on reach (card 283)\n"
	"\n",
	"281 general quality constituent control\n"
	"\n"
	"rgid       stream parameter group id\n"
	"dwqid      general quality id\n"
	"qsdfg      if = 0 no sediment associated qual\n"
	"           if = 1 sediment associated in stream, adsorption/desorption of qual is simulated\n"
	"ini.cond.  initial instream concentration at start of simulation by group  (mg/l), (ug/l), or (#/100ml)\n"
	"decay      general first-order instream loss rate of qual by reach group (1/day)\n"
	"tcdecay    temperature correction coefficient for first-order decay of qual (min=1, max=2)\n"
	"addc       atmospheric dry deposition flux (lb or #)/acre/day\n"
	"awdc       atmospheric wet deposition conc (mg/l), (ug/l), or (#/100ml)\n"
	"potber     scour potency pactor for stream bank erosion if qsdfg > 0, (lb or #)/ton-sediment\n"
	"\n",
	"282 mon-atmospheric dry deposition flux\n"
	"\n"
	"only required if maddfgrch = 1 (see card 280)\n"
	"\n"
	"rgid    reach group id\n"
	"dwqid   general quality id\n"
	"jan-dec flux of constituent in atmospheric dry deposition at start of each month (lb/acre/day or #/acre/day)\n"
	"\n",
	"283 mon-atmospheric wet deposition concentration\n"
	"\n"
	"only required if mawdfgrch = 1 (see card 280)\n"
	"\n"
	"rgid    reach group id\n"
	"dwqid   general quality id\n"
	"jan-dec concentration of constituent in atmospheric wet deposition at start of each month (mg/l), (ug/l), or (#/100ml)\n"
	"\n",
	"285 parameters for decay of contaminant adsorbed to sediment\n"
	"\n"
	"only required if qsdfg > 0 (see card 281)\n"
	"\n"
	"rgid      reach group id\n"
	"dwqid     general quality id\n"
	"addcpm1   decay rate for qual adsorbed to suspended sediment (/day)\n"
	"addcpm2   temperature correction coefficient for decay of qual on suspended sediment (range from 1.0 to 2.0)\n"
	"addcpm3   decay rate for qual adsorbed to bed sediment (/day)\n"
	"addcpm4   temperature correction coefficient for decay of qual on bed sediment (range from 1.0 to 2.0)\n"
	"\n",
	"286 adsorption coefficients of qual \n"
	"\n"
	"only required if qsdfg > 0 (see card 281)\n"
	"\n"
	"rgid      reach group id\n"
	"dwqid     general quality id\n"
	"adpm1     distribution coefficients for qual with suspended sand (l/mg)\n"
	"adpm2     distribution coefficients for qual with suspended silt (l/mg)\n"
	"adpm3     distribution coefficients for qual with suspended clay (l/mg)\n"
	"adpm4     distribution coefficients for qual with bed sand (l/mg)\n"
	"adpm5     distribution coefficients for qual with bed silt (l/mg)\n"
	"adpm6     distribution coefficients for qual with bed clay (l/mg)\n"
	"\n",
	"287 adsorption/desorption rate parameters \n"
	"\n"
	"only required if qsdfg > 0 (see card 281)\n"
	"\n"
	"rgid      reach group id\n"
	"dwqid     general quality id\n"
	"adpm1     transfer rates between adsorbed and desorbed states of qual with suspended sand (/day)\n"
	"adpm2     transfer rates between adsorbed and desorbed states of qual with suspended silt (/day)\n"
	"adpm3     transfer rates between adsorbed and desorbed states of qual with suspended clay (/day)\n"
	"adpm4     transfer rates between adsorbed and desorbed states of qual with bed sand (/day)\n"
	"adpm5     transfer rates between adsorbed and desorbed states of qual with bed silt (/day)\n"
	"adpm6     transfer rates between adsorbed and desorbed states of qual with bed clay (/day)\n"
	"\n",
	"288 adsorption/desorption temperature correction parameters\n"
	"\n"
	"only required if qsdfg > 0 (see card 281)\n"
	"\n"
	"rgid      reach group id\n"
	"dwqid     general quality id\n"
	"adpm1     temperature correction coefficients for adsorption/desorption on suspended sand (range from 1.0 to 2.0)\n"
	"adpm2     temperature correction coefficients for adsorption/desorption on suspended silt (range from 1.0 to 2.0)\n"
	"adpm3     temperature correction coefficients for adsorption/desorption on suspended clay (range from 1.0 to 2.0)\n"
	"adpm4     temperature correction coefficients for adsorption/desorption on bed sand (range from 1.0 to 2.0)\n"
	"adpm5     temperature correction coefficients for adsorption/desorption on bed silt (range from 1.0 to 2.0)\n"
	"adpm6     temperature correction coefficients for adsorption/desorption on bed clay (range from 1.0 to 2.0)\n"
	"\n",
	"289 initial concentrations on sediment\n"
	"\n"
	"only required if qsdfg > 0 (see card 281)\n"
	"\n"
	"rgid      reach group id\n"
	"dwqid     general quality id\n"
	"sqal1     initial concentrations of qual on suspended sand (concu/mg)\n"
	"sqal2     initial concentrations of qual on suspended silt (concu/mg)\n"
	"sqal3     initial concentrations of qual on suspended clay (concu/mg)\n"
	"sqal4     initial concentrations of qual on bed sand (concu/mg)\n"
	"sqal5     initial concentrations of qual on bed silt (concu/mg)\n"
	"sqal6     initial concentrations of qual on bed clay (concu/mg)\n"
	"\n",
	"400 general channel information\n"
	"\n"
	"admod   advection method (1 for dynamic mixing same as in HSPF and 2 for static mixing)\n"
	"kc      crop factor associated with PEVT (used to back calculate EVAP; EVAP = PEVT/kc)\n"
	"sedber  stream bank erosion sediment (1 for on and 0 for off)\n"
	"vconfg  a value of 1 for vconfg means that F(vol) (volume-dependent) outflow demand components are multiplied by a factor which is allowed to vary through the year.\n" 
	"        These monthly adjustment factors are input in Table-type MON-CONVF in this section (card 401)\n"
	"\n",
	"401 monthly F(vol) adjustment factors\n"
	"\n"
	"only required if vconfg = 1 (see card 400)\n"
	"rgid     stream parameter group id\n"
	"jan-dec  F(vol) adjustment factors at the start of each month\n"
	"\n",
	"405 channel routing network\n"
	"\n"
	"rchid         reach id (same as subbasin id)\n"
	"outputcontrol output control switch for the corresponding reach\n"
	"              0 = will not write general output\n"
	"              1 = will write general output\n"
	"NumOutlets    numbers of channel outlets\n"
	"DSn           downstream channels, DS1  DS2  ......DSn\n"
	"\n",
	"435 linkage controls (optional)\n"
	"\n"
	"rchid         reach id (same as subbasin id)\n"
	"outlet        outlet control switch for the corresponding reach\n"
	"              0 = will read input timeseries file\n"
	"                  (rchid/outlet can be duplicated for multiple input files)\n"
	"              n = will write output timeseries file for outlet n.\n"
	"filepath      the timeseries file path (continuous string without space)\n"
	"\n",
	"410 reach geometry information\n"
	"\n"
	"rchid   reach/lake id (same as subbasin id)\n"
	"rgid    reach/lake parameter group id\n"
	"trgid   threshold reach/lake parameter group id\n"
	"lkfg    reach/lake flag (0 for reach otherwise lake)\n"
	"        lake flag = 1 (rectangular weir for internal option)\n"
	"        lake flag = 2 (triangular weir for internal option)\n"
	"        lake flag = 11 (BMP with rectangular weir for internal option)\n"
	"        lake flag = 12 (BMP with triangular weir for internal option)\n"
	"idepth  reach/lake initial water depth (feet)\n"
	"length  reach/lake length (miles)\n"
	"depth   reach/lake bank full depth (feet)\n"
	"width   reach/lake bankfull width (feet)\n"
	"slope   reach longitudinal slope/lake infiltration rate (in/hr)\n"
	"mann    reach Manning's roughness coefficient/lake weir width (ft)\n"
	"r1      reach ratio of bottom width to bank full width (bottom width = r1 * width)/lake orifice height (ft)\n"
	"r2      reach side slope of flood plane/lake orifice diameter (ft)\n"
	"w1      reach flood plane width factor (total width of flood plane = w1*Width)/lake median particle size diameter, db50 (ft)\n"
	"crrat   ratio of maximum velocity to mean velocity in the RCHRES cross-section under typical flow conditions (greater than or equal to 1)\n"
	"ks      the weighting factor for hydraulic routing (calibration)\n"
	"\n",
	"420  point source information\n"
	"\n"
	"nPtSource   number of individual point sources\n"
	"nPtQuals    number of point source quals\n"
	"filepath    point source file path (card 31)\n"
	"\n",
	"425 point source Qual IDs\n"
	"\n"
 	"Qualindex  point source qual index \n"
 	"Qualname   point source qual name\n"
 	"Qualid     point source qual id\n"
 	"sqalfr     point source sediment associated qual fraction (0-1)\n"
	"\n",
	"430 point source withdrawal\n"
	"\n"
 	"subbasin  point source reach id\n"
 	"permit    point source permit\n"
 	"pipe      point source pipe\n"
 	"wd_target point source withdrawal target reach id\n"
	"\n",
	"440 sediment parameters controls\n"
	"\n"
	"crvfg   if crvfg = 1, erosion-related cover may vary throughout the year.\n" 
	"        values are supplied in Table-type MON-COVER (card 453)\n"
	"vsivfg  if vsivfg = 1, the rate of net vertical sediment input may vary throughout the year.\n" 
	"        if vsivfg = 2, the vertical sediment input is added to the detached sediment storage only on days when no rainfall occurred during the previous day.\n" 
	"        values are supplied in Table-type MON-NVSI (card 454)\n"
	"sandfg  if sandfg = 0, the sand is not simulated.\n" 
	"        if sandfg = 1, the sand transport capacity is calculated using the Toffaleti method.\n" 
	"        if sandfg = 2, the sand transport capacity is calculated using the Colby method.\n" 
	"        if sandfg = 3, the sand transport capacity is calculated using the power function of velocity.\n" 
	"sweepfg if sweepfg = 0, the street sweeping is not simulated.\n" 
	"        if sweepfg = 1, the street sweeping is applied to sediemnt only.\n" 
	"        if sweepfg = 2, the street sweeping is applied to sediment and general water quality constituents.\n" 
	"\n",
	"445 street sweeping for sediment (read if sedfg = 1)\n"
	"\n"
	"defid        parameter group id\n"
	"deluid       landuse id (impervious only)\n"
	"deluname     landuse name\n"
	"start_month  start month of street sweeping requirement\n"
	"end_month    end month of street sweeping requirement\n"
	"frequency    days between street sweeping within the landuse (0 for no sweeping)\n"
	"percent_area fraction of land surface which is available for street sweeping (0 for no sweeping)\n"
	"effic_sand   fraction of sand in solids storage that is available for removal by sweeping (0-1)\n"
	"effic_silt   fraction of silt in solids storage that is available for removal by sweeping (0-1)\n"
	"effic_clay   fraction of clay in solids storage that is available for removal by sweeping (0-1)\n"
	"\n",
	"446 street sweeping for GQual (read if sedfg = 1 and pqalfg = 1)\n"
	"\n"
	"defid        parameter group id\n"
	"deluid       landuse id (impervious only)\n"
	"deluname     landuse name\n"
	"effic_GQual  fraction of general water quality constituent in surface storage that is available for removal by sweeping (0-1)\n"
	"\n",
	"450 sediment parameter group 1 (read if sedfg = 1)\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"smpf    supporting management practice factor\n"
	"krer    coefficient in the soil detachment equation\n"
	"jrer    exponent in the soil detachment equation\n"
	"affix   fraction by which detached sediment storage decreases each day as a result of\n"
	"        soil compaction.\n"
	"cover   fraction of land surface which is shielded from rainfall erosion\n"
	"nvsi    rate at which sediment enters detached storage from the atmosphere\n"
	"        negative value may be used to simulate removal by human activity or wind\n"
	"kser    coefficient in the detached sediment washoff equation\n"
	"jser    exponent in the detached sediment washoff equation\n"
	"kger    coefficient in the matrix soil scour equation, which simulates gully erosion\n"
	"jger    exponent in the matrix soil scour equation, which simulates gully erosion\n"
	"accsdp  rate at which solids accumulate on the land surface (used in impervious land)\n"
	"remsdp  fraction of solids storage which is removed each day when there is no runoff,\n"
	"        for example, because of street sweeping (used in impervious land)\n"
	"\n",
	"451 sediment parameter group 2 (read if sedfg = 1)\n"
	"\n"
	"defid     parameter group id\n"
	"deluid    landuse id\n"
	"sed-suro  background concentration associated with surface flow (mg/l)\n"
	"sed-ifwo  background concentration associated with interflow outflow (mg/l)\n"
	"sed-agwo  background concentration associated with groundwater outflow (mg/l)\n"
	"sed_i     fraction of total sediment from land that is sediment class_i (sand, silt, and clay)\n"
	"\n"
	"(sand + silt + clay = 1)\n"
	"\n"
	"Background sediment load is added to total sediment from LAND prior to applying fractions\n"
	"\n",
	"452 GQUAL-sediment to stream mapping (read if pqualfg = 1 and sedfg = 1)\n"
	"\n"
	"defid   parameter group id\n"
	"dwqid   general quality id\n"
	"lutype  (landuse type flow id (1 = impervious surfaceflow,\n"
	"        2 = pervious surfaceflow, 3 = pervious interflow,\n"
	"        4 = pervious groundflow)\n"
	"sed_i   fraction of GQUAL sediment that is sediment class_i (sand, silt, and clay)\n"
	"\n",
	"453 monthly erosion-related cover values \n"
	"\n"
	"only required if crvfg = 1 (see card 440)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec erosion-related cover values at start of each month\n"
	"\n",
	"454 monthly net vertical sediment input \n"
	"\n"
	"only required if vsivfg > 0 (see card 440)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec net vertical sediment input at start of each month (lb/acre/day)\n"
	"\n",
	"455 sediment general parameters group 3 (read if sedfg = 1)\n"
	"\n"
	"    general sediment related parameters for instream transport\n"
	"\n"
	"    rgid     stream parameter group id\n"
	"    bedwid   bed width (ft) - this is constant for the entire simulation period\n"
	"    beddep   initial bed depth (ft)\n"
	"    por      porosity\n"
	"    burial   burial rate of aggregated sediment layer (in/day)\n"
	"             if burial = 0 then burial rate in card 456 is used\n"
	"\n",
	"456 sediment parameters group 4 (read if sedfg = 1)\n"
	"\n"
	"    sediment variables for instream transport\n"
	"\n"
	"    rgid           stream parameter group id\n"
	"    sed_id         sediment class id\n"
	"    sedflg         sediment flag indicating sediment class (0 for sand, 1 for silt, and 2 for clay)\n"
	"    sedo           initial sediment conc in fluid phase (mg/liter)\n"
	"    sedfrac        initial sediment fractions (by weight) in the bed material\n"			
	"    db50/d         median diameter of the non-cohesive sediment (sand) (in) (sandfg = 1 or 2)\n" 
	"                   / effective diameter of the cohesive particles (silt and clay) (in)\n"
	"    w              corresponding fall velocity of the particle in still water (in/s)\n"
	"    rho            density of the particles (gm/cm^3)\n"
	"    ksand/taucd    coefficient in the sandload power function formula (sandfg = 3)\n"
	"                   / critical bed shear stress for deposition - generally taucd <= taucs (lb/ft^2)\n"											//   (04-28-04)
	"                   if tau > taucd then no deposition\n"
	"                   if tau < taucd then deposition rate approaches settling velocity, w\n"		
	"    expsnd/taucs   exponent in the sandload power function formula (sandfg = 3)\n"          
	"                   / critical bed shear stress for scour of the cohesive particle (lb/ft^2)\n"				
	"                   if tau < taucs then no scour\n"
	"                   if tau > taucs then scour steadily increases\n"
	"    m              erodibility coefficient of the cohesive particle (lb/ft^2/day)\n"
	"    burial         burial rate of the sediment particle (in/day)\n"
	"                   it is used if burial rate in card 455 is zero\n"
	"\n",
	"457 Streambank erosion sediment parameters (read if sedfg = 1 and sedber = 1)\n"
	"\n"
	"rchid   reach id\n"
	"kber    coefficient for scour of the bank matrix soil (calibration)\n"
	"jber    exponent for scour of the bank matrix soil (calibration)\n"
	"qber    bank erosion flow threshold causing channel bank soil erosion (cfs)\n"
	"        if = negative then threshold flow is at the bank full depth (cfs)\n"
	"sed_i   fraction of sediment class_i (sand, silt, and clay)\n"
	"\n",
	"460 Soil Temperature Control  (read if tempfg =1)\n"
	"\n"
	"msltfg  if = 1 monthly vary aslt and bslt parameters in surface flow temperature calculation\n"
	"miftfg  if = 1 monthly vary aift and bift parameters in interflow temperature calculation\n"
	"mgwtfg  if = 1 monthly vary agwt and bgwt parameters in ground water temperature calculation\n"
	"\n",
	"461 Soil Temperature   (read if tempfg =1)\n"
	"\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"tsopfg  if = 0 compute subsurface temperatures using a mean departure from air temperature plus a smoothing factor\n"
	"        if = 1 compute subsurface temperature using regression\n"
	"        if = 2 the lower/gw layer temperature is a function of upper layer temperature instead of air temperature\n"
	"aslt    surface layer temperature when the air temperature 0 degrees C\n"
	"bslt    slope of the surface layer temperature regression equation\n"
	"aift    mean difference between interflow temperature and air temperature (C)\n"
	"bift    smoothing factor in the interflow temperature calculation\n"
	"agwt    mean difference between groundwater temperature and air temperature (C)\n"
	"bgwt    smoothing factor in the groundwater temperature calculation\n"
	"islt    initial surface flow temperature (C)\n"
	"iift    initial interflow temperature (C)\n"
	"igwt    initial groundwater temperature (C)\n"
	"\n"
	"        y = a + b * x\n"
	"\n",
	"462 Soil Temperature mon-aslt \n"
	"\n"
	"only required if tempfg = 1 and msltfg = 1 (see card 460)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec surface layer temperature when the air temperature 0 degrees C at start of each month (C)\n"
	"\n",
	"463 Soil Temperature mon-bslt \n"
	"\n"
	"only required if tempfg = 1 and msltfg = 1 (see card 460)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec slope of the surface layer temperature regression equation at start of each month\n"
	"\n",
	"464 Soil Temperature mon-aift \n"
	"\n"
	"only required if tempfg = 1 and miftfg = 1 (see card 460)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec mean difference between interflow temperature and air temperature at start of each month (C)\n"
	"\n",
	"465 Soil Temperature mon-bift \n"
	"\n"
	"only required if tempfg = 1 and miftfg = 1 (see card 460)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec smoothing factor in the interflow temperature calculation at start of each month\n"
	"\n",
	"466 Soil Temperature mon-agwt \n"
	"\n"
	"only required if tempfg = 1 and mgwtfg = 1 (see card 460)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec mean difference between groundwater temperature and air temperature at start of each month (C)\n"
	"\n",
	"467 Soil Temperature mon-bgwt \n"
	"\n"
	"only required if tempfg = 1 and mgwtfg = 1 (see card 460)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec smoothing factor in the groundwater temperature calculation at start of each month\n"
	"\n",
	"470 Temperature Parameters for Land Groups  (read if tempfg =1)\n"
	"\n"
	"subbasin   subbasin id\n"
	"melev      the mean watershed elevation (ft)\n"
	"eldat      difference in elevation between the watershed and the air temperature gage (ft)\n"
	"rmelev     the mean reach elevation (ft)\n"
	"reldat     difference in elevation between the reach and the air temperature gage (ft)\n"
	"           (positive if reach is higher than the gage).\n"
	"\n",
	"475 Temperature Parameters for Stream Groups  (read if tempfg = 1)\n"
	"\n"
	"rgid    stream parameter group id\n"
	"cfsaex  correction factor for solar radiation; fraction of RCHRES surface exposed to radiation\n"
	"katrad  longwave radiation coefficient\n"
	"kcond   conduction-convection heat transport coefficient\n"
	"kevap   evaporation coefficient\n"
	"\n",
	"480 Bed Heat Conduction Parameters for Stream Groups (read if tempfg = 1)\n"
	"\n"
	"rgid    stream parameter group id\n"
	"preflg  flag for heat transfer rates for water surface (0 = off)\n"
	"bedflg  bed conduction flag\n"
	"        0 - bed conduction is not simulated\n"
	"        1 - single interface (water-mud) heat transfer method\n"
	"        2 - two-interface (water-mud and mud-ground) heat transfer method\n"
	"        3 - Jobson method (not supported)\n"
	"tgflg   source of the ground temperature for the bed conduction (used when bedflg is 1 or 2)\n"
	"        1 - time series (not supported)\n"
	"        2 - single value\n"
	"        3 - monthly values (card 485)\n"
	"muddep  depth of the mud layer in the two-interface model (bedflg = 2) (m)\n"
	"tgrnd   constant (tgflg = 2) ground temperature (bedflg = 1 or 2) (degree C)\n"
	"kmud    heat conduction coefficient between water and the mud/ground (bedflg = 1 or 2) (kcal/m2/degC/hr)\n"
	"kgrnd   heat conduction coefficient between ground and mud in the two-interface model (bedflg = 2) (kcal/m2/degC/hr)\n"
	"\n",
	"485 monthly ground temperatures for bed heat conduction algorithms\n"
	"\n"
	"only required if tgflg = 3 (see card 480)\n"
	"rgid     stream parameter group id\n"
	"jan-dec  tgrndm - monthly ground temperatures for use in the bed heat conduction models (degree C)\n"
	"\n",
	"500 land to stream mapping\n"
	"\n"
	"rgid    stream parameter group id\n"
	"dwqid   general quality id\n"
	"lutype  (landuse type flow id (1 = impervious surfaceflow,\n"
	"        2 = pervious surfaceflow, 3 = pervious interflow,\n"
	"        4 = pervious groundflow)\n"
	"bod     bod fraction in pqual\n"
	"nox     nitrate fraction in pqual\n"
	"tam     total ammonia fraction in pqual\n"
	"snh4    particulate NH4-N fraction in pqual\n"
	"po4     ortho-phosphorus fraction in pqual\n"
	"spo4    particulate PO4-P fraction in pqual\n"
	"orn     organic-nitrogen fraction in pqual\n"
	"orp     organic-phosphorus fraction in pqual\n"
	"orc     organic-carbon fraction in pqual\n"
	"\n",
	"501 atmosphere to stream mapping\n"
	"\n"
	"only required if adfgrch = 1 (see card 280)\n"
	"\n"
	"rgid    stream parameter group ID\n"
	"dwqid   general quality ID\n"
	"bod     bod fraction in PQUAL\n"
	"nox     nitrate fraction in PQUAL\n"
	"tam     total ammonia fraction in PQUAL\n"
	"po4     orthophosphate fraction in PQUAL\n"
	"orn     organic-nitrogen fraction in PQUAL\n"
	"orp     organic-phosphorus fraction in PQUAL\n"
	"orc     organic-carbon fraction in PQUAL\n"
	"\n",
	"502 gases control   (read if oxfg =1)\n"
	"\n"
	"midofg  if = 1 monthly vary DO concentration in interflow\n"
	"mico2fg if = 1 monthly vary CO2 concentration in interflow\n"
	"madofg  if = 1 monthly vary DO concentration in ground water\n"
	"maco2fg if = 1 monthly vary CO2 concentration in ground water\n"
	"\n",
	"503   DO-CO2 Control constant values (read if oxfg =1)\n"
	"\n"
	"sdoxp   concentration of dissolved oxygen in surface flow (mg/l)\n"
	"sco2p   concentration of dissolved CO2 in surface flow (mg/l)\n"
	"idoxp   concentration of dissolved oxygen in interflow outflow (mg/l)\n"
	"ico2p   concentration of dissolved CO2 in interflow outflow (mg/l)\n"
	"adoxp   concentration of dissolved oxygen in active groundwater outflow (mg/l)\n"
	"aco2p   concentration of dissolved CO2 in active groundwater outflow (mg/l)\n"
	"\n",
	"504 mon-DO (interflow)  mg C/l\n"
	"\n"
	"only required if oxfg = 1 and midofg = 1 (see card 502)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec interflow dissolved oxygen concentration at start of each month (mg/l)\n"
	"\n",
	"505 mon-DO (groundwater)\n"
	"\n"
	"only required if oxfg = 1 and madofg = 1 (see card 502)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec groundwater dissolved oxygen concentration at start of each month (mg/l)\n"
	"\n",
	"506 mon-CO2 (interflow)  mg C/l\n"
	"\n"
	"only required if oxfg = 1 and mico2fg = 1 (see card 502)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec interflow carbon dioxide concentration at start of each month (mg/l)\n"
	"\n",
	"507 mon-CO2 (groundwater)\n"
	"\n"
	"only required if oxfg = 1 and maco2fg = 1 (see card 502)\n"
	"defid   parameter group id\n"
	"deluid  landuse id\n"
	"jan-dec groundwater carbon dioxide concentration at start of each month (mg/l)\n"
	"\n",
	"510 DO-BOD control\n"
	"\n"
	"only required if oxfg = 1 (see card 0)\n"
	"benrfg  benthic release flag (for benthic related parameters)\n"
	"reamfg  reaeration flag (indicates the method used to calculate the reaeration coefficient for free-flowing streams)\n"
	"        if = 1 then Tsivoglou method is used\n"
	"        if = 2 then Owens, Churchill, or O'Connor-Dobbins method is used depending on velocity and depth of water\n"
	"        if = 3 then Coefficient is calculated as a power function of velocity and/or depth\n"
	"\n",
	"511   ox-parm1\n"
	"\n"
	"only required if oxfg = 1 (see card 0)\n"
	"rgid    stream parameter group id\n"
	"kbod20  bod decay rate at 20 degree C (1/hr)\n"
	"tcbod   temperature adjustment coefficient for bod decay\n"
	"kodset  bod settling rate (m/hr)\n"
	"supsat  maximum allowable dissolved oxygen supersaturation (expressed as a multiple of the dissolved oxygen saturation concentration)\n"
	"tcginv  temperature correction coefficient for surface gas invasion\n"
	"reak    empirical constant in the equation\n"
	"        if reamfg = 1 then it is an escape coefficient (1/ft)\n"
	"        if reamfg = 3 then it is used to calculate the reaeration coefficient (1/hr)\n"
	"expred  exponent to depth in the reaeration coefficient equation (for reamfg = 3)\n"
	"exprev  exponent to velocity in the reaeration coefficient equation (for reamfg = 3)\n"
	"cforea  correction factor in the lake reaeration equation; it accounts for good or poor circulation characteristics\n"
	"\n",
	"512 ox-parm2\n"
	"\n"
	"only required if oxfg = 1 (see card 0)\n"
	"rgid       stream parameter group id\n"
	"benod      benthal oxygen demand at 20 degrees C (with unlimited DO concentration) (mg/m2/hr)\n"
	"tcben      temperature correction coefficient for benthal oxygen demand\n"
	"expod      exponential factor in the dissolved oxygen term of the benthal oxygen demand equation\n"
	"brbod      benthal release rate of BOD under aerobic conditions.(mg/m2/hr)\n"
	"brbod_inc  increment to benthal release of BOD under anaerobic conditions. (mg/m2/hr)\n"
	"expre1     the exponent in the DO term of the benthal BOD release equation\n"
	"\n",
	"513 oxrx-initial conditions\n"
	"\n"
	"only required if oxfg = 1 (see card 0)\n"
	"rgid   stream parameter group id\n"
	"dox    DO initial condition. (mg/l)\n"
	"bod    BOD initial condition in water column. (mg/l)\n"
	"satdo  Initial DO saturation concentration. (mg/l)\n"
	"\n",
	"514 ox-scour parms\n"
	"\n"
	"only required if oxfg = 1 (see card 0)\n"
	"rgid    stream parameter group id\n"
	"scrvel  threshold velocity above which the effect of scouring on benthal release rates is considered. (m/s)\n"
	"scrmul  multiplier by which benthal releases are increased during scouring.\n"
	"\n",
	"520 nutrients control\n"
	"\n"
	"only required if nutfg = 1 (see card 0)\n"
	"tamfg    total ammonia flag\n"
	"no2fg    nitrite flag\n"
	"po4fg    ortho-phosphorus flag\n"
	"amvfg    ammonia volatilization flag\n"
	"denfg    denitrification flag\n"
	"adnhfg   NH4 adsorption flag\n"
	"adpofg   PO4 adsorption flag\n"
	"mphfg    monthly pH flag (not supported in this version)\n"
	"\n",
	"521 nut-parm1\n"
	"\n"
	"only required if nutfg = 1 (see card 0)\n"
	"rgid    stream parameter group id\n"
	"cvbo    conversion from milligrams biomass to milligrams oxygen (mg/mg)\n"
	"cvbpc   conversion from biomass expressed as phosphorus to carbon (mols/mol)\n"
	"cvbpn   conversion from biomass expressed as phosphorus to nitrogen (mols/mol)\n"
	"bpcntc  percentage of biomass which is carbon (by weight)\n"
	"ktam20  nitrification rate of ammonia at 20 degrees C (1/hr)\n"
	"kno220  nitrification rate of nitrite at 20 degrees C (1/hr)\n"
	"tcnit   temperature correction coefficient for nitrification\n"
	"kno320  nitrate denitrification rate at 20 degrees C (1/hr)\n"
	"tcden   temperature correction coefficient for denitrification\n"
	"denoxt  dissolved oxygen concentration threshold for denitrification (mg/l)\n"
	"\n",
	"522 nut-parm2\n"
	"\n"
	"only required if nutfg = 1 (see card 0)\n"
	"rgid         stream parameter group id\n"
	"brtam_1      benthal release rate of ammonia under aerobic condition (mg/m2/hr)\n"
	"brtam_2      benthal release rates of ammonia under anaerobic conditions (mg/m2/hr)\n"
	"brpo4_1      benthal release rate of ortho-phosphorus under aerobic condition (mg/m2/hr)\n"
	"brpo4_2      benthal release rate of ortho-phosphorus under anaerobic condition (mg/m2/hr)\n"
	"bnh4(1-3)  constant bed concentrations of ammonia-N adsorbed to sand, silt, and clay (mg/kg)\n"
	"bpo4(1-3)  constant bed concentrations of ortho-phosphorus-P adsorbed to sand, silt, and clay (mg/kg)\n"
	"\n",
	"523 nut-parm3\n"
	"\n"
	"only required if nutfg = 1 (see card 0)\n"
	"rgid         stream parameter group id\n"
	"anaer        concentration of dissolved oxygen below which anaerobic conditions are assumed to exist (mg/l)\n"
	"adnhpm(1-3)  adsorption coefficients (Kd) for ammonia-N adsorbed to sand, silt, and clay (cm3/g)\n"
	"adpopm(1-3)  adsorption coefficients for ortho-phosphorus-P adsorbed to sand, silt, and clay (cm3/g)\n"
	"expnvg       exponent in the gas layer mass transfer coefficient equation for NH3 volatilization\n"
	"expnvl       exponent in the liquid layer mass transfer coefficient equation for NH3 volatilization\n"
	"\n",
	"524 nut-initial conditions\n"
	"\n"
	"only required if nutfg = 1 (see card 0)\n"
	"rgid       stream parameter group id\n"
	"no3        initial concentration of nitrate (mg/l)\n"
	"tam        initial concentration of total ammonia (mg/l)\n"
	"no2        initial concentration of nitrite (as N) (mg/l)\n"
	"po4        initial concentration of ortho-phosphorus (as P) (mg/l)\n"
	"snh4(1-3)  initial suspended concentrations of ammonia-N adsorbed to sand, silt, and clay (mg/kg)\n"
	"spo4(1-3)  initial suspended concentrations of ortho-phosphorus-P adsorbed to sand, silt, and clay (mg/kg)\n"
	"\n",
	"530 plank control\n"
	"\n"
	"only required if plkfg = 1 (see card 0)\n"
	"phyfg    phytoplankton flag\n"
	"zoofg    zooplankton flag\n"
	"balfg    benthic algae flag\n"
	"sdltfg   influence of sediment washload on light extinction flag\n"
	"amrfg    ammonia retardation of nitrogen-limited growth flag\n"
	"decfg    linkage between carbon dioxide and phytoplankton growth flag (if on, the linkage is decoupled)\n"
	"nsfg     ammonia is included as part of available nitrogen supply in nitrogen limited growth calculations\n"
	"orefg    indicates the oref parameter in card 534 as a flowrate (if not checked) otherwise valocity\n"
	"\n",
	"531 plank-parm1\n"
	"\n"
	"only required if plkfg = 1 (see card 0)\n"
	"rgid    stream parameter group id\n"
	"ratclp  ratio of chlorophyll A content of biomass to phosphorus content\n"
	"nonref  non-refractory fraction of algae and zooplankton biomass\n"
	"litsed  multiplication factor to total sediment concentration to determine sediment contribution to light extinction (l/mg/ft)\n"
	"alnpr   fraction of nitrogen requirements for phytoplankton growth that is satisfied by nitrate\n"
	"extb    base extinction coefficient for light (1/m)\n"
	"malgr   maximum unit algal growth rate (1/hr)\n"
	"\n",
	"532 plank-parm2\n"
	"\n"
	"only required if plkfg = 1 (see card 0)\n"
	"rgid    stream parameter group id\n"
	"cmmlt   Michaelis-Menten constant for light limited growth (lay/min)\n"
	"cmmn    nitrate Michaelis-Menten constant for nitrogen limited growth (mg/l)\n"
	"cmmnp   nitrate Michaelis-Menten constant for phosphorus limited growth (mg/l)\n"
	"cmmp    phosphate Michaelis-Menten constant for phosphorus limited growth (mg/l)\n"
	"talgrh  temperature above which algal growth ceases (C)\n"
	"talgrl  temperature below which algal growth ceases (C)\n"
	"talgrm  temperature below which algal growth is retarded (C)\n"
	"\n",
	"533 plank-parm3\n"
	"\n"
	"only required if plkfg = 1 (see card 0)\n"
	"rgid   stream parameter group id\n"
	"alr20  algal unit respiration rate at 20 degrees C (1/hr)\n"
	"aldh   high algal unit death rate (1/hr)\n"
	"aldl   low algal unit death rate (1/hr)\n"
	"oxald  increment to phytoplankton unit death rate due to anaerobic conditions (1/hr)\n"
	"naldh  inorganic nitrogen concentration below which high algal death rate occurs (as nitrogen) (mg/l)\n"
	"paldh  inorganic phosphorus concentration below which high algal death rate occurs (as phosphorus) (mg/l)\n"
	"\n",
	"534 plank-parm4\n"
	"\n"
	"only required if plkfg = 1 (see card 0)\n"
	"rgid    stream parameter group id\n"
	"phycon  constant inflow concentration of plankton from land to reach (mg/l)\n"
	"seed    minimum concentration of plankton not subject to advection (i.e., at high flow) (mg/l)\n"
	"mxstay  concentration of plankton not subject to advection at very low flow (mg/l)\n"
	"oref    velocity/outflow at which the concentration of plankton not subject to advection is midway between SEED and MXSTAY, see card 530 (m/s or m3/s)\n"
	"claldh  chlorophyll a concentration above which high algal death rate occurs (ug/l)\n"
	"physet  phytoplankton settling rate (m/hr)\n"
	"refset  settling rate for dead refractory organics (m/hr)\n"
	"cfsaex  This factor is used to adjust the input solar radiation to make it applicable to the RCHRES;\n"
    "        for example, to account for shading of the surface by trees or buildings\n"
    "mbal    maximum benthic algae density (as biomass) (mg/m2)\n"
	"cfbalr  ratio of benthic algal to phytoplankton respiration rate\n"
	"cfbalg  ratio of benthic algal to phytoplankton growth rate\n"
	"\n",
	"535 plank-initial conditions\n"
	"\n"
	"only required if plkfg = 1 (see card 0)\n"
	"rgid   stream parameter group id\n"
	"phyto  initial phytoplankton concentration, as biomass (mg/l)\n"
	"benal  initial benthic algae density, as biomass (mg/m2)\n"
	"orn    initial dead refractory organic nitrogen concentration (mg/l)\n"
	"orp    initial dead refractory organic phosphorus concentration (mg/l)\n"
	"orc    initial dead refractory organic carbon concentration (mg/l)\n"
	"\n",
	"540 pH control\n"
	"\n"
	"only required if phfg = 1 (see card 0)\n"
	"phffg1   value of 0 indicates that the removal factor for total inorganic carbon is constant, given as phfrc1\n"
	"         a value of 1 indicates the monthly removal factors\n"
	"phffg2   value of 0 indicates that the removal factor for dissolved carbon dioxide is constant, given as phfrc2\n"
	"         a value of 1 indicates the monthly removal factors\n"
	"phfrc1   removal fraction for total inorganic carbon (0-1)\n"
	"phfrc2   removal fraction for dissolved carbon dioxide (0-1)\n"
	"\n",
	"541 pH-parm\n"
	"\n"
	"only required if phfg = 1 (see card 0)\n"
	"rgid       stream parameter group id\n"
	"phcnt      maximum number of iterations used to solve for the pH\n"
	"alkcon     number of the conservative substance which is used to simulate alkalinity\n"
	"           Alkalinity must be simulated in order to obtain valid results\n"
	"cfcinv     ratio of the carbon dioxide invasion rate to the oxygen reaeration rate\n"
	"brco2_1    benthal release rate of CO2 (as carbon) for aerobic conditions (mg/m2/hr)\n"
	"brco2_2    benthal release rate of CO2 (as carbon) for anaerobic conditions (mg/m2/hr)\n"
	"\n",
	"542 pH-initial conditions\n"
	"\n"
	"only required if phfg = 1 (see card 0)\n"
	"rgid   stream parameter group id\n"
	"tic    initial total inorganic carbon (mg/l)\n"
	"co2    initial carbon dioxide (as carbon) (mg/l)\n"
	"ph     initial pH\n"
	"\n",
	"543 mon-tic (monthly removal fraction for total inorganic carbon)\n"
	"\n"
	"only required if phfg = 1 and phffg1 = 1 (see card 502 and card 540)\n"
	"rgid    stream parameter group id\n"
	"jan-dec total inorganic carbon removal fraction at the start of each month\n"
	"\n",
	"544 mon-co2 (monthly removal fraction for dissolved carbon dioxide)\n"
	"\n"
	"only required if phfg = 1 and phffg2 = 1 (see card 540)\n"
	"rgid    stream parameter group id\n"
	"jan-dec dissolved carbon dioxide removal fraction at the start of each month\n"
	"\n",
	"600 TMDL control flags\n"
	"\n"
	"ncpt       if > 0 then use point source control card 660\n"
	"ncland     if > 0 then use land-based control card 670\n" 
	"           if = 1 then apply reduction to only surface output\n"
	"           if = 2 then apply reduction to total land output\n"
	"ncrch      if > 0 then use stream-based control card 685 and 690\n"
	"ntrgp      number of threshold groups in Card 410 and 610\n"
	"ntnum      number of defined thresholds for analysis\n"
	"           if > 0 then use threshold control cards 605 and 610\n"
	"\n",
	"605 TMDL threshold mapping (used if ntnum > 0 in card 600)\n"
	"\n"
	"tnum       threshold ordinal number\n"
	"tqsd       threshold qual (1 for dissolved only and 2 for total)\n"
	"tcount     number of water quality constituent to aggregate\n"
	"tqid       list of tqid to aggregate - number of tqid in list = tcount (GQUAL/RQUAL IDs)\n"
	"\n",
	"610 TMDL threshold definitions (used if ntnum > 0 in card 600)\n"
	"\n"
	"trgid      threshold reach group ID (corresponds to trgid on Card 410)\n"
	"tnum       threshold number (corresponds to tnum on Card 605)\n"
	"ttype      threshold type (possible values: 0, 1, 2, 3 or -1, -2, -3)\n"
	"            0 = no standard to be applied for the trgid\n"
	"            1 = instantaneous values > threshold\n"
	"            2 = arithmetic mean > threshold\n"
	"            3 = geometric mean > threshold\n"
	"           -1 = instantaneous values < threshold\n"
	"           -2 = arithmetic mean < threshold\n"
	"           -3 = geometric mean < threshold\n"
	"tdays      number of days over model output is aggregated and/or is compared\n"
	"           if tdays = 0 then threshold becomes percent of time\n"
	"jan-dec    twelve monthly values for threshold (for constant, use same value 12 times)\n"
	"           (units are same as in card 250)\n"
	"\n"
	"examples: ttype  tdays  description/interpretation\n"
	"              1      1  at least one instantaneous value within a 1-day running period > threshold\n"
	"             -1      1  at least one instantaneous value within a 1-day running period < threshold\n"
	"              1      0  percent of time that instantaneous value > threshold\n"
	"              2      4  4-day running arithmetic mean > threshold\n"
	"              3     30  30-day running geometric mean > threshold (for previous 30-days)\n"
	"\n",
	"660 TMDL point source control (used if ncpt > 0 on card 600)\n"
	"\n"
	"rchid         reach id\n"
	"permit        point source index (level1)\n"
	"pipe          point source index qualifier (level2)\n"
	"reduction     reduction of pollutant from point source (in fraction)\n"
	"\n",
	"670 TMDL land-based control (used if ncland > 0 on card 600)\n"
	"\n"
	"subbasin      subbasin id\n"
	"deluid        landuse id\n"
	"pluname       land use name\n"
	"reduction     reduction of pollutant from corresponding landuse and subwatershed (fraction)\n"
	"\n",
	"680 TMDL stream-based switch control (used if ncrch > 0 on card 600)\n"
	"\n"
	"rchid         controlled reach id\n"
	"outlet        controlled reach outlet id\n"
	"switch_mon    monthly switch for the conc limit or reduction of pollutant from the corresponding reach (0-off, 1-on)\n"
	"\n",
	"685 TMDL stream-based limit control (used if ncrch > 0 on card 600)\n"
	"\n"
	"rchid         controlled reach id\n"
	"outlet        controlled reach outlet id\n"
	"limit_flow    flow limit from the corresponding reach (cfs)\n"
	"limit_pol     concentration limit of pollutant from the corresponding reach (mg/l or ug/l or #/100ml)\n"
	"\n",
	"690 TMDL stream-based reduction control (used if ncrch > 0 on card 600)\n"
	"\n"
	"rchid         controlled reach id\n"
	"outlet        controlled reach outlet id\n"
	"reduc_flow    reduction of flow from corresponding reach (fraction)\n"
	"reduc_pol     reduction of pollutant from corresponding reach (fraction)\n"
	"              reduction in outflow will also reduce the pollutant mass from the outflow and \n"
	"              any defined reduction to pollutant will be the additional\n"
};

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLSPCMODEL::CLSPCMODEL()
{
	bWeather = true;
	bCalcEnd = false;
//	tmList = NULL;

	infomsg = ""; 
	nsws = 0;
	ngroup = 0;
	nlandp = 0;
	nlandimp = 0;
	nrgroup = 0;	// number of stream groups
	optlevel = 1;
	summarylevel = 0;
	deltm = 60;
	FtableRecord = 0;				

	//card 413
	rec_width = 0;
	rec_height= 0;

	m_strFileName = "";
	m_strPath = "";
	strPointFileName = "";		// input point file name		(02-2005)
	strPointFilePath = "";		// input file location			(02-2005)
	bReadDB = false;
	bRunNIMS = false;
	nReadc30 = 0;
	bReadc670 = false;

	m_strModelResultLocation = "";
	m_strPSDataLocation = "";

	pswsinfo = NULL;
	m_filelanduse = NULL;
	m_filestream = NULL;
	m_filepointsource = NULL;
	m_filethreshold = NULL;
	m_filethresholdstat = NULL;
	rqual_s = NULL;
	rqname_s = NULL;
	rqflag_s = NULL;		// to get the selecetd rquals
	ppluinfo = NULL;
	pluinfop = NULL;
	pLURoute = NULL;
	pFtable = NULL;	
	q_bfd = NULL;

	//initialize flags in page 0
	snowfg = 0;
	pwatfg = 1;
	sedfg = 0;
	gqsdfg = 0;
	pqalfg = 0;
	tempfg = 0;
	oxfg = 0;			
	nutfg = 0;
	plkfg = 0;
	phfg = 0;
	vcsfg = 0;
	vuzfg = 0;
	vnnfg = 0;
	vifwfg = 0;
	vircfg = 0;
	vlefg = 0;
	uzfg = 0;
	rtopfg = 0;

	ppw_param2 = NULL;
	ppw_param3 = NULL;
	ppw_param4 = NULL;
	ppw_state = NULL;

	cepscm_p = NULL;
	uzsnm_p = NULL;
	nsurm_p = NULL;
	intfwm_p = NULL;
	ircm_p = NULL;
	lzetpm_p = NULL;

	nQuals = 0;
	pQual = NULL;
	pQualwq = NULL;
	pQualInput = NULL;
	pGQ_SEDDECAY = NULL;
	pGQ_KD = NULL;
	pGQ_ADRATE = NULL;
	pGQ_ADTHETA = NULL;
	pGQ_SEDCONC = NULL;
	pIMonAccum = NULL;
	pIMonSQOLIM = NULL;
	pIMonSUROCONC = NULL;			
	pIMonINTERCONC = NULL;
	pIMonGRNDCONC = NULL;
	pIMonDRYDEP = NULL;
	pIMonWETDEP = NULL;

	pMDDrch = NULL;
	pMWDrch = NULL;

	// threshold summary
	pMTDATA      = NULL;
	pTHR_RESULTS = NULL;
	pThreshold   = NULL;

	//monthly flags
	vqofg = 0;
	qsowfg = 0;					
	vsqcfg = 0;
	qifwfg = 0;
	viqcfg = 0;
	qagwfg = 0;
	vaqcfg = 0;
	adfglnd = 0;
	maddfglnd = 0;
	mawdfglnd = 0;
	adfgrch = 0;
	maddfgrch = 0;
	mawdfgrch = 0;

	nch = 0;
	nLinkFiles = 0;
	admod = 1;
	sedber = 0;
	vconfg = 0;
	crvfg = 0;
	sandfg = 0;
	vsivfg = 0;
	sweepfg = 0;
	kc = 0.0;
	js = 0.0;

	// for summary files
	counter = 0;

	pReachFtable = NULL;
	pReachInfo = NULL;
	pChannelInfo = NULL;
	nPtSource = 0;
	nPtWithDrawal = 0;
	nPtQuals = 0;
	pPtWithDrawal = NULL;
	pPtQual = NULL;
	pPSData = NULL;

	psd_sweep = NULL;		// street sweeping for sediment
	pGQ_sweep = NULL;		// street sweeping for GQual
	psd_param1=NULL;
	psd_param2=NULL;
	rsd_genparam =NULL;		// general parameters
	rsd_param =NULL;		// cohesive sediments
	rsd_berparam =NULL;		// streambank erosion parameters

	msltfg = 0;
	miftfg = 0;
	mgwtfg = 0;

	asltm = NULL;
	bsltm = NULL;
	aiftm = NULL;
	biftm = NULL;
	agwtm = NULL;
	bgwtm = NULL;

	bedflg = false; 
	mtgflg = false;
	ptmp_param1 = NULL;
	ptmps_param1 = NULL;		
	ptmps_param2 = NULL;
	ptmps_mon = NULL;
	pstmp_parm1 = NULL;

	lapse[0]  = 0.0035;
	lapse[1]  = 0.0035;
	lapse[2]  = 0.0035;
	lapse[3]  = 0.0035;
	lapse[4]  = 0.0035;
	lapse[5]  = 0.0035;
	lapse[6]  = 0.0037;
	lapse[7]  = 0.0040;
	lapse[8]  = 0.0041;
	lapse[9]  = 0.0043;
	lapse[10] = 0.0046;
	lapse[11] = 0.0047;
	lapse[12] = 0.0048;
	lapse[13] = 0.0049;
	lapse[14] = 0.0050;
	lapse[15] = 0.0050;
	lapse[16] = 0.0048;
	lapse[17] = 0.0046;
	lapse[18] = 0.0044;
	lapse[19] = 0.0042;
	lapse[20] = 0.0040;
	lapse[21] = 0.0038;
	lapse[22] = 0.0037;
	lapse[23] = 0.0036;

	midofg = 0;
	mico2fg = 0;
	madofg = 0;
	maco2fg = 0;

	// DO CO2 paramters
	doco_parm1 =NULL;
	sdoconc = NULL;
	sco2conc = NULL;
	idoconc = NULL;
	adoconc = NULL;
	ico2conc = NULL;
	aco2conc = NULL;

	//RQUAL (03-2005)
	sed_mapp = NULL;
	land_mapp = NULL;
	atms_mapp = NULL;
	benrfg = 0;
	reamfg = 2;
	ox_parm1 =NULL;
	ox_parm2 =NULL;
	oxrx_init =NULL;
	scour_parms = NULL;
	// nutrients
	tamfg = 0;
	no2fg = 0;
	po4fg = 0;
	amvfg = 0;
	denfg = 0;
	adnhfg = 0;
	adpofg = 0;
	mphfg = 0;
	nut_parm1 = NULL;
	nut_parm2 = NULL;
	nut_parm3 = NULL;
	nut_init  = NULL;
	// plank
	phyfg = 0;
	zoofg = 0;
	balfg = 0;
	sdltfg = 0;
	amrfg = 0;
	decfg = 0;
	nsfg = 0;
	orefg = 0;
	plank_parm1 =NULL;
	plank_parm2 =NULL;
	plank_parm3 =NULL;
	plank_parm4 =NULL;
	plank_init =NULL;
	// ph
	phffg1 = 0;
	phffg2 = 0;
	phfrc1 = 0.0;
	phfrc2 = 0.0;
	ph_para =NULL;
	ph_init =NULL;
	mtic_rf = NULL;	// monthly removal fraction for total inorganic carbon
	mco2_rf = NULL;	// monthly removal fraction for dissolved carbon dioxide
	pMONTH_COV = NULL;
	pCRVm = NULL;
	pVSIVm = NULL;

	ncpt = 0;
	ncland = 0;
	ncrch = 0;
	ntrgp = 0;
	ntnum = 0;
	ncrchOutlets = 0;

	pTMDLDistrib = NULL;
	pFlowControls = NULL;
	pSedControls = NULL;
	pQualControls = NULL;

	stream = NULL;
	fPSQualDeduction = NULL;
	pPSReduction = NULL;
	pMON_SWITCH = NULL;
	pBMPLimit = NULL;
	pBMPReduction = NULL;

	//snow related parameters
	pSnowCtl2 = NULL;
	pSnowParam1 = NULL;
	pSnowParam2 = NULL;
	pSnowInit1 = NULL;

    //Irrigation Application Options related parmeter - Sabu Paul 9-2004
	irrigfg = 0;
	petfg = 0;
	monVaryIrrig = 0;
	pirrigpet = NULL;
    pirriginfop = NULL;
	pmonetcinfop = NULL;
	pirrigwdinfo = NULL;
	curPeriodET = NULL;
	curPeriodPrec = NULL;
	irrigDemand = NULL;
	wsIrrigDemand = NULL;
	cumulativePrec = NULL ; //for storing the previous few days precipitation
	cumulativeET = NULL ;

	int i;
//	for (i=0; i<PARA_NUM; i++)
//		cOP.blistOutput[i] = false;

	bDataValid = true;

	nHydro = 0;
	nSed = 0;
	nGQUAL = 0;
	nRQUAL = 0;
	nSnow = 0;							
	nCustom = 0;
	nDefault = 1;
	NumSed = 0;		// number of sediment classes (if sedfg = 1)
	nLUsummary = 0;	// landuse summary
	nCHsummary = 0;	// channel summary
	nPSsummary = 0;	// point source summary
	nThreshold = 0;
	nSUSTAIN = 0;
	nContorlGlobal = 0;
	nWaterControl = 0;

	for(i=0; i<sizeof(nPageOrder)/sizeof(int); ++i)
		strDesc[nPageOrder[i]] = strGComments[i];
}

void CLSPCMODEL::ResetData()
{
	nLinkFiles = 0;
	counter = 0;

//	if(tmList != NULL)
//	{
//		delete []tmList;
//		tmList = NULL;
//	}
	if(pswsinfo != NULL)
	{
		delete []pswsinfo;
		pswsinfo = NULL;
	}
	if(ppluinfo != NULL)
	{
		delete []ppluinfo;
		ppluinfo = NULL;
	}
	if(pluinfop != NULL)
	{
		delete []pluinfop;
		pluinfop = NULL;
	}
	if(pLURoute != NULL)
	{
		delete []pLURoute;
		pLURoute = NULL;
	}
	if(pFtable != NULL)				
	{
		delete []pFtable;
		pFtable = NULL;
	}
	if(ppw_param2 != NULL)
	{
		delete []ppw_param2;
		ppw_param2 = NULL;
	}
	if(ppw_param3 != NULL)
	{
		delete []ppw_param3;
		ppw_param3 = NULL;
	}
	if(ppw_param4 != NULL)
	{
		delete []ppw_param4;
		ppw_param4 = NULL;
	}
	if(ppw_state != NULL)
	{
		delete []ppw_state;
		ppw_state = NULL;
	}
	if(cepscm_p != NULL)
	{
		delete []cepscm_p;
		cepscm_p = NULL;
	}
	if(uzsnm_p != NULL)
	{
		delete []uzsnm_p;
		uzsnm_p = NULL;
	}
	if(nsurm_p != NULL)
	{
		delete []nsurm_p;
		nsurm_p = NULL;
	}
	if(intfwm_p != NULL)
	{
		delete []intfwm_p;
		intfwm_p = NULL;
	}
	if(ircm_p != NULL)
	{
		delete []ircm_p;
		ircm_p = NULL;
	}
	if(lzetpm_p != NULL)
	{
		delete []lzetpm_p;
		lzetpm_p = NULL;
	}
	if(pQual != NULL)
	{
		delete []pQual;
		pQual = NULL;
	}
	if(pQualwq != NULL)
	{
		delete []pQualwq;
		pQualwq = NULL;
	}
	if(pQualInput != NULL)
	{
		delete []pQualInput;
		pQualInput = NULL;
	}
	if(pGQ_SEDDECAY != NULL)
	{
		delete []pGQ_SEDDECAY;
		pGQ_SEDDECAY = NULL;
	}
	if(pGQ_KD != NULL)
	{
		delete []pGQ_KD;
		pGQ_KD = NULL;
	}
	if(pGQ_ADRATE != NULL)
	{
		delete []pGQ_ADRATE;
		pGQ_ADRATE = NULL;
	}
	if(pGQ_ADTHETA != NULL)
	{
		delete []pGQ_ADTHETA;
		pGQ_ADTHETA = NULL;
	}
	if(pGQ_SEDCONC != NULL)
	{
		delete []pGQ_SEDCONC;
		pGQ_SEDCONC = NULL;
	}
	if(pIMonAccum != NULL)
	{
		delete []pIMonAccum;
		pIMonAccum = NULL;
	}
	if(pIMonSQOLIM != NULL)
	{
		delete []pIMonSQOLIM;
		pIMonSQOLIM = NULL;
	}
	if(pIMonSUROCONC != NULL)
	{
		delete []pIMonSUROCONC;
		pIMonSUROCONC = NULL;
	}
	if(pIMonINTERCONC != NULL)
	{
		delete []pIMonINTERCONC;
		pIMonINTERCONC = NULL;
	}
	if(pIMonGRNDCONC != NULL)
	{
		delete []pIMonGRNDCONC;
		pIMonGRNDCONC = NULL;
	}
	if(pIMonDRYDEP != NULL)
	{
		delete []pIMonDRYDEP;
		pIMonDRYDEP = NULL;
	}
	if(pIMonWETDEP != NULL)
	{
		delete []pIMonWETDEP;
		pIMonWETDEP = NULL;
	}
	if(pMDDrch != NULL)
	{
		delete []pMDDrch;
		pMDDrch = NULL;
	}
	if(pMWDrch != NULL)
	{
		delete []pMWDrch;
		pMWDrch = NULL;
	}
	if(pMTDATA != NULL)
	{
		delete []pMTDATA;
		pMTDATA = NULL;
	}
	if(pTHR_RESULTS != NULL)
	{
		delete []pTHR_RESULTS;
		pTHR_RESULTS = NULL;
	}
	if(pThreshold != NULL)				
	{
		delete []pThreshold;
		pThreshold = NULL;
	}
	if(pReachFtable != NULL)
	{
		delete []pReachFtable;
		pReachFtable = NULL;
	}
	if(pReachInfo != NULL)
	{
		delete []pReachInfo;
		pReachInfo = NULL;
	}
	if(pChannelInfo != NULL)
	{
		delete []pChannelInfo;
		pChannelInfo = NULL;
	}
	if(pPtWithDrawal != NULL)
	{
		delete []pPtWithDrawal;
		pPtWithDrawal = NULL;
	}
	if(pPtQual != NULL)
	{
		delete []pPtQual;
		pPtQual = NULL;
	}
	if(pPSData != NULL)
	{
		delete []pPSData;
		pPSData = NULL;
	}
	if(psd_sweep != NULL)
	{
		delete []psd_sweep;
		psd_sweep = NULL;
	}
	if(pGQ_sweep != NULL)
	{
		delete []pGQ_sweep;
		pGQ_sweep = NULL;
	}
	if(psd_param1 != NULL)
	{
		delete []psd_param1;
		psd_param1 = NULL;
	}
	if(psd_param2 != NULL)
	{
		delete []psd_param2;
		psd_param2 = NULL;
	}
	if(rsd_berparam != NULL)
	{
		delete []rsd_berparam;
		rsd_berparam = NULL;
	}
	if(rsd_genparam != NULL)
	{
		delete []rsd_genparam;
		rsd_genparam = NULL;
	}
	if(rsd_param != NULL)
	{
		delete []rsd_param;
		rsd_param = NULL;
	}

	if(asltm != NULL)
	{
		delete []asltm;
		asltm = NULL;
	}
	if(bsltm != NULL)
	{
		delete []bsltm;
		bsltm = NULL;
	}
	if(aiftm != NULL)
	{
		delete []aiftm;
		aiftm = NULL;
	}
	if(biftm != NULL)
	{
		delete []biftm;
		biftm = NULL;
	}
	if(agwtm != NULL)
	{
		delete []agwtm;
		agwtm = NULL;
	}
	if(bgwtm != NULL)
	{
		delete []bgwtm;
		bgwtm = NULL;
	}
	if(ptmp_param1 != NULL)
	{
		delete []ptmp_param1;
		ptmp_param1 = NULL;
	}
	if(ptmps_param1 != NULL)
	{
		delete []ptmps_param1;
		ptmps_param1 = NULL;
	}
	if(ptmps_param2 != NULL)
	{
		delete []ptmps_param2;
		ptmps_param2 = NULL;
	}
	if(ptmps_mon != NULL)
	{
		delete []ptmps_mon;
		ptmps_mon = NULL;
	}
	if(pstmp_parm1 != NULL)
	{
		delete []pstmp_parm1;
		pstmp_parm1 = NULL;
	}
	if(doco_parm1 != NULL)
	{
		delete []doco_parm1;
		doco_parm1 = NULL;
	}
	if(sdoconc != NULL)
	{
		delete []sdoconc;
		sdoconc = NULL;
	}
	if(sco2conc != NULL)
	{
		delete []sco2conc;
		sco2conc = NULL;
	}
	if(idoconc != NULL)
	{
		delete []idoconc;
		idoconc = NULL;
	}
	if(adoconc != NULL)
	{
		delete []adoconc;
		adoconc = NULL;
	}
	if(ico2conc != NULL)
	{
		delete []ico2conc;
		ico2conc = NULL;
	}
	if(aco2conc != NULL)
	{
		delete []aco2conc;
		aco2conc = NULL;
	}
	if(sed_mapp != NULL)
	{
		delete []sed_mapp;
		sed_mapp = NULL;
	}
	if(land_mapp != NULL)
	{
		delete []land_mapp;
		land_mapp = NULL;
	}
	if(atms_mapp != NULL)
	{
		delete []atms_mapp;
		atms_mapp = NULL;
	}
	if(ox_parm1 != NULL)
	{
		delete []ox_parm1;
		ox_parm1 = NULL;
	}
	if(ox_parm2 != NULL)
	{
		delete []ox_parm2;
		ox_parm2 = NULL;
	}
	if(oxrx_init != NULL)
	{
		delete []oxrx_init;
		oxrx_init = NULL;
	}
	if(scour_parms != NULL)
	{
		delete []scour_parms;
		scour_parms = NULL;
	}
	if(nut_parm1 != NULL)
	{
		delete []nut_parm1;
		nut_parm1 = NULL;
	}
	if(nut_parm2 != NULL)
	{
		delete []nut_parm2;
		nut_parm2 = NULL;
	}
	if(nut_parm3 != NULL)
	{
		delete []nut_parm3;
		nut_parm3 = NULL;
	}
	if(nut_init != NULL)
	{
		delete []nut_init;
		nut_init = NULL;
	}
	if(plank_parm1 != NULL)
	{
		delete []plank_parm1;
		plank_parm1 = NULL;
	}
	if(plank_parm2 != NULL)
	{
		delete []plank_parm2;
		plank_parm2 = NULL;
	}
	if(plank_parm3 != NULL)
	{
		delete []plank_parm3;
		plank_parm3 = NULL;
	}
	if(plank_parm4 != NULL)
	{
		delete []plank_parm4;
		plank_parm4 = NULL;
	}
	if(plank_init != NULL)
	{
		delete []plank_init;
		plank_init = NULL;
	}
	if(ph_para != NULL)
	{
		delete []ph_para;
		ph_para = NULL;
	}
	if(ph_init != NULL)
	{
		delete []ph_init;
		ph_init = NULL;
	}
	if(mtic_rf != NULL)
	{
		delete []mtic_rf;
		mtic_rf = NULL;
	}
	if(mco2_rf != NULL)
	{
		delete []mco2_rf;
		mco2_rf = NULL;
	}
	if(pMONTH_COV != NULL)
	{
		delete []pMONTH_COV;
		pMONTH_COV = NULL;
	}
	if(pCRVm != NULL)
	{
		delete []pCRVm;
		pCRVm = NULL;
	}
	if(pVSIVm != NULL)
	{
		delete []pVSIVm;
		pVSIVm = NULL;
	}
	if(pTMDLDistrib != NULL)
	{
		delete []pTMDLDistrib;
		pTMDLDistrib = NULL;
	}
	if(pFlowControls != NULL)
	{
		delete []pFlowControls;
		pFlowControls = NULL;
	}
	if(pSedControls != NULL)
	{
		delete []pSedControls;
		pSedControls = NULL;
	}
	if(pQualControls != NULL)
	{
		delete []pQualControls;
		pQualControls = NULL;
	}
	if(stream != NULL)
	{
		delete []stream;
		stream = NULL;
	}
	if(fPSQualDeduction != NULL)
	{
		delete []fPSQualDeduction;
		fPSQualDeduction = NULL;
	}
	if(pPSReduction  != NULL)
	{
		delete []pPSReduction;
		pPSReduction = NULL;
	}
	if(pMON_SWITCH  != NULL)
	{
		delete []pMON_SWITCH;
		pMON_SWITCH = NULL;
	}
	if(pBMPLimit  != NULL)
	{
		delete []pBMPLimit;
		pBMPLimit = NULL;
	}
	if(pBMPReduction  != NULL)
	{
		delete []pBMPReduction;
		pBMPReduction = NULL;
	}
	if(pSnowCtl2 != NULL)
	{
		delete []pSnowCtl2;
		pSnowCtl2 = NULL;
	}
	if(pSnowParam1 != NULL)
	{
		delete []pSnowParam1;
		pSnowParam1 = NULL;
	}
	if(pSnowParam2 != NULL)
	{
		delete []pSnowParam2;
		pSnowParam2 = NULL;
	}
	if(pSnowInit1 != NULL)
	{
		delete []pSnowInit1;
		pSnowInit1 = NULL;
	}
	if(pirrigpet != NULL)
	{
		delete []pirrigpet;
		pirrigpet = NULL;
	}
	if(pirriginfop != NULL)
	{
		delete []pirriginfop;
		pirriginfop = NULL;
	}
	if(	pmonetcinfop != NULL)
	{
		delete []pmonetcinfop;
		pmonetcinfop = NULL;
	}
	if(pirrigwdinfo != NULL)
	{
		delete []pirrigwdinfo;
		pirrigwdinfo = NULL;
	}
	if(curPeriodET != NULL)
	{
		delete []curPeriodET;
		curPeriodET = NULL;
	}
	if(curPeriodPrec != NULL)
	{
		delete []curPeriodPrec;
		curPeriodPrec = NULL;
	}
	if(irrigDemand != NULL)
	{
		delete []irrigDemand;
		irrigDemand = NULL;
	}
	if(wsIrrigDemand !=NULL)
	{
		delete []wsIrrigDemand;
		wsIrrigDemand = NULL;
	}
	if(cumulativePrec !=NULL)
	{
		delete []cumulativePrec;
		cumulativePrec = NULL;
	}
	if(cumulativeET !=NULL)
	{
		delete []cumulativeET;
		cumulativeET = NULL;
	}
	if (rqual_s != NULL)
	{
		delete []rqual_s;
		rqual_s = NULL;
	}
	if (rqname_s != NULL)
	{
		delete []rqname_s;
		rqname_s = NULL;
	}
	if (rqflag_s != NULL)
	{
		delete []rqflag_s;
		rqflag_s = NULL;
	}
	if (q_bfd != NULL)
	{
		delete[]q_bfd;
		q_bfd = NULL;
	}
}

CLSPCMODEL::~CLSPCMODEL()
{
	ResetData();
}

bool CLSPCMODEL::ReadInfo(CString strFileName)
{
	CMainFrame *pWnd = (CMainFrame *)AfxGetMainWnd();

	Log("Reading input file:"+strFileName);
	FILE *fpin = NULL;
	char strLine[MAXLINE];
	
	// open the file for reading
	fpin = fopen (strFileName, "rt");
	if(fpin == NULL)
	{
		AfxMessageBox("Cannot open file "+strFileName+" for reading");
		Log("Cannot open file "+strFileName+" for reading");
		return false;
	}
	
	int Section = 0;					
	
	// skip the line start with a 'C'
	while(true)
	{
		// if this is the EOF, return
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			if(Section != 415)			//  Ftable ......    (08-02-04)
			{
				AfxMessageBox("LSPC F-tables generated using stream geometry", MB_ICONINFORMATION);
				Log("LSPC F-tables generated using stream geometry");
			}
				
			goto L222;
			
//			fclose(fpin);
			//UnitConvertion();
//			return true;
		}
		CString str(strLine);
		str.TrimLeft();
		if(str.GetLength() == 0)
			continue;

		if(str[0] == 'C' || str[0] == 'c')
		{
			//find the version 
			if(str.Find("Version 5.0") != -1)
			{
				CString STR_VERSION(strLine);
				STR_VERSION.TrimLeft("c ");
				STR_VERSION.TrimLeft();
				STR_VERSION.TrimRight();
				if(STR_VERSION != LSPC_VERSION && pWnd->bRunModel == false && pWnd->bRunNIMS == false)
				{
					AfxMessageBox("The input file that is being read was developed with a different executable file.");
				}
			}

			// if 'C' is followed by a number, read this section
			if(str.GetLength() >= 2)
			{
				if(str[1] >= '0' && str[1] <= '9')
				{
					// get section number
					int nSection;
					CStringToken strToken(str);
					CString strNum = strToken.NextToken();
					strNum = strNum.Mid(1);
					sscanf(LPCSTR(strNum),"%d",&nSection);
					TRACE("Reading section %d \n",nSection);
					Log("Reading section %d \n",nSection);
					if (nSection == 415)	// Ftable  (08-02-04)
						Section = nSection;	
					
					if (!ReadFileSection(fpin,nSection))
					{
						fclose(fpin);
						return false;
					}
				}
			}
		}
	}

L222:

	fclose(fpin);
	
	bReadDB = false;

	if (nReadc30 == 0)	//card is missing from the input text file
	{
		m_strModelResultLocation = m_strPath;	//input file path
		cWD.strWeatherFolderPath = m_strPath;	//input file path
	}
	else if (nReadc30 == 1)	//card has the weather file path only
	{
		m_strModelResultLocation = m_strPath;	//input file path
	}

	if (bReadc670 == false)
	{
		if(pTMDLDistrib != NULL)
			delete []pTMDLDistrib;

		if(ncland > 0)
		{
			int Num = nQuals + 1;	// flow is always there
			if (sedfg == 1)
				Num += 3;			// sand, silt, and clay
			int nNum = nsws*nlandp*Num;
			if(nNum > 0 )
			{
				pTMDLDistrib = new TMDL_LU_QUAL_CPARAM[nNum];
				{
					//open the external file for this card
					CString FileName = m_strPath + "c670.inp";

					// open the file for reading
					FILE *file = NULL;
					file = fopen (FileName, "rt");
					if(file == NULL)
					{
						AfxMessageBox("Cannot open file "+FileName+" for reading");
						Log("Cannot open file "+FileName+" for reading");
						return false;
					}
		
					int nSection = 670;
					Log("Reading card 670 from the file:"+FileName);
					if (!ReadInfo2(FileName, nSection, file))
					{
						fclose(file);
						return false;
					}
					
					SkipCommentLine(file);
					for(int i=0; i<nsws*nlandp; ++i)
					{
						memset (strLine, 0, MAXLINE);
						if(fgets (strLine, MAXLINE, file) == NULL)
						{
							TRACE("Wrong reading %d",nSection);
							Log("Wrong reading %d",nSection);
							fclose(file);
							return false;
						}
						CString str(strLine);
						CStringToken strToken(str," \t\r\n\"");
						pTMDLDistrib[i*Num].subbasin = atoi(LPCSTR(strToken.NextToken()));
						pTMDLDistrib[i*Num].luid = atoi(LPCSTR(strToken.NextToken()));
						pTMDLDistrib[i*Num].strLUName = strToken.NextToken();

						for (int j=0; j<Num; ++j)
						{
							pTMDLDistrib[i*Num+j].subbasin = pTMDLDistrib[i*Num].subbasin;
							pTMDLDistrib[i*Num+j].luid = pTMDLDistrib[i*Num].luid;
							pTMDLDistrib[i*Num+j].strLUName = pTMDLDistrib[i*Num].strLUName;
							pTMDLDistrib[i*Num+j].fRatio = atof(LPCSTR(strToken.NextToken()));
						}
					}
						
					//close the file
					fclose(file);
				}
			}
		}
	}
	
	//UnitConvertion();
	Log("Finished input file reading:"+strFileName);
	return true;
}

bool CLSPCMODEL::ReadInfo2(CString strFileName, int nCard, FILE *fpin)
{
	Log("Reading input file:"+strFileName);
	char strLine[MAXLINE];
	int nSection = 0;
	
	// skip the line start with a 'C'
	while(true)
	{
		// if this is the EOF, return
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			if(nSection != nCard)
			{
				AfxMessageBox("Can not find the card: %d", nCard);
				Log("Can not find the card: %d", nCard);
				return false;
			}
		}
		CString str(strLine);
		str.TrimLeft();
		if(str.GetLength() == 0)
			continue;

		if(str[0] == 'C' || str[0] == 'c')
		{
			// if 'C' is followed by a number, read this section
			if(str.GetLength() >= 2)
			{
				if(str[1] >= '0' && str[1] <= '9')
				{
					// get section number
					CStringToken strToken(str);
					CString strNum = strToken.NextToken();
					strNum = strNum.Mid(1);
					sscanf(LPCSTR(strNum),"%d",&nSection);
					TRACE("Reading section %d \n",nSection);
					Log("Reading section %d \n",nSection);
					
					if (nSection == nCard)
					{
						//found the card
						return true;
					}
				}
			}
		}
	}
}

bool CLSPCMODEL::ReadFileSection(FILE *fpin, int nSection)
{
	CMainFrame *pWnd = (CMainFrame *)AfxGetMainWnd();

	CString *strArray = NULL;
	CString strRName = "";
	CString noutsys = "";

//	FILE *fpin = fp;
	char strLine[MAXLINE];

	int *nGroupArray = NULL;
	int *nGroupId = NULL;
	int *nThresholdArray = NULL;
	int *nThresholdId = NULL;
	int *pQualid = NULL;
	int i = 0, j = 0;
	int np = 0;
	int	ni = 0;
	int nNum = 0;
	int nMarkedReach = 0;
	int nRecord = 0;
	int nReach = 0;
	int nPtSource0 = 0;
	int ncountout = 1;
	int nIndex = 0;

	long nPos;
	
	if(nSection != 30 && nSection != 31 && nSection != 46)
		SkipCommentLine(fpin);
	memset (strLine, 0, MAXLINE);
	switch(nSection)
	{
	case 0://required
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str);
			snowfg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			pwatfg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?1:1;	// required (always on)
			sedfg   = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			pqalfg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			tempfg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			oxfg    = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nutfg   = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			plkfg   = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			phfg    = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;

			if(phfg == 1)
			{
				tempfg = 1;
				pqalfg = 1;
				oxfg = 1;
				nutfg = 1;
				plkfg = 1;
			}
			else if(plkfg == 1)
			{
				tempfg = 1;
				pqalfg = 1;
				oxfg = 1;
				nutfg = 1;
			}
			else if(nutfg == 1)
			{
				tempfg = 1;
				pqalfg = 1;
				oxfg = 1;
			}
			else if(oxfg == 1)
			{
				pqalfg = 1;
				tempfg = 1;
			}
			else if(snowfg == 1)
			{
				tempfg = 1;
			}
		}		
		break;
	case 10://required
        // allocate space first
		if(cWD.pWFILEINFO != NULL)
			delete []cWD.pWFILEINFO;

		// count the number of files 
		cWD.nNumWeatherFiles = 0;
		nPos = ftell(fpin);
		while (fgets (strLine, MAXLINE, fpin) != NULL)
		{
			CString str(strLine);
			CStringToken strToken(str);
			CString str0 = strToken.NextToken();
			if(str0[0] != 'C' && str0[0] != 'c')
				++cWD.nNumWeatherFiles;
			else
			{
				fseek (fpin, nPos, SEEK_SET);
				break;
			}
			memset (strLine, 0, MAXLINE);
		}

		if(cWD.nNumWeatherFiles <= 0)
		{
			AfxMessageBox("No weather file is found");
			return false;
		}

		cWD.pWFILEINFO = new WFILEINFO[cWD.nNumWeatherFiles];
		for(i=0; i<cWD.nNumWeatherFiles; i++)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str);
			cWD.pWFILEINFO[i].nWFileID = atoi(LPCSTR(strToken.NextToken()));
			cWD.pWFILEINFO[i].strWFile = strToken.NextToken();
			cWD.pWFILEINFO[i].nWParam = atoi(LPCSTR(strToken.NextToken()));

			if (cWD.pWFILEINFO[i].nWParam > 0)
				cWD.pWFILEINFO[i].m_nParamID = new int[cWD.pWFILEINFO[i].nWParam];

			for(j=0; j<cWD.pWFILEINFO[i].nWParam; j++)
				cWD.pWFILEINFO[i].m_nParamID[j] = atoi(LPCSTR(strToken.NextToken()));
		}
		break;
	case 15://required
        // allocate space first
		if(cWD.pWSTATIONINFO != NULL)
			delete []cWD.pWSTATIONINFO;

		// count the number of files 
		cWD.nNumWeatherStations = 0;
		nPos = ftell(fpin);
		while (fgets (strLine, MAXLINE, fpin) != NULL)
		{
			CString str(strLine);
			CStringToken strToken(str);
			CString str0 = strToken.NextToken();
			if(str0[0] != 'C' && str0[0] != 'c')
				++cWD.nNumWeatherStations;
			else
			{
				fseek (fpin, nPos, SEEK_SET);
				break;
			}
			memset (strLine, 0, MAXLINE);
		}

		if(cWD.nNumWeatherStations <= 0)
			return false;

		cWD.pWSTATIONINFO = new WSTATIONINFO[cWD.nNumWeatherStations];
		for(i=0; i<cWD.nNumWeatherStations; i++)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str);
			cWD.pWSTATIONINFO[i].nWStationID = atoi(LPCSTR(strToken.NextToken()));
			cWD.pWSTATIONINFO[i].nWFile = atoi(LPCSTR(strToken.NextToken()));

			cWD.nNumWeatherParam = 0;

			if (cWD.pWSTATIONINFO[i].nWFile > 0)
				cWD.pWSTATIONINFO[i].m_nWFileIndex = new int[cWD.pWSTATIONINFO[i].nWFile];
			
			for(j=0; j<cWD.pWSTATIONINFO[i].nWFile; j++)
			{
				int nID = atoi(LPCSTR(strToken.NextToken()));
				nIndex = cWD.FindFileIndex(nID);
				cWD.pWSTATIONINFO[i].m_nWFileIndex[j] = nIndex;
				cWD.nNumWeatherParam += cWD.pWFILEINFO[nIndex].nWParam;
			}

			//check the number of weather parameters for this weather station
			if (cWD.nNumWeatherParam < 2)
			{
				CString strError;
				strError.Format("Weather Station %d: Precipitation and ET data is required to run the model",cWD.pWSTATIONINFO[i].nWStationID);
				AfxMessageBox(strError);
				TRACE(strError);
				Log(strError);
				return false;
			}

			if ((snowfg == 1 || tempfg == 1) && cWD.nNumWeatherParam < 6)
			{
				CString strError;
				strError.Format("Weather Station %d: Missing weather parameter(s) to simulate snow/temperature",cWD.pWSTATIONINFO[i].nWStationID);
				AfxMessageBox(strError);
				TRACE(strError);
				Log(strError);
				return false;
			}
		}
		break;
	case 20://required
        // allocate space first
		if(cWD.pWSTATIONINFO == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}

		for(i=0; i<cWD.nNumWeatherStations; i++)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str);
			int nID = atoi(LPCSTR(strToken.NextToken()));
			//find the station index
			nIndex = cWD.FindStationIndex(nID);

			//allocate memory
			if (cWD.pWSTATIONINFO[nIndex].m_lfMultiplier != NULL)
				delete[]cWD.pWSTATIONINFO[nIndex].m_lfMultiplier;
			if(cWD.nNumWeatherParam > 0)
				cWD.pWSTATIONINFO[nIndex].m_lfMultiplier = new double[cWD.nNumWeatherParam];

			for (j=0; j<cWD.nNumWeatherParam; j++)
				cWD.pWSTATIONINFO[nIndex].m_lfMultiplier[j] = atof(LPCSTR(strToken.NextToken()));
		}
		break;
	case 30://required
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str);
			CString FileName = strToken.NextToken();

			if (strToken.HasMoreTokens())
			{
				nReadc30 = 2;
				m_strModelResultLocation = FileName;
				cWD.strWeatherFolderPath = strToken.NextToken();
			}
			else
			{
				nReadc30 = 1;
				//m_strModelResultLocation = FileName;	//location of the input file path
				cWD.strWeatherFolderPath = FileName;
			}

			//check if weather data directory path is correct
			if (!FolderExists(cWD.strWeatherFolderPath))
			{
				//open dialog box to select the folder
				CDirDialog dlg;
				dlg.m_strSelDir = cWD.strWeatherFolderPath;
				dlg.m_strTitle = "Weather Station Data Directory:";
				if(dlg.DoBrowse() == 1)
					cWD.strWeatherFolderPath = dlg.m_strPath;
			}

			if(cWD.strWeatherFolderPath.GetAt(cWD.strWeatherFolderPath.GetLength()-1) != '\\'
				&& cWD.strWeatherFolderPath.GetAt(cWD.strWeatherFolderPath.GetLength()-1) != '/')
				cWD.strWeatherFolderPath += "\\";
			if (nReadc30 == 2)
			{
				if(m_strModelResultLocation.GetAt(m_strModelResultLocation.GetLength()-1) != '\\'
					&& m_strModelResultLocation.GetAt(m_strModelResultLocation.GetLength()-1) != '/')
					m_strModelResultLocation += "\\";
			}
		}
		break;
	case 31: // point source file (optional)  
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			break;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str);
			strPointFilePath = strToken.NextToken();	// input file location		 
			strPointFileName = strToken.NextToken();	// input point file name	 

			//check if the directory path is correct
			if (!FolderExists(strPointFilePath))
			{
				//open dialog box to select the folder
				CDirDialog dlg;
				dlg.m_strSelDir = strPointFilePath;
				dlg.m_strTitle = "Point Source Data Directory:";
				if(dlg.DoBrowse() == 1)
					strPointFilePath = dlg.m_strPath;
			}

			if (strPointFilePath.GetAt(1) == ':')
			{
				if(strPointFilePath.GetAt(strPointFilePath.GetLength()-1) != '\\'
					&& strPointFilePath.GetAt(strPointFilePath.GetLength()-1) != '/')
					strPointFilePath += "\\";
				m_strPSDataLocation = strPointFilePath + strPointFileName;
			}
			else
			{
				strPointFilePath = "";			 
				strPointFileName = "";		 
			}
		}
		break;
	case 32: // landuse-change file (optional)  
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			break;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str);
			// flag to use landuse-change file (0-off)
			cLU.nLUchangeFlag = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			// input landuse-change file path
			cLU.strLUchangeFilePath = strToken.NextToken();
			
			if (cLU.nLUchangeFlag != 0 && cLU.strLUchangeFilePath.GetLength() == 0)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
		}
		break;
	case 40://required
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nsws);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nch);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nrgroup);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&ngroup);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nlandp);
		}
		break;
	case 45://required
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			nDefault = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nSnow = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nHydro = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nSed = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nGQUAL = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nRQUAL = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nCustom = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nLUsummary = atoi(LPCSTR(strToken.NextToken()));
			nCHsummary = atoi(LPCSTR(strToken.NextToken()));
			nPSsummary = atoi(LPCSTR(strToken.NextToken()));
			nThreshold = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nSUSTAIN = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;

			if (nLUsummary > 0)
			{
				if (nLUsummary > 3) nLUsummary = 1;
				summarylevel = nLUsummary - 1;
			}
			if (nCHsummary > 0)
			{
				if (nLUsummary > 0) 
					nCHsummary = nLUsummary;
				else if (nCHsummary > 3) 
					nCHsummary = 1;
				summarylevel = nCHsummary - 1;
			}
			if (nPSsummary > 0)
			{
				if (nLUsummary > 0) 
					nPSsummary = nLUsummary;
				else if (nCHsummary > 0) 
					nPSsummary = nCHsummary;
				else if (nPSsummary > 3) 
					nPSsummary = 1;
				summarylevel = nPSsummary - 1;
			}

			if (nDefault == 1)
			{
				nSnow = 0;
				nHydro = 0;
				nSed = 0;
				nGQUAL = 0;
				nRQUAL = 0;
				nCustom = 0;
			}
			else if (nSnow == 1 || nHydro == 1 || nSed == 1 || nGQUAL == 1 || nRQUAL == 1)
			{
				nDefault = 0;
				nCustom = 0;
			}
			else if (nCustom == 1)
			{
				nDefault = 0;
				nSnow = 0;
				nHydro = 0;
				nSed = 0;
				nGQUAL = 0;
				nRQUAL = 0;
			}
		}
		break;
	case 46://optional
		if(nCustom == 1)
			SkipCommentLine(fpin);
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			break;
		}
		if(nCustom == 1)
		{
			//read all the flags
			int i = 0;
			int nTemp;
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			for(i=0; i<PARA_NUM; ++i)
			{
				if(strToken.HasMoreTokens())
				{
					sscanf(LPCSTR(strToken.NextToken()),"%d",&nTemp);
					cOP.blistOutput[i] = (nTemp == 1)?true:false;
				}
			}
		}
		break;
	case 50://required
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			int nYear,nMonth,nDay;
			CString str(strLine);
			CStringToken strToken(str);
			sscanf(LPCSTR(strToken.NextToken()),"%d/%d/%d",&nMonth,&nDay,&nYear);
			tStart = COleDateTime(nYear,nMonth,nDay,0,0,0);
			sscanf(LPCSTR(strToken.NextToken()),"%d/%d/%d",&nMonth,&nDay,&nYear);
			tEnd = COleDateTime(nYear,nMonth,nDay,23,59,59);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&deltm);
			sscanf(LPCSTR(strToken.NextToken()),"%d/%d/%d",&nMonth,&nDay,&nYear);
			toStart = COleDateTime(nYear,nMonth,nDay,0,0,0);
			sscanf(LPCSTR(strToken.NextToken()),"%d/%d/%d",&nMonth,&nDay,&nYear);
			toEnd = COleDateTime(nYear,nMonth,nDay,23,59,59);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&optlevel);

			//only support daily or time step output
			if(optlevel > 2)	
				optlevel = 1;                                                 

			delts = deltm * 60.;	// sec	
			delt60 = deltm / 60.;	// hour
			deltd = deltm / 1440.;	// day	
		}
		break;
	case 60:
		// group information
		if(pswsinfo != NULL)
			delete []pswsinfo;
		if(nGroupArray != NULL)
			delete []nGroupArray;
		if(nGroupId != NULL)
			delete []nGroupId;

		if(nsws <= 0 || ngroup <= 0)
			return false;

		nGroupId = new int[ngroup];
		nGroupArray = new int[nsws];
		pswsinfo = new swsinfo[nsws];

		for(i=0; i<nsws; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			int nID;
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pswsinfo[i].subbasin);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pswsinfo[i].gid);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pswsinfo[i].nwst);
			if (pswsinfo[i].nwst > 0)
			{
				if (pswsinfo[i].wstindex != NULL)
					delete[]pswsinfo[i].wstindex;
				pswsinfo[i].wstindex = new int[pswsinfo[i].nwst];
				if (pswsinfo[i].wti != NULL)
					delete[]pswsinfo[i].wti;
				pswsinfo[i].wti = new double[pswsinfo[i].nwst];
			}

			for (j=0; j<pswsinfo[i].nwst; j++)
			{
				sscanf(LPCSTR(strToken.NextToken()),"%d",&nID);
				pswsinfo[i].wstindex[j] = cWD.FindStationIndex(nID);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pswsinfo[i].wti[j]);
			}
			//array of land group id
			nGroupArray[i] = pswsinfo[i].gid;
		}
		
		//sort the array
		qsort (nGroupArray, nsws, sizeof(int), compare);

		if (ngroup > 0)
		{
			int gid = -1;
			CList<int,int> nGroupList;
			for (i=0; i<nsws; i++)
			{
				if (nGroupArray[i] != gid)
				{
					gid = nGroupArray[i];
					nGroupList.AddTail(nGroupArray[i]);
				}

			}

			if (ngroup != nGroupList.GetCount())
				AfxMessageBox("Number of Land Groups in Card 40 should be equal to the number of Land Groups in card 60");

			nIndex = 0;
			POSITION pos = nGroupList.GetHeadPosition();
			while (pos)
				nGroupId[nIndex++] = nGroupList.GetNext(pos);

			for (i=0; i<nsws; i++)
			{
				for (j=0; j<ngroup; j++)
				{
					if (pswsinfo[i].gid == nGroupId[j])
					{
						pswsinfo[i].gindex = j;
						break;
					}
				}
			}
			// Remove all of the elements in the list.
			nGroupList.RemoveAll();
		}

		if (nGroupArray != NULL)	delete []nGroupArray;
		if (nGroupId != NULL)		delete []nGroupId;

		break;
	case 70://required
		// pervious landuse
		if(ppluinfo != NULL)
			delete []ppluinfo;
		if(nlandp <= 0)
			return false;
		ppluinfo = new LandUsePInfo[nlandp];
		for(i = 0; i < nlandp; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			sscanf(LPCSTR(strToken.NextToken()),"%d",&ppluinfo[i].luidp);
			ppluinfo[i].plusname = strToken.NextToken();
			ppluinfo[i].luPREmult = atof(LPCSTR(strToken.NextToken()));
			ppluinfo[i].luPETmult = atof(LPCSTR(strToken.NextToken()));
		}
		break;
	case 80://required
		if(pLURoute != NULL)
			delete []pLURoute;

		if(ngroup <=0 || nlandp <= 0)
			return false;
		nNum = ngroup*nlandp;
		pLURoute = new LURoute[nNum];
		for(i=0; i<nNum; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pLURoute[i].gid);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pLURoute[i].luid);
			sscanf(LPCSTR(strToken.NextToken()),"%lf",&pLURoute[i].input_suro);
			sscanf(LPCSTR(strToken.NextToken()),"%lf",&pLURoute[i].input_ifwo);
			sscanf(LPCSTR(strToken.NextToken()),"%lf",&pLURoute[i].input_agwo);
			
			//validate the route_suro
			if (pLURoute[i].input_suro >= 1)
			{
				pLURoute[i].route_suro = 1;
				pLURoute[i].bypass_suro = 0;
			}
			else if(pLURoute[i].input_suro <= -1)
			{
				pLURoute[i].route_suro = 0;
				pLURoute[i].bypass_suro = 0;
			}
			else if(pLURoute[i].input_suro >= 0)
			{
				pLURoute[i].route_suro = pLURoute[i].input_suro;
				pLURoute[i].bypass_suro = 1-pLURoute[i].route_suro;
			}
			else // it is negative which is lost from the system
			{
				pLURoute[i].route_suro = 1+pLURoute[i].input_suro;
				pLURoute[i].bypass_suro = 0;
			}

			//validate the route_ifwo
			if (pLURoute[i].input_ifwo >= 1)
			{
				pLURoute[i].route_ifwo = 1;
				pLURoute[i].bypass_ifwo = 0;
			}
			else if(pLURoute[i].input_ifwo <= -1)
			{
				pLURoute[i].route_ifwo = 0;
				pLURoute[i].bypass_ifwo = 0;
			}
			else if(pLURoute[i].input_ifwo >= 0)
			{
				pLURoute[i].route_ifwo = pLURoute[i].input_ifwo;
				pLURoute[i].bypass_ifwo = 1-pLURoute[i].route_ifwo;
			}
			else // it is negative which is lost from the system
			{
				pLURoute[i].route_ifwo = 1+pLURoute[i].input_ifwo;
				pLURoute[i].bypass_ifwo = 0;
			}

			//validate the route_agwo
			if (pLURoute[i].input_agwo >= 1)
			{
				pLURoute[i].route_agwo = 1;
				pLURoute[i].bypass_agwo = 0;
			}
			else if (pLURoute[i].input_agwo <= -1)
			{
				pLURoute[i].route_agwo = 0;
				pLURoute[i].bypass_agwo = 0;
			}
			else if(pLURoute[i].input_agwo >= 0)
			{
				pLURoute[i].route_agwo = pLURoute[i].input_agwo;
				pLURoute[i].bypass_agwo = 1-pLURoute[i].route_agwo;
			}
			else // it is negative which is lost from the system
			{
				pLURoute[i].route_agwo = 1+pLURoute[i].input_agwo;
				pLURoute[i].bypass_agwo = 0;
			}
		}
		break;
	case 90://required
		if(pluinfop != NULL)
			delete []pluinfop;

		if(nlandp <=0 || nsws <= 0)
			return false;
		nNum = nlandp*nsws;
		pluinfop = new LUInfo[nNum];

		nIndex = -1;
		nlandimp = 0;
		for(i=0; i<nNum; i++)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pluinfop[i].subbasin);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pluinfop[i].luid);
			pluinfop[i].luname = strToken.NextToken();
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pluinfop[i].piid);
			sscanf(LPCSTR(strToken.NextToken()),"%lf",&pluinfop[i].area);
			sscanf(LPCSTR(strToken.NextToken()),"%lf",&pluinfop[i].slsur);
			sscanf(LPCSTR(strToken.NextToken()),"%lf",&pluinfop[i].lsur);

			//flag no landuse change as default
			pluinfop[i].bLUchange = false;
			pluinfop[i].sindex = -1;
			pluinfop[i].records = 0;
			pluinfop[i].m_fileOut = NULL;

			//count the number of impervious land uses
			if (nIndex == -1)
				nIndex = pluinfop[i].subbasin;
			if (pluinfop[i].piid == 1 && pluinfop[i].subbasin == nIndex)
				nlandimp++;
		}
		break;
	//snow related parameters
	case 92:
		if(pSnowCtl2 != NULL)
			delete []pSnowCtl2;

		if(snowfg == 1)
		{
			int nRecords = nlandp*ngroup;
			if(nRecords <= 0)
				return false;
			pSnowCtl2 = new CSnowControl2[nRecords];
			for(int i=0; i<nRecords; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf",
					&pSnowCtl2[i].nGrpid,
					&pSnowCtl2[i].luid,
					&pSnowCtl2[i].ICEFLAG,
					&pSnowCtl2[i].lfForest,
					&pSnowCtl2[i].fzg,
					&pSnowCtl2[i].fzgl);
			}
		}
		break;
	case 93:
		if(pSnowParam1 != NULL)
			delete []pSnowParam1;
			
		if(snowfg == 1)
		{
			int nRecords = nlandp*ngroup;
			
			if(nRecords <= 0)
				return false;
			pSnowParam1 = new CSnowParam1[nRecords];
			for(int i=0; i<nRecords; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf",
					&pSnowParam1[i].nGrpid,
					&pSnowParam1[i].luid,
					&pSnowParam1[i].LAT,
					&pSnowParam1[i].MELEV,
					&pSnowParam1[i].SHADE,
					&pSnowParam1[i].SNOWCF,
					&pSnowParam1[i].COVIND);
			}
		}
		break;
	case 94:
		if(pSnowParam2 != NULL)
			delete []pSnowParam2;

		if(snowfg == 1)
		{
			int nRecords = nlandp*ngroup;
			
			if(nRecords <= 0)
				return false;
			pSnowParam2 = new CSnowParam2[nRecords];
			for(int i=0; i<nRecords; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf",
					&pSnowParam2[i].nGrpid,
					&pSnowParam2[i].luid,
					&pSnowParam2[i].RDCSN,
					&pSnowParam2[i].TSNOW,
					&pSnowParam2[i].SNOEVP,
					&pSnowParam2[i].CCFACT,
					&pSnowParam2[i].MWATER,
					&pSnowParam2[i].MGMELT);
			}
		}
		break;
	case 96:
		if(pSnowInit1 != NULL)
			delete []pSnowInit1;
			
		if(snowfg == 1)
		{
			int nRecords = nlandp*ngroup;
			if(nRecords <= 0)
				return false;
			pSnowInit1 = new CSnowInit1[nRecords];
			for(int i=0; i<nRecords; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pSnowInit1[i].nGrpid,
					&pSnowInit1[i].luid,
					&pSnowInit1[i].packsnow,
					&pSnowInit1[i].packice,
					&pSnowInit1[i].packwatr,
					&pSnowInit1[i].RDENPF,
					&pSnowInit1[i].DULL,
					&pSnowInit1[i].PAKTMP,
					&pSnowInit1[i].COVINX,
					&pSnowInit1[i].XLNMLT,
					&pSnowInit1[i].SKYCLR);
			}
		}
		break;
	case 100://required
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str);
			vcsfg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			vuzfg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			vnnfg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			vifwfg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			vircfg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			vlefg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
		}
		break;
	case 110://required
		//pwat-parm2
		if(ppw_param2!=NULL)
			delete []ppw_param2;
		nNum = nlandp*ngroup;
		if(nNum <= 0)
			return false;
		ppw_param2 = new PW_PARA2[nNum];
		for(i = 0; i< nNum; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			sscanf(strLine,"%d %d %lf %lf %lf %lf",&ppw_param2[i].gid,&ppw_param2[i].lid,&ppw_param2[i].lzsn_p,&ppw_param2[i].infilt_p,&ppw_param2[i].kvary_p,&ppw_param2[i].agwr_p);
		}
		break;
	case 120://required
		//pwat-parm3
		if(ppw_param3!=NULL)
			delete []ppw_param3;
		
		nNum = nlandp*ngroup;
		if(nNum <= 0)
			return false;
		ppw_param3 = new PW_PARA3[nNum];
		for(i = 0; i< nNum; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf",&ppw_param3[i].gid,&ppw_param3[i].lid,&ppw_param3[i].petmax_p,&ppw_param3[i].petmin_p,&ppw_param3[i].infexp_p,&ppw_param3[i].infild_p,&ppw_param3[i].deepfr_p,&ppw_param3[i].basetp_p,&ppw_param3[i].agwetp_p);
		}
		break;
	case 130://required
		//pwat-parm4
		if(ppw_param4!=NULL)
			delete []ppw_param4;
		nNum = nlandp*ngroup;
		if(nNum <= 0)
			return false;
		ppw_param4 = new PW_PARA4[nNum];
		for(i = 0; i< nNum; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				return false;
			}
			sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf",&ppw_param4[i].gid,&ppw_param4[i].lid,&ppw_param4[i].cepsc_p,&ppw_param4[i].uzsn_p,&ppw_param4[i].nsur_p,&ppw_param4[i].intfw_p,&ppw_param4[i].irc_p,&ppw_param4[i].lzetp_p);
		}
		break;
	case 140://required
		// pw-state1
		if(ppw_state!=NULL)
			delete []ppw_state;
		nNum = nlandp*ngroup;
		if(nNum <= 0)
			return false;
		ppw_state = new PW_STATE[nNum];
		for(i = 0; i< nNum; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf",&ppw_state[i].gid,&ppw_state[i].lid,&ppw_state[i].ceps_p,&ppw_state[i].surs_p,&ppw_state[i].uzs_p,&ppw_state[i].ifws_p,&ppw_state[i].lzs_p,&ppw_state[i].agws_p,&ppw_state[i].gwvs_p);
		}
		break;
	case 150:
		if(cepscm_p!=NULL)
			delete []cepscm_p;
			
		if(vcsfg==1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			cepscm_p = new MON_DATE[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&cepscm_p[i].gid,
					&cepscm_p[i].lid,
					&cepscm_p[i].fnum[0],
					&cepscm_p[i].fnum[1],
					&cepscm_p[i].fnum[2],
					&cepscm_p[i].fnum[3],
					&cepscm_p[i].fnum[4],
					&cepscm_p[i].fnum[5],
					&cepscm_p[i].fnum[6],
					&cepscm_p[i].fnum[7],
					&cepscm_p[i].fnum[8],
					&cepscm_p[i].fnum[9],
					&cepscm_p[i].fnum[10],
					&cepscm_p[i].fnum[11]);
			}
		}
		break;
	case 160:
		if(uzsnm_p!=NULL)
			delete []uzsnm_p;
		if(vuzfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			uzsnm_p = new MON_DATE[nNum];
			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&uzsnm_p[i].gid,
					&uzsnm_p[i].lid,
					&uzsnm_p[i].fnum[0],
					&uzsnm_p[i].fnum[1],
					&uzsnm_p[i].fnum[2],
					&uzsnm_p[i].fnum[3],
					&uzsnm_p[i].fnum[4],
					&uzsnm_p[i].fnum[5],
					&uzsnm_p[i].fnum[6],
					&uzsnm_p[i].fnum[7],
					&uzsnm_p[i].fnum[8],
					&uzsnm_p[i].fnum[9],
					&uzsnm_p[i].fnum[10],
					&uzsnm_p[i].fnum[11]);
			}
		}
		break;
	case 170:
		if(nsurm_p!=NULL)
			delete []nsurm_p;

		if(vnnfg==1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			nsurm_p = new MON_DATE[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&nsurm_p[i].gid,
					&nsurm_p[i].lid,
					&nsurm_p[i].fnum[0],
					&nsurm_p[i].fnum[1],
					&nsurm_p[i].fnum[2],
					&nsurm_p[i].fnum[3],
					&nsurm_p[i].fnum[4],
					&nsurm_p[i].fnum[5],
					&nsurm_p[i].fnum[6],
					&nsurm_p[i].fnum[7],
					&nsurm_p[i].fnum[8],
					&nsurm_p[i].fnum[9],
					&nsurm_p[i].fnum[10],
					&nsurm_p[i].fnum[11]);
			}
		}
		break;
	case 180:
		if(intfwm_p!=NULL)
			delete []intfwm_p;
		if(vifwfg==1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			intfwm_p = new MON_DATE[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&intfwm_p[i].gid,
					&intfwm_p[i].lid,
					&intfwm_p[i].fnum[0],
					&intfwm_p[i].fnum[1],
					&intfwm_p[i].fnum[2],
					&intfwm_p[i].fnum[3],
					&intfwm_p[i].fnum[4],
					&intfwm_p[i].fnum[5],
					&intfwm_p[i].fnum[6],
					&intfwm_p[i].fnum[7],
					&intfwm_p[i].fnum[8],
					&intfwm_p[i].fnum[9],
					&intfwm_p[i].fnum[10],
					&intfwm_p[i].fnum[11]);
			}
		}
		break;
	case 190:
		if(ircm_p!=NULL)
			delete []ircm_p;
		if(vircfg==1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			ircm_p = new MON_DATE[nNum];
			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&ircm_p[i].gid,
					&ircm_p[i].lid,
					&ircm_p[i].fnum[0],
					&ircm_p[i].fnum[1],
					&ircm_p[i].fnum[2],
					&ircm_p[i].fnum[3],
					&ircm_p[i].fnum[4],
					&ircm_p[i].fnum[5],
					&ircm_p[i].fnum[6],
					&ircm_p[i].fnum[7],
					&ircm_p[i].fnum[8],
					&ircm_p[i].fnum[9],
					&ircm_p[i].fnum[10],
					&ircm_p[i].fnum[11]);
			}
		}
		break;
	case 200:
		if(lzetpm_p!=NULL)
			delete []lzetpm_p;
		if(vlefg==1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			lzetpm_p = new MON_DATE[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&lzetpm_p[i].gid,
					&lzetpm_p[i].lid,
					&lzetpm_p[i].fnum[0],
					&lzetpm_p[i].fnum[1],
					&lzetpm_p[i].fnum[2],
					&lzetpm_p[i].fnum[3],
					&lzetpm_p[i].fnum[4],
					&lzetpm_p[i].fnum[5],
					&lzetpm_p[i].fnum[6],
					&lzetpm_p[i].fnum[7],
					&lzetpm_p[i].fnum[8],
					&lzetpm_p[i].fnum[9],
					&lzetpm_p[i].fnum[10],
					&lzetpm_p[i].fnum[11]);
			}
		}
		break;
	case 201://required
        if(fgets (strLine, MAXLINE, fpin) == NULL)
        {
            TRACE("Wrong reading %d",nSection);
            Log("Wrong reading %d",nSection);
            return false;
        }
		else
		{
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			irrigfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			petfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			monVaryIrrig = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
		}
		break;
    case 202: 
        if(pirrigpet != NULL)
            delete []pirrigpet;

        if(irrigfg == 1 && petfg == 1) 
		{
            nNum = ngroup;
            if(nNum <= 0)
                return false;
            pirrigpet = new IrrigPET[nNum];

            for(i = 0; i < nNum; ++i)
            {
                memset (strLine, 0, MAXLINE);
                if(fgets (strLine, MAXLINE, fpin) == NULL)
                {
                    TRACE("Wrong reading %d",nSection);
                    Log("Wrong reading %d",nSection);
                    return false;
                }
                CString str(strLine);
                CStringToken strToken(str," \t\r\n\"");
                sscanf(LPCSTR(strToken.NextToken()),"%d",&pirrigpet[i].gid);
                sscanf(LPCSTR(strToken.NextToken()),"%lf",&pirrigpet[i].petval);
            }
        }
        break;
    case 203: 
        if(pirriginfop != NULL)
            delete []pirriginfop;

        if(irrigfg == 1) 
		{
            nNum = ngroup*nlandp;
            if(nNum <= 0)
                return false;
            pirriginfop = new IrrigInfo[nNum];

            for(i = 0; i < nNum; ++i)
            {
                memset (strLine, 0, MAXLINE);
                if(fgets (strLine, MAXLINE, fpin) == NULL)
                {
                    TRACE("Wrong reading %d",nSection);
                    Log("Wrong reading %d",nSection);
                    return false;
                }
                CString str(strLine);
                CStringToken strToken(str," \t\r\n\"");
                sscanf(LPCSTR(strToken.NextToken()),"%d",&pirriginfop[i].gid);
                sscanf(LPCSTR(strToken.NextToken()),"%d",&pirriginfop[i].luid);
                sscanf(LPCSTR(strToken.NextToken()),"%d",&pirriginfop[i].startmonth);
                sscanf(LPCSTR(strToken.NextToken()),"%d",&pirriginfop[i].endmonth);
                sscanf(LPCSTR(strToken.NextToken()),"%lf",&pirriginfop[i].fraction1);
                sscanf(LPCSTR(strToken.NextToken()),"%lf",&pirriginfop[i].fraction2);
                sscanf(LPCSTR(strToken.NextToken()),"%lf",&pirriginfop[i].fraction3);
                sscanf(LPCSTR(strToken.NextToken()),"%lf",&pirriginfop[i].fraction4);
                sscanf(LPCSTR(strToken.NextToken()),"%lf",&pirriginfop[i].fraction5);
                sscanf(LPCSTR(strToken.NextToken()),"%lf",&pirriginfop[i].etcoeff);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&pirriginfop[i].etdays);
            }
        }
        break;
	case 204: 
        if(pmonetcinfop != NULL)
            delete []pmonetcinfop;
        if(irrigfg == 1 && monVaryIrrig == 1) 
		{
            nNum = ngroup*nlandp;
            if(nNum <= 0)
                return false;
            pmonetcinfop = new MonETCInfo[nNum];

            for(i = 0; i < nNum; ++i)
            {
                memset (strLine, 0, MAXLINE);
                if(fgets (strLine, MAXLINE, fpin) == NULL)
                {
                    TRACE("Wrong reading %d",nSection);
                    Log("Wrong reading %d",nSection);
                    return false;
                }
                CString str(strLine);
                CStringToken strToken(str," \t\r\n\"");
                sscanf(LPCSTR(strToken.NextToken()),"%d",&pirriginfop[i].gid);
                sscanf(LPCSTR(strToken.NextToken()),"%d",&pirriginfop[i].luid);
				for(int mon = 0 ; mon < 12; mon++)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&pmonetcinfop[i].monETCs[mon]);
            }
        }
        break;
	case 205: 
		if(pirrigwdinfo != NULL)
			delete []pirrigwdinfo ;
		if(irrigfg == 1)
		{
			nNum = nsws ; 
			if(nNum <=0 )
				return false;
			pirrigwdinfo = new IrrigWDInfo[nNum];
			for(i = 0; i < nNum ; ++i )
			{
                memset (strLine, 0, MAXLINE);
                if(fgets (strLine, MAXLINE, fpin) == NULL)
                {
                    TRACE("Wrong reading %d",nSection);
                    Log("Wrong reading %d",nSection);
                    return false;
                }
                CString str(strLine);
                CStringToken strToken(str," \t\r\n\"");
                sscanf(LPCSTR(strToken.NextToken()),"%d",&pirrigwdinfo[i].wsid);
                sscanf(LPCSTR(strToken.NextToken()),"%d",&pirrigwdinfo[i].streamid);
                sscanf(LPCSTR(strToken.NextToken()),"%lf",&pirrigwdinfo[i].irrigdep);
//				pirrigwdinfo[i].extsrc = true;
			}
		}
		break;
	case 250:
		if(pQual!=NULL)
			delete []pQual;

		if(pqalfg == 1)
		{
			// count
			gqsdfg = 0;
			nQuals = 0;
			nPos = ftell(fpin);
			while (fgets (strLine, MAXLINE, fpin) != NULL)
			{
				CString str(strLine);
				CStringToken strToken(str);
				CString str0 = strToken.NextToken();
				if(str0[0] != 'C' && str0[0] != 'c')
					++nQuals;
				else
				{
					fseek (fpin, nPos, SEEK_SET);
					break;
				}
				memset (strLine, 0, MAXLINE);
			}
			// allocate memory
			nQuals /= ngroup;   
			if(nQuals == 0)
				return false;
			nNum = nQuals*ngroup;
			if(nNum <= 0)
				return false;
			pQual = new QUALS[nNum];    
			// read the input info
			for(i=0; i<nNum; i++)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d ",&pQual[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d ",&pQual[i].qualid);
				pQual[i].qname = strToken.NextToken();
				CString str0 = strToken.NextToken();
				str0.MakeLower();
				pQual[i].qunit = str0;
				pQual[i].qsdfg = atoi(LPCSTR(strToken.NextToken()));
				pQual[i].gqsdfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
				pQual[i].qsofg = (atoi(LPCSTR(strToken.NextToken())) == 1)?1:2;
				pQual[i].potfcfg = (atoi(LPCSTR(strToken.NextToken())) == 1)?1:2;
				if (pQual[i].gqsdfg == 1) gqsdfg = 1;
			}
		}
		break;
	case 255:
		if(pqalfg == 1)
		{
			if(fgets (strLine, MAXLINE, fpin) == NULL)
				return false;
			CString str(strLine);
			CStringToken strToken(str);
			vqofg  = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			qsowfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			vsqcfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			qifwfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			viqcfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			qagwfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			vaqcfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			adfglnd   = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			maddfglnd = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			mawdfglnd = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
		}
		break;
	case 260:
		if(pQualInput!=NULL)
			delete []pQualInput;
		if(pqalfg == 1)
		{
			nNum = ngroup*nQuals*nlandp;
			if(nNum <= 0)
				return false;
			pQualInput = new QUAL_INPUT[nNum];

			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&pQualInput[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&pQualInput[i].qualid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&pQualInput[i].lid);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].sqo);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].potfw);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].potfs);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].potfc);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].acqop);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].sqolim);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].wsqop);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].soqc);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].ioqc);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].aoqc);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].addc);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualInput[i].awdc);
			}
		}
		break;
	case 270:
		if(pIMonAccum!=NULL)
			delete []pIMonAccum;
		if(pqalfg == 1 && vqofg == 1)
		{
			nNum = ngroup*nQuals*nlandp;
			if(nNum <= 0)
				return false;
			pIMonAccum = new IMON_DATE[nNum];
			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pIMonAccum[i].gid,
					&pIMonAccum[i].qualid,
					&pIMonAccum[i].lid,
					&pIMonAccum[i].fnum[0],
					&pIMonAccum[i].fnum[1],
					&pIMonAccum[i].fnum[2],
					&pIMonAccum[i].fnum[3],
					&pIMonAccum[i].fnum[4],
					&pIMonAccum[i].fnum[5],
					&pIMonAccum[i].fnum[6],
					&pIMonAccum[i].fnum[7],
					&pIMonAccum[i].fnum[8],
					&pIMonAccum[i].fnum[9],
					&pIMonAccum[i].fnum[10],
					&pIMonAccum[i].fnum[11]);
			}
		}
		break;
	case 271:
		if(pIMonSQOLIM!=NULL)
			delete []pIMonSQOLIM;
		if(pqalfg == 1 && vqofg == 1)
		{
			nNum = ngroup*nQuals*nlandp;
			if(nNum <= 0)
				return false;
			pIMonSQOLIM = new IMON_DATE[nNum];
			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pIMonSQOLIM[i].gid,
					&pIMonSQOLIM[i].qualid,
					&pIMonSQOLIM[i].lid,
					&pIMonSQOLIM[i].fnum[0],
					&pIMonSQOLIM[i].fnum[1],
					&pIMonSQOLIM[i].fnum[2],
					&pIMonSQOLIM[i].fnum[3],
					&pIMonSQOLIM[i].fnum[4],
					&pIMonSQOLIM[i].fnum[5],
					&pIMonSQOLIM[i].fnum[6],
					&pIMonSQOLIM[i].fnum[7],
					&pIMonSQOLIM[i].fnum[8],
					&pIMonSQOLIM[i].fnum[9],
					&pIMonSQOLIM[i].fnum[10],
					&pIMonSQOLIM[i].fnum[11]);
			}
		}
		break;
	case 272:
		if(pIMonSUROCONC!=NULL)
			delete []pIMonSUROCONC;
		if(pqalfg == 1 && vsqcfg == 1)
		{
			nNum = ngroup*nQuals*nlandp;
			if(nNum <= 0)
				return false;
			pIMonSUROCONC = new IMON_DATE[nNum];
			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pIMonSUROCONC[i].gid,
					&pIMonSUROCONC[i].qualid,
					&pIMonSUROCONC[i].lid,
					&pIMonSUROCONC[i].fnum[0],
					&pIMonSUROCONC[i].fnum[1],
					&pIMonSUROCONC[i].fnum[2],
					&pIMonSUROCONC[i].fnum[3],
					&pIMonSUROCONC[i].fnum[4],
					&pIMonSUROCONC[i].fnum[5],
					&pIMonSUROCONC[i].fnum[6],
					&pIMonSUROCONC[i].fnum[7],
					&pIMonSUROCONC[i].fnum[8],
					&pIMonSUROCONC[i].fnum[9],
					&pIMonSUROCONC[i].fnum[10],
					&pIMonSUROCONC[i].fnum[11]);
			}
		}
		break;
	case 273:
		if(pIMonINTERCONC!=NULL)
			delete []pIMonINTERCONC;
		if(pqalfg == 1 && viqcfg == 1)
		{
			nNum = ngroup*nQuals*nlandp;
			if(nNum <= 0)
				return false;
			pIMonINTERCONC = new IMON_DATE[nNum];
			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pIMonINTERCONC[i].gid,
					&pIMonINTERCONC[i].qualid,
					&pIMonINTERCONC[i].lid,
					&pIMonINTERCONC[i].fnum[0],
					&pIMonINTERCONC[i].fnum[1],
					&pIMonINTERCONC[i].fnum[2],
					&pIMonINTERCONC[i].fnum[3],
					&pIMonINTERCONC[i].fnum[4],
					&pIMonINTERCONC[i].fnum[5],
					&pIMonINTERCONC[i].fnum[6],
					&pIMonINTERCONC[i].fnum[7],
					&pIMonINTERCONC[i].fnum[8],
					&pIMonINTERCONC[i].fnum[9],
					&pIMonINTERCONC[i].fnum[10],
					&pIMonINTERCONC[i].fnum[11]);
			}
		}
		break;
	case 274:
		if(pIMonGRNDCONC!=NULL)
			delete []pIMonGRNDCONC;
		if(pqalfg == 1 && vaqcfg  == 1)
		{
			nNum = ngroup*nQuals*nlandp;
			if(nNum <= 0)
				return false;
			pIMonGRNDCONC = new IMON_DATE[nNum];
			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pIMonGRNDCONC[i].gid,
					&pIMonGRNDCONC[i].qualid,
					&pIMonGRNDCONC[i].lid,
					&pIMonGRNDCONC[i].fnum[0],
					&pIMonGRNDCONC[i].fnum[1],
					&pIMonGRNDCONC[i].fnum[2],
					&pIMonGRNDCONC[i].fnum[3],
					&pIMonGRNDCONC[i].fnum[4],
					&pIMonGRNDCONC[i].fnum[5],
					&pIMonGRNDCONC[i].fnum[6],
					&pIMonGRNDCONC[i].fnum[7],
					&pIMonGRNDCONC[i].fnum[8],
					&pIMonGRNDCONC[i].fnum[9],
					&pIMonGRNDCONC[i].fnum[10],
					&pIMonGRNDCONC[i].fnum[11]);
			}
		}
		break;
	case 275:
		if(pIMonDRYDEP!=NULL)
			delete []pIMonDRYDEP;
		if(pqalfg == 1 && maddfglnd == 1)
		{
			nNum = ngroup*nQuals*nlandp;
			if(nNum <= 0)
				return false;
			pIMonDRYDEP = new IMON_DATE[nNum];
			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pIMonDRYDEP[i].gid,
					&pIMonDRYDEP[i].qualid,
					&pIMonDRYDEP[i].lid,
					&pIMonDRYDEP[i].fnum[0],
					&pIMonDRYDEP[i].fnum[1],
					&pIMonDRYDEP[i].fnum[2],
					&pIMonDRYDEP[i].fnum[3],
					&pIMonDRYDEP[i].fnum[4],
					&pIMonDRYDEP[i].fnum[5],
					&pIMonDRYDEP[i].fnum[6],
					&pIMonDRYDEP[i].fnum[7],
					&pIMonDRYDEP[i].fnum[8],
					&pIMonDRYDEP[i].fnum[9],
					&pIMonDRYDEP[i].fnum[10],
					&pIMonDRYDEP[i].fnum[11]);
			}
		}
		break;
	case 276:
		if(pIMonWETDEP != NULL)
			delete []pIMonWETDEP;
		if(pqalfg == 1 && mawdfglnd == 1)
		{
			nNum = ngroup*nQuals*nlandp;
			if(nNum <= 0)
				return false;
			pIMonWETDEP = new IMON_DATE[nNum];
			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pIMonWETDEP[i].gid,
					&pIMonWETDEP[i].qualid,
					&pIMonWETDEP[i].lid,
					&pIMonWETDEP[i].fnum[0],
					&pIMonWETDEP[i].fnum[1],
					&pIMonWETDEP[i].fnum[2],
					&pIMonWETDEP[i].fnum[3],
					&pIMonWETDEP[i].fnum[4],
					&pIMonWETDEP[i].fnum[5],
					&pIMonWETDEP[i].fnum[6],
					&pIMonWETDEP[i].fnum[7],
					&pIMonWETDEP[i].fnum[8],
					&pIMonWETDEP[i].fnum[9],
					&pIMonWETDEP[i].fnum[10],
					&pIMonWETDEP[i].fnum[11]);
			}
		}
		break;
	case 280:
		if(pqalfg == 1)
		{
			if(fgets (strLine, MAXLINE, fpin) == NULL)
				return false;
			CString str(strLine);
			CStringToken strToken(str);
			adfgrch   = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			maddfgrch = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			mawdfgrch = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
		}
		break;
	case 281:
		if(pQualwq!=NULL)
			delete []pQualwq;

		if(pqalfg == 1)
		{
			nNum = nQuals*nrgroup;
			if(nNum <= 0)
				return false;
			pQualwq = new QUALSWQ[nNum];    
			// read the input info
			for(i=0; i<nNum; i++)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				sscanf(LPCSTR(strToken.NextToken()),"%d",&pQualwq[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&pQualwq[i].qualid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&pQualwq[i].qsdfg);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualwq[i].inicon);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualwq[i].fstdec);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualwq[i].thfst);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualwq[i].addc);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualwq[i].awdc);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pQualwq[i].potber);

				if (pQualwq[i].thfst < 1) pQualwq[i].thfst = 1.0;
				if (pQualwq[i].thfst > 2) pQualwq[i].thfst = 2.0;
			}
		}
		break;
	case 282:
		if(pMDDrch!=NULL)
			delete []pMDDrch;
		if(pqalfg == 1 && maddfgrch == 1)
		{
			nNum = nrgroup*nQuals;
			if(nNum <= 0)
				return false;
			pMDDrch = new MON_DATA[nNum];
			for(int i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pMDDrch[i].rgid,
					&pMDDrch[i].qualid,
					&pMDDrch[i].fnum[0],
					&pMDDrch[i].fnum[1],
					&pMDDrch[i].fnum[2],
					&pMDDrch[i].fnum[3],
					&pMDDrch[i].fnum[4],
					&pMDDrch[i].fnum[5],
					&pMDDrch[i].fnum[6],
					&pMDDrch[i].fnum[7],
					&pMDDrch[i].fnum[8],
					&pMDDrch[i].fnum[9],
					&pMDDrch[i].fnum[10],
					&pMDDrch[i].fnum[11]);
			}
		}
		break;
	case 283:
		if(pMWDrch != NULL)
			delete []pMWDrch;
		if(pqalfg == 1 && mawdfgrch == 1)
		{
			nNum = nrgroup*nQuals;
			if(nNum <= 0)
				return false;
			pMWDrch = new MON_DATA[nNum];
			for(int i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pMWDrch[i].rgid,
					&pMWDrch[i].qualid,
					&pMWDrch[i].fnum[0],
					&pMWDrch[i].fnum[1],
					&pMWDrch[i].fnum[2],
					&pMWDrch[i].fnum[3],
					&pMWDrch[i].fnum[4],
					&pMWDrch[i].fnum[5],
					&pMWDrch[i].fnum[6],
					&pMWDrch[i].fnum[7],
					&pMWDrch[i].fnum[8],
					&pMWDrch[i].fnum[9],
					&pMWDrch[i].fnum[10],
					&pMWDrch[i].fnum[11]);
			}
		}
		break;
	case 285:
		if(pGQ_SEDDECAY != NULL)
			delete []pGQ_SEDDECAY;

		if(pqalfg == 1 && sedfg == 1)
		{
			nNum = nrgroup*nQuals;
			if(nNum <= 0)
				return false;
			pGQ_SEDDECAY = new GQ_SEDDECAY[nNum];

			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_SEDDECAY[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_SEDDECAY[i].qualid);
				for (int j=0; j<4; j++)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&pGQ_SEDDECAY[i].addcpm[j]);
			}
		}
		break;
	case 286:
		if(pGQ_KD != NULL)
			delete []pGQ_KD;

		if(pqalfg == 1 && sedfg == 1)
		{
			nNum = nrgroup*nQuals;
			if(nNum <= 0)
				return false;
			pGQ_KD = new GQ_KD[nNum];

			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_KD[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_KD[i].qualid);
				for (int j=0; j<6; j++)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&pGQ_KD[i].adpm[j]);
			}
		}
		break;
	case 287:
		if(pGQ_ADRATE != NULL)
			delete []pGQ_ADRATE;

		if(pqalfg == 1 && sedfg == 1)
		{
			nNum = nrgroup*nQuals;
			if(nNum <= 0)
				return false;
			pGQ_ADRATE = new GQ_ADRATE[nNum];

			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_ADRATE[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_ADRATE[i].qualid);
				for (int j=0; j<6; j++)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&pGQ_ADRATE[i].adpm[j]);
			}
		}
		break;
	case 288:
		if(pGQ_ADTHETA != NULL)
			delete []pGQ_ADTHETA;

		if(pqalfg == 1 && sedfg == 1)
		{
			nNum = nrgroup*nQuals;
			if(nNum <= 0)
				return false;
			pGQ_ADTHETA = new GQ_ADTHETA[nNum];

			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_ADTHETA[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_ADTHETA[i].qualid);
				for (int j=0; j<6; j++)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&pGQ_ADTHETA[i].adpm[j]);
			}
		}
		break;
	case 289:
		if(pGQ_SEDCONC != NULL)
			delete []pGQ_SEDCONC;

		if(pqalfg == 1 && sedfg == 1)
		{
			nNum = nrgroup*nQuals;
			if(nNum <= 0)
				return false;
			pGQ_SEDCONC = new GQ_SEDCONC[nNum];

			for(int i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_SEDCONC[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d", &pGQ_SEDCONC[i].qualid);
				for (int j=0; j<6; j++)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&pGQ_SEDCONC[i].sqal[j]);
			}
		}
		break;
	case 400: // channel information
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			sscanf(LPCSTR(strToken.NextToken()),"%d",&admod);
			sscanf(LPCSTR(strToken.NextToken()),"%lf",&kc);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&sedber);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&vconfg);

			if (admod != 2)	
				admod = 1;
			if (sedber != 1)	
				sedber = 0;
			if (sedber == 1 && sedfg == 0)	
			{
				CString strError;
				strError.Format("Sediment flag must be ON (sedfg=1) to simulate stream bank erosion (sedber=1)");
				AfxMessageBox(strError);
				TRACE(strError);
				Log(strError);
			}
		}
		break;
	case 401:    
		if(pMONTH_COV!=NULL)
			delete []pMONTH_COV;

		if(vconfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			pMONTH_COV = new MONTH_PH[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pMONTH_COV[i].gid,
					&pMONTH_COV[i].fnum[0],
					&pMONTH_COV[i].fnum[1],
					&pMONTH_COV[i].fnum[2],
					&pMONTH_COV[i].fnum[3],
					&pMONTH_COV[i].fnum[4],
					&pMONTH_COV[i].fnum[5],
					&pMONTH_COV[i].fnum[6],
					&pMONTH_COV[i].fnum[7],
					&pMONTH_COV[i].fnum[8],
					&pMONTH_COV[i].fnum[9],
					&pMONTH_COV[i].fnum[10],
					&pMONTH_COV[i].fnum[11]);
			}
		}
		break;
	case 405:// channel network    
		if(pChannelInfo != NULL)
			delete []pChannelInfo;

		if(nch <= 0)
			return false;

		pChannelInfo = new ChannelInfo[nch];
		infomsg = "These outlets flow out of the selected project area:\n";
		for(i=0; i<nch; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			pChannelInfo[i].rchid = atoi(LPCSTR(strToken.NextToken()));
			pChannelInfo[i].comp = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			pChannelInfo[i].nDSchan = atoi(LPCSTR(strToken.NextToken()));
			// allocate memory here
			if (pChannelInfo[i].nDSchan > 0)
				pChannelInfo[i].down_ch = new int [pChannelInfo[i].nDSchan];

			CString strtemp;
			for(int j=0; j<pChannelInfo[i].nDSchan; ++j)
			{
				pChannelInfo[i].down_ch[j] = atoi(LPCSTR(strToken.NextToken()));

				if (pChannelInfo[i].down_ch[j]<0)
				{
					if (ncountout < 4)
					{
						++ncountout;
						strtemp.Format("Outlet %d of channel %d\t",j+1, pChannelInfo[i].rchid);
					}
					else
					{
						ncountout = 1;
						strtemp.Format("Outlet %d of channel %d\t\n",j+1, pChannelInfo[i].rchid);
					}
					noutsys += strtemp;
				}
			}
			pChannelInfo[i].nSelfOrder = -1;
//			pChannelInfo[i].nIndexSWS = -1;
//			pChannelInfo[i].nIndexUL = -1;
//			pChannelInfo[i].nIndexUR = -1;
//			pChannelInfo[i].nIndexD = -1;

			//populated in card 435
			pChannelInfo[i].cListUpStream.RemoveAll();
			pChannelInfo[i].cListDownStream.RemoveAll();
		}
		infomsg += noutsys;
		break;
	case 410:// reach info
		if(pReachInfo != NULL)
			delete []pReachInfo;
		if(nGroupArray != NULL)
			delete []nGroupArray;
		if(nGroupId != NULL)
			delete []nGroupId;
		if(nThresholdArray != NULL)
			delete []nThresholdArray;
		if(nThresholdId != NULL)
			delete []nThresholdId;

		if(nch <= 0 || nrgroup <= 0)
			return false;

		nGroupId = new int[nrgroup];
		nGroupArray = new int[nch];
		nThresholdArray = new int[nch];
		pReachInfo = new ReachInfo[nch];
		ncrchOutlets = 0;

		for(i=0; i<nch; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			pReachInfo[i].rchid = atoi(LPCSTR(strToken.NextToken()));
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pReachInfo[i].gid);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&pReachInfo[i].tgid);
			CString strTemp = strToken.LeftOut();
			sscanf(LPCSTR(strTemp),"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
				&pReachInfo[i].lkfg,
				&pReachInfo[i].idepth,
				&pReachInfo[i].length,
				&pReachInfo[i].depth,
				&pReachInfo[i].width,
				&pReachInfo[i].slope,
				&pReachInfo[i].mann,
				&pReachInfo[i].r1,
				&pReachInfo[i].r2,
				&pReachInfo[i].w1,
				&pReachInfo[i].crrat,
				&pReachInfo[i].ks);

			if(pReachInfo[i].slope <1.0e-4 && pReachInfo[i].lkfg == 0)
				pReachInfo[i].slope = 1.0e-4;
			if(pReachInfo[i].crrat < 1)
				pReachInfo[i].crrat = 1;

			// check for no routing
			if (pReachInfo[i].length <= 0 || pReachInfo[i].width <= 0 || pReachInfo[i].depth <= 0)
				pReachInfo[i].routefg = 0;

			// count the number of outlets for BMP reaches
			if(pReachInfo[i].lkfg > 10)
				ncrchOutlets += pChannelInfo[i].nDSchan;
			
			//populate array of land group id
			nGroupArray[i] = pReachInfo[i].gid;
			
			//populate array of threshold group id
			nThresholdArray[i] = pReachInfo[i].tgid;
		}

		//sort the arrays
		qsort (nGroupArray, nch, sizeof(int), compare);
		qsort (nThresholdArray, nch, sizeof(int), compare);

		if (nrgroup > 0)
		{
			int gid = -1;
			int tgid = -1;
			CList<int,int> nGroupList;
			CList<int,int> nThresholdList;
			for (i=0; i<nch; i++)
			{
				if (nGroupArray[i] != gid)
				{
					gid = nGroupArray[i];
					nGroupList.AddTail(gid);
				}

				if (nThresholdArray[i] != tgid)
				{
					tgid = nThresholdArray[i];
					if (tgid > 0)
						nThresholdList.AddTail(tgid);
				}
			}

			if (nrgroup != nGroupList.GetCount())
				AfxMessageBox("Number of Reach Groups in Card 40 should be equal to the number of Reach Groups in Card 410");

			nIndex = 0;
			POSITION pos = nGroupList.GetHeadPosition();
			while (pos)
				nGroupId[nIndex++] = nGroupList.GetNext(pos);

			ntrgp = nThresholdList.GetCount();
			if (ntrgp > 0)
			{
				nThresholdId = new int[ntrgp];
				nIndex = 0;
				pos = nThresholdList.GetHeadPosition();
				while (pos)
					nThresholdId[nIndex++] = nThresholdList.GetNext(pos);
			}

			for (i=0; i<nch; i++)
			{
				for (j=0; j<nrgroup; j++)
				{
					if (pReachInfo[i].gid == nGroupId[j])
					{
						pReachInfo[i].rgid = j+1;
						break;
					}
				}

				pReachInfo[i].trgid = 0;

				for (j=0; j<ntrgp; j++)
				{
					if (pReachInfo[i].tgid == nThresholdId[j])
					{
						pReachInfo[i].trgid = j+1;
						break;
					}
				}
			}
			// Remove all of the elements in the list.
			nGroupList.RemoveAll();
			nThresholdList.RemoveAll();
		}

		if (nGroupArray != NULL)		delete []nGroupArray;
		if (nGroupId != NULL)			delete []nGroupId;
		if (nThresholdArray != NULL)	delete []nThresholdArray;
		if (nThresholdId != NULL)		delete []nThresholdId;

		break;

	//this card contains all cross section related informations
	case 413:
		//the input format should be
		// reachname px py px2 py2... 
		if(pReachInfo == NULL)
			return false;
		//get the record number in this array
		nMarkedReach = 0;
		nPos = ftell(fpin);
		while (fgets (strLine, MAXLINE, fpin) != NULL)
		{
			CString str(strLine);
			CStringToken strToken(str);
			CString str0 = strToken.NextToken();
			if(str0[0] != 'C' && str0[0] != 'c')
				++nMarkedReach;
			else
			{
				fseek (fpin, nPos, SEEK_SET);
				break;
			}
		}
		if(nMarkedReach == 0)	//optional card
			break;

		if(nMarkedReach > nch)
		{
			AfxMessageBox("nMarkedReach are greater than nch");
			return false;
		}
		for (i=0; i<nMarkedReach; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			int rid = -1;
			int rchid = atoi(LPCSTR(strToken.NextToken()));
			for (int j=0; j<nch; ++j)
			{
				if (rchid == pReachInfo[j].rchid)
				{
					rid = j+1;
					break;
				}
			}
			if(rid < 1)
				continue;
			pReachInfo[rid-1].poly.CPoly_Free();
			pReachInfo[rid-1].poly.bCustomized = TRUE;
			// get the (x,y) pair
			while(true)
			{
				double x=0,y=0;
				if(strToken.HasMoreTokens())
				{
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&x);
					if(strToken.HasMoreTokens())
					{
						sscanf(LPCSTR(strToken.NextToken()),"%lf",&y);
						Point *pt = new Point();
						pt->x = x;
						pt->y = y;
						pReachInfo[rid-1].poly.pointList.AddTail((CObject *)pt);
					}
					else
						break;
				}
				else
					break;				
			}
		}
		break;
	case 415:	// Import Ftable			  
		if(pFtable != NULL)
			delete []pFtable;

		if(pReachFtable != NULL)
			delete []pReachFtable;

		if(nch <= 0)
			return false;

		pReachFtable = new ReachFtable[nch];
		for (i=0; i<nch; i++)
		{
			pReachFtable[i].rchid = -1;
			pReachFtable[i].nFTstart = -1;
			pReachFtable[i].nFTrecord = 0;
			if(pChannelInfo[i].nDSchan > 0)
				pReachFtable[i].bypass_fr = new double[pChannelInfo[i].nDSchan];
			for (int j=0; j<pChannelInfo[i].nDSchan; j++)
				pReachFtable[i].bypass_fr[j] = 0.0;
		}

		nPos = ftell(fpin);
		while (fgets (strLine, MAXLINE, fpin) != NULL)
		{
			CString str(strLine);
			CStringToken strToken(str);
			CString str0 = strToken.NextToken();
			if(str0[0] != 'C' && str0[0] != 'c')
				++nRecord;
			else
			{
				fseek (fpin, nPos, SEEK_SET);
				break;
			}
		}
		
		FtableRecord = nRecord;

		if (FtableRecord > 0)
		{
			int rchid = -1;
			pFtable = new Ftable_Selected[FtableRecord];
			nNum = FtableRecord;
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				pFtable[i].rchid = atoi(LPCSTR(strToken.NextToken()));
				if (rchid != pFtable[i].rchid)
				{
					for (int j=0; j<nch; j++)
					{
						if (pReachInfo[j].rchid == pFtable[i].rchid)
						{
							pReachFtable[j].rchid = pFtable[i].rchid;
							pReachFtable[j].nFTstart = i;
							break;
						}	
					}
					rchid = pFtable[i].rchid;
					++nReach;
				}

				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pFtable[i].depth);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pFtable[i].area);
				pFtable[i].area *= 43559.66;// from acre to ft^2
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pFtable[i].vol);
				pFtable[i].vol *= 43559.66;	// from ac-ft to ft^3

				//add a small fraction to make each value different to the other
				pFtable[i].depth += (pFtable[i].depth * i / 1.0E12);
				pFtable[i].area  += (pFtable[i].area  * i / 1.0E12);
				pFtable[i].vol   += (pFtable[i].vol   * i / 1.0E12);

				// allocate memory 
				for (int j=0; j<nch; j++)
				{
					if (pFtable[i].rchid == pChannelInfo[j].rchid)
					{
						pReachFtable[j].nFTrecord += 1;
						pFtable[i].disch1 = 0.0;
						if(pChannelInfo[j].nDSchan > 0)
							pFtable[i].disch = new double[pChannelInfo[j].nDSchan];
						for (int k=0; k<pChannelInfo[j].nDSchan; k++)
						{
							sscanf(LPCSTR(strToken.NextToken()),"%lf",&pFtable[i].disch[k]);
							//add a small fraction to make each value different to the other
							pFtable[i].disch[k] += (pFtable[i].disch[k] * i / 1.0E12);
							pFtable[i].disch1 += pFtable[i].disch[k];
							pReachFtable[j].bypass_fr[k] += pFtable[i].disch[k]; // add flow for each outlet
						}
						break;
					}
				}
			}
			if (nReach > 0 && pWnd->bRunModel == false && pWnd->bRunNIMS == false)
			{
				CString Ftab;
				Ftab.Format("LSPC has found user-defined F-tables for %d out of %d segments\n\n",nReach,nch);
				Ftab += infomsg;
				AfxMessageBox(Ftab, MB_ICONINFORMATION);
				Log("LSPC has found user-defined F-tables");
			}
		}
		else if (pWnd->bRunModel == false && pWnd->bRunNIMS == false)
		{
			AfxMessageBox("LSPC F-tables generated using stream geometry", MB_ICONINFORMATION);
			Log("LSPC F-tables generated using stream geometry");
		}

		// calculate the bypass fraction for the outlets
		for(i=0; i<nch; i++)
		{
			double sumflow = 0.0;
			for(j=0; j<pChannelInfo[i].nDSchan; j++)
				sumflow += pReachFtable[i].bypass_fr[j];

			for(j=0; j<pChannelInfo[i].nDSchan; j++)
			{
				if (sumflow > 0)
					pReachFtable[i].bypass_fr[j] /= sumflow;
				else
					pReachFtable[i].bypass_fr[j]  = 1.0;
			}
		}

		break;
	case 420: // point source information
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nPtSource);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nPtQuals);
		}
		break;
	case 425:// point source

		if(pPtQual != NULL)
			delete []pPtQual;

		if(nPtQuals <= 0)	// point source quals
			break;
		// allocate memory here
		pPtQual = new PtQual[nPtQuals];
		// read data
		for (i=0; i<nPtQuals; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			strToken.NextToken();	// skip first record
			pPtQual[i].qualindex = i+1;	
			pPtQual[i].qualname = strToken.NextToken();
			pPtQual[i].qualid = atoi(LPCSTR(strToken.NextToken()));
			pPtQual[i].sqalfr = atof(LPCSTR(strToken.NextToken()));
		}
		break;
	case 430:// point source withdrawal (optional)

		if(pPtWithDrawal != NULL)
			delete []pPtWithDrawal;

		if(nPtSource <= 0)	// number of point sources
			break;

		// count the number of withdrawal point sources
		nPtWithDrawal = 0;
		nPos = ftell(fpin);
		while (fgets (strLine, MAXLINE, fpin) != NULL)
		{
			CString str(strLine);
			CStringToken strToken(str);
			CString str0 = strToken.NextToken();
			if(str0[0] != 'C' && str0[0] != 'c')
				++nPtWithDrawal;
			else
			{
				fseek (fpin, nPos, SEEK_SET);
				break;
			}
			memset (strLine, 0, MAXLINE);
		}

		if(nPtWithDrawal <= 0)
			break;

		// allocate memory here
		pPtWithDrawal = new PtWithDrawal[nPtWithDrawal];
		// read data
		for (i=0; i<nPtWithDrawal; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			pPtWithDrawal[i].wdrawlrchid = atoi(LPCSTR(strToken.NextToken()));	
			pPtWithDrawal[i].strPermit = strToken.NextToken();
			pPtWithDrawal[i].strPipe = strToken.NextToken();
			pPtWithDrawal[i].targetrchid = atoi(LPCSTR(strToken.NextToken()));
		}
		break;
	case 435: 
		if(nch <= 0)
			return false;

		// count the linkage files 
		nLinkFiles = 0;
		nPos = ftell(fpin);
		while (fgets (strLine, MAXLINE, fpin) != NULL)
		{
			CString str(strLine);
			CStringToken strToken(str);
			CString str0 = strToken.NextToken();
			if(str0[0] != 'C' && str0[0] != 'c')
				++nLinkFiles;
			else
			{
				fseek (fpin, nPos, SEEK_SET);
				break;
			}
			memset (strLine, 0, MAXLINE);
		}
		
		//read the data lines
		if (nLinkFiles > 0)
		{
			if (strArray != NULL)	
				delete []strArray;
			strArray = new CString[nLinkFiles];
		}

		for(i=0; i<nLinkFiles; i++)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				if (strArray != NULL)	
					delete []strArray;
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			int rchid = atoi(LPCSTR(strToken.NextToken()));
			int nOutlet = atoi(LPCSTR(strToken.NextToken()));
			CString strFilePath = strToken.NextToken();
			strFilePath.TrimLeft();
			strFilePath.TrimRight();
			strArray[i] = strFilePath;
			if (nOutlet < 0)
			{
				CString strError;
				strError.Format("Outlet index:%d for reach:%d is not correct in card 435",nOutlet, rchid);
				AfxMessageBox(strError);
				TRACE(strError);
				Log(strError);
				if (strArray != NULL)	
					delete []strArray;
				return false;
			}
			// verify the input file path
			else if (nOutlet == 0)
			{
				if (!FolderExists(strFilePath))
				{
					CString strError;
					strError.Format("Card 435: Invalid Linkage Input File Path: %s for Reach ID: %d",strFilePath,rchid);
					AfxMessageBox(strError);
					TRACE(strError);
					Log(strError);
					if (strArray != NULL)	
						delete []strArray;
					return false;
				}
			}
			else // verify the output folder path
			{
				//find the folder
				int nPathLength = strFilePath.GetLength();
				int nFileLength = nPathLength - strFilePath.ReverseFind('\\') - 1;
				CString strFolderPath = strFilePath.Left(nPathLength - nFileLength);

				if (!FolderExists(strFolderPath))
				{
					CString strError;
					strError.Format("Card 435: Invalid Linkage Output Folder Path: %s for Reach ID: %d",strFolderPath,rchid);
					AfxMessageBox(strError);
					TRACE(strError);
					Log(strError);
					if (strArray != NULL)	
						delete []strArray;
					return false;
				}
			}

			//find the reach index
			int nIndex = FindIndexOrder(rchid);
			if (nIndex == -1)
			{
				CString strError;
				strError.Format("Reach ID: %d: in card 435 not found",rchid);
				AfxMessageBox(strError);
				TRACE(strError);
				Log(strError);
				if (strArray != NULL)	
					delete []strArray;
				return false;
			}

			Link435 plink435;
			plink435.nrchid = rchid;
			plink435.nOutlet = nOutlet;
			plink435.strFilePath = strFilePath;
			plink435.m_linkfile = NULL;
			plink435.pLinkData = NULL;

			if (nOutlet == 0)
				pChannelInfo[nIndex].cListUpStream.AddTail(plink435);
			else
				pChannelInfo[nIndex].cListDownStream.AddTail(plink435);
		}
		
		// check for duplicate files
		if (DuplicateExists(nLinkFiles,strArray))
		{
			CString strError;
			strError.Format("Duplicate File Paths found in card 435");
			AfxMessageBox(strError);
			TRACE(strError);
			Log(strError);
			if (strArray != NULL)	
				delete []strArray;
			return false;
		}
		
		//release the memory
		if (strArray != NULL)	
			delete []strArray;

		break;
	case 440: 
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			sscanf(LPCSTR(strToken.NextToken()),"%d",&crvfg);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&vsivfg);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&sandfg);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&sweepfg);
			if (sandfg > 3)	
				sandfg = 0;	
		}
		break;
	case 445: 
		if(psd_sweep!=NULL)
			delete []psd_sweep;

		if(sedfg == 1 && sweepfg != 0)
		{
			//street sweeping
			nNum = nlandimp*ngroup;
			if(nNum <= 0)
				return false;
			psd_sweep = new SD_SWEEP[nNum];
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}

				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				sscanf(LPCSTR(strToken.NextToken()),"%d",&psd_sweep[i].defid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&psd_sweep[i].deluid);
				psd_sweep[i].luname = strToken.NextToken();
				sscanf(LPCSTR(strToken.NextToken()),"%d",&psd_sweep[i].start_month);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&psd_sweep[i].end_month);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&psd_sweep[i].frequency);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&psd_sweep[i].percent_area);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&psd_sweep[i].effic_sand);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&psd_sweep[i].effic_silt);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&psd_sweep[i].effic_clay);
			}
		}
		break;
	case 446: 
		if(pGQ_sweep!=NULL)
			delete []pGQ_sweep;

		if(sedfg == 1 && pqalfg == 1 && sweepfg == 2)
		{
			//street sweeping
			nNum = nlandimp*ngroup;
			if(nNum <= 0)
				return false;

			pGQ_sweep = new GQ_SWEEP[nNum];
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}

				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				sscanf(LPCSTR(strToken.NextToken()),"%d",&pGQ_sweep[i].defid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&pGQ_sweep[i].deluid);
				pGQ_sweep[i].luname = strToken.NextToken();
				if (nQuals > 0)
					pGQ_sweep[i].effic_GQual = new double[nQuals];
				for(j=0; j<nQuals; ++j)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&pGQ_sweep[i].effic_GQual[j]);
			}
		}
		break;
	case 450: 
		if(psd_param1!=NULL)
			delete []psd_param1;

		if(sedfg ==1)
		{
			//pwat-parm1
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			psd_param1 = new SD_PARA1[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&psd_param1[i].gid,
					&psd_param1[i].lid,
					&psd_param1[i].smpf_p,
					&psd_param1[i].krer_p,
					&psd_param1[i].jrer_p,
					&psd_param1[i].affix_p,
					&psd_param1[i].cover_p,
					&psd_param1[i].nvsi_p,
					&psd_param1[i].kser_p,
					&psd_param1[i].jser_p,
					&psd_param1[i].kger_p,
					&psd_param1[i].jger_p,
					&psd_param1[i].accsdp_p,
					&psd_param1[i].remsdp_p);
			}
		}
		break;
	case 451: 
		if(psd_param2!=NULL)
			delete []psd_param2;

		if(sedfg == 1)
		{
			//pwat-parm2
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			psd_param2 = new SD_PARA2[nNum];
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				int ntoks = 0;			  // number of tokens
				CStringToken tmpToken(str);
				while (tmpToken.HasMoreTokens())
				{
					ntoks++;
					tmpToken.NextToken();
				}
				NumSed = ntoks - 5;	// number of sediment classes (sand, silt, and clay)

				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&psd_param2[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&psd_param2[i].lid);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&psd_param2[i].sed_suro);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&psd_param2[i].sed_ifwo);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&psd_param2[i].sed_agwo);
				
				// allocate memory here
				if (NumSed > 0)
					psd_param2[i].sed = new double[NumSed];
				for (int j=0; j<NumSed; ++j)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&psd_param2[i].sed[j]);
			}
		}
		break;
	case 452: // sediment to stream mapping
		if(sed_mapp!=NULL)
			delete []sed_mapp;
		if(pqalfg == 1 && sedfg == 1 && gqsdfg == 1)
		{
			if(nQuals <= 0 || ngroup <= 0)
				return false;
			nNum = ngroup*4;
			sed_mapp = new SEDGQUAL_MAPP[nNum];
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&sed_mapp[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&sed_mapp[i].qualid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&sed_mapp[i].lutype);
				// allocate memory here
				if (NumSed > 0)
					sed_mapp[i].sed = new double[NumSed];
				for (int j=0; j<NumSed; ++j)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&sed_mapp[i].sed[j]);
			}
		}
		break;
	case 453:
		if(pCRVm!=NULL)
			delete []pCRVm;

		if(sedfg ==1 && crvfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			pCRVm = new MONTH_TMP[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pCRVm[i].gid,
					&pCRVm[i].lid,
					&pCRVm[i].fnum[0],
					&pCRVm[i].fnum[1],
					&pCRVm[i].fnum[2],
					&pCRVm[i].fnum[3],
					&pCRVm[i].fnum[4],
					&pCRVm[i].fnum[5],
					&pCRVm[i].fnum[6],
					&pCRVm[i].fnum[7],
					&pCRVm[i].fnum[8],
					&pCRVm[i].fnum[9],
					&pCRVm[i].fnum[10],
					&pCRVm[i].fnum[11]);
			}
		}
		break;
	case 454:
		if(pVSIVm!=NULL)
			delete []pVSIVm;

		if(sedfg ==1 && vsivfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			pVSIVm = new MONTH_TMP[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pVSIVm[i].gid,
					&pVSIVm[i].lid,
					&pVSIVm[i].fnum[0],
					&pVSIVm[i].fnum[1],
					&pVSIVm[i].fnum[2],
					&pVSIVm[i].fnum[3],
					&pVSIVm[i].fnum[4],
					&pVSIVm[i].fnum[5],
					&pVSIVm[i].fnum[6],
					&pVSIVm[i].fnum[7],
					&pVSIVm[i].fnum[8],
					&pVSIVm[i].fnum[9],
					&pVSIVm[i].fnum[10],
					&pVSIVm[i].fnum[11]);
			}
		}
		break;
	case 455:// reach sediment paramter
		if(rsd_genparam != NULL)
			delete []rsd_genparam;

		if(sedfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			rsd_genparam = new STREAMSED_GENPARM[nNum];

			for (i =0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf",
				&rsd_genparam[i].gid,
				&rsd_genparam[i].bedwid,
				&rsd_genparam[i].beddep,
				&rsd_genparam[i].por,
				&rsd_genparam[i].burial);
			}
		}
		break;
	case 456:// reach sediment paramter (sediment classes)
		if(rsd_param != NULL)
			delete []rsd_param;

		if(sedfg == 1)
		{
			nNum = nrgroup*NumSed;
			if(nNum <= 0)
				return false;
			rsd_param = new STREAMSED_PARM[nNum];
			
			for (i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&rsd_param[i].gid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&rsd_param[i].sed_id);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&rsd_param[i].sedflg);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_param[i].sedo);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_param[i].sedfrac);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_param[i].d);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_param[i].w);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_param[i].rho);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_param[i].taucd);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_param[i].taucs);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_param[i].m);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_param[i].burial);
			}
		}
		break;
	case 457: 
		if(rsd_berparam!=NULL)
			delete []rsd_berparam;

		if(sedfg == 1 && sedber == 1)
		{
			nNum = nch;
			if(nNum <= 0)
				return false;
			rsd_berparam = new SD_BER[nNum];
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str);
				rsd_berparam[i].rchid = atoi(LPCSTR(strToken.NextToken()));
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_berparam[i].kber);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_berparam[i].jber);
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_berparam[i].qber);
				
				// allocate memory here
				if (NumSed > 0)
					rsd_berparam[i].sed = new double[NumSed];
				for (int j=0; j<NumSed; ++j)
					sscanf(LPCSTR(strToken.NextToken()),"%lf",&rsd_berparam[i].sed[j]);
			}
		}
		break;
	case 460: 
		if(tempfg == 1)
		{
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			msltfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			miftfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			mgwtfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
		}
		break;
	case 461: 
		if(pstmp_parm1!=NULL)
			delete []pstmp_parm1;

		if(tempfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			pstmp_parm1 = new STMP_PARA1[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&pstmp_parm1[i].gid,
					&pstmp_parm1[i].lid,
					&pstmp_parm1[i].tsopfg,
					&pstmp_parm1[i].aslt,
					&pstmp_parm1[i].bslt,
					&pstmp_parm1[i].aift,
					&pstmp_parm1[i].bift,
					&pstmp_parm1[i].agwt,
					&pstmp_parm1[i].bgwt,
					&pstmp_parm1[i].islt,
					&pstmp_parm1[i].iift,
					&pstmp_parm1[i].igwt);

				if(pstmp_parm1[i].tsopfg < 0 || pstmp_parm1[i].tsopfg > 2)
				{
					TRACE("Wrong reading tsopfg=%d",pstmp_parm1[i].tsopfg);
					Log("Wrong reading tsopfg%d",pstmp_parm1[i].tsopfg);
					return false;
				}
			}
		}
		break;
	case 462:
		if(asltm!=NULL)
			delete []asltm;

		if(tempfg == 1 && msltfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			asltm = new MONTH_TMP[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&asltm[i].gid,
					&asltm[i].lid,
					&asltm[i].fnum[0],
					&asltm[i].fnum[1],
					&asltm[i].fnum[2],
					&asltm[i].fnum[3],
					&asltm[i].fnum[4],
					&asltm[i].fnum[5],
					&asltm[i].fnum[6],
					&asltm[i].fnum[7],
					&asltm[i].fnum[8],
					&asltm[i].fnum[9],
					&asltm[i].fnum[10],
					&asltm[i].fnum[11]);
			}
		}
		break;
	case 463:
		if(bsltm!=NULL)
			delete []bsltm;

		if(tempfg == 1 && msltfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			bsltm = new MONTH_TMP[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&bsltm[i].gid,
					&bsltm[i].lid,
					&bsltm[i].fnum[0],
					&bsltm[i].fnum[1],
					&bsltm[i].fnum[2],
					&bsltm[i].fnum[3],
					&bsltm[i].fnum[4],
					&bsltm[i].fnum[5],
					&bsltm[i].fnum[6],
					&bsltm[i].fnum[7],
					&bsltm[i].fnum[8],
					&bsltm[i].fnum[9],
					&bsltm[i].fnum[10],
					&bsltm[i].fnum[11]);
			}
		}
		break;
	case 464:
		if(aiftm!=NULL)
			delete []aiftm;

		if(tempfg == 1 && miftfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			aiftm = new MONTH_TMP[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&aiftm[i].gid,
					&aiftm[i].lid,
					&aiftm[i].fnum[0],
					&aiftm[i].fnum[1],
					&aiftm[i].fnum[2],
					&aiftm[i].fnum[3],
					&aiftm[i].fnum[4],
					&aiftm[i].fnum[5],
					&aiftm[i].fnum[6],
					&aiftm[i].fnum[7],
					&aiftm[i].fnum[8],
					&aiftm[i].fnum[9],
					&aiftm[i].fnum[10],
					&aiftm[i].fnum[11]);
			}
		}
		break;
	case 465:
		if(biftm!=NULL)
			delete []biftm;

		if(tempfg == 1 && miftfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			biftm = new MONTH_TMP[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&biftm[i].gid,
					&biftm[i].lid,
					&biftm[i].fnum[0],
					&biftm[i].fnum[1],
					&biftm[i].fnum[2],
					&biftm[i].fnum[3],
					&biftm[i].fnum[4],
					&biftm[i].fnum[5],
					&biftm[i].fnum[6],
					&biftm[i].fnum[7],
					&biftm[i].fnum[8],
					&biftm[i].fnum[9],
					&biftm[i].fnum[10],
					&biftm[i].fnum[11]);
			}
		}
		break;
	case 466:
		if(agwtm!=NULL)
			delete []agwtm;

		if(tempfg == 1 && mgwtfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			agwtm = new MONTH_TMP[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&agwtm[i].gid,
					&agwtm[i].lid,
					&agwtm[i].fnum[0],
					&agwtm[i].fnum[1],
					&agwtm[i].fnum[2],
					&agwtm[i].fnum[3],
					&agwtm[i].fnum[4],
					&agwtm[i].fnum[5],
					&agwtm[i].fnum[6],
					&agwtm[i].fnum[7],
					&agwtm[i].fnum[8],
					&agwtm[i].fnum[9],
					&agwtm[i].fnum[10],
					&agwtm[i].fnum[11]);
			}
		}
		break;
	case 467:
		if(bgwtm!=NULL)
			delete []bgwtm;

		if(tempfg == 1 && mgwtfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			bgwtm = new MONTH_TMP[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&bgwtm[i].gid,
					&bgwtm[i].lid,
					&bgwtm[i].fnum[0],
					&bgwtm[i].fnum[1],
					&bgwtm[i].fnum[2],
					&bgwtm[i].fnum[3],
					&bgwtm[i].fnum[4],
					&bgwtm[i].fnum[5],
					&bgwtm[i].fnum[6],
					&bgwtm[i].fnum[7],
					&bgwtm[i].fnum[8],
					&bgwtm[i].fnum[9],
					&bgwtm[i].fnum[10],
					&bgwtm[i].fnum[11]);
			}
		}
		break;
	case 470: 
		if(ptmp_param1!=NULL)
			delete []ptmp_param1;

		if(tempfg == 1)
		{
			if(nsws <= 0)
				return false;
			ptmp_param1 = new TMP_PARA1[nsws];
			for(i = 0; i < nsws; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				ptmp_param1[i].subbasin = atoi(LPCSTR(strToken.NextToken()));
				CString strTemp = strToken.LeftOut();
				sscanf(LPCSTR(strTemp),"%lf %lf""%lf %lf",&ptmp_param1[i].elev,&ptmp_param1[i].eldat,&ptmp_param1[i].relev,&ptmp_param1[i].reldat);
			}
		}
		break;
	case 474: //optional
		if(tempfg == 1)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return true;
			}
			else
			{
				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				lapse[0] = atof(LPCSTR(strToken.NextToken()));
				lapse[1] = atof(LPCSTR(strToken.NextToken()));
				lapse[2] = atof(LPCSTR(strToken.NextToken()));
				lapse[3] = atof(LPCSTR(strToken.NextToken()));
				lapse[4] = atof(LPCSTR(strToken.NextToken()));
				lapse[5] = atof(LPCSTR(strToken.NextToken()));
				lapse[6] = atof(LPCSTR(strToken.NextToken()));
				lapse[7] = atof(LPCSTR(strToken.NextToken()));
				lapse[8] = atof(LPCSTR(strToken.NextToken()));
				lapse[9] = atof(LPCSTR(strToken.NextToken()));
				lapse[10] = atof(LPCSTR(strToken.NextToken()));
				lapse[11] = atof(LPCSTR(strToken.NextToken()));
				lapse[12] = atof(LPCSTR(strToken.NextToken()));
				lapse[13] = atof(LPCSTR(strToken.NextToken()));
				lapse[14] = atof(LPCSTR(strToken.NextToken()));
				lapse[15] = atof(LPCSTR(strToken.NextToken()));
				lapse[16] = atof(LPCSTR(strToken.NextToken()));
				lapse[17] = atof(LPCSTR(strToken.NextToken()));
				lapse[18] = atof(LPCSTR(strToken.NextToken()));
				lapse[19] = atof(LPCSTR(strToken.NextToken()));
				lapse[20] = atof(LPCSTR(strToken.NextToken()));
				lapse[21] = atof(LPCSTR(strToken.NextToken()));
				lapse[22] = atof(LPCSTR(strToken.NextToken()));
				lapse[23] = atof(LPCSTR(strToken.NextToken()));
			}
		}
		break;
	case 475: 
		if(ptmps_param1!=NULL)
			delete []ptmps_param1;

		if(tempfg == 1)
		{
			if(nrgroup <= 0)
				return false;
			ptmps_param1 = new TMPS_PARA1[nrgroup];
			for(i = 0; i < nrgroup; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				sscanf(LPCSTR(strToken.NextToken()),"%d",&ptmps_param1[i].gid);
				CString strTemp = strToken.LeftOut();
				sscanf(LPCSTR(strTemp),"%lf %lf %lf %lf",
					&ptmps_param1[i].cfsaex_p,
					&ptmps_param1[i].katrad_p,
					&ptmps_param1[i].kcond_p,
					&ptmps_param1[i].kevap_p);
			}
		}
		break;
	case 480: 
		if(ptmps_param2!=NULL)
			delete []ptmps_param2;

		if(tempfg == 1)
		{
			if(nrgroup <= 0)
				return false;
			ptmps_param2 = new TMPS_PARA2[nrgroup];
			for(i=0; i<nrgroup; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				sscanf(LPCSTR(strToken.NextToken()),"%d",&ptmps_param2[i].rgid);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&ptmps_param2[i].preflg);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&ptmps_param2[i].bedflg);
				sscanf(LPCSTR(strToken.NextToken()),"%d",&ptmps_param2[i].tgflg);
				CString strTemp = strToken.LeftOut();
				sscanf(LPCSTR(strTemp),"%lf %lf %lf %lf",
					&ptmps_param2[i].muddep,
					&ptmps_param2[i].tgrnd,
					&ptmps_param2[i].kmud,
					&ptmps_param2[i].kgrnd);

				if (ptmps_param2[i].bedflg > 2)
					ptmps_param2[i].bedflg = 2;	//option 3 is not supported
				if (ptmps_param2[i].bedflg > 0)
					bedflg = true;
				if (ptmps_param2[i].tgflg < 2)
					ptmps_param2[i].tgflg = 2; //option 1 is not supported
				if (ptmps_param2[i].tgflg == 3)
					mtgflg = true;
			}
		}
		break;
	case 485:    
		if(ptmps_mon!=NULL)
			delete []ptmps_mon;

		if(tempfg == 1 && bedflg == true && mtgflg == true)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;

			ptmps_mon = new MONTH_PARM[nNum];
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&ptmps_mon[i].rgid,
					&ptmps_mon[i].fnum[0],
					&ptmps_mon[i].fnum[1],
					&ptmps_mon[i].fnum[2],
					&ptmps_mon[i].fnum[3],
					&ptmps_mon[i].fnum[4],
					&ptmps_mon[i].fnum[5],
					&ptmps_mon[i].fnum[6],
					&ptmps_mon[i].fnum[7],
					&ptmps_mon[i].fnum[8],
					&ptmps_mon[i].fnum[9],
					&ptmps_mon[i].fnum[10],
					&ptmps_mon[i].fnum[11]);
			}
		}
		break;
	case 500: // land to stream mapping
		if(land_mapp!=NULL)
			delete []land_mapp;

		if(oxfg == 1)
		{
			nNum = nQuals*nrgroup*4;
			if(nNum <= 0)
				return false;
			land_mapp = new LAND_MAPP[nNum];
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&land_mapp[i].gid,
					&land_mapp[i].qualid,
					&land_mapp[i].lutype,
					&land_mapp[i].bod,
					&land_mapp[i].nox,
					&land_mapp[i].tam,
					&land_mapp[i].snh4,
					&land_mapp[i].po4,
					&land_mapp[i].spo4,
					&land_mapp[i].orn,
					&land_mapp[i].orp,
					&land_mapp[i].orc);
			}
		}
		break;
	case 501: // atmosphere to stream mapping
		if(atms_mapp!=NULL)
			delete []atms_mapp;

		if(oxfg == 1 && adfgrch == 1)
		{
			nNum = nQuals*nrgroup;
			if(nNum <= 0)
				return false;
			atms_mapp = new ATMS_MAPP[nNum];
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf",
					&atms_mapp[i].gid,
					&atms_mapp[i].qualid,
					&atms_mapp[i].bod,
					&atms_mapp[i].nox,
					&atms_mapp[i].tam,
					&atms_mapp[i].po4,
					&atms_mapp[i].orn,
					&atms_mapp[i].orp,
					&atms_mapp[i].orc);
			}
		}
		break;
	case 502: 
		if(oxfg ==1)
		{
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			midofg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			mico2fg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			madofg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			maco2fg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
		}
		break;
	case 503: 
		if(doco_parm1!=NULL)
			delete []doco_parm1;

		if(oxfg == 1)
		{
			nNum =nlandp*ngroup;
			if(nNum <= 0)
				return false;
			doco_parm1 = new DOCO_PARA1[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf",
					&doco_parm1[i].gid,
					&doco_parm1[i].lid,
					&doco_parm1[i].sdoxp,
					&doco_parm1[i].sco2p,
					&doco_parm1[i].idoxp,
					&doco_parm1[i].ico2p,
					&doco_parm1[i].adoxp,
					&doco_parm1[i].aco2p);
			}
		}
		break;
	case 504:
		if(idoconc!=NULL)
			delete []idoconc;

		if(oxfg == 1 && midofg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			idoconc = new MONTH_OX[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&idoconc[i].gid,
					&idoconc[i].lid,
					&idoconc[i].fnum[0],
					&idoconc[i].fnum[1],
					&idoconc[i].fnum[2],
					&idoconc[i].fnum[3],
					&idoconc[i].fnum[4],
					&idoconc[i].fnum[5],
					&idoconc[i].fnum[6],
					&idoconc[i].fnum[7],
					&idoconc[i].fnum[8],
					&idoconc[i].fnum[9],
					&idoconc[i].fnum[10],
					&idoconc[i].fnum[11]);
			}
		}
		break;
	case 505:
		if(adoconc!=NULL)
			delete []adoconc;

		if(oxfg == 1 && madofg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			adoconc = new MONTH_OX[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&adoconc[i].gid,
					&adoconc[i].lid,
					&adoconc[i].fnum[0],
					&adoconc[i].fnum[1],
					&adoconc[i].fnum[2],
					&adoconc[i].fnum[3],
					&adoconc[i].fnum[4],
					&adoconc[i].fnum[5],
					&adoconc[i].fnum[6],
					&adoconc[i].fnum[7],
					&adoconc[i].fnum[8],
					&adoconc[i].fnum[9],
					&adoconc[i].fnum[10],
					&adoconc[i].fnum[11]);
			}
		}
		break;
	case 506:   // interflow conc of CO2 
		if(ico2conc!=NULL)
			delete []ico2conc;

		if(mico2fg  == 1 && oxfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			ico2conc = new MONTH_OX[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&ico2conc[i].gid,
					&ico2conc[i].lid,
					&ico2conc[i].fnum[0],
					&ico2conc[i].fnum[1],
					&ico2conc[i].fnum[2],
					&ico2conc[i].fnum[3],
					&ico2conc[i].fnum[4],
					&ico2conc[i].fnum[5],
					&ico2conc[i].fnum[6],
					&ico2conc[i].fnum[7],
					&ico2conc[i].fnum[8],
					&ico2conc[i].fnum[9],
					&ico2conc[i].fnum[10],
					&ico2conc[i].fnum[11]);
			}
		}
		break;
	case 507:   // groundwater conc of CO2 
		if(aco2conc!=NULL)
			delete []aco2conc;

		if(maco2fg  == 1 && oxfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum <= 0)
				return false;
			aco2conc = new MONTH_OX[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&aco2conc[i].gid,
					&aco2conc[i].lid,
					&aco2conc[i].fnum[0],
					&aco2conc[i].fnum[1],
					&aco2conc[i].fnum[2],
					&aco2conc[i].fnum[3],
					&aco2conc[i].fnum[4],
					&aco2conc[i].fnum[5],
					&aco2conc[i].fnum[6],
					&aco2conc[i].fnum[7],
					&aco2conc[i].fnum[8],
					&aco2conc[i].fnum[9],
					&aco2conc[i].fnum[10],
					&aco2conc[i].fnum[11]);
			}
		}
		break;
	case 510: //	DO/BOD control
		if(oxfg == 1)
		{
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			benrfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			reamfg = atoi(LPCSTR(strToken.NextToken()));
			if (reamfg > 3 || reamfg < 1)
				reamfg = 2; //default option
		}
		break;
	case 511: // ox-parm1
		if(ox_parm1!=NULL)
			delete []ox_parm1;

		if(oxfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			ox_parm1 = new OX_PARA1[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&ox_parm1[i].gid,
					&ox_parm1[i].kbod20,
					&ox_parm1[i].tcbod,
					&ox_parm1[i].kodset,
					&ox_parm1[i].supsat,
					&ox_parm1[i].tcginv,
					&ox_parm1[i].reak,
					&ox_parm1[i].expred,
					&ox_parm1[i].exprev,
					&ox_parm1[i].cforea);
			}
		}
		break;
	case 512: // ox-parm2
		if(ox_parm2!=NULL)
			delete []ox_parm2;

		if(oxfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			ox_parm2 = new OX_PARA2[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf",
					&ox_parm2[i].gid,
					&ox_parm2[i].benod,
					&ox_parm2[i].tcben,
					&ox_parm2[i].expod,
					&ox_parm2[i].brbod,
					&ox_parm2[i].brbod_inc,
					&ox_parm2[i].exprel);
			}
		}
		break;
	case 513: // oxrx-initial conditions
		if(oxrx_init!=NULL)
			delete []oxrx_init;

		if(oxfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			oxrx_init = new OXRX_INIT[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf",
					&oxrx_init[i].gid,
					&oxrx_init[i].dox,
					&oxrx_init[i].bod,
					&oxrx_init[i].satdo);
			}
		}
		break;
	case 514: // scour parameters
		if(scour_parms!=NULL)
			delete []scour_parms;

		if(oxfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			scour_parms = new SCOUR_PARMS[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf",
					&scour_parms[i].gid,
					&scour_parms[i].scrvel,
					&scour_parms[i].scrmul);
			}
		}
		break;
	case 520: //	NUTRIENTS control
		if(nutfg == 1)
		{
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			tamfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			no2fg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			po4fg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			amvfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			denfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			adnhfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			adpofg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			mphfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:0;	// not supported at this time (05-2005)

			if ((tamfg == 0 && (amvfg == 1 || adnhfg == 1)) || (po4fg == 0 && adpofg == 1))
			{
				AfxMessageBox("Error - either: 1) tam is not being simulated, and nh3 volat. or	nh4 adsorption is being simulated; or 2) po4 is not being simulated, and po4 adsorption is being simulated");
				return false;
			}
		}
		break;
	case 521: // nut-parm1
		if(nut_parm1!=NULL)
			delete []nut_parm1;

		if(nutfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			nut_parm1 = new NUT_PARA1[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&nut_parm1[i].gid,
					&nut_parm1[i].cvbo,
					&nut_parm1[i].cvbpc,
					&nut_parm1[i].cvbpn,
					&nut_parm1[i].bpcntc,
					&nut_parm1[i].ktam20,
					&nut_parm1[i].kno220,
					&nut_parm1[i].tcnit,
					&nut_parm1[i].kno320,
					&nut_parm1[i].tcden,
					&nut_parm1[i].denoxt);
			}
		}
		break;
	case 522: // nut-parm2
		if(nut_parm2!=NULL)
			delete []nut_parm2;

		if(nutfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			nut_parm2 = new NUT_PARA2[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&nut_parm2[i].gid,
					&nut_parm2[i].brtam_1,
					&nut_parm2[i].brtam_2,
					&nut_parm2[i].brpo4_1,
					&nut_parm2[i].brpo4_2,
					&nut_parm2[i].bnh4_1,
					&nut_parm2[i].bnh4_2,
					&nut_parm2[i].bnh4_3,
					&nut_parm2[i].bpo4_1,
					&nut_parm2[i].bpo4_2,
					&nut_parm2[i].bpo4_3);
			}
		}
		break;
	case 523: // nut-parm3
		if(nut_parm3!=NULL)
			delete []nut_parm3;

		if(nutfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			nut_parm3 = new NUT_PARA3[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&nut_parm3[i].gid,
					&nut_parm3[i].anaer,
					&nut_parm3[i].adnhpm_1,
					&nut_parm3[i].adnhpm_2,
					&nut_parm3[i].adnhpm_3,
					&nut_parm3[i].adpopm_1,
					&nut_parm3[i].adpopm_2,
					&nut_parm3[i].adpopm_3,
					&nut_parm3[i].expnvg,
					&nut_parm3[i].expnvl);
			}
		}
		break;
	case 524: // oxrx-initial conditions
		if(nut_init!=NULL)
			delete []nut_init;

		if(nutfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			nut_init = new NUT_INIT[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&nut_init[i].gid,
					&nut_init[i].no3,
					&nut_init[i].tam,
					&nut_init[i].no2,
					&nut_init[i].po4,
					&nut_init[i].snh4_1,
					&nut_init[i].snh4_2,
					&nut_init[i].snh4_3,
					&nut_init[i].spo4_1,
					&nut_init[i].spo4_2,
					&nut_init[i].spo4_3);
			}
		}
		break;
	case 530: //	PLANK control
		if(plkfg == 1)
		{
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			phyfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			zoofg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			balfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			sdltfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			amrfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			decfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			nsfg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
			orefg = (atoi(LPCSTR(strToken.NextToken())) == 0)?0:1;
		}
		break;
	case 531: // plank-parm1
		if(plank_parm1!=NULL)
			delete []plank_parm1;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			plank_parm1 = new PLANK_PARA1[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf",
					&plank_parm1[i].gid,
					&plank_parm1[i].ratclp,
					&plank_parm1[i].nonref,
					&plank_parm1[i].litsed,
					&plank_parm1[i].alnpr,
					&plank_parm1[i].extb,
					&plank_parm1[i].malgr);
			}
		}
		break;
	case 532: // plank-parm2
		if(plank_parm2!=NULL)
			delete []plank_parm2;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			plank_parm2 = new PLANK_PARA2[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf",
					&plank_parm2[i].gid,
					&plank_parm2[i].cmmlt,
					&plank_parm2[i].cmmn,
					&plank_parm2[i].cmmnp,
					&plank_parm2[i].cmmp,
					&plank_parm2[i].talgrh,
					&plank_parm2[i].talgrl,
					&plank_parm2[i].talgrm);
			}
		}
		break;
	case 533: // plank-parm3
		if(plank_parm3!=NULL)
			delete []plank_parm3;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			plank_parm3 = new PLANK_PARA3[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf",
					&plank_parm3[i].gid,
					&plank_parm3[i].alr20,
					&plank_parm3[i].aldh,
					&plank_parm3[i].aldl,
					&plank_parm3[i].oxald,
					&plank_parm3[i].naldh,
					&plank_parm3[i].paldh);
			}
		}
		break;
	case 534: // plank-parm4
		if(plank_parm4!=NULL)
			delete []plank_parm4;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			plank_parm4 = new PLANK_PARA4[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&plank_parm4[i].gid,
					&plank_parm4[i].phycon,
					&plank_parm4[i].seed,
					&plank_parm4[i].mxstay,
					&plank_parm4[i].oref,
					&plank_parm4[i].claldh,
					&plank_parm4[i].physet,
					&plank_parm4[i].refset,
					&plank_parm4[i].cfsaex,
					&plank_parm4[i].mbal,
					&plank_parm4[i].cfbalr,
					&plank_parm4[i].cfbalg);
			}
		}
		break;
	case 535: // plank-initial conditions
		if(plank_init!=NULL)
			delete []plank_init;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			plank_init = new PLANK_INIT[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf",
					&plank_init[i].gid,
					&plank_init[i].phyto,
					&plank_init[i].benal,
					&plank_init[i].orn,
					&plank_init[i].orp,
					&plank_init[i].orc);
			}
		}
		break;
	case 540: //	PH control
		if(phfg == 1)
		{
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			sscanf(strLine,"%d %d %lf %lf",&phffg1,&phffg2,&phfrc1,&phfrc2);
		}
		break;
	case 541: // plank-parm1
		if(ph_para!=NULL)
			delete []ph_para;

		if(phfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			ph_para = new PH_PARA[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %d %d %lf %lf %lf",
					&ph_para[i].gid,
					&ph_para[i].phcnt,
					&ph_para[i].alkcon,
					&ph_para[i].cfcinv,
					&ph_para[i].brco2_1,
					&ph_para[i].brco2_2);
			}
		}
		break;
	case 542: // plank-initial conditions
		if(ph_init!=NULL)
			delete []ph_init;

		if(phfg == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			ph_init = new PH_INIT[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf",
					&ph_init[i].gid,
					&ph_init[i].tic,
					&ph_init[i].co2,
					&ph_init[i].ph);
			}
		}
		break;
	case 543:    
		if(mtic_rf!=NULL)
			delete []mtic_rf;

		if(phfg  == 1 && phffg1 == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			mtic_rf = new MONTH_PH[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&mtic_rf[i].gid,
					&mtic_rf[i].fnum[0],
					&mtic_rf[i].fnum[1],
					&mtic_rf[i].fnum[2],
					&mtic_rf[i].fnum[3],
					&mtic_rf[i].fnum[4],
					&mtic_rf[i].fnum[5],
					&mtic_rf[i].fnum[6],
					&mtic_rf[i].fnum[7],
					&mtic_rf[i].fnum[8],
					&mtic_rf[i].fnum[9],
					&mtic_rf[i].fnum[10],
					&mtic_rf[i].fnum[11]);
			}
		}
		break;
	case 544:    
		if(mco2_rf!=NULL)
			delete []mco2_rf;

		if(phfg  == 1 && phffg2 == 1)
		{
			nNum = nrgroup;
			if(nNum <= 0)
				return false;
			mco2_rf = new MONTH_PH[nNum];
			for(i = 0; i< nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				sscanf(strLine,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
					&mco2_rf[i].gid,
					&mco2_rf[i].fnum[0],
					&mco2_rf[i].fnum[1],
					&mco2_rf[i].fnum[2],
					&mco2_rf[i].fnum[3],
					&mco2_rf[i].fnum[4],
					&mco2_rf[i].fnum[5],
					&mco2_rf[i].fnum[6],
					&mco2_rf[i].fnum[7],
					&mco2_rf[i].fnum[8],
					&mco2_rf[i].fnum[9],
					&mco2_rf[i].fnum[10],
					&mco2_rf[i].fnum[11]);
			}
		}
		break;
	case 600:
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		sscanf(strLine,"%d %d %d %d %d",&ncpt,&ncland,&ncrch,&ntrgp,&ntnum);
		break;
	case 605:    
		if(pThreshold != NULL)
			delete []pThreshold;

		if(ntnum <= 0)
			break;

		pThreshold = new THR_MAPPING[ntnum];
		for(i=0; i<ntnum; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			pThreshold[i].tnum  = atoi(LPCSTR(strToken.NextToken()));
			pThreshold[i].tqsd  = atoi(LPCSTR(strToken.NextToken()));
			pThreshold[i].tqnum = atoi(LPCSTR(strToken.NextToken()));
			// allocate memory here
			if (pThreshold[i].tqnum > 0)
			{
				pThreshold[i].tqid = new int[pThreshold[i].tqnum];
				for(int j=0; j<pThreshold[i].tqnum; j++)
					pThreshold[i].tqid[j] = atoi(LPCSTR(strToken.NextToken()));
			}
			// check tqsd value
			if (pThreshold[i].tqsd != 1)
				pThreshold[i].tqsd = 2;
		}
		break;
	case 610:
		if(pMTDATA != NULL)
			delete []pMTDATA;

		nNum = ntrgp*ntnum;
		if(nNum <= 0)
			break;

		pMTDATA = new MON_TDATA[nNum];
		for(i = 0; i< nNum; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				TRACE("Wrong reading %d",nSection);
				Log("Wrong reading %d",nSection);
				return false;
			}
			sscanf(strLine,"%d %d %d %d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
				&pMTDATA[i].trgid,
				&pMTDATA[i].tnum,
				&pMTDATA[i].ttype,
				&pMTDATA[i].tdays,
				&pMTDATA[i].fnum[0],
				&pMTDATA[i].fnum[1],
				&pMTDATA[i].fnum[2],
				&pMTDATA[i].fnum[3],
				&pMTDATA[i].fnum[4],
				&pMTDATA[i].fnum[5],
				&pMTDATA[i].fnum[6],
				&pMTDATA[i].fnum[7],
				&pMTDATA[i].fnum[8],
				&pMTDATA[i].fnum[9],
				&pMTDATA[i].fnum[10],
				&pMTDATA[i].fnum[11]);
		}
		break;
	case 660: 
		if(pPSReduction!=NULL)
			delete []pPSReduction;

		if(nPtSource <= 0)
			break;

		// allocate memory here
		pPSReduction = new PSReduction[nPtSource];
		if (nPtQuals > 0)
		{
			for (i=0; i<nPtSource; i++)
				pPSReduction[i].fReduction_qual = new double[nPtQuals];
		}

		// read data
		memset (strLine, 0, MAXLINE);
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("Wrong reading %d",nSection);
			Log("Wrong reading %d",nSection);
			return false;
		}
		else
		{
			CString str(strLine);
			CStringToken strToken(str," \t\r\n\"");
			if (str.Find(":") != -1)
			{
				//open the external file for this card
				CString FileName = strToken.NextToken();

				// open the file for reading
				FILE *file = NULL;
				file = fopen (FileName, "rt");
				if(file == NULL)
				{
					AfxMessageBox("Cannot open file "+FileName+" for reading");
					Log("Cannot open file "+FileName+" for reading");
					return false;
				}
	
				Log("Reading card 660 from the file:"+FileName);
				if (!ReadInfo2(FileName, nSection, file))
				{
					fclose(file);
					return false;
				}
				
				SkipCommentLine(file);
				for(i=0; i<nPtSource; ++i)
				{
					memset (strLine, 0, MAXLINE);
					if(fgets (strLine, MAXLINE, file) == NULL)
					{
						TRACE("Wrong reading %d",nSection);
						Log("Wrong reading %d",nSection);
						fclose(file);
						return false;
					}
					CString str(strLine);
					CStringToken strToken(str," \t\r\n\"");
					pPSReduction[i].nPSindex = i+1;		// point source index
					pPSReduction[i].rchid = atoi(LPCSTR(strToken.NextToken()));

					//added (2-11-2014)
					int nIndex = FindIndexOrder(pPSReduction[i].rchid);
					if (nIndex == -1)
					{
						CString strError;
						strError.Format("Reach ID: %d: in card 660 is not valid",pPSReduction[i].rchid);
						AfxMessageBox(strError);
						TRACE(strError);
						Log(strError);
						return false;
					}
					pPSReduction[i].strPermitName = strToken.NextToken();
					pPSReduction[i].strPipeName = strToken.NextToken();

					sscanf(LPCSTR(strToken.NextToken()),"%lf",&pPSReduction[i].fReduction_flow);
					for(j=0; j<nPtQuals; ++j)
					{
						pPSReduction[i].fReduction_qual[j] = atof(LPCSTR(strToken.NextToken()));
					}
				}
					
				//close the file
				fclose(file);
			}
			else
			{
				//the card exists in the current file
				i=0;
				pPSReduction[i].nPSindex = i+1;		// point source index
				pPSReduction[i].rchid = atoi(LPCSTR(strToken.NextToken()));

				//added (2-11-2014)
				int nIndex = FindIndexOrder(pPSReduction[i].rchid);
				if (nIndex == -1)
				{
					CString strError;
					strError.Format("Reach ID: %d: in card 660 is not valid",pPSReduction[i].rchid);
					AfxMessageBox(strError);
					TRACE(strError);
					Log(strError);
					return false;
				}

				pPSReduction[i].strPermitName = strToken.NextToken();
				pPSReduction[i].strPipeName = strToken.NextToken();

				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pPSReduction[i].fReduction_flow);
				for(j=0; j<nPtQuals; ++j)
				{
					pPSReduction[i].fReduction_qual[j] = atof(LPCSTR(strToken.NextToken()));
				}

				for(i=1; i<nPtSource; ++i)
				{
					memset (strLine, 0, MAXLINE);
					if(fgets (strLine, MAXLINE, fpin) == NULL)
					{
						TRACE("Wrong reading %d",nSection);
						Log("Wrong reading %d",nSection);
						return false;
					}
					CString str(strLine);
					CStringToken strToken(str," \t\r\n\"");
					pPSReduction[i].nPSindex = i+1;		// point source index
					pPSReduction[i].rchid = atoi(LPCSTR(strToken.NextToken()));

					//added (2-11-2014)
					nIndex = FindIndexOrder(pPSReduction[i].rchid);
					if (nIndex == -1)
					{
						CString strError;
						strError.Format("Reach ID: %d: in card 660 is not valid",pPSReduction[i].rchid);
						AfxMessageBox(strError);
						TRACE(strError);
						Log(strError);
						return false;
					}

					pPSReduction[i].strPermitName = strToken.NextToken();
					pPSReduction[i].strPipeName = strToken.NextToken();

					sscanf(LPCSTR(strToken.NextToken()),"%lf",&pPSReduction[i].fReduction_flow);
					for(j=0; j<nPtQuals; ++j)
					{
						pPSReduction[i].fReduction_qual[j] = atof(LPCSTR(strToken.NextToken()));
					}
				}
			}
		}
		break;
/*	case 670: 
		if(pTMDLDistrib != NULL)
			delete []pTMDLDistrib;

		if(ncland > 0)
		{
			int Num = nQuals + 1;	// flow is always there
			if (sedfg == 1)
				Num += 3;			// sand, silt, and clay
			int nNum = nsws*nlandp*Num;
			if(nNum > 0 )
			{
				pTMDLDistrib = new TMDL_LU_QUAL_CPARAM[nNum];
				for(i=0; i<nsws*nlandp; ++i)
				{
					memset (strLine, 0, MAXLINE);
					if(fgets (strLine, MAXLINE, fpin) == NULL)
					{
						TRACE("Wrong reading %d",nSection);
						Log("Wrong reading %d",nSection);
						return false;
					}
					CString str(strLine);
					CStringToken strToken(str," \t\r\n\"");
					pTMDLDistrib[i*Num].subbasin = atoi(LPCSTR(strToken.NextToken()));
					pTMDLDistrib[i*Num].luid = atoi(LPCSTR(strToken.NextToken()));
					pTMDLDistrib[i*Num].strLUName = strToken.NextToken();

					for (int j=0; j<Num; ++j)
					{
						pTMDLDistrib[i*Num+j].subbasin = pTMDLDistrib[i*Num].subbasin;
						pTMDLDistrib[i*Num+j].luid = pTMDLDistrib[i*Num].luid;
						pTMDLDistrib[i*Num+j].strLUName = pTMDLDistrib[i*Num].strLUName;
						pTMDLDistrib[i*Num+j].fRatio = atof(LPCSTR(strToken.NextToken()));
					}
				}
			}
		}
		break;
*/	case 670: 
		if(pTMDLDistrib != NULL)
			delete []pTMDLDistrib;

		if(ncland > 0)
		{
			int Num = nQuals + 1;	// flow is always there
			if (sedfg == 1)
				Num += 3;			// sand, silt, and clay
			int nNum = nsws*nlandp*Num;
			if(nNum > 0 )
			{
				pTMDLDistrib = new TMDL_LU_QUAL_CPARAM[nNum];

				//read the data
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				else
				{
					bReadc670 = true;
					CString str(strLine);
					CStringToken strToken(str," \t\r\n\"");
					if (str.Find(":") != -1)
					{
						//open the external file for this card
						CString FileName = strToken.NextToken();

						// open the file for reading
						FILE *file = NULL;
						file = fopen (FileName, "rt");
						if(file == NULL)
						{
							AfxMessageBox("Cannot open file "+FileName+" for reading");
							Log("Cannot open file "+FileName+" for reading");
							return false;
						}
			
						Log("Reading card 670 from the file:"+FileName);
						if (!ReadInfo2(FileName, nSection, file))
						{
							fclose(file);
							return false;
						}
						
						SkipCommentLine(file);
						for(i=0; i<nsws*nlandp; ++i)
						{
							memset (strLine, 0, MAXLINE);
							if(fgets (strLine, MAXLINE, file) == NULL)
							{
								TRACE("Wrong reading %d",nSection);
								Log("Wrong reading %d",nSection);
								fclose(file);
								return false;
							}
							CString str(strLine);
							CStringToken strToken(str," \t\r\n\"");
							pTMDLDistrib[i*Num].subbasin = atoi(LPCSTR(strToken.NextToken()));
							pTMDLDistrib[i*Num].luid = atoi(LPCSTR(strToken.NextToken()));
							pTMDLDistrib[i*Num].strLUName = strToken.NextToken();

							for (j=0; j<Num; ++j)
							{
								pTMDLDistrib[i*Num+j].subbasin = pTMDLDistrib[i*Num].subbasin;
								pTMDLDistrib[i*Num+j].luid = pTMDLDistrib[i*Num].luid;
								pTMDLDistrib[i*Num+j].strLUName = pTMDLDistrib[i*Num].strLUName;
								pTMDLDistrib[i*Num+j].fRatio = atof(LPCSTR(strToken.NextToken()));
							}
						}
							
						//close the file
						fclose(file);
					}
					else
					{
						//the card exists in the current file
						i=0;
						pTMDLDistrib[i*Num].subbasin = atoi(LPCSTR(strToken.NextToken()));
						pTMDLDistrib[i*Num].luid = atoi(LPCSTR(strToken.NextToken()));
						pTMDLDistrib[i*Num].strLUName = strToken.NextToken();

						for (int j=0; j<Num; ++j)
						{
							pTMDLDistrib[i*Num+j].subbasin = pTMDLDistrib[i*Num].subbasin;
							pTMDLDistrib[i*Num+j].luid = pTMDLDistrib[i*Num].luid;
							pTMDLDistrib[i*Num+j].strLUName = pTMDLDistrib[i*Num].strLUName;
							pTMDLDistrib[i*Num+j].fRatio = atof(LPCSTR(strToken.NextToken()));
						}

						for(i=1; i<nsws*nlandp; ++i)
						{
							memset (strLine, 0, MAXLINE);
							if(fgets (strLine, MAXLINE, fpin) == NULL)
							{
								TRACE("Wrong reading %d",nSection);
								Log("Wrong reading %d",nSection);
								return false;
							}
							CString str(strLine);
							CStringToken strToken(str," \t\r\n\"");
							pTMDLDistrib[i*Num].subbasin = atoi(LPCSTR(strToken.NextToken()));
							pTMDLDistrib[i*Num].luid = atoi(LPCSTR(strToken.NextToken()));
							pTMDLDistrib[i*Num].strLUName = strToken.NextToken();

							for (int j=0; j<Num; ++j)
							{
								pTMDLDistrib[i*Num+j].subbasin = pTMDLDistrib[i*Num].subbasin;
								pTMDLDistrib[i*Num+j].luid = pTMDLDistrib[i*Num].luid;
								pTMDLDistrib[i*Num+j].strLUName = pTMDLDistrib[i*Num].strLUName;
								pTMDLDistrib[i*Num+j].fRatio = atof(LPCSTR(strToken.NextToken()));
							}
						}
					}
				}
			}
		}
		break;
	case 680:
		if(pMON_SWITCH != NULL)
			delete []pMON_SWITCH;

		if (ncrch > 0 && ncrchOutlets > 0)
		{
			int nNum = ncrchOutlets;
			// allocate memory here
				pMON_SWITCH = new MON_SWITCH[nNum];

			int Num = 12;

			// read data
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				pMON_SWITCH[i].rchid = atoi(LPCSTR(strToken.NextToken()));
				pMON_SWITCH[i].nOutletId = atoi(LPCSTR(strToken.NextToken()));
				for(int j=0; j<Num; ++j)
					pMON_SWITCH[i].nSwitch[j] = atoi(LPCSTR(strToken.NextToken()));
			}
		}
		break;
	case 685:
		if(pBMPLimit!=NULL)
			delete []pBMPLimit;

		if (ncrch > 0 && ncrchOutlets > 0)
		{
			int nNum = ncrchOutlets;
			// allocate memory here
				pBMPLimit = new BMPLimit[nNum];

			int Num = nQuals;
			if (sedfg == 1 || oxfg == 1)
				Num += 12;	// sand,silt,clay,RQuals 

			if (Num > 0)
			{
				for (i=0; i<nNum; i++)
					pBMPLimit[i].fLimit_qual = new double[Num];
			}
			// read data
			for(i=0; i<nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				pBMPLimit[i].rchid = atoi(LPCSTR(strToken.NextToken()));
				pBMPLimit[i].nOutletId = atoi(LPCSTR(strToken.NextToken()));
				pBMPLimit[i].fLimit_flow = atof(LPCSTR(strToken.NextToken()));	
				for(int j=0; j<Num; ++j)
					pBMPLimit[i].fLimit_qual[j] = atof(LPCSTR(strToken.NextToken()));
			}
		}
		break;
	case 690:
		if(pBMPReduction!=NULL)
			delete []pBMPReduction;

		if (ncrch > 0 && ncrchOutlets > 0)
		{
			int nNum = ncrchOutlets;
			// allocate memory here
				pBMPReduction = new BMPReduction[nNum];

			int Num = nQuals;
			if (sedfg == 1 || oxfg == 1)
				Num += 12;	// sand,silt,clay,RQuals 

			if (Num > 0)
			{
				for (i=0; i<nNum; i++)
					pBMPReduction[i].fReduction_qual = new double[Num];
			}
			// read data
			for(i = 0; i < nNum; ++i)
			{
				memset (strLine, 0, MAXLINE);
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					TRACE("Wrong reading %d",nSection);
					Log("Wrong reading %d",nSection);
					return false;
				}
				CString str(strLine);
				CStringToken strToken(str," \t\r\n\"");
				pBMPReduction[i].rchid = atoi(LPCSTR(strToken.NextToken()));
				pBMPReduction[i].nOutletId = atoi(LPCSTR(strToken.NextToken()));
				pBMPReduction[i].fReduction_flow = atof(LPCSTR(strToken.NextToken()));
				for(int j=0; j<Num; ++j)
					pBMPReduction[i].fReduction_qual[j] = atof(LPCSTR(strToken.NextToken()));
			}
		}
		break;
	default:
		break;
	}

	return true;
}

void CLSPCMODEL::WriteInputFile(CString strFileName)
{
	FILE *fpin = NULL;
	
	// open the file for writing
	fpin = fopen (strFileName, "wt");
	if(fpin == NULL)
	{
		AfxMessageBox("Cannot open file "+strFileName+" for writing");
		Log("Cannot open file "+strFileName+" for writing");
		return;
	}

	CString str;
    str.Format("c %s\n",LSPC_VERSION);

    fputs("c-----------------------------------------------------------------------------------------\n",fpin);
	fputs("c LSPC -- Loading Simulation Program, C++\n",fpin);
    fputs(LPCSTR(str),fpin);
	fputs("c\n",fpin);
	fputs("c Designed and maintained by:\n",fpin);
	fputs("c     Tetra Tech, Inc.\n",fpin);
	fputs("c     10306 Eaton Place, Suite 340\n",fpin);
	fputs("c     Fairfax, VA 22030\n",fpin);
	fputs("c     (703) 385-6000\n",fpin);
    fputs("c-----------------------------------------------------------------------------------------\n",fpin);
	fputs("c LSPC MODEL INPUT FILE\n", fpin);

    SYSTEMTIME tm;
	GetLocalTime(&tm);

    str.Format("c This input file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
    fputs(LPCSTR(str),fpin);
	fputs("c-----------------------------------------------------------------------------------------\n",fpin);
    WriteFileSection(fpin,0);
	WriteFileSection(fpin,10);
	WriteFileSection(fpin,15);
	WriteFileSection(fpin,20);
	WriteFileSection(fpin,30);
	WriteFileSection(fpin,31);				
	WriteFileSection(fpin,32);
	WriteFileSection(fpin,40);
	WriteFileSection(fpin,45);
	WriteFileSection(fpin,46);
	WriteFileSection(fpin,50);
	WriteFileSection(fpin,60);
	WriteFileSection(fpin,70);
	WriteFileSection(fpin,80);
	WriteFileSection(fpin,90);
	WriteFileSection(fpin,92);
	WriteFileSection(fpin,93);
	WriteFileSection(fpin,94);
	WriteFileSection(fpin,96);
	WriteFileSection(fpin,100);
	WriteFileSection(fpin,110);
	WriteFileSection(fpin,120);
	WriteFileSection(fpin,130);
	WriteFileSection(fpin,140);
	WriteFileSection(fpin,150);
	WriteFileSection(fpin,160);
	WriteFileSection(fpin,170);
	WriteFileSection(fpin,180);
	WriteFileSection(fpin,190);
	WriteFileSection(fpin,200);
	WriteFileSection(fpin,201);
	WriteFileSection(fpin,202);			
	WriteFileSection(fpin,203);
	WriteFileSection(fpin,204);
	WriteFileSection(fpin,205);
	WriteFileSection(fpin,250);
	WriteFileSection(fpin,255);
	WriteFileSection(fpin,260);
	WriteFileSection(fpin,270);
	WriteFileSection(fpin,271);
	WriteFileSection(fpin,272);
	WriteFileSection(fpin,273);
	WriteFileSection(fpin,274);
	WriteFileSection(fpin,275);
	WriteFileSection(fpin,276);
	WriteFileSection(fpin,280);		
	WriteFileSection(fpin,281);		
	WriteFileSection(fpin,282);		
	WriteFileSection(fpin,283);		
	WriteFileSection(fpin,285);		
	WriteFileSection(fpin,286);		
	WriteFileSection(fpin,287);		
	WriteFileSection(fpin,288);		
	WriteFileSection(fpin,289);		
	WriteFileSection(fpin,400);
	WriteFileSection(fpin,401);
	WriteFileSection(fpin,405);		 
	WriteFileSection(fpin,410);
	WriteFileSection(fpin,413);
	WriteFileSection(fpin,415);			
	WriteFileSection(fpin,420);
	WriteFileSection(fpin,425);
	WriteFileSection(fpin,430);
	WriteFileSection(fpin,435);
	WriteFileSection(fpin,440);
	WriteFileSection(fpin,445);
	WriteFileSection(fpin,446);
	WriteFileSection(fpin,450);
	WriteFileSection(fpin,451);
	WriteFileSection(fpin,452);
	WriteFileSection(fpin,453);
	WriteFileSection(fpin,454);
	WriteFileSection(fpin,455);
	WriteFileSection(fpin,456);
	WriteFileSection(fpin,457);
	WriteFileSection(fpin,460);
	WriteFileSection(fpin,461);
	WriteFileSection(fpin,462);
	WriteFileSection(fpin,463);
	WriteFileSection(fpin,464);
	WriteFileSection(fpin,465);
	WriteFileSection(fpin,466);
	WriteFileSection(fpin,467);
	WriteFileSection(fpin,470);
	WriteFileSection(fpin,474);		
	WriteFileSection(fpin,475);		
	WriteFileSection(fpin,480);		
	WriteFileSection(fpin,485);		
	WriteFileSection(fpin,500);
	WriteFileSection(fpin,501);
	WriteFileSection(fpin,502);
	WriteFileSection(fpin,503);
	WriteFileSection(fpin,504);
	WriteFileSection(fpin,505);
	WriteFileSection(fpin,506);
	WriteFileSection(fpin,507);
	WriteFileSection(fpin,510);
	WriteFileSection(fpin,511);
	WriteFileSection(fpin,512);
	WriteFileSection(fpin,513);
	WriteFileSection(fpin,514);
	WriteFileSection(fpin,520);
	WriteFileSection(fpin,521);
	WriteFileSection(fpin,522);
	WriteFileSection(fpin,523);
	WriteFileSection(fpin,524);
	WriteFileSection(fpin,530);
	WriteFileSection(fpin,531);
	WriteFileSection(fpin,532);
	WriteFileSection(fpin,533);
	WriteFileSection(fpin,534);
	WriteFileSection(fpin,535);
	WriteFileSection(fpin,540);
	WriteFileSection(fpin,541);
	WriteFileSection(fpin,542);
	WriteFileSection(fpin,543);
	WriteFileSection(fpin,544);
	WriteFileSection(fpin,600);
	WriteFileSection(fpin,605);
	WriteFileSection(fpin,610);
	WriteFileSection(fpin,660);
	WriteFileSection(fpin,670);
	WriteFileSection(fpin,680);
	WriteFileSection(fpin,685);
	WriteFileSection(fpin,690);

	fclose(fpin);
}

void CLSPCMODEL::WriteFileSection(FILE *fpin, int nSection)
{
	CString strLine,strTemp,strParam = "";
	int i,j,k;
	int chk =0;
	int nRecords = 0;
    int nYear,nMonth,nDay,nYear1,nMonth1,nDay1;
    int noYear,noMonth,noDay,noYear1,noMonth1,noDay1;
	POSITION pos;

	switch(nSection)
	{
	case 0:
        fputs("c0   general control\n",fpin);
		fputs("c \n",fpin);
		fputs("c    snowfg   if = 1 run snow module\n",fpin);
		fputs("c    pwatfg   if = 1 run pwater\n",fpin);
		fputs("c    sedfg    if = 1 run sediment\n",fpin);
		fputs("c    pqalfg   if = 1 run general quality\n",fpin);
		fputs("c    tempfg   if = 1 run temperature module\n",fpin);
		fputs("c    oxfg     if = 1 run DO-BOD module\n",fpin);
		fputs("c    nutfg    if = 1 run nutrients module\n",fpin);
		fputs("c    plkfg    if = 1 run plank module\n",fpin);
		fputs("c    phfg     if = 1 run pH-CO2 module\n",fpin);
        fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	snowfg  pwatfg  sedfg  pqalfg  tempfg  oxfg  nutfg  plkfg  phfg\n",fpin);
		strLine.Format("\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",snowfg, pwatfg, sedfg, pqalfg, tempfg, oxfg, nutfg, plkfg, phfg);
		fputs(LPCSTR(strLine),fpin);
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 10:
		fputs("c10  weather file definition (name and parameters)\n",fpin);
		fputs("c \n",fpin);
		fputs("c    wfileid    weather file id\n",fpin);
		fputs("c    wfilename  weather file name\n",fpin);
		fputs("c    wparamnum  number of parameters in the weather file\n",fpin);
		fputs("c    wparamid   weather paramter id\n",fpin);
		fputs("c               1-precipitation (in/ivl)\n",fpin);
		fputs("c               2-potential evaporation (in/ivl)\n",fpin);
		fputs("c               3-air temperature (degree F)\n",fpin);
		fputs("c               4-wind speed (mile/ivl)\n",fpin);
		fputs("c               5-solar radiation (ly/ivl)\n",fpin);
		fputs("c               6-dew point (degree F)\n",fpin);
		fputs("c               7-cloud cover (tenth)\n",fpin);
        fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
        fputs("c	wfileid   wfilename   wparamnum   wparamid...\n",fpin);
		for(i=0; i<cWD.nNumWeatherFiles; i++)
		{
			CString str;
			strLine.Format("");
			str.Format("\t%d\t%s\t%d",cWD.pWFILEINFO[i].nWFileID,LPCSTR(cWD.pWFILEINFO[i].strWFile),cWD.pWFILEINFO[i].nWParam);
			strLine += str;
			for(j=0; j<cWD.pWFILEINFO[i].nWParam; j++)
			{
				str.Format("\t%d",cWD.pWFILEINFO[i].m_nParamID[j]);
				strLine += str;
			}
			strLine += "\n";
			fputs(LPCSTR(strLine),fpin);
		}
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 15:
		fputs("c15  weather station definition (station id and associated weather files)\n",fpin);
		fputs("c \n",fpin);
		fputs("c    wstationid  weather station id\n",fpin);
		fputs("c    wfilenum  	number of files for the weather station\n",fpin);
		fputs("c    wfileid   	weather file id (card 10)\n",fpin);
        fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
        fputs("c   wstationid   wfilenum   wfileid...\n",fpin);
		for(i=0; i<cWD.nNumWeatherStations; i++)
		{
			CString str;
			strLine.Format("");
			str.Format("\t%d\t%d",cWD.pWSTATIONINFO[i].nWStationID,cWD.pWSTATIONINFO[i].nWFile);
			strLine += str;
			for(j=0; j<cWD.pWSTATIONINFO[i].nWFile; j++)
			{
				int nIndex = cWD.pWSTATIONINFO[i].m_nWFileIndex[j];
				str.Format("\t%d",cWD.pWFILEINFO[nIndex].nWFileID);
				strLine += str;
			}
			strLine += "\n";
			fputs(LPCSTR(strLine),fpin);
		}
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 20:
		fputs("c20  weather parameter multiplier\n",fpin);
		fputs("c \n",fpin);
		fputs("c    wstationid  weather station id (card 15)\n",fpin);
		fputs("c    wparmmult   multiplier for each weather parameter\n",fpin);
		fputs("c    			1- multiplier for precipitation\n",fpin);
		fputs("c    			2- multiplier for potential evapotranspiration\n",fpin);
		fputs("c    			3- multiplier for air temperature\n",fpin);
		fputs("c    			4- multiplier for wind speed\n",fpin);
		fputs("c    			5- multiplier for solar radiation\n",fpin);
		fputs("c    			6- multiplier for dew point\n",fpin);
		fputs("c    			7- multiplier for cloud cover\n",fpin); 
        fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
        fputs("c  wstationid  wparmmult1...  \n",fpin);
		for(i=0; i<cWD.nNumWeatherStations; i++)
		{
			CString str;
			strLine.Format("");
			str.Format("\t%d",cWD.pWSTATIONINFO[i].nWStationID);
			strLine += str;
			for(j=0; j<cWD.nNumWeatherParam; j++)
			{
				str.Format("\t%lf",cWD.pWSTATIONINFO[i].m_lfMultiplier[j]);
				strLine += str;
			}
			strLine += "\n";
			fputs(LPCSTR(strLine),fpin);
		}
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 30:
		fputs("c30	output file path     input (weather) file path  (each must be a continuous string)\n",fpin);
		if (bRunNIMS == true)
	        fputs("\t"+cWD.strWeatherFolderPath+"\n",fpin);
		else
			fputs("\t"+m_strModelResultLocation+"\t"+cWD.strWeatherFolderPath+"\n",fpin);
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 31:
		if (nPtSource > 0)
		{
			fputs("c31	point source file path     point source file name  (each must be a continuous string)\n",fpin);
			if (strPointFilePath != "" && strPointFileName!= "")		
				fputs("\t"+strPointFilePath+"\t"+strPointFileName+"\n",fpin);
			fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		}
		break;
	case 32:
		if (cLU.nLUchangeFlag > 0 && cLU.strLUchangeFilePath.GetLength() > 0)
		{
			fputs("c32	landuse-change information\n",fpin);
			WriteCardComments(fpin,nSection);

			fputs("c LUChangeFlag        flag to use landuse-change file (0-off)\n",fpin);
			fputs("c LUChangeFilePath    landuse-change file path\n",fpin);

			fputs("c	LUChangeFlag   LUChangeFilePath\n",fpin);
			strLine.Format("\t%d\t%s\n",cLU.nLUchangeFlag,cLU.strLUchangeFilePath);
			fputs(LPCSTR(strLine),fpin);
			fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		}
		break;
	case 40:
		fputs("c40	general watershed controls\n",fpin);
		fputs("c\n",fpin);
		fputs("c    nsubbasin   number of subwatersheds\n",fpin);
		fputs("c    nrchid      number of stream channels (corresponds with number of subwatersheds)\n",fpin);
		fputs("c    nrgid       number of stream groups to assign parameters\n",fpin);
		fputs("c    ndefid      number of land groups to assign parameters\n",fpin);
		fputs("c    ndeluid     maximum number of land use\n",fpin);
        fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	nsws   nrch    nrgroup    nlgroup    nlandp\n",fpin);
		strLine.Format("\t%d\t%d\t%d\t%d\t%d\n",nsws,nch,nrgroup,ngroup,nlandp);
		fputs(LPCSTR(strLine),fpin);
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 45:
		fputs("c45  general output controls\n",fpin);
		fputs("c\n",fpin);
		fputs("c    Standard    Output standard model parameters\n",fpin);
		fputs("c    Snow        Output snow related parameters\n",fpin);					
		fputs("c    Hydrology   Output hydrology related parameters\n",fpin);
		fputs("c    Sediment    Output sediment related parameters\n",fpin);
		fputs("c    GQUAL       Output general water quality related parameters\n",fpin);
		fputs("c    RQUAL       Output biochemical water quality related parameters\n",fpin);
		fputs("c    Custom      Output user specified parameters\n",fpin);
		fputs("c    Landuse     Output landuse summary\n",fpin);
		fputs("c                 if = 0 no output \n",fpin);
		fputs("c                 if = 1 average annual output\n",fpin);
		fputs("c                 if = 2 yearly output\n",fpin);
		fputs("c                 if = 3 monthly output\n",fpin);
		fputs("c    Stream      Output stream summary\n",fpin);
		fputs("c                 if = 0 no output \n",fpin);
		fputs("c                 if = 1 average annual output\n",fpin);
		fputs("c                 if = 2 yearly output\n",fpin);
		fputs("c                 if = 3 monthly output\n",fpin);
		fputs("c    PointSource Output point source summary\n",fpin);
		fputs("c                 if = 0 no output \n",fpin);
		fputs("c                 if = 1 average annual output\n",fpin);
		fputs("c                 if = 2 yearly output\n",fpin);
		fputs("c                 if = 3 monthly output\n",fpin);
		fputs("c    Threshold   Output threshold analysis summary\n",fpin);
		fputs("c                 if = 0 no output \n",fpin);
		fputs("c                 if = 1 average monthly output\n",fpin);
		fputs("c    SUSTAIN     Output unit-area land timeseries for SUSTAIN external option\n",fpin);
		fputs("c                 if = 0 no output \n",fpin);
		fputs("c                 if = 1 timeseries output\n",fpin);
		fputs("c\n",fpin);
        fputs("c	Standard  Snow  Hydrology  Sediment  GQUAL  RQUAL  Custom  Landuse  Stream  PointSource  Threshold  SUSTAIN\n",fpin);			
		if (bRunNIMS == true)
			strLine.Format("\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",nDefault,nSnow,nHydro,nSed,nGQUAL,nRQUAL,nCustom,1,1,nPSsummary,nThreshold,nSUSTAIN);
		else
			strLine.Format("\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",nDefault,nSnow,nHydro,nSed,nGQUAL,nRQUAL,nCustom,nLUsummary,nCHsummary,nPSsummary,nThreshold,nSUSTAIN);
		fputs(LPCSTR(strLine),fpin);
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 46:
		fputs("c46  user specified output parameter list\n",fpin);
		fputs("c\n",fpin);
		strTemp = "c   PRECP   AIRTMP  SNOTMP  SNOWF   RAINF   PRAIN   MELT   SNOWE  ";
		strParam += strTemp;
		strTemp = "WYIELD  PACK    PACKF   PACKW   PACKI   PDEPTH  COVINDX   NEGHTS  ";
		strParam += strTemp;
		strTemp = "XLNMELT     RDENPKF     SKYCLEAR    SNOCOV  DULLNESS    ALBEDO    ";
		strParam += strTemp;
		strTemp = "PAKTEMP     DEWTMP  SURS    UZS     LZS     AGWS    SURO    IFWO  ";
		strParam += strTemp;
		strTemp = "AGWO    PERO    TAET    PERC    INFIL   GWI     IGWI    AGWI      ";
		strParam += strTemp;
		strTemp = "DEP     AVDEP   HRAD    AVVEL   SAREA   VOLUME   RO  TAU   WSSD   ";
		strParam += strTemp;
		strTemp = "SCRSD   SOSED  SOBER   SSEDC  LSSED   LRSED  LBEDDEP  LDEPSCR     ";
		strParam += strTemp;
		strTemp = "LROSED  SQO     WASHQS  SCRQS   SOQO    POQUAL  SOQUAL  IOQUAL    ";
		strParam += strTemp;
		strTemp = "GOQUAL  POQC  CONC  CONCOUT  CONCSQAL   MATSQAL  MATIN   MATOUT   ";
		strParam += strTemp;
		strTemp = "MATOSQAL  DOX   DOXMIN  DOXMAX   DOXAV   DOXX   BOD   BODX  NO3   ";
		strParam += strTemp;
		strTemp = "NO3X   TAM    TAMX    NO2    NO2X    PO4    PO4X   SNH4   SNH4X   ";
		strParam += strTemp;
		strTemp = "SPO4   SPO4X    PHYTO   PHYTOX   PHYCLA   BENAL   ORN     ORNX    ";
		strParam += strTemp;
		strTemp = "ORP     ORPX   ORC   ORCX   PH   ALK   TIC   TICX   CO2   CO2X   TEMP";
		strParam += strTemp;

		strParam += "\n";
		fputs(LPCSTR(strParam),fpin);

		if(nCustom == 1)
		{
			CString str;
			strLine = "";
			for(int i=0; i<PARA_NUM; i++)
			{
				str.Format("\t%d", cOP.blistOutput[i]?1:0);
				strLine += str;
			}
			strLine += "\n";
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 50:
		fputs("c50  model simulation time period\n",fpin);
        fputs("c\n",fpin);
        fputs("c    mstart   model start day.\n",fpin);
		fputs("c    mend     model end day.\n",fpin);
		fputs("c    deltm    time step in minutes.\n",fpin);				
        fputs("c    mostart  model output start day.\n",fpin);
		fputs("c    moend    model output end day.\n",fpin);
		fputs("c    optlevel  if = 1 general output (daily)\n",fpin);
		fputs("c              if = 2 output per time interval (min)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	mstart   mend    deltm	mostart    moend   optlevel\n",fpin);				
		nYear = tStart.GetYear();
		nMonth = tStart.GetMonth();
		nDay = tStart.GetDay();
		nYear1 = tEnd.GetYear();
		nMonth1 = tEnd.GetMonth();
		nDay1 = tEnd.GetDay();
		noYear = toStart.GetYear();
		noMonth = toStart.GetMonth();
		noDay = toStart.GetDay();
		noYear1 = toEnd.GetYear();
		noMonth1 = toEnd.GetMonth();
		noDay1 = toEnd.GetDay();
		strLine.Format("\t%d/%d/%d\t%d/%d/%d\t%d\t%d/%d/%d\t%d/%d/%d\t%d\n",nMonth,nDay,nYear,nMonth1,nDay1,nYear1,deltm,noMonth,noDay,noYear,noMonth1,noDay1,noYear1,optlevel);	
		fputs(LPCSTR(strLine),fpin);
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 60:
		fputs("c60  group information\n",fpin);
		fputs("c \n",fpin);
		fputs("c    subbasin  subbasin id\n",fpin);
		fputs("c    defid     group parameter id\n",fpin);
		fputs("c    nwst      number of weather stations assigned to the watershed\n",fpin);
		fputs("c    wsti = station id\n",fpin);
		fputs("c    wti = weighting to calculate input\n",fpin);
        fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
        fputs("c	subbasin   defid   nwst  wst1   wt1   wst2   wt2   ...\n",fpin);
		for(i=0; i<nsws; i++)
		{
			CString str;
			strLine.Format("");
			str.Format("\t%d\t%d\t%d",pswsinfo[i].subbasin,pswsinfo[i].gid,pswsinfo[i].nwst);
			strLine += str;
			for(j=0; j<pswsinfo[i].nwst; j++)
			{
				str.Format("\t%d\t%lf",cWD.pWSTATIONINFO[pswsinfo[i].wstindex[j]].nWStationID,pswsinfo[i].wti[j]);
				strLine += str;
			}
			strLine += "\n";
			fputs(LPCSTR(strLine),fpin);
		}
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 70:
		fputs("c70  modeled land use names\n",fpin);
		fputs("c \n",fpin);
		fputs("c    deluid     landuse id\n",fpin);
		fputs("c    deluname   landuse name\n",fpin);
		fputs("c    premult    multiplier for precipitation\n",fpin);
		fputs("c    petmult    multiplier for potential evapotranspiration\n",fpin);
		fputs("c \n",fpin);
		fputs("c	deluid  deluname  premult  petmult\n",fpin);
		if (nlandp > 0)
		{
			for(i = 0; i < nlandp; ++i)
			{
				ppluinfo[i].plusname.Replace(' ','_');
				strLine.Format("\t%d\t%s\t%lf\t%lf\n",ppluinfo[i].luidp,LPCSTR(ppluinfo[i].plusname),ppluinfo[i].luPREmult,ppluinfo[i].luPETmult);
				fputs(LPCSTR(strLine),fpin);
			}
		}
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 80:
		fputs("c80  land use to stream routing\n",fpin);
		fputs("c \n",fpin);
		fputs("c    defid       landuse default group id\n",fpin);
		fputs("c    deluid      land use id\n",fpin);
		fputs("c    route_suro  fraction of surface runoff that routes to the stream (0-1) (default=1)\n",fpin);
		fputs("c                if negative (<0) value then that fraction will be lost from the system\n",fpin);
		fputs("c    route_ifwo  fraction of interflow outflow that routes to the stream (0-1) (default=1)\n",fpin);
		fputs("c                if negative (<0) value then that fraction will be lost from the system\n",fpin);
		fputs("c    route_agwo  fraction of groundwater outflow that routes to the stream (0-1) (default=1)\n",fpin);
		fputs("c                if negative (<0) value then that fraction will be lost from the system\n",fpin);
		fputs("c \n",fpin);
		fputs("c    Example: 0.3 means 30% of outflow routes to the stream and 70% bypasses to the next down stream in the reach network\n",fpin);
		fputs("c            -0.3 means 30% of outflow is permanently lost from the system and 70% routes to the stream\n",fpin);
		fputs("c             Enter a value of -1 to permanently lose all water from the respective layer\n",fpin);
		fputs("c             This convention applies to all three parameters (route_suro, route_ifwo, and route_agwo)\n",fpin);
		fputs("c \n",fpin);
        fputs("c  defid  deluid  route_suro  route_ifwo  route_agwo\n",fpin);
		if (ngroup > 0 && nlandp > 0)
		{
			for(i=0; i<ngroup*nlandp; ++i)
			{
				strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\n",
					pLURoute[i].gid,
					pLURoute[i].luid,
					pLURoute[i].input_suro,
					pLURoute[i].input_ifwo,
					pLURoute[i].input_agwo);
				fputs(LPCSTR(strLine),fpin);
			}
		}
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 90:
		fputs("c90  land use information\n",fpin);
		fputs("c \n",fpin);
		fputs("c    subbasin   subbasin id\n",fpin);
		fputs("c    deluid     land use id\n",fpin);
		fputs("c    deluname   land use name\n",fpin);
		fputs("c    perimp     1 imperivous land (subsurface processes disabled)\n",fpin);
		fputs("c               2 pervious  land (subsurface processes activated)\n",fpin);
		fputs("c    area_ac    area (acres)\n",fpin);
		fputs("c    slsur      slope of overland flow plane (none)\n",fpin);
		fputs("c    lsur       length of overland flow plane (feet)\n",fpin);
		fputs("c \n",fpin);
        fputs("c  subbasin  deluid  deluname  perimp  area_ac  slsur  lsur\n",fpin);
		if (nlandp > 0 && nsws > 0)
		{
			for(i=0; i<nlandp*nsws; ++i)
			{
				pluinfop[i].luname.Replace(' ','_');
				strLine.Format("\t%d\t%d\t%s\t%d\t%lf\t%lf\t%lf\n",
					pluinfop[i].subbasin,
					pluinfop[i].luid,
					pluinfop[i].luname,
					pluinfop[i].piid,
					pluinfop[i].area,
					pluinfop[i].slsur,
					pluinfop[i].lsur);
				fputs(LPCSTR(strLine),fpin);
			}
		}
        fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
    case 92:
		fputs("c92  SNOW-FLAGS\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c \n",fpin);
		fputs("c defid     parameter group id\n",fpin);
		fputs("c deluid    landuse id\n",fpin);
		fputs("c iceflag   0 = Ice formation in the snow pack is not simulated\n",fpin);
		fputs("c           1 = Ice formation is simulated\n",fpin);
		fputs("c forest    0.0 - 1.0  Fraction of LAND covered by Forest (winter transpiration)\n",fpin);
		fputs("c fzg       parameter that adjusts for the effect of ice (in the snow pack) on infiltration when iceflag is 1 (/in.)\n",fpin);
		fputs("c fzgl      lower limit of inffac as adjusted by ice in the snow pack when iceflag is 1\n",fpin);
		fputs("c \n",fpin);
		fputs("c	defid  deluid  iceflag  forest  fzg  fzgl\n",fpin);
		if(snowfg == 1)
		{
			nRecords = nlandp*ngroup;
			if (nRecords > 0)
			{
				for(i=0; i<nRecords; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%lf\t%lf\t%lf\n",
						pSnowCtl2[i].nGrpid,
						pSnowCtl2[i].luid,
						pSnowCtl2[i].ICEFLAG,
						pSnowCtl2[i].lfForest,
						pSnowCtl2[i].fzg,
						pSnowCtl2[i].fzgl);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 93:
		fputs("c93  snow-parm\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c \n",fpin);
		fputs("c defid    parameter group id\n",fpin);
		fputs("c deluid   landuse id\n",fpin);
		fputs("c lat      latitude of the pervious land segment (PLS) - ENERGY BALANCE METHOD ONLY (degree)\n",fpin);
		fputs("c          positive for the northern hemisphere, negative for southern\n",fpin);
		fputs("c melev    mean elevation of LAND above sea level - ENERGY BALANCE METHOD ONLY (ft)\n",fpin);
		fputs("c shade    fraction of LAND shaded from solar radiation (i.e. by trees) - ENERGY BALANCE METHOD ONLY\n",fpin);
		fputs("c snowcf   precipitation-to-snow multiplier (accounts for poor gage-catch efficiency during snow)\n",fpin);
		fputs("c covind   maximum snowpack (water equivalent) at which the entire LAND is covered with snow (in)\n",fpin);
		fputs("c \n",fpin);
		fputs("c	defid   deluid   lat   melev   shade   snowcf   covind\n",fpin);
		if(snowfg == 1)
		{
			nRecords = nlandp*ngroup;
			if (nRecords > 0)
			{
				for(i=0; i<nRecords; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						pSnowParam1[i].nGrpid,
						pSnowParam1[i].luid,
						pSnowParam1[i].LAT,
						pSnowParam1[i].MELEV,
						pSnowParam1[i].SHADE,
						pSnowParam1[i].SNOWCF,
						pSnowParam1[i].COVIND);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 94:
		fputs("c94  snow-parm2\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c \n",fpin);
		fputs("c defid    parameter group id\n",fpin);
		fputs("c deluid   landuse id\n",fpin);
		fputs("c rdcsn    density of cold, new snow relative to water (For snow falling at temps below freezing.\n",fpin);
		fputs("c          at higher temperatures the density of snow is adjusted)\n",fpin);
		fputs("c tsnow    air temperature below which precipitation will be snow, under saturated conditions (deg F)\n",fpin);
		fputs("c          under non-saturated conditions the temperature is adjusted slightly.\n",fpin);
		fputs("c snoevp   adapts sublimation equation to field conditions - ENERGY BALANCE METHOD ONLY\n",fpin);
		fputs("c ccfact   adapts snow condensation/convection melt equation to field conditions - ENERGY BALANCE METHOD ONLY\n",fpin);
		fputs("c mwater   maximum water content of the snow pack, in depth of water per depth of water.\n",fpin);
		fputs("c mgmelt   maximum rate of snowmelt by ground heat, in depth of water per day (in/day)\n",fpin);
		fputs("c          this is the value which applies when the pack temperature is at the freezing point.\n",fpin);
		fputs("c \n",fpin);
		fputs("c	defid   deluid   rdcsn     tsnow   snoevp    ccfact    mwater    mgmelt\n",fpin);
		if(snowfg == 1)
		{
			nRecords = nlandp*ngroup;
			if (nRecords > 0)
			{
				for(i=0; i<nRecords; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						pSnowParam2[i].nGrpid,
						pSnowParam2[i].luid,
						pSnowParam2[i].RDCSN,
						pSnowParam2[i].TSNOW,
						pSnowParam2[i].SNOEVP,
						pSnowParam2[i].CCFACT,
						pSnowParam2[i].MWATER,
						pSnowParam2[i].MGMELT);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 96:
		fputs("c96  snow-init\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c \n",fpin);
		fputs("c   defid       parameter group id\n",fpin);
		fputs("c   deluid      landuse id\n",fpin);
		fputs("c   pack-snow   initial quantity of snow in the pack (water equivalent).\n",fpin);
		fputs("c   pack-ice    initial quantity of ice in the pack (water equivalent).\n",fpin);
		fputs("c   pack-watr   initial quantity of liquid water in the pack.\n",fpin);
		fputs("c   rdenpf      density of the frozen contents (snow and ice) of the pack, relative to water.\n",fpin);
		fputs("c   dull        index of the dullness of the snow pack surface, from which albedo is estimated - ENERGY BALANCE METHOD ONLY\n",fpin);
		fputs("c   paktmp      mean temperature of the frozen contents of the snow pack.\n",fpin);
		fputs("c   covinx      current snow pack depth (water equivalent) required to obtain complete areal coverage of LAND.\n",fpin);
		fputs("c               if the pack is less than this amount, areal coverage is prorated (PACKF/COVINX).\n",fpin);
		fputs("c   xlnmlt      current remaining possible increment to ice storage in the pack.\n",fpin);
		fputs("c               relevant when Ice formation is simulated (iceflag = 1)\n",fpin);
		fputs("c   skyclr      fraction of sky which is assumed to be clear at the present time.\n",fpin);
		fputs("c\n",fpin);
		fputs("c	defid   deluid   pack-snow   pack-ice   pack-watr   rdenpf   dull   paktmp   covinx   xlnmlt   skyclr\n",fpin);
		if(snowfg == 1)
		{
			nRecords = nlandp*ngroup;
			if (nRecords > 0)
			{
				for(i=0; i<nRecords; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						pSnowInit1[i].nGrpid,
						pSnowInit1[i].luid,
						pSnowInit1[i].packsnow,
						pSnowInit1[i].packice,
						pSnowInit1[i].packwatr,
						pSnowInit1[i].RDENPF,
						pSnowInit1[i].DULL,
						pSnowInit1[i].PAKTMP,
						pSnowInit1[i].COVINX,
						pSnowInit1[i].XLNMLT,
						pSnowInit1[i].SKYCLR);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
    case 100:
		fputs("c100 pwat-parm1\n",fpin);
		fputs("c    pervious and impervious land hydrology control\n",fpin);
		fputs("c\n",fpin);
		fputs("c    (value of 0 = use constant pwat-parm4; 1 = use corresponding monthly variable card)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    vcsfg    interception storage capacity					(card 150)\n",fpin);
		fputs("c    vuzfg    upper zone nominal storage						(card 160)\n",fpin);
		fputs("c    vnnfg    manning's n for the overland flow plane		(card 170)\n",fpin);
		fputs("c    vifwfg   interflow inflow parameter						(card 180)\n",fpin);
		fputs("c    vircfg   interflow recession constant					(card 190)\n",fpin);
		fputs("c    vlefg    lower zone evapotranspiration (e-t) parameter	(card 200)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	vcsfg  vuzfg  vnnfg  vifwfg  vircfg  vlefg\n",fpin);
		strLine.Format("\t%d\t%d\t%d\t%d\t%d\t%d\n",vcsfg,vuzfg,vnnfg,vifwfg,vircfg,vlefg);
		fputs(LPCSTR(strLine),fpin);
		fputs("c-----------------------------------------------------------------------------------------\n",fpin);
        break;
    case 110:
		fputs("c110 pwat-parm2\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    lzsn    lower zone nominal soil moisture storage (inches)\n",fpin);
		fputs("c    infilt  infiltration capacity of the soil (in/hr)\n",fpin);
		fputs("c    kvary   variable groundwater recession (1/inches)\n",fpin);
		fputs("c    agwrc   base groundwater recession (none)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid lzsn      infilt      kvary      agwrc\n",fpin);
		if (nlandp > 0 && ngroup > 0)
		{
			for(i = 0; i< nlandp*ngroup; ++i)
			{
				strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\n",
					ppw_param2[i].gid,
					ppw_param2[i].lid,
					ppw_param2[i].lzsn_p,
					ppw_param2[i].infilt_p,
					ppw_param2[i].kvary_p,
					ppw_param2[i].agwr_p);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 120:
		fputs("c120 pwat-parm3\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    petmax  air temperature below which e-t will is reduced (deg F)\n",fpin);
		fputs("c    petmin  air temperature below which e-t is set to zero (deg F)\n",fpin);
		fputs("c    infexp  exponent in the infiltration equation (none)\n",fpin);
		fputs("c    infild  ratio between the maximum and mean infiltration capacities over the PLS (none)\n",fpin);
		fputs("c    deepfr  fraction of groundwater inflow that will enter deep groundwater (none)\n",fpin);
		fputs("c    basetp  fraction of remaining potential e-t that can be satisfied from baseflow (none)\n",fpin);
		fputs("c    agwetp  fraction of remaining potential e-t that can be satisfied from active groundwater (none)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   petmax     petmin     infexp     infild     deepfr     basetp     agwetp\n",fpin);
		if (nlandp > 0 && ngroup > 0)
		{
			for(i = 0; i< nlandp*ngroup; ++i)
			{
				strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
					ppw_param3[i].gid,
					ppw_param3[i].lid,
					ppw_param3[i].petmax_p,
					ppw_param3[i].petmin_p,
					ppw_param3[i].infexp_p,
					ppw_param3[i].infild_p,
					ppw_param3[i].deepfr_p,
					ppw_param3[i].basetp_p,
					ppw_param3[i].agwetp_p);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 130:
		fputs("c130 pwat-parm4\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    cepsc   interception storage capacity (inches)\n",fpin);
		fputs("c    uzsn    upper zone nominal storage (inches)\n",fpin);
		fputs("c    nsur    Manning's n for the assumed overland flow plane (none)\n",fpin);
		fputs("c    intfw   interflow inflow parameter (none)\n",fpin);
		fputs("c    irc     interflow recession parameter (none)\n",fpin);
		fputs("c    lzetp   lower zone e-t parameter (none)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   cepsc      uzsn     nsur       intfw       irc        lzetp\n",fpin);
		if (nlandp > 0 && ngroup > 0)
		{
			for(i = 0; i< nlandp*ngroup; ++i)
			{
				strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
					ppw_param4[i].gid,
					ppw_param4[i].lid,
					ppw_param4[i].cepsc_p,
					ppw_param4[i].uzsn_p,
					ppw_param4[i].nsur_p,
					ppw_param4[i].intfw_p,
					ppw_param4[i].irc_p,
					ppw_param4[i].lzetp_p);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c----------------------------------------------------------------------------------------\n",fpin);
		break;
	case 140:
		fputs("c140 pwat-state1\n",fpin);
		fputs("c    initial conditions for the simulation\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    ceps    initial interception storage.\n",fpin);
		fputs("c    surs    initial surface (overland flow) storage.\n",fpin);
		fputs("c    uzs     initial upper zone storage.\n",fpin);
		fputs("c    ifws    initial interflow storage.\n",fpin);
		fputs("c    lzs     initial lower zone storage.\n",fpin);
		fputs("c    agws    initial active groundwater storage.\n",fpin);
		fputs("c    gwvs    initial index to groundwater slope.\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid ceps      surs       uzs      ifws       lzs       agws      gwvs\n",fpin);
		if (nlandp > 0 && ngroup > 0)
		{
			for(i = 0; i< nlandp*ngroup; ++i)
			{
				strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
					ppw_state[i].gid,
					ppw_state[i].lid,
					ppw_state[i].ceps_p,
					ppw_state[i].surs_p,
					ppw_state[i].uzs_p,
					ppw_state[i].ifws_p,
					ppw_state[i].lzs_p,
					ppw_state[i].agws_p,
					ppw_state[i].gwvs_p);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 150:
		fputs("c150 mon-interception storage (cepscm)\n",fpin);
		fputs("c    only required if vcsfg=1 in pwat-parm1 (see card 100)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec interception storage capacity at start of each month (inches)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		
		if(vcsfg == 1)
		{
			if (nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						cepscm_p[i].gid,
						cepscm_p[i].lid,
						cepscm_p[i].fnum[0],
						cepscm_p[i].fnum[1],
						cepscm_p[i].fnum[2],
						cepscm_p[i].fnum[3],
						cepscm_p[i].fnum[4],
						cepscm_p[i].fnum[5],
						cepscm_p[i].fnum[6],
						cepscm_p[i].fnum[7],
						cepscm_p[i].fnum[8],
						cepscm_p[i].fnum[9],
						cepscm_p[i].fnum[10],
						cepscm_p[i].fnum[11]);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 160:
		fputs("c160 mon-upper zone nominal storage (uzsnm)\n",fpin);
		fputs("c    only required if vuzfg=1 in pwat-parm1 (see card 100)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec upper zone nominal storage at start of each month (inches)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(vuzfg == 1)
		{
			if (nlandp > 0 && ngroup > 0)
			{
				for(int i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						uzsnm_p[i].gid,
						uzsnm_p[i].lid,
						uzsnm_p[i].fnum[0],
						uzsnm_p[i].fnum[1],
						uzsnm_p[i].fnum[2],
						uzsnm_p[i].fnum[3],
						uzsnm_p[i].fnum[4],
						uzsnm_p[i].fnum[5],
						uzsnm_p[i].fnum[6],
						uzsnm_p[i].fnum[7],
						uzsnm_p[i].fnum[8],
						uzsnm_p[i].fnum[9],
						uzsnm_p[i].fnum[10],
						uzsnm_p[i].fnum[11]);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------\n",fpin);
		break;
	case 170:
		fputs("c170 mon-Manning's roughness coefficient (nsurm)\n",fpin);
		fputs("c    only required if vnnfg=1 in pwat-parm1 (see card 100)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec Manning's roughness coefficient at start of each month (none)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(vnnfg==1)
		{
			if (nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						nsurm_p[i].gid,
						nsurm_p[i].lid,
						nsurm_p[i].fnum[0],
						nsurm_p[i].fnum[1],
						nsurm_p[i].fnum[2],
						nsurm_p[i].fnum[3],
						nsurm_p[i].fnum[4],
						nsurm_p[i].fnum[5],
						nsurm_p[i].fnum[6],
						nsurm_p[i].fnum[7],
						nsurm_p[i].fnum[8],
						nsurm_p[i].fnum[9],
						nsurm_p[i].fnum[10],
						nsurm_p[i].fnum[11]);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------\n",fpin);
		break;
	case 180:
		fputs("c180 mon-interflow inflow parameter (intfwm)\n",fpin);
		fputs("c    only required if vifwfg=1 in pwat-parm1 (see card 100)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec interflow inflow parameter at start of each month (none)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(vifwfg==1)
		{
			if (nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						intfwm_p[i].gid,
						intfwm_p[i].lid,
						intfwm_p[i].fnum[0],
						intfwm_p[i].fnum[1],
						intfwm_p[i].fnum[2],
						intfwm_p[i].fnum[3],
						intfwm_p[i].fnum[4],
						intfwm_p[i].fnum[5],
						intfwm_p[i].fnum[6],
						intfwm_p[i].fnum[7],
						intfwm_p[i].fnum[8],
						intfwm_p[i].fnum[9],
						intfwm_p[i].fnum[10],
						intfwm_p[i].fnum[11]);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------\n",fpin);
		break;
	case 190:
		fputs("c190 mon-interflow recession constant (ircm)\n",fpin);
		fputs("c    only required if vircfg=1 in pwat-parm1 (see card 100)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec interflow recession constant at start of each month (none)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(vircfg==1)
		{
			if (nlandp > 0 && ngroup > 0)
			{
				for(int i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						ircm_p[i].gid,
						ircm_p[i].lid,
						ircm_p[i].fnum[0],
						ircm_p[i].fnum[1],
						ircm_p[i].fnum[2],
						ircm_p[i].fnum[3],
						ircm_p[i].fnum[4],
						ircm_p[i].fnum[5],
						ircm_p[i].fnum[6],
						ircm_p[i].fnum[7],
						ircm_p[i].fnum[8],
						ircm_p[i].fnum[9],
						ircm_p[i].fnum[10],
						ircm_p[i].fnum[11]);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 200:
		fputs("c200 mon-lower zone evapotranspiration parameter (lzetpm)\n",fpin);
		fputs("c    only required if vlefg=1 in pwat-parm1 (see card 100)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec lower zone evapotranspiration parameter at start of each month (none)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(vlefg==1)
		{
			if (nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						lzetpm_p[i].gid,
						lzetpm_p[i].lid,
						lzetpm_p[i].fnum[0],
						lzetpm_p[i].fnum[1],
						lzetpm_p[i].fnum[2],
						lzetpm_p[i].fnum[3],
						lzetpm_p[i].fnum[4],
						lzetpm_p[i].fnum[5],
						lzetpm_p[i].fnum[6],
						lzetpm_p[i].fnum[7],
						lzetpm_p[i].fnum[8],
						lzetpm_p[i].fnum[9],
						lzetpm_p[i].fnum[10],
						lzetpm_p[i].fnum[11]);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
        break;
	case 201: //Irrigation Application Options - Flag
		fputs("c201   Irrigation Application Option Flags\n",fpin);
        fputs("cIrrigation flag decide whether to run irrigation\n",fpin);
		fputs("c\n",fpin);
        fputs("c    irrigfg   if = 1 run irrigation option\n",fpin);
        fputs("c    petfg     if = 1 use constant PET rather than time series from the air file\n",fpin);
		fputs("c    monVaryIrrig   if = 1 use monthly varying ET coefficient\n",fpin); 
		fputs("c\n",fpin);
		fputs("c	irrigfg	 petfg  monVaryIrrig\n",fpin);
		strLine.Format("\t%d\t%d\t%d\n",irrigfg,petfg,monVaryIrrig);
		fputs(LPCSTR(strLine),fpin);
		fputs("c-----------------------------------------------------------------------------------------\n",fpin);
		break;
    case 202: //Irrigation Application Options
        fputs("c202 Irrigation PET Value\n",fpin);
        fputs("c   defid        Group ID number.\n",fpin);
        fputs("c   petval       Constant PET value to calculate actual ET (in/hr)\n",fpin);
		fputs("c\n",fpin);
		fputs("c	defid	 petval\n",fpin);
        if (irrigfg == 1 && petfg == 1)
		{
			nRecords = ngroup;
			if (nRecords > 0)
			{
				for(i=0; i<nRecords; ++i)
				{
					strLine.Format("\t%d\t%lf\n",
							pirrigpet[i].gid,
							pirrigpet[i].petval);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
        fputs("c--------------------------------------------------------------------------------------------\n",fpin);
        break;
    case 203: //Irrigation Application Options
        fputs("c203 Irrigation Application Options\n",fpin);
        fputs("c   defid        Group ID number.\n",fpin);
        fputs("c   deluid       Landuse ID number\n",fpin);
        fputs("c   startmonth   startmonth of irrigation requirement\n",fpin);
        fputs("c   endmonth     endmonth of irrigation requirement\n",fpin);
        fputs("c   fraction1    fraction of irrigation requirement applied over the canopy.\n",fpin);
        fputs("c   fraction2    fraction of irrigation water applied directly to the soil surface.\n",fpin);
        fputs("c   fraction3    fraction of irrigation water applied to the upper soil zone via buried systems\n",fpin);
        fputs("c   fraction4    fraction of irrigation water likewise applied to the lower soil zone.\n",fpin);
        fputs("c   fraction5    fraction of irrigation water entering directly into the local groundwater, such as seepage irrigation.\n",fpin);
        fputs("c   etcoeff      Coefficient to calculate actual ET, based on PET.\n",fpin);
        fputs("c   etdays       Number of threshold days to calculate irrigation demand (pet*etcoeff - precip)\n",fpin);
        fputs("c                (if etdays = 0 then irrigation demand = pet * etcoeff)\n",fpin);
		fputs("c\n",fpin);
		fputs("c	defid	deluid	startmonth	endmonth	fraction1	fraction2	fraction3	fraction4	fraction5	etcoeff	etdays\n",fpin);
        if (irrigfg == 1)
		{
			nRecords = nlandp*ngroup;
			if (nRecords > 0)
			{
				for(i=0; i<nRecords; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%d\n",
							pirriginfop[i].gid,
							pirriginfop[i].luid,
							pirriginfop[i].startmonth,
							pirriginfop[i].endmonth,
							pirriginfop[i].fraction1,
							pirriginfop[i].fraction2,
							pirriginfop[i].fraction3,
							pirriginfop[i].fraction4,
							pirriginfop[i].fraction5,
							pirriginfop[i].etcoeff,
							pirriginfop[i].etdays);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
        fputs("c--------------------------------------------------------------------------------------------\n",fpin);
        break;
    case 204: //Irrigation Application Options
        fputs("c204 Monthly-variable ET coefficients\n",fpin);
        fputs("c   defid        Group ID number.\n",fpin);
        fputs("c   deluid       Landuse ID number\n",fpin);
        fputs("c   monetcs      Monthly-variable coefficient to calculate actual ET for Jan..Dec\n",fpin);
		fputs("c\n",fpin);
		fputs("c	defid	deluid	monETCs1	monETCs2	monETCs3	monETCs4	monETCs5	monETCs6	monETCs7	monETCs8	monETCs9	monETCs10	monETCs11	monETCs12\n",fpin);
		if(irrigfg == 1 && monVaryIrrig == 1) 
		{
			nRecords = nlandp*ngroup;
			if (nRecords > 0)
			{
				for(i=0; i<nRecords; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n", 
							pmonetcinfop[i].gid,
							pmonetcinfop[i].luid,
							pmonetcinfop[i].monETCs[0],
							pmonetcinfop[i].monETCs[1],
							pmonetcinfop[i].monETCs[2],
							pmonetcinfop[i].monETCs[3],
							pmonetcinfop[i].monETCs[4],
							pmonetcinfop[i].monETCs[5],
							pmonetcinfop[i].monETCs[6],
							pmonetcinfop[i].monETCs[7],
							pmonetcinfop[i].monETCs[8],
							pmonetcinfop[i].monETCs[9],
							pmonetcinfop[i].monETCs[10],
							pmonetcinfop[i].monETCs[11]);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
        fputs("c--------------------------------------------------------------------------------------------\n",fpin);
        break;
	case 205: //Irrigation Withdrawal options
		fputs("c205 Irrigation Withdrawal Options\n",fpin);  //Irrigation option
		fputs("c	Irrigation withdrawal information for each watershed\n",fpin);
        fputs("c    subbasin    subbasin id\n",fpin);
        fputs("c    rchid       reach id from where water is withdrawn (if reach does not exist then\n",fpin); 
        fputs("c                etdemand is assumed to be satisfied from an external source)\n",fpin);
        fputs("c    irrigdep    depth of irrigation withdrawal pipe (ft)\n",fpin); 
		fputs("c\n",fpin);
		fputs("c	subbasin	rchid\n",fpin);
        if (irrigfg == 1)
		{
			nRecords = nsws;
			if (nRecords > 0)
			{
				for(i=0; i<nRecords; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\n",
						pirrigwdinfo[i].wsid,
						pirrigwdinfo[i].streamid,
						pirrigwdinfo[i].irrigdep);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
        fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 250:
        fputs("c250 general quality constituent control\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid    parameter group id\n",fpin);
		fputs("c    dwqid    general quality id\n",fpin);
		fputs("c    qname    name of qual (must be a continuous string)\n",fpin);
		fputs("c    qunit    units for quality constituent output (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c    qsdfg    if = 0 no sediment associated qual \n",fpin);
		fputs("c		     if = 1 sediment associated in pervious/impervious land (qsdfg should be > 0 in card 281)\n",fpin);
		fputs("c		     if = 2 sediment associated in pervious/impervious land\n",fpin);
		fputs("c		            and sediment associated qual is added to the dissolved part\n",fpin);
		fputs("c    gqsdfg   if = 0 general quality constituent\n",fpin);
		fputs("c             if = 1 general quality constituent simulated as a sediment (only one qual can be simulated as a sediment in each group)\n",fpin);
		fputs("c    qsofg    if = 1 then then accumulation and removal occur daily\n",fpin);
		fputs("c             if = 2 then then accumulation and removal occur every interval\n",fpin);
		fputs("c    potfcfg  if = 1 then apply background concentration potency factor (card 260) to only surface output\n",fpin);
		fputs("c             if = 2 then apply background concentration potency factor (card 260) to total land output\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid dwqid   qname  qunit  qsdfg  gqsdfg  qsofg  potfcfg\n",fpin);
		if(pqalfg == 1)
		{
			if (nQuals > 0 && ngroup > 0)
			{
				for(i=0; i<nQuals*ngroup; ++i)
				{
					pQual[i].qname.Replace(' ','_');
					strLine.Format("\t%d\t%d\t%s\t%s\t%d\t%d\t%d\t%d\n",
						pQual[i].gid,
						pQual[i].qualid,
						pQual[i].qname,
						pQual[i].qunit,
						pQual[i].qsdfg,
						pQual[i].gqsdfg,
						pQual[i].qsofg,
						pQual[i].potfcfg);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c-----------------------------------------------------------------------------------------------------------\n",fpin);
		break;
    case 255:
		fputs("C255 subsurface quality control\n",fpin);
		fputs("c\n",fpin);
		fputs("c    (value of 0 = use constant qual-input; 1 = use corresponding monthly variable card)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    vqofg       if = 1 the accumulation rate and limiting storage of QUALOF varies monthly   (cards 270, 271)\n",fpin);
		fputs("c    qsowfg      if = 1 the constituent is a QUALSURO (surface flow associated).\n",fpin);
		fputs("c    vsqcfg      if = 1 the concentration of this constituent in surface outflow varies monthly   (card 272)= 1 read table 272\n",fpin);
		fputs("c    qifwfg      if = 1 the constituent is a QUALIF (interflow associated).\n",fpin);
		fputs("c    viqcfg      if = 1 the concentration of this constituent in interflow outflow varies monthly   (card 273)= 1 read table 273\n",fpin);
		fputs("c    qagwfg      if = 1 the constituent is a QUALGW (groundwater associated).\n",fpin);
		fputs("c    vaqcfg      if = 1 the concentration of this constituent in groundwater outflow varies monthly (card 274)\n",fpin);
		fputs("c    adfglnd     if = 1 atmosperic deposition on land\n",fpin);
		fputs("c    maddfglnd   if = 1 atmosperic dry deposition varies monthly on land (card 275)\n",fpin);
		fputs("c    mawdfglnd   if = 1 atmosperic wet deposition varies monthly on land (card 276)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	vqofg  qsowfg  vsqcfg  qifwfg  viqcfg  qagwfg  vaqcfg  adfglnd  maddfglnd  mawdfglnd\n",fpin);
		if(pqalfg == 1)
		{
			strLine.Format("\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",vqofg,qsowfg,vsqcfg,qifwfg,viqcfg,qagwfg,vaqcfg,adfglnd,maddfglnd,mawdfglnd);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c-----------------------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 260:
		fputs("C260  qual-input\n",fpin);
		fputs("c    storage on surface and nonseasonal parameters\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    sqo     initial storage of QUALOF on surface (lb or #)\n",fpin);
		fputs("c    potfw   washoff potency factor if qsdfg > 0, card 250 (lb or #)/ton-sediment\n",fpin);
		fputs("c    potfs   scour potency pactor if qsdfg > 0, card 250 (lb or #)/ton-sediment\n",fpin);
		fputs("c    potfc   background concentration potency pactor if qsdfg > 0, card 250 (lb or #)/ton-sediment\n",fpin);
		fputs("c    acqop   accumulation rate of QUALOF on surface (lb or #)/acre/day\n",fpin);
		fputs("c    sqolim  maximum storage of QUALOF on surface (lb or #)/acre\n",fpin);
		fputs("c    wsqop   rate of surface runoff that removes 90% of stored QUALOF per hour (in/hr)\n",fpin);
		fputs("c    soqc    concentration of constituent in surface outflow (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c    ioqc    concentration of constituent in interflow outflow (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c    aoqc    concentration of constituent in groundwater outflow (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c    addc    atmospheric dry deposition flux (lb/acre/day or #/acre/day)\n",fpin);
		fputs("c    awdc    atmospheric wet deposition concentration (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c\n",fpin);
		fputs("c	the units of the following parameters are as follow:\n",fpin);
		fputs("c	if in card 250, the unit is mg/l or ug/l, then M is lbs\n",fpin);		
		fputs("c	if in card 250, the unit is #/100ml, then M is #, in this case the unit for\n",fpin);		
		fputs("c	soqc, ioqc and aoqc should be #/100ml instead of mg/l\n",fpin);		
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid  dwqid  deluid  sqo     potfw     potfs   potfc   acqop   sqolim   wsqop	   soqc   ioqc   aoqc   addc  awdc\n",fpin);
		if(pqalfg == 1)
		{
			for(i=0; i<ngroup*nQuals*nlandp; ++i)
			{
				strLine.Format("\t%d\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
					pQualInput[i].gid,
					pQualInput[i].qualid,
					pQualInput[i].lid,
					GetValueText(pQualInput[i].sqo),
					GetValueText(pQualInput[i].potfw),
					GetValueText(pQualInput[i].potfs),
					GetValueText(pQualInput[i].potfc),
					GetValueText(pQualInput[i].acqop),
					GetValueText(pQualInput[i].sqolim),
					GetValueText(pQualInput[i].wsqop),
					GetValueText(pQualInput[i].soqc),
					GetValueText(pQualInput[i].ioqc),
					GetValueText(pQualInput[i].aoqc),
					GetValueText(pQualInput[i].addc),
					GetValueText(pQualInput[i].awdc));
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 270:
		fputs("c270 mon-accumulation rate (monaccum)\n",fpin);
		fputs("c    only required if vqofg =1 (see card 255)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec accumulation rate at start of each month (lb/acre/day)\n",fpin);
		fputs("c	if in card 250, the unit is #/100ml, the above unit should be #/acre/day\n",fpin);		
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid dwqid   deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(pqalfg == 1 && vqofg == 1)
		{
			if (ngroup > 0 && nQuals > 0 && nlandp > 0)
			{
				for(i = 0; i< ngroup*nQuals*nlandp; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pIMonAccum[i].gid,
						pIMonAccum[i].qualid,
						pIMonAccum[i].lid,
						GetValueText(pIMonAccum[i].fnum[0]),
						GetValueText(pIMonAccum[i].fnum[1]),
						GetValueText(pIMonAccum[i].fnum[2]),
						GetValueText(pIMonAccum[i].fnum[3]),
						GetValueText(pIMonAccum[i].fnum[4]),
						GetValueText(pIMonAccum[i].fnum[5]),
						GetValueText(pIMonAccum[i].fnum[6]),
						GetValueText(pIMonAccum[i].fnum[7]),
						GetValueText(pIMonAccum[i].fnum[8]),
						GetValueText(pIMonAccum[i].fnum[9]),
						GetValueText(pIMonAccum[i].fnum[10]),
						GetValueText(pIMonAccum[i].fnum[11]));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c---------------------------------------------------------------------------------------\n",fpin);
		break;
	case 271:
		fputs("c271 mon-storage limit of quality constituent (monsqolim)\n",fpin);
		fputs("c    only required if vqofg = 1 (see card 255)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec maximum storage at start of each month (lb/acre)\n",fpin);
		fputs("c	if in card 250, the unit is #/100ml, the above unit should be #/acre\n",fpin);		
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid dwqid   deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(pqalfg == 1 && vqofg == 1)
		{
			if (ngroup > 0 && nQuals > 0 && nlandp > 0)
			{
				for(i = 0; i< ngroup*nQuals*nlandp; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pIMonSQOLIM[i].gid,
						pIMonSQOLIM[i].qualid,
						pIMonSQOLIM[i].lid,
						GetValueText(pIMonSQOLIM[i].fnum[0]),
						GetValueText(pIMonSQOLIM[i].fnum[1]),
						GetValueText(pIMonSQOLIM[i].fnum[2]),
						GetValueText(pIMonSQOLIM[i].fnum[3]),
						GetValueText(pIMonSQOLIM[i].fnum[4]),
						GetValueText(pIMonSQOLIM[i].fnum[5]),
						GetValueText(pIMonSQOLIM[i].fnum[6]),
						GetValueText(pIMonSQOLIM[i].fnum[7]),
						GetValueText(pIMonSQOLIM[i].fnum[8]),
						GetValueText(pIMonSQOLIM[i].fnum[9]),
						GetValueText(pIMonSQOLIM[i].fnum[10]),
						GetValueText(pIMonSQOLIM[i].fnum[11]));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c---------------------------------------------------------------------------------------\n",fpin);
		break;
	case 272:
		fputs("c272 mon-surfaceflow concentration (monsuroconc)\n",fpin);
		fputs("c    only required if vsqcfg = 1 (see card 255)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec concentration of constituent in surface flow at start of each month (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c	if in card 250, the unit is #/100ml, the above unit should be #/100ml\n",fpin);		
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid dwqid   deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(pqalfg == 1 && vsqcfg == 1)
		{
			if (ngroup > 0 && nQuals > 0 && nlandp > 0)
			{
				for(i = 0; i< ngroup*nQuals*nlandp; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pIMonSUROCONC[i].gid,
						pIMonSUROCONC[i].qualid,
						pIMonSUROCONC[i].lid,
						GetValueText(pIMonSUROCONC[i].fnum[0]),
						GetValueText(pIMonSUROCONC[i].fnum[1]),
						GetValueText(pIMonSUROCONC[i].fnum[2]),
						GetValueText(pIMonSUROCONC[i].fnum[3]),
						GetValueText(pIMonSUROCONC[i].fnum[4]),
						GetValueText(pIMonSUROCONC[i].fnum[5]),
						GetValueText(pIMonSUROCONC[i].fnum[6]),
						GetValueText(pIMonSUROCONC[i].fnum[7]),
						GetValueText(pIMonSUROCONC[i].fnum[8]),
						GetValueText(pIMonSUROCONC[i].fnum[9]),
						GetValueText(pIMonSUROCONC[i].fnum[10]),
						GetValueText(pIMonSUROCONC[i].fnum[11]));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c---------------------------------------------------------------------------------------\n",fpin);
		break;
	case 273:
		fputs("c273 mon-interflow concentration (moninterconc)\n",fpin);
		fputs("c    only required if viqcfg = 1 (see card 255)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec concentration of constituent in interflow at start of each month (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c	if in card 250, the unit is #/100ml, the above unit should be #/100ml\n",fpin);		
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid dwqid   deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(pqalfg == 1 && viqcfg == 1)
		{
			if (ngroup > 0 && nQuals > 0 && nlandp > 0)
			{
				for(i = 0; i< ngroup*nQuals*nlandp; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pIMonINTERCONC[i].gid,
						pIMonINTERCONC[i].qualid,
						pIMonINTERCONC[i].lid,
						GetValueText(pIMonINTERCONC[i].fnum[0]),
						GetValueText(pIMonINTERCONC[i].fnum[1]),
						GetValueText(pIMonINTERCONC[i].fnum[2]),
						GetValueText(pIMonINTERCONC[i].fnum[3]),
						GetValueText(pIMonINTERCONC[i].fnum[4]),
						GetValueText(pIMonINTERCONC[i].fnum[5]),
						GetValueText(pIMonINTERCONC[i].fnum[6]),
						GetValueText(pIMonINTERCONC[i].fnum[7]),
						GetValueText(pIMonINTERCONC[i].fnum[8]),
						GetValueText(pIMonINTERCONC[i].fnum[9]),
						GetValueText(pIMonINTERCONC[i].fnum[10]),
						GetValueText(pIMonINTERCONC[i].fnum[11]));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c---------------------------------------------------------------------------------------\n",fpin);
		break;
	case 274:
		fputs("c274 mon-groundwater concentration (mongrndconc)\n",fpin);
		fputs("c    only required if vaqcfg = 1 (see card 255)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec concentration of constituent in groundwater at start of each month (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c	if in card 250, the unit is #/100ml, the above unit should be #/100ml\n",fpin);		
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid dwqid   deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(pqalfg == 1 && vaqcfg  == 1)
		{
			if (ngroup > 0 && nQuals > 0 && nlandp > 0)
			{
				for(i = 0; i< ngroup*nQuals*nlandp; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pIMonGRNDCONC[i].gid,
						pIMonGRNDCONC[i].qualid,
						pIMonGRNDCONC[i].lid,
						GetValueText(pIMonGRNDCONC[i].fnum[0]),
						GetValueText(pIMonGRNDCONC[i].fnum[1]),
						GetValueText(pIMonGRNDCONC[i].fnum[2]),
						GetValueText(pIMonGRNDCONC[i].fnum[3]),
						GetValueText(pIMonGRNDCONC[i].fnum[4]),
						GetValueText(pIMonGRNDCONC[i].fnum[5]),
						GetValueText(pIMonGRNDCONC[i].fnum[6]),
						GetValueText(pIMonGRNDCONC[i].fnum[7]),
						GetValueText(pIMonGRNDCONC[i].fnum[8]),
						GetValueText(pIMonGRNDCONC[i].fnum[9]),
						GetValueText(pIMonGRNDCONC[i].fnum[10]),
						GetValueText(pIMonGRNDCONC[i].fnum[11]));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 275:
		fputs("c275 mon-atmospheric dry deposition flux\n",fpin);
		fputs("c    only required if maddfglnd = 1 (see card 255)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec flux of constituent in dry deposition at start of each month (lb/acre/day or #/acre/day)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid dwqid   deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(pqalfg == 1 && maddfglnd == 1)
		{
			if (ngroup > 0 && nQuals > 0 && nlandp > 0)
			{
				for(i = 0; i< ngroup*nQuals*nlandp; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pIMonDRYDEP[i].gid,
						pIMonDRYDEP[i].qualid,
						pIMonDRYDEP[i].lid,
						GetValueText(pIMonDRYDEP[i].fnum[0]),
						GetValueText(pIMonDRYDEP[i].fnum[1]),
						GetValueText(pIMonDRYDEP[i].fnum[2]),
						GetValueText(pIMonDRYDEP[i].fnum[3]),
						GetValueText(pIMonDRYDEP[i].fnum[4]),
						GetValueText(pIMonDRYDEP[i].fnum[5]),
						GetValueText(pIMonDRYDEP[i].fnum[6]),
						GetValueText(pIMonDRYDEP[i].fnum[7]),
						GetValueText(pIMonDRYDEP[i].fnum[8]),
						GetValueText(pIMonDRYDEP[i].fnum[9]),
						GetValueText(pIMonDRYDEP[i].fnum[10]),
						GetValueText(pIMonDRYDEP[i].fnum[11]));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 276:
		fputs("c276 mon-atmospheric wet deposition concentration\n",fpin);
		fputs("c    only required if mawdfglnd = 1 (see card 255)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec concentration of constituent in atmospheric wet deposition at start of each month (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid dwqid   deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(pqalfg == 1 && mawdfglnd == 1)
		{
			if (ngroup > 0 && nQuals > 0 && nlandp > 0)
			{
				for(i = 0; i< ngroup*nQuals*nlandp; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pIMonWETDEP[i].gid,
						pIMonWETDEP[i].qualid,
						pIMonWETDEP[i].lid,
						GetValueText(pIMonWETDEP[i].fnum[0]),
						GetValueText(pIMonWETDEP[i].fnum[1]),
						GetValueText(pIMonWETDEP[i].fnum[2]),
						GetValueText(pIMonWETDEP[i].fnum[3]),
						GetValueText(pIMonWETDEP[i].fnum[4]),
						GetValueText(pIMonWETDEP[i].fnum[5]),
						GetValueText(pIMonWETDEP[i].fnum[6]),
						GetValueText(pIMonWETDEP[i].fnum[7]),
						GetValueText(pIMonWETDEP[i].fnum[8]),
						GetValueText(pIMonWETDEP[i].fnum[9]),
						GetValueText(pIMonWETDEP[i].fnum[10]),
						GetValueText(pIMonWETDEP[i].fnum[11]));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
    case 280:
		fputs("C280 stream water quality control\n",fpin);
		fputs("c\n",fpin);
		fputs("c    adfgrch     if = 1 atmosperic deposition on reach (0 for no atmospheric deposition)\n",fpin);
		fputs("c    maddfgrch   if = 1 atmosperic dry deposition varies monthly on reach (card 282)\n",fpin);
		fputs("c    mawdfgrch   if = 1 atmosperic wet deposition varies monthly on reach (card 283)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	adfgrch  maddfgrch  mawdfgrch\n",fpin);
		if(pqalfg == 1)
		{
			strLine.Format("\t%d\t%d\t%d\n",adfgrch,maddfgrch,mawdfgrch);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c-----------------------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 281:
        fputs("c281 general quality constituent control\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid     stream parameter group id\n",fpin);
		fputs("c    dwqid    general quality id\n",fpin);
		fputs("c    qsdfg    if = 0 no sediment associated qual \n",fpin);
		fputs("c		     if = 1 sediment associated in stream, adsorption/desorption of qual is simulated\n",fpin);
//		fputs("c		     if = 2 sediment associated in stream, adsorption/desorption of qual is simulated\n",fpin);
//		fputs("c		            and sediment associated qual (only from the stream bank erosion) is added to the dissolved part\n",fpin);
        fputs("c    iniCond  initial instream concentration at start of simulation by group (mg/l), (ug/l), or (#/100ml)\n",fpin);
        fputs("c    decay    general first-order instream loss rate of qual by reach group (1/day)\n",fpin);
		fputs("c    tcdecay  temperature correction coefficient for first-order decay of qual (min=1, max=2)\n",fpin);
		fputs("c    addc     atmospheric dry deposition flux (lb/acre/day or #/acre/day)\n",fpin);
		fputs("c    awdc     atmospheric wet deposition concentration (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c    potber   scour potency pactor for stream bank erosion if qsdfg > 0, (lb or #)/ton-sediment\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid  dwqid   qsdfg   iniCond  decay  tcdecay   addc   awdc   potber\n",fpin);
		if(pqalfg == 1)
		{
			if (nQuals > 0 && nrgroup > 0)
			{
				for(i=0; i<nQuals*nrgroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pQualwq[i].gid,
						pQualwq[i].qualid,
						pQualwq[i].qsdfg,
						GetValueText(pQualwq[i].inicon),
						GetValueText(pQualwq[i].fstdec),
						GetValueText(pQualwq[i].thfst),
						GetValueText(pQualwq[i].addc),
						GetValueText(pQualwq[i].awdc),
						GetValueText(pQualwq[i].potber));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c-----------------------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 282:
		fputs("c282 mon-atmospheric dry deposition flux\n",fpin);
		fputs("c    only required if maddfgrch = 1 (see card 280)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    reach group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    jan-dec flux of constituent in dry deposition at start of each month (lb/acre/day or #/acre/day)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid dwqid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(pqalfg == 1 && maddfgrch == 1)
		{
			if (nrgroup > 0 && nQuals > 0)
			{
				for(i = 0; i< nrgroup*nQuals; ++i)
				{
					strLine.Format("\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pMDDrch[i].rgid,
						pMDDrch[i].qualid,
						GetValueText(pMDDrch[i].fnum[0]),
						GetValueText(pMDDrch[i].fnum[1]),
						GetValueText(pMDDrch[i].fnum[2]),
						GetValueText(pMDDrch[i].fnum[3]),
						GetValueText(pMDDrch[i].fnum[4]),
						GetValueText(pMDDrch[i].fnum[5]),
						GetValueText(pMDDrch[i].fnum[6]),
						GetValueText(pMDDrch[i].fnum[7]),
						GetValueText(pMDDrch[i].fnum[8]),
						GetValueText(pMDDrch[i].fnum[9]),
						GetValueText(pMDDrch[i].fnum[10]),
						GetValueText(pMDDrch[i].fnum[11]));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 283:
		fputs("c283 mon-atmospheric wet deposition concentration\n",fpin);
		fputs("c    only required if mawdfgrch = 1 (see card 280)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    reach group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    jan-dec concentration of constituent in atmospheric wet deposition at start of each month (mg/l), (ug/l), or (#/100ml)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid dwqid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(pqalfg == 1 && mawdfgrch == 1)
		{
			if (nrgroup > 0 && nQuals > 0)
			{
				for(i = 0; i< nrgroup*nQuals; ++i)
				{
					strLine.Format("\t%d\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
						pMWDrch[i].rgid,
						pMWDrch[i].qualid,
						GetValueText(pMWDrch[i].fnum[0]),
						GetValueText(pMWDrch[i].fnum[1]),
						GetValueText(pMWDrch[i].fnum[2]),
						GetValueText(pMWDrch[i].fnum[3]),
						GetValueText(pMWDrch[i].fnum[4]),
						GetValueText(pMWDrch[i].fnum[5]),
						GetValueText(pMWDrch[i].fnum[6]),
						GetValueText(pMWDrch[i].fnum[7]),
						GetValueText(pMWDrch[i].fnum[8]),
						GetValueText(pMWDrch[i].fnum[9]),
						GetValueText(pMWDrch[i].fnum[10]),
						GetValueText(pMWDrch[i].fnum[11]));
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 285:
		fputs("c285 parameters for decay of contaminant adsorbed to sediment\n",fpin);
		fputs("c    only required if qsdfg > 0 (see card 281)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid      reach group id\n",fpin);
		fputs("c    dwqid     general quality id\n",fpin);
		fputs("c    addcpm1   decay rate for qual adsorbed to suspended sediment (/day)\n",fpin);
		fputs("c    addcpm2   temperature correction coefficient for decay of qual on suspended sediment (range from 1.0 to 2.0)\n",fpin);
		fputs("c    addcpm3   decay rate for qual adsorbed to bed sediment (/day)\n",fpin);
		fputs("c    addcpm4   temperature correction coefficient for decay of qual on bed sediment (range from 1.0 to 2.0)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   rgid  dwqid   addcpm1   addcpm2   addcpm3   addcpm4\n",fpin);
		if(pqalfg == 1 && sedfg == 1)
		{
			for(i=0; i<nrgroup*nQuals; ++i)
			{
				strLine.Format("\t%d\t%d",
					pGQ_SEDDECAY[i].gid,
					pGQ_SEDDECAY[i].qualid);

				CString strTemp;
				for(j=0; j<4; ++j)
				{
					strTemp.Format("\t%s",GetValueText(pGQ_SEDDECAY[i].addcpm[j]));
					strLine += strTemp;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 286:
		fputs("c286 adsorption coefficients of qual\n",fpin);
		fputs("c    only required if qsdfg > 0 (see card 281)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid      reach group id\n",fpin);
		fputs("c    dwqid     general quality id\n",fpin);
		fputs("c    adpm1     distribution coefficients for qual with suspended sand (l/mg)\n",fpin);
		fputs("c    adpm2     distribution coefficients for qual with suspended silt (l/mg)\n",fpin);
		fputs("c    adpm3     distribution coefficients for qual with suspended clay (l/mg)\n",fpin);
		fputs("c    adpm4     distribution coefficients for qual with bed sand (l/mg)\n",fpin);
		fputs("c    adpm5     distribution coefficients for qual with bed silt (l/mg)\n",fpin);
		fputs("c    adpm6     distribution coefficients for qual with bed clay (l/mg)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   rgid  dwqid   adpm1   adpm2   adpm3   adpm4   adpm5   adpm6\n",fpin);
		if(pqalfg == 1 && sedfg == 1)
		{
			for(i=0; i<nrgroup*nQuals; ++i)
			{
				strLine.Format("\t%d\t%d",
					pGQ_KD[i].gid,
					pGQ_KD[i].qualid);

				CString strTemp;
				for(j=0; j<6; ++j)
				{
					strTemp.Format("\t%s",GetValueText(pGQ_KD[i].adpm[j]));
					strLine += strTemp;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 287:
		fputs("c287 adsorption/desorption rate parameters\n",fpin);
		fputs("c    only required if qsdfg > 0 (see card 281)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid      reach group id\n",fpin);
		fputs("c    dwqid     general quality id\n",fpin);
		fputs("c    adpm1     transfer rates between adsorbed and desorbed states of qual with suspended sand (/day)\n",fpin);
		fputs("c    adpm2     transfer rates between adsorbed and desorbed states of qual with suspended silt (/day)\n",fpin);
		fputs("c    adpm3     transfer rates between adsorbed and desorbed states of qual with suspended clay (/day)\n",fpin);
		fputs("c    adpm4     transfer rates between adsorbed and desorbed states of qual with bed sand (/day)\n",fpin);
		fputs("c    adpm5     transfer rates between adsorbed and desorbed states of qual with bed silt (/day)\n",fpin);
		fputs("c    adpm6     transfer rates between adsorbed and desorbed states of qual with bed clay (/day)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   rgid  dwqid   adpm1   adpm2   adpm3   adpm4   adpm5   adpm6\n",fpin);
		if(pqalfg == 1 && sedfg == 1)
		{
			for(i=0; i<nrgroup*nQuals; ++i)
			{
				strLine.Format("\t%d\t%d",
					pGQ_ADRATE[i].gid,
					pGQ_ADRATE[i].qualid);

				CString strTemp;
				for(j=0; j<6; ++j)
				{
					strTemp.Format("\t%s",GetValueText(pGQ_ADRATE[i].adpm[j]));
					strLine += strTemp;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 288:
		fputs("c288 adsorption/desorption temperature correction parameters\n",fpin);
		fputs("c    only required if qsdfg > 0 (see card 281)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid      reach group id\n",fpin);
		fputs("c    dwqid     general quality id\n",fpin);
		fputs("c    adpm1     temperature correction coefficients for adsorption/desorption on suspended sand (range from 1.0 to 2.0)\n",fpin);
		fputs("c    adpm2     temperature correction coefficients for adsorption/desorption on suspended silt (range from 1.0 to 2.0)\n",fpin);
		fputs("c    adpm3     temperature correction coefficients for adsorption/desorption on suspended clay (range from 1.0 to 2.0)\n",fpin);
		fputs("c    adpm4     temperature correction coefficients for adsorption/desorption on bed sand (range from 1.0 to 2.0)\n",fpin);
		fputs("c    adpm5     temperature correction coefficients for adsorption/desorption on bed silt (range from 1.0 to 2.0)\n",fpin);
		fputs("c    adpm6     temperature correction coefficients for adsorption/desorption on bed clay (range from 1.0 to 2.0)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   rgid  dwqid   adpm1   adpm2   adpm3   adpm4   adpm5   adpm6\n",fpin);
		if(pqalfg == 1 && sedfg == 1)
		{
			for(i=0; i<nrgroup*nQuals; ++i)
			{
				strLine.Format("\t%d\t%d",
					pGQ_ADTHETA[i].gid,
					pGQ_ADTHETA[i].qualid);

				CString strTemp;
				for(j=0; j<6; ++j)
				{
					strTemp.Format("\t%s",GetValueText(pGQ_ADTHETA[i].adpm[j]));
					strLine += strTemp;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 289:
		fputs("c289 initial concentrations on sediment\n",fpin);
		fputs("c    only required if qsdfg > 0 (see card 281)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid      reach group id\n",fpin);
		fputs("c    dwqid     general quality id\n",fpin);
		fputs("c    sqal1     initial concentrations of qual on suspended sand (concu/mg)\n",fpin);
		fputs("c    sqal2     initial concentrations of qual on suspended silt (concu/mg)\n",fpin);
		fputs("c    sqal3     initial concentrations of qual on suspended clay (concu/mg)\n",fpin);
		fputs("c    sqal4     initial concentrations of qual on bed sand (concu/mg)\n",fpin);
		fputs("c    sqal5     initial concentrations of qual on bed silt (concu/mg)\n",fpin);
		fputs("c    sqal6     initial concentrations of qual on bed clay (concu/mg)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   rgid  dwqid   sqal1   sqal2   sqal3   sqal4   sqal5   sqal6\n",fpin);
		if(pqalfg == 1 && sedfg == 1)
		{
			for(i=0; i<nrgroup*nQuals; ++i)
			{
				strLine.Format("\t%d\t%d",
					pGQ_SEDCONC[i].gid,
					pGQ_SEDCONC[i].qualid);

				CString strTemp;
				for(j=0; j<6; ++j)
				{
					strTemp.Format("\t%s",GetValueText(pGQ_SEDCONC[i].sqal[j]));
					strLine += strTemp;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 400: // channel information
		fputs("c400 general channel information\n",fpin);
		fputs("c\n",fpin);
		fputs("c    admod   advection method (1 for dynamic mixing same as in HSPF and 2 for static mixing)\n",fpin);
		fputs("c    kc      crop factor associated with PEVT (used to back-calculate EVAP; EVAP = PEVT/kc)\n",fpin);
		fputs("c    sedber  stream bank erosion sediment (1 for on and 0 for off) (if sedfg=1)\n",fpin);
		fputs("c    vconfg  a value of 1 for vconfg means that F(vol) (volume-dependent) outflow demand components are multiplied by a factor which is allowed to vary through the year.\n",fpin); 
		fputs("c            These monthly adjustment factors are input in Table-type MON-CONVF in this section (card 401)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	admod    kc   sedber   vconfg\n",fpin);
		strLine.Format("\t%d\t%12.12e\t%d\t%d\n",admod, kc, sedber, vconfg);
		fputs(LPCSTR(strLine),fpin);
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 401:		
		fputs("c401 monthly F(vol) adjustment factors\n",fpin);
		fputs("c    only required if vconfg = 1 (see card 400)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid     stream parameter group id\n",fpin);
		fputs("c    jan-dec  F(vol) adjustment factors at the start of each month\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c  rgid	jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(vconfg == 1)
		{
			for(i=0; i<nrgroup; ++i)
			{
				strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
					pMONTH_COV[i].gid,
					pMONTH_COV[i].fnum[0],
					pMONTH_COV[i].fnum[1],
					pMONTH_COV[i].fnum[2],
					pMONTH_COV[i].fnum[3],
					pMONTH_COV[i].fnum[4],
					pMONTH_COV[i].fnum[5],
					pMONTH_COV[i].fnum[6],
					pMONTH_COV[i].fnum[7],
					pMONTH_COV[i].fnum[8],
					pMONTH_COV[i].fnum[9],
					pMONTH_COV[i].fnum[10],
					pMONTH_COV[i].fnum[11]
					);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 405:// channel network	 						
		fputs("c405 channel routing network\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid   reach id (same as subbasin id)\n",fpin);
		fputs("c    control output control switch for the corresponding reach\n",fpin);
		fputs("c            0 = will not write general output\n",fpin);
		fputs("c            1 = will write general output\n",fpin);
		fputs("c    NumOutlets number of downstream outlets\n",fpin);
		fputs("c    DSn     downstream outlets  DS1   Ds2  ....  DSn\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c    rchid   control   NumOutlets   DS1   DS2  .......   DSn\n",fpin);
		for(i=0; i<nch; ++i)
		{
			strLine.Format("\t%d\t%d\t%d",
				pChannelInfo[i].rchid,
				pChannelInfo[i].comp,
				pChannelInfo[i].nDSchan);
				if (pChannelInfo[i].down_ch != NULL)
				{
					CString strTemp;
					for(j=0; j< pChannelInfo[i].nDSchan; ++j)
					{
						strTemp.Format("\t%d",pChannelInfo[i].down_ch[j]);
						strLine += strTemp;
					}
					strLine += "\n";
					fputs(LPCSTR(strLine),fpin);
				}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 410:// reach geometry info
		fputs("c410 reach geometry information\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid   reach/lake id (same as subbasin id)\n",fpin);
		fputs("c    rgid    reach/lake group id\n",fpin);
		fputs("c    trgid   threshold reach/lake group id\n",fpin);
		fputs("c    lkfg    reach/lake flag (0 for reach otherwise lake)\n",fpin);
		fputs("c            lake flag = 1 (rectangular weir for internal option)\n",fpin);
		fputs("c            lake flag = 2 (triangular weir for internal option)\n",fpin);
		fputs("c            lake flag = 11 (BMP with rectangular weir for internal option)\n",fpin);
		fputs("c            lake flag = 12 (BMP with triangular weir for internal option)\n",fpin);
		fputs("c    idepth  reach/lake initial water depth (feet)\n",fpin);
		fputs("c    length  reach/lake length (miles)\n",fpin);
		fputs("c    depth   reach/lake bank full depth (feet)\n",fpin);
		fputs("c    width   reach/lake bankfull width (feet)\n",fpin);
		fputs("c    slope   reach longitudinal slope/lake infiltration rate (in/hr)\n",fpin);
		fputs("c    mann    reach Manning's roughness coefficient/lake weir width (ft)\n",fpin);
		fputs("c    r1      reach ratio of bottom width to bank full width (bottom width = r1 * width)/lake orifice height (ft)\n",fpin);
		fputs("c    r2      reach side slope of flood plane/lake orifice diameter (ft)\n",fpin);
		fputs("c    w1      reach flood plane width factor (total width of flood plane = w1*Width)/lake median particle size diameter, db50 (ft)\n",fpin);
		fputs("c    crat    ratio of maximum velocity to mean velocity in the RCHRES cross-section under typical flow conditions (greater than or equal to 1)\n",fpin);
		fputs("c    ks	    the weighting factor for hydraulic routing (calibration)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rchid	rgid  trgid   lkfg	idepth	length    depth  width    slope     mann    r1    r2    w1    crrat  ks\n",fpin);
		for(i=0; i<nch; ++i)
		{
			strLine.Format("\t%d\t%d\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
				pReachInfo[i].rchid,
				pReachInfo[i].gid,
				pReachInfo[i].tgid,
				pReachInfo[i].lkfg,
				pReachInfo[i].idepth,
				pReachInfo[i].length,
				pReachInfo[i].depth,
				pReachInfo[i].width,
				pReachInfo[i].slope,
				pReachInfo[i].mann,
				pReachInfo[i].r1,
				pReachInfo[i].r2,
				pReachInfo[i].w1,
				pReachInfo[i].crrat,
				pReachInfo[i].ks);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 413:
		fputs("c413 Reach Cross-section Information\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid   x1	y1	x2	y2...\n",fpin);
		fputs("c    rchid   reach id (same as subbasin id)\n",fpin);
		fputs("c    x       distance from the left reach bank (ft)\n",fpin);
		fputs("c            it should not be greater than bank full width in card 410 (ft)\n",fpin);
		fputs("c    y       elevation from the reach bed (ft)\n",fpin);
		fputs("c            it should not be greater than bank full depth in card 410 (ft)\n",fpin);
		fputs("c\n",fpin);
		for (i=0; i<nch; ++i)
		{
			int nPoints = pReachInfo[i].poly.pointList.GetCount();
			if(nPoints >= 3)
			{
				strLine.Format("\t%d",pReachInfo[i].rchid);
				fputs(LPCSTR(strLine),fpin);
				double x,y;
				for (int j=0; j< nPoints; ++j)
				{
					POSITION pos = pReachInfo[i].poly.pointList.FindIndex(j);
					Point *pti = (Point *)pReachInfo[i].poly.pointList.GetAt(pos);
					x = pti->x;
					y = pti->y;
					strLine.Format("\t%lf\t%lf",x,y);
					fputs(LPCSTR(strLine),fpin);
				}
				fputs("\n",fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 415:	// reach Ftable	 (01-2005)
		fputs("c415 reach discharge-volume relationship\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid   reach id\n",fpin);
		fputs("c    depth   water depth (feet)\n",fpin);
		fputs("c    area    water surface area (acres)\n",fpin);
		fputs("c    vol     water volume (ac-ft)\n",fpin);
		fputs("c    disch(1, 2, 3, ....noutflows)  outflows (cfs)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rchid  depth   area    vol    disch1    disch2   .......   dischN\n",fpin);
		for(i=0; i<FtableRecord; ++i)
		{
			//strLine.Format("\t%d\t%12.12e\t%12.12e\t%12.12e",
			strLine.Format("\t%d\t%.6lf\t%.6lf\t%.6lf",
				pFtable[i].rchid,
				//remove a small fraction previously added in read function
				//pFtable[i].depth,
				pFtable[i].depth - (pFtable[i].depth * i / 1.0E12),
				//pFtable[i].area/43559.66,
				(pFtable[i].area - (pFtable[i].area * i / 1.0E12))/43559.66,
				//pFtable[i].vol/43559.66);
				(pFtable[i].vol - (pFtable[i].vol * i / 1.0E12))/43559.66);
			
			// the following code is used to replace the above for dynamic purpose
			if (pFtable[i].disch != NULL)
			{
				for (j=0; j<nch; ++j)
				{
					if (pFtable[i].rchid == pChannelInfo[j].rchid)
					{
						CString strTemp;
						for(k=0; k< pChannelInfo[j].nDSchan; ++k)
						{
							//remove a small fraction previously added in read function
							//strTemp.Format("\t%12.12e",pFtable[i].disch[k]);
							strTemp.Format("\t%.6lf",pFtable[i].disch[k] - (pFtable[i].disch[k] * i / 1.0E12));
							strLine += strTemp;
						}
						strLine += "\n";
						
						fputs(LPCSTR(strLine),fpin);
						break;
					}
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 420: // point source information
		fputs("c420 general point source information\n",fpin);
		fputs("c\n",fpin);
		fputs("c    nPtSource   number of individual point sources\n",fpin);
		fputs("c    nPtQuals    number of point source quals\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c  nPtSource  nPtQuals\n",fpin);
		strLine.Format("\t%d\t%d\n",nPtSource,nPtQuals);
		fputs(LPCSTR(strLine),fpin);
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 425:// point source
 		fputs("c425 point source \n",fpin);
 		fputs("c    Qualindex  point source qual index \n",fpin);
 		fputs("c    Qualname   point source qual name\n",fpin);
 		fputs("c    Qualid	   point source qual id\n",fpin);
 		fputs("c    sqalfr	   point source sediment associated qual fraction (0-1)\n",fpin);
 		fputs("c\n",fpin);
 		WriteCardComments(fpin,nSection);
 		fputs("c  Qualindex  Qualname  qualid\n",fpin);
 		if (nPtQuals > 0)
 		{
			if(pPtQual != NULL)
			{
				for(j=0; j<nPtQuals; ++j)
				{
					pPtQual[j].qualname.Replace(' ','_');
					strLine.Format("\t%d\t%s\t%d\t%lf",pPtQual[j].qualindex,pPtQual[j].qualname,pPtQual[j].qualid,pPtQual[j].sqalfr);
					strLine += "\n";
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 430:// point source withdrawal
 		fputs("c430 point source withdrawal\n",fpin);
 		fputs("c    subbasin  point source reach id\n",fpin);
 		fputs("c    permit    point source permit\n",fpin);
 		fputs("c    pipe      point source pipe\n",fpin);
 		fputs("c    wd_target point source withdrawal target reach id\n",fpin);
 		fputs("c\n",fpin);
 		WriteCardComments(fpin,nSection);
 		fputs("c  subbasin  permit  pipe   wd_target\n",fpin);
 		if (nPtWithDrawal > 0)
 		{
			if(pPtWithDrawal != NULL)
			{
				for(j=0; j<nPtWithDrawal; ++j)
				{
					pPtWithDrawal[j].strPermit.Replace(' ','_');
					pPtWithDrawal[j].strPipe.Replace(' ','_');
					strLine.Format("\t%d\t%s\t%s\t%d",
						pPtWithDrawal[j].wdrawlrchid,
						pPtWithDrawal[j].strPermit,
						pPtWithDrawal[j].strPipe,
						pPtWithDrawal[j].targetrchid);
					strLine += "\n";
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 435: 
		fputs("c435 linkage controls (optional)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid         reach id (same as subbasin id)\n",fpin);
		fputs("c    outlet        outlet control switch for the corresponding reach\n",fpin);
		fputs("c                  0 = will read input timeseries file\n",fpin);
		fputs("c                      (rchid/outlet can be duplicated for multiple input files)\n",fpin);
		fputs("c                  n = will write output timeseries file for outlet n.\n",fpin);
		fputs("c    filepath      the timeseries file path (continuous string without space)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rchid    outlet    filepath\n",fpin);
		if (nLinkFiles > 0)
		{
			for(i=0; i<nch; ++i)
			{
				//write the input timeseries connections
				if(!pChannelInfo[i].cListUpStream.IsEmpty())
				{
					pos = pChannelInfo[i].cListUpStream.GetHeadPosition();
					while (pos != NULL)
					{
						Link435& plink435 = (Link435&) pChannelInfo[i].cListUpStream.GetNext(pos);
						strLine.Format("\t%d\t%d\t%s",
							plink435.nrchid,
							plink435.nOutlet,
							plink435.strFilePath);
							strLine += "\n";
							fputs(LPCSTR(strLine),fpin);
					}
				}

				//write the output timeseries connections
				if(!pChannelInfo[i].cListDownStream.IsEmpty())
				{
					pos = pChannelInfo[i].cListDownStream.GetHeadPosition();
					while (pos != NULL)
					{
						Link435& plink435 = (Link435&) pChannelInfo[i].cListDownStream.GetNext(pos);
						strLine.Format("\t%d\t%d\t%s",
							plink435.nrchid,
							plink435.nOutlet,
							plink435.strFilePath);
							strLine += "\n";
							fputs(LPCSTR(strLine),fpin);
					}
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 440: 
		fputs("c440 sediment parameters controls\n",fpin);
		fputs("c\n",fpin);
		fputs("c    crvfg   if crvfg = 1, erosion-related cover may vary throughout the year.\n",fpin); 
		fputs("c            values are supplied in Table-type MON-COVER (card 453)\n",fpin);
		fputs("c    vsivfg  if vsivfg = 1, the rate of net vertical sediment input may vary throughout the year.\n",fpin); 
		fputs("c            if vsivfg = 2, the vertical sediment input is added to the detached sediment storage only on days when no rainfall occurred during the previous day.\n",fpin); 
		fputs("c            values are supplied in Table-type MON-NVSI (card 454)\n",fpin);
		fputs("c    sandfg  if sandfg = 0, the sand is not simulated.\n",fpin); 
		fputs("c            if sandfg = 1, the sand transport capacity is calculated using the Toffaleti method.\n",fpin);
		fputs("c            if sandfg = 2, the sand transport capacity is calculated using the Colby method.\n",fpin);
		fputs("c            if sandfg = 3, the sand transport capacity is calculated using the power function of velocity.\n",fpin); 
		fputs("c    sweepfg if sweepfg = 0, the street sweeping is not simulated.\n",fpin); 
		fputs("c            if sweepfg = 1, the street sweeping is applied to sediemnt only.\n",fpin);  
		fputs("c            if sweepfg = 2, the street sweeping is applied to sediment and general water quality constituents.\n",fpin);  
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	crvfg    vsivfg    sandfg    sweepfg\n",fpin);
		strLine.Format("\t%d\t%d\t%d\t%d\n",crvfg, vsivfg, sandfg, sweepfg);
		fputs(LPCSTR(strLine),fpin);
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 445:
		fputs("c445 street sweeping for sediment (read if sedfg = 1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid         parameter group id\n",fpin);
		fputs("c    deluid        landuse id (impervious only)\n",fpin);
		fputs("c    deluname      landuse name\n",fpin);
		fputs("c    start_month   start month of street sweeping requirement\n",fpin);
		fputs("c    end_month     end month of street sweeping requirement\n",fpin);
		fputs("c    frequency     days between street sweeping within the landuse (0 for no sweeping)\n",fpin);
		fputs("c    percent_area  fraction of land surface which is available for street sweeping (0 for no sweeping)\n",fpin);
		fputs("c    effic_sand    fraction of sand in solids storage that is available for removal by sweeping (0-1)\n",fpin);
		fputs("c    effic_silt    fraction of silt in solids storage that is available for removal by sweeping (0-1)\n",fpin);
		fputs("c    effic_clay    fraction of clay in solids storage that is available for removal by sweeping (0-1)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid   deluid   deluname   start_month   end_month   frequency   percent_area   effic_sand   effic_silt   effic_clay\n",fpin);
		if(sedfg == 1 && sweepfg != 0)
		{
			for(i=0; i<nlandimp*ngroup; ++i)
			{
				psd_sweep[i].luname.Replace(' ','_');
				strLine.Format("\t%d\t%d\t%s\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\n",
					psd_sweep[i].defid,
					psd_sweep[i].deluid,
					psd_sweep[i].luname,
					psd_sweep[i].start_month,
					psd_sweep[i].end_month,
					psd_sweep[i].frequency,
					psd_sweep[i].percent_area,
					psd_sweep[i].effic_sand,
					psd_sweep[i].effic_silt,
					psd_sweep[i].effic_clay);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 446:
		fputs("c446 street sweeping for GQual (read if sedfg = 1 and pqalfg = 1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid         parameter group id\n",fpin);
		fputs("c    deluid        landuse id (impervious only)\n",fpin);
		fputs("c    deluname      landuse name\n",fpin);
		fputs("c    effic_GQual   fraction of general water quality constituent in surface storage that is available for removal by sweeping (0-1)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid   deluid   deluname   effic_GQual1   effic_GQual2 ... effic_GQualn\n",fpin);
		if(sedfg == 1 && pqalfg == 1 && sweepfg == 2)
		{
			for(i=0; i<nlandimp*ngroup; ++i)
			{
				pGQ_sweep[i].luname.Replace(' ','_');
				strLine.Format("\t%d\t%d\t%s",
					pGQ_sweep[i].defid,
					pGQ_sweep[i].deluid,
					pGQ_sweep[i].luname);
					CString str = "";
					for(j=0; j<nQuals; j++)
					{
						str.Format("\t%lf", pGQ_sweep[i].effic_GQual[j]);
						strLine += str;
					}
					strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 450:
		fputs("c450 sediment parameter group 1 (read if sedfg =1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    smpf    supporting management practice factor\n",fpin);
		fputs("c    krer    coefficient in the soil detachment equation\n",fpin);
		fputs("c    jrer    exponent in the soil detachment equation\n",fpin);
		fputs("c    affix   fraction by which detached sediment storage decreases each day as a result of\n",fpin);
		fputs("c            soil compaction. (/day)\n",fpin);
		fputs("c    cover   fraction of land surface which is shielded from rainfall erosion\n",fpin);
		fputs("c    nvsi    rate at which sediment enters detached storage from the atmosphere (lb/ac/day)\n",fpin);
		fputs("c            negative value may be used to simulate removal by human activity or wind\n",fpin);
		fputs("c    kser    coefficient in the detached sediment washoff equation\n",fpin);
		fputs("c    jser    exponent in the detached sediment washoff equation\n",fpin);
		fputs("c    kger    coefficient in the matrix soil scour equation, which simulates gully erosion\n",fpin);
		fputs("c    jger    exponent in the matrix soil scour equation, which simulates gully erosion\n",fpin);
		fputs("c    accsdp  rate at which solids accumulate on the land surface (used in impervious land)\n",fpin);
		fputs("c    remsdp  fraction of solids storage which is removed each day when there is no runoff,\n",fpin);
		fputs("c            for example, because of street sweeping (used in impervious land)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid  smpf   krer   jrer  affix  cover    nvsi  kser   jser  kger  jger   accsdp remsdp\n",fpin);
		if(sedfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						psd_param1[i].gid,
						psd_param1[i].lid,
						psd_param1[i].smpf_p,
						psd_param1[i].krer_p,
						psd_param1[i].jrer_p,
						psd_param1[i].affix_p,
						psd_param1[i].cover_p,
						psd_param1[i].nvsi_p,
						psd_param1[i].kser_p,
						psd_param1[i].jser_p,
						psd_param1[i].kger_p,
						psd_param1[i].jger_p,
						psd_param1[i].accsdp_p,
						psd_param1[i].remsdp_p);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 451:
		fputs("c451 sediment parameter group 2 (read if sedfg =1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid     parameter group id\n",fpin);
		fputs("c    deluid    landuse id\n",fpin);
		fputs("c    sed-suro  background concentration associated with surface flow (mg/l)\n",fpin);
		fputs("c    sed-ifwo  background concentration associated with interflow outflow (mg/l)\n",fpin);
		fputs("c    sed-agwo  background concentration associated with groundwater outflow (mg/l)\n",fpin);
		fputs("c    sed_i     fraction of sediment class_i (sand, silt, and clay)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    (sand + silt + clay = 1)\n",fpin);
		fputs("c    Background sediment load is added to total sediment from LAND prior to applying fractions\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid   deluid    sed_suro   sed_ifwo   sed_agwo   sed_1   sed_2   sed_3 ........sed_n\n",fpin);
		if(sedfg == 1)
		{
			for(i=0; i<nlandp*ngroup; ++i)
			{
				strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf",
					psd_param2[i].gid,
					psd_param2[i].lid,
					psd_param2[i].sed_suro,
					psd_param2[i].sed_ifwo,
					psd_param2[i].sed_agwo);
				CString str = "";
				for(j=0; j<NumSed; j++)
				{
					str.Format("\t%lf", psd_param2[i].sed[j]);
					strLine += str;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 452:
		fputs("c452 GQUAL-sediment to stream mapping (read if sediment as gqual)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    lutype  landuse type flow id (1 = impervious surfaceflow, \n",fpin);
		fputs("c            2 = pervious surfaceflow, 3 = pervious interflow, 4 = pervious groundflow)\n",fpin);
		fputs("c    sed_i   fraction of sediment class_i (sand, silt, and clay)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid dwqid    lutype   sed_1   sed_2   sed_3 ........sed_n\n",fpin);
		if(sedfg == 1 && pqalfg == 1 && gqsdfg == 1 && sed_mapp != NULL)
		{
			if(nQuals > 0 && ngroup > 0)
			{
				for(i = 0; i< ngroup*4; ++i)
				{
					strLine.Format("\t%d\t%d\t%d",
						sed_mapp[i].gid,
						sed_mapp[i].qualid,
						sed_mapp[i].lutype);
					CString str = "";
					for(j=0; j<NumSed; j++)
					{
						str.Format("\t%lf", sed_mapp[i].sed[j]);
						strLine += str;
					}
					strLine += "\n";
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 453:		
		fputs("c453 monthly erosion-related cover values\n",fpin);
		fputs("c    only required if crvfg = 1 (see card 440)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec erosion-related cover values at start of each month\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(sedfg ==1 && crvfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						pCRVm[i].gid,
						pCRVm[i].lid,
						pCRVm[i].fnum[0],
						pCRVm[i].fnum[1],
						pCRVm[i].fnum[2],
						pCRVm[i].fnum[3],
						pCRVm[i].fnum[4],
						pCRVm[i].fnum[5],
						pCRVm[i].fnum[6],
						pCRVm[i].fnum[7],
						pCRVm[i].fnum[8],
						pCRVm[i].fnum[9],
						pCRVm[i].fnum[10],
						pCRVm[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 454:		
		fputs("c454 monthly net vertical sediment input\n",fpin);
		fputs("c    only required if vsivfg = 1 (see card 440)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec net vertical sediment input at start of each month (lb/acre/day)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(sedfg ==1 && vsivfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						pVSIVm[i].gid,
						pVSIVm[i].lid,
						pVSIVm[i].fnum[0],
						pVSIVm[i].fnum[1],
						pVSIVm[i].fnum[2],
						pVSIVm[i].fnum[3],
						pVSIVm[i].fnum[4],
						pVSIVm[i].fnum[5],
						pVSIVm[i].fnum[6],
						pVSIVm[i].fnum[7],
						pVSIVm[i].fnum[8],
						pVSIVm[i].fnum[9],
						pVSIVm[i].fnum[10],
						pVSIVm[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 455:
		fputs("c455 sediment general parameters group 3 (read if sedfg = 1)\n",fpin);
		fputs("c    general sediment related parameters for instream transport\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid     stream parameter group id\n",fpin);
		fputs("c    bedwid   bed width (ft) - this is constant for the entire simulation period\n",fpin);
		fputs("c    beddep   initial bed depth (ft)\n",fpin);
		fputs("c    por      porosity\n",fpin);
		fputs("c    burial   burial rate of aggregated sediment layer (in/day)\n",fpin);
		fputs("c             if burial = 0 then burial rate in card 456 is used\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c\n",fpin);
		fputs("c	rgid  bedwid  beddep  por  burial\n",fpin);
		if(sedfg == 1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\n",
						rsd_genparam[i].gid,
						rsd_genparam[i].bedwid,
						rsd_genparam[i].beddep,
						rsd_genparam[i].por,
						rsd_genparam[i].burial);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 456:
		fputs("c456 sediment parameters group 4 (read if sedfg = 1)\n",fpin);
		fputs("c    cohesive suspended sediment variables for instream transport\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid           stream parameter group id\n",fpin);
		fputs("c    sed_id         sediment class id\n",fpin);
		fputs("c    sedflg         sediment flag indicating sediment class (0 for sand, 1 for silt, and 2 for clay)\n",fpin);
		fputs("c    sedo           initial sediment conc in fluid phase (mg/liter)\n",fpin);
		fputs("c    sedfrac        initial sediment fractions (by weight) in the bed material\n",fpin);
		fputs("c    db50/d         median diameter of the non-cohesive sediment (sand) (in) (sandfg = 1 or 2)\n",fpin); 
		fputs("c                   / effective diameter of the cohesive particles (silt and clay) (in)\n",fpin);
		fputs("c    w              corresponding fall velocity of the particle in still water (in/s)\n",fpin);
		fputs("c    rho            density of the particles (gm/cm^3)\n",fpin);
		fputs("c    ksand/taucd    coefficient in the sandload power function formula (sandfg = 3)\n",fpin); 
		fputs("c                   / critical bed shear stress for deposition of the cohesive particle - generally taucd <= taucs (lb/ft^2)\n",fpin);
		fputs("c                   if tau > taucd then no deposition\n",fpin);
		fputs("c                   if tau < taucd then deposition rate approaches settling velocity, w\n",fpin);
		fputs("c    expsnd/taucs   exponent in the sandload power function formula (sandfg = 3)\n",fpin);
		fputs("c                   / critical bed shear stress for scour of the cohesive particle (lb/ft^2)\n",fpin);
		fputs("c                   if tau < taucs then no scour\n",fpin);
		fputs("c                   if tau > taucs then scour steadily increases\n",fpin);
		fputs("c    m              erodibility coefficient of the cohesive particle (lb/ft^2/day)\n",fpin);
		fputs("c    burial         burial rate of the sediment particle (in/day)\n",fpin);
		fputs("c                   it is used if burial rate in card 455 is zero\n",fpin);
		fputs("c\n",fpin);      
		WriteCardComments(fpin,nSection);
		fputs("c\n",fpin);
		fputs("c	rgid  sed_id  sedflg	sedo  sedfrac  db50/d   w  rho  ksand/taucd  expsnd/taucs  m   burial\n",fpin);
		if(sedfg == 1)
		{
			if(nrgroup > 0 && NumSed > 0)
			{
				for(i=0; i<nrgroup*NumSed; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						rsd_param[i].gid,
						rsd_param[i].sed_id,
						rsd_param[i].sedflg,
						rsd_param[i].sedo,
						rsd_param[i].sedfrac,
						rsd_param[i].d,
						rsd_param[i].w,
						rsd_param[i].rho,
						rsd_param[i].taucd,
						rsd_param[i].taucs,
						rsd_param[i].m,
						rsd_param[i].burial);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 457:
		fputs("c457 Streambank erosion sediment parameters (read if sedfg = 1 and sedber = 1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid   reach id\n",fpin);
		fputs("c    kber    coefficient for scour of the bank matrix soil (calibration)\n",fpin);
		fputs("c    jber    exponent for scour of the bank matrix soil (calibration)\n",fpin);
		fputs("c    qber    bank erosion flow threshold causing channel bank soil erosion (cfs)\n",fpin);
		fputs("c            if = negative then threshold flow is at the bank full depth (cfs)\n",fpin);
		fputs("c    sed_i   fraction of sediment class_i (sand, silt, and clay)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rchid    kber    jber    qber   sed_1   sed_2   sed_3 ....sed_n\n",fpin);
		if(sedfg == 1 && sedber == 1)
		{
			for(i=0; i<nch; ++i)
			{
				if (rsd_berparam[i].qber < 0 && q_bfd != NULL)
					rsd_berparam[i].qber = q_bfd[i];

				strLine.Format("\t%d\t%12.12e\t%lf\t%lf",
					rsd_berparam[i].rchid,
					rsd_berparam[i].kber,
					rsd_berparam[i].jber,
					rsd_berparam[i].qber);
				CString str = "";
				for(j=0; j<NumSed; j++)
				{
					str.Format("\t%lf", rsd_berparam[i].sed[j]);
					strLine += str;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 460:
		fputs("c460 soil temperature control   (read if tempfg = 1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    msltfg  if = 1 monthly vary aslt and bslt parameters in surface flow temperature calculation\n",fpin);
		fputs("c    miftfg  if = 1 monthly vary aift and bift parameters in interflow temperature calculation\n",fpin);
		fputs("c    mgwtfg  if = 1 monthly vary agwt and bgwt parameters in ground water temperature calculation\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	msltfg     miftfg      mgwtfg\n",fpin);
		if(tempfg == 1)
		{
			strLine.Format("\t%d\t%d\t%d\n",msltfg, miftfg, mgwtfg);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 461:
		fputs("c461 Soil Temperature   (read if tempfg =1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    tsopfg  if = 0 compute subsurface temperatures using a mean departure from air temperature plus a smoothing factor\n",fpin);
		fputs("c            if = 1 compute subsurface temperature using regression\n",fpin);
		fputs("c            if = 2 the lower/gw layer temperature is a function of upper layer temperature instead of air temperature\n",fpin);
		fputs("c    aslt    surface layer temperature when the air temperature 0 degrees C\n",fpin);
		fputs("c    bslt    slope of the surface layer temperature regression equation\n",fpin);
		fputs("c    aift    mean difference between interflow temperature and air temperature (C)\n",fpin);
		fputs("c    bift    smoothing factor in the interflow temperature calculation\n",fpin);
		fputs("c    agwt    mean difference between groundwater temperature and air temperature (C)\n",fpin);
		fputs("c    bgwt    smoothing factor in the groundwater temperature calculation\n",fpin);
		fputs("c    islt    initial surface flow temperature (C)\n",fpin);
		fputs("c    iift    initial interflow temperature (C)\n",fpin);
		fputs("c    igwt    initial groundwater temperature (C)\n",fpin);
		fputs("c\n",fpin);
		fputs("c            y = a + b * x\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   tsopfg    aslt     bslt     aift     bift     agwt   bgwt  islt   iift   igwt\n",fpin);
		if(tempfg ==1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						pstmp_parm1[i].gid,
						pstmp_parm1[i].lid,
						pstmp_parm1[i].tsopfg,
						pstmp_parm1[i].aslt,
						pstmp_parm1[i].bslt,
						pstmp_parm1[i].aift,
						pstmp_parm1[i].bift,
						pstmp_parm1[i].agwt,
						pstmp_parm1[i].bgwt,
						pstmp_parm1[i].islt,
						pstmp_parm1[i].iift,
						pstmp_parm1[i].igwt);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 462:		
		fputs("c462 mon-aslt \n",fpin);
		fputs("c    only required if tempfg = 1 and msltfg = 1 (see card 460)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec surface layer temperature when the air temperature 0 degrees C at start of each month (C)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(tempfg == 1 && msltfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						asltm[i].gid,
						asltm[i].lid,
						asltm[i].fnum[0],
						asltm[i].fnum[1],
						asltm[i].fnum[2],
						asltm[i].fnum[3],
						asltm[i].fnum[4],
						asltm[i].fnum[5],
						asltm[i].fnum[6],
						asltm[i].fnum[7],
						asltm[i].fnum[8],
						asltm[i].fnum[9],
						asltm[i].fnum[10],
						asltm[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 463:		
		fputs("c463 mon-bslt \n",fpin);
		fputs("c    only required if tempfg = 1 and msltfg = 1 (see card 460)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec slope of the surface layer temperature regression equation at start of each month\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(tempfg == 1 && msltfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						bsltm[i].gid,
						bsltm[i].lid,
						bsltm[i].fnum[0],
						bsltm[i].fnum[1],
						bsltm[i].fnum[2],
						bsltm[i].fnum[3],
						bsltm[i].fnum[4],
						bsltm[i].fnum[5],
						bsltm[i].fnum[6],
						bsltm[i].fnum[7],
						bsltm[i].fnum[8],
						bsltm[i].fnum[9],
						bsltm[i].fnum[10],
						bsltm[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 464:		
		fputs("c464 mon-aift \n",fpin);
		fputs("c    only required if tempfg = 1 and miftfg = 1 (see card 460)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec mean difference between interflow temperature and air temperature at start of each month (C)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(tempfg == 1 && miftfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						aiftm[i].gid,
						aiftm[i].lid,
						aiftm[i].fnum[0],
						aiftm[i].fnum[1],
						aiftm[i].fnum[2],
						aiftm[i].fnum[3],
						aiftm[i].fnum[4],
						aiftm[i].fnum[5],
						aiftm[i].fnum[6],
						aiftm[i].fnum[7],
						aiftm[i].fnum[8],
						aiftm[i].fnum[9],
						aiftm[i].fnum[10],
						aiftm[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 465:		
		fputs("c465 mon-bift \n",fpin);
		fputs("c    only required if tempfg = 1 and miftfg = 1 (see card 460)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec smoothing factor in the interflow temperature calculation at start of each month\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(tempfg == 1 && miftfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						biftm[i].gid,
						biftm[i].lid,
						biftm[i].fnum[0],
						biftm[i].fnum[1],
						biftm[i].fnum[2],
						biftm[i].fnum[3],
						biftm[i].fnum[4],
						biftm[i].fnum[5],
						biftm[i].fnum[6],
						biftm[i].fnum[7],
						biftm[i].fnum[8],
						biftm[i].fnum[9],
						biftm[i].fnum[10],
						biftm[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 466:		
		fputs("c466 mon-agwt \n",fpin);
		fputs("c    only required if tempfg = 1 and mgwtfg = 1 (see card 460)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec mean difference between groundwater temperature and air temperature at start of each month (C)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(tempfg == 1 && mgwtfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						agwtm[i].gid,
						agwtm[i].lid,
						agwtm[i].fnum[0],
						agwtm[i].fnum[1],
						agwtm[i].fnum[2],
						agwtm[i].fnum[3],
						agwtm[i].fnum[4],
						agwtm[i].fnum[5],
						agwtm[i].fnum[6],
						agwtm[i].fnum[7],
						agwtm[i].fnum[8],
						agwtm[i].fnum[9],
						agwtm[i].fnum[10],
						agwtm[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 467:		
		fputs("c467 mon-bgwt \n",fpin);
		fputs("c    only required if tempfg = 1 and mgwtfg = 1 (see card 460)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec smoothing factor in the groundwater temperature calculation at start of each month\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(tempfg == 1 && mgwtfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						bgwtm[i].gid,
						bgwtm[i].lid,
						bgwtm[i].fnum[0],
						bgwtm[i].fnum[1],
						bgwtm[i].fnum[2],
						bgwtm[i].fnum[3],
						bgwtm[i].fnum[4],
						bgwtm[i].fnum[5],
						bgwtm[i].fnum[6],
						bgwtm[i].fnum[7],
						bgwtm[i].fnum[8],
						bgwtm[i].fnum[9],
						bgwtm[i].fnum[10],
						bgwtm[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 470:
		fputs("c470 Temperature Parameters for Land Groups  (read if tempfg =1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    subbasin    subbasin id\n",fpin);
		fputs("c    melev	    the mean watershed elevation (ft)\n",fpin);
		fputs("c    eldat       difference in elevation between watershed and the air temperature gage (ft)\n",fpin);
		fputs("c    rmelev      the mean RCHRES elevation (ft)\n",fpin);
		fputs("c    reldat      difference in elevation between the RCHRES and the air temperature gage (ft)\n",fpin);
		fputs("c                (positive if RCHRES is higher than the gage).\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	subbasin   melev     eldat   rmelev     reldat\n",fpin);
		if(tempfg == 1 && nsws > 0)
		{
			for(i = 0; i < nsws; ++i)
			{
				strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\n",
					ptmp_param1[i].subbasin,
					ptmp_param1[i].elev,
					ptmp_param1[i].eldat,
					ptmp_param1[i].relev,
					ptmp_param1[i].reldat);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 474:
		fputs("c474 24-hourly dry lapse rates (read if tempfg = 1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    12AM-11PM  lapse_rate - dry period lapse rate varying between 0.0035 to 0.005 (degree F/ft)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c  	12AM   1AM   2AM   3AM   4AM   5AM   6AM   7AM   8AM   9AM   10AM   11AM	12PM   1PM   2PM   3PM   4PM   5PM   6PM   7PM   8PM   9PM   10PM   11PM\n",fpin);
		if(tempfg == 1)
		{
			strLine.Format("\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
				lapse[0],
				lapse[1],
				lapse[2],
				lapse[3],
				lapse[4],
				lapse[5],
				lapse[6],
				lapse[7],
				lapse[8],
				lapse[9],
				lapse[10],
				lapse[11],
				lapse[12],
				lapse[13],
				lapse[14],
				lapse[15],
				lapse[16],
				lapse[17],
				lapse[18],
				lapse[19],
				lapse[20],
				lapse[21],
				lapse[22],
				lapse[23]);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 475:
		fputs("c475 Temperature Parameters for Stream Groups  (read if tempfg =1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameters group id\n",fpin);
		fputs("c    cfsaex  correction factor for solar radiation; fraction of RCHRES surface exposed to radiation\n",fpin);
		fputs("c    katrad  longwave radiation coefficient\n",fpin);
		fputs("c    kcond   conduction-convection heat transport coefficient\n",fpin);
		fputs("c    kevap   evaporation coefficient\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   cfsaex    katrad     kcond     kevap\n",fpin);
		if(tempfg == 1 && nrgroup > 0)
		{
			for(i = 0; i < nrgroup; ++i)
			{
				strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\n",
					ptmps_param1[i].gid,
					ptmps_param1[i].cfsaex_p,
					ptmps_param1[i].katrad_p,
					ptmps_param1[i].kcond_p,
					ptmps_param1[i].kevap_p);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 480:
		fputs("c480 Bed Heat Conduction Parameters for Stream Groups  (read if tempfg=1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameters group id\n",fpin);
		fputs("c    preflg  flag for heat transfer rates for water surface (0 = off)\n",fpin);
		fputs("c    bedflg  bed conduction flag\n",fpin);
		fputs("c            0 - bed conduction is not simulated\n",fpin);
		fputs("c            1 - single interface (water-mud) heat transfer method\n",fpin);
		fputs("c            2 - two-interface (water-mud and mud-ground) heat transfer method\n",fpin);
		fputs("c            3 - Jobson method (not supported)\n",fpin);
		fputs("c    tgflg   source of the ground temperature for the bed conduction (used when bedflg is 1 or 2)\n",fpin);
		fputs("c            1 - time series (not supported)\n",fpin);
		fputs("c            2 - single value\n",fpin);
		fputs("c            3 - monthly values (card 485)\n",fpin);
		fputs("c    muddep  depth of the mud layer in the two-interface model (bedflg = 2) (m)\n",fpin);
		fputs("c    tgrnd   constant (tgflg = 2) ground temperature (bedflg = 1 or 2) (degree C)\n",fpin);
		fputs("c    kmud    heat conduction coefficient between water and the mud/ground (bedflg = 1 or 2) (kcal/m2/degC/hr)\n",fpin);
		fputs("c    kgrnd   heat conduction coefficient between ground and mud in the two-interface model (bedflg = 2) (kcal/m2/degC/hr)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   preflg   bedflg   tgflg   muddep   tgrnd   kmud   kgrnd\n",fpin);
		if(tempfg == 1)
		{
			for(i=0; i<nrgroup; ++i)
			{
				strLine.Format("\t%d\t%d\t%d\t%d\t%lf\t%lf\t%lf\t%lf\n",
					ptmps_param2[i].rgid,
					ptmps_param2[i].preflg,
					ptmps_param2[i].bedflg,
					ptmps_param2[i].tgflg,
					ptmps_param2[i].muddep,
					ptmps_param2[i].tgrnd,
					ptmps_param2[i].kmud,
					ptmps_param2[i].kgrnd);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 485:		
		fputs("c485 monthly ground temperatures for bed heat conduction algorithms\n",fpin);
		fputs("c    only required if tgflg = 3 (see card 480)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid     stream parameter group id\n",fpin);
		fputs("c    jan-dec  tgrndm - monthly ground temperatures for use in the bed heat conduction models (degree C)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c  rgid	jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(tempfg == 1 && bedflg == true && mtgflg == true)
		{
			for(i=0; i<nrgroup; ++i)
			{
				strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
					ptmps_mon[i].rgid,
					ptmps_mon[i].fnum[0],
					ptmps_mon[i].fnum[1],
					ptmps_mon[i].fnum[2],
					ptmps_mon[i].fnum[3],
					ptmps_mon[i].fnum[4],
					ptmps_mon[i].fnum[5],
					ptmps_mon[i].fnum[6],
					ptmps_mon[i].fnum[7],
					ptmps_mon[i].fnum[8],
					ptmps_mon[i].fnum[9],
					ptmps_mon[i].fnum[10],
					ptmps_mon[i].fnum[11]
					);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 500:
		fputs("c500 land to stream mapping (read if oxfg =1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameters group id\n",fpin);
		fputs("c    dwqid   general quality id\n",fpin);
		fputs("c    lutype  landuse type flow id (1 = impervious surfaceflow, \n",fpin);
		fputs("c            2 = pervious surfaceflow, 3 = pervious interflow, 4 = pervious groundflow)\n",fpin);
		fputs("c    bod     bod fraction in pqual\n",fpin);
		fputs("c    nox     nitrate fraction in pqual\n",fpin);
		fputs("c    tam     total ammonia fraction in  pqual\n",fpin);
		fputs("c    snh4    particulate NH4-N fraction in pqual\n",fpin);
		fputs("c    po4     ortho-phosphorus fraction in pqual\n",fpin);
		fputs("c    spo4    particulate PO4-P fraction in pqual\n",fpin);
		fputs("c    orn     organic-nitrogen fraction in pqual\n",fpin);
		fputs("c    orp     organic-phosphorus fraction in pqual\n",fpin);
		fputs("c    orc     organic-carbon fraction in pqual\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   dwqid    lutype   bod   nox   tam   snh4   po4   spo4   orn   orp   orc\n",fpin);
		if(oxfg == 1)
		{
			if(nQuals > 0 && nrgroup > 0)
			{
				for(i = 0; i< nQuals*nrgroup*4; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						land_mapp[i].gid,
						land_mapp[i].qualid,
						land_mapp[i].lutype,
						land_mapp[i].bod,
						land_mapp[i].nox,
						land_mapp[i].tam,
						land_mapp[i].snh4,
						land_mapp[i].po4,
						land_mapp[i].spo4,
						land_mapp[i].orn,
						land_mapp[i].orp,
						land_mapp[i].orc);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 501:
		fputs("c501 atmosphere to stream mapping\n",fpin);
		fputs("c\n",fpin);
		fputs("c    only required if adfgrch = 1 (see card 280)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameter group ID\n",fpin);
		fputs("c    dwqid   general quality ID\n",fpin);
		fputs("c    bod     bod fraction in PQUAL\n",fpin);
		fputs("c    nox     nitrate fraction in PQUAL\n",fpin);
		fputs("c    tam     total ammonia fraction in PQUAL\n",fpin);
		fputs("c    po4     orthophosphate fraction in PQUAL\n",fpin);
		fputs("c    orn     organic-nitrogen fraction in PQUAL\n",fpin);
		fputs("c    orp     organic-phosphorus fraction in PQUAL\n",fpin);
		fputs("c    orc     organic-carbon fraction in PQUAL\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid  dwqid  bod  nox  tam  po4  orn  orp  orc\n",fpin);
		if(oxfg == 1 && adfgrch == 1)
		{
			for(i=0; i<nQuals*nrgroup; ++i)
			{
				strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
					atms_mapp[i].gid,
					atms_mapp[i].qualid,
					atms_mapp[i].bod,
					atms_mapp[i].nox,
					atms_mapp[i].tam,
					atms_mapp[i].po4,
					atms_mapp[i].orn,
					atms_mapp[i].orp,
					atms_mapp[i].orc);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 502:		
		fputs("c502 gases control   (read if oxfg =1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    midofg  if = 1 monthly very DO concentration in interflow\n",fpin);
		fputs("c    mico2fg if = 1 monthly very CO2 concentration in interflow\n",fpin);
		fputs("c    madofg  if = 1 monthly very DO concentration in ground water\n",fpin);
		fputs("c    maco2fg if = 1 monthly very CO2 concentration in ground water\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	midofg     mico2fg      madofg      maco2fg\n",fpin);
		if(oxfg == 1)
		{
			strLine.Format("\t%d\t%d\t%d\t%d\n",midofg, mico2fg, madofg,maco2fg);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 503:		
		fputs("c503   DO-CO2 Control constant values (read if oxfg =1)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    sdoxp   concentration of dissolved oxygen in surface flow (mg/l)\n",fpin);
		fputs("c    sco2p   concentration of dissolved CO2 in surface flow (mg/l)\n",fpin);
		fputs("c    idoxp   concentration of dissolved oxygen in interflow outflow (mg/l)\n",fpin);
		fputs("c    ico2p   concentration of dissolved CO2 in interflow outflow (mg/l)\n",fpin);
		fputs("c    adoxp   concentration of dissolved oxygen in active groundwater outflow (mg/l)\n",fpin);
		fputs("c    aco2p   concentration of dissolved CO2 in active groundwater outflow (mg/l)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   sdoxp    sco2p     idoxp    ico2p     adoxp    aco2p\n",fpin);
		if(oxfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						doco_parm1[i].gid,
						doco_parm1[i].lid,
						doco_parm1[i].sdoxp,
						doco_parm1[i].sco2p,
						doco_parm1[i].idoxp,
						doco_parm1[i].ico2p,
						doco_parm1[i].adoxp,
						doco_parm1[i].aco2p);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 504:		// replaced card 500
		fputs("c504 mon-DO (interflow)  mg C/l\n",fpin);
		fputs("c    only required if oxfg = 1 and midofg = 1 (see card 502)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec interflow dissolved oxygen concentration at start of each month (mg/l)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(oxfg == 1 && midofg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						idoconc[i].gid,
						idoconc[i].lid,
						idoconc[i].fnum[0],
						idoconc[i].fnum[1],
						idoconc[i].fnum[2],
						idoconc[i].fnum[3],
						idoconc[i].fnum[4],
						idoconc[i].fnum[5],
						idoconc[i].fnum[6],
						idoconc[i].fnum[7],
						idoconc[i].fnum[8],
						idoconc[i].fnum[9],
						idoconc[i].fnum[10],
						idoconc[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 505:		
		fputs("c505 mon-DO (groundwater)\n",fpin);
		fputs("c    only required if oxfg = 1 and madofg = 1 (see card 502)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec groundwater dissolved oxygen concentration at start of each month (mg/l)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(oxfg == 1 && madofg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						adoconc[i].gid,
						adoconc[i].lid,
						adoconc[i].fnum[0],
						adoconc[i].fnum[1],
						adoconc[i].fnum[2],
						adoconc[i].fnum[3],
						adoconc[i].fnum[4],
						adoconc[i].fnum[5],
						adoconc[i].fnum[6],
						adoconc[i].fnum[7],
						adoconc[i].fnum[8],
						adoconc[i].fnum[9],
						adoconc[i].fnum[10],
						adoconc[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 506:		// replaced card 520
		fputs("c506 mon-CO2 (interflow)  mg C/l\n",fpin);
		fputs("c    only required if oxfg = 1 and mico2fg = 1 (see card 502)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec interflow carbon dioxide concentration at start of each month (mg/l)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(mico2fg  == 1 && oxfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						ico2conc[i].gid,
						ico2conc[i].lid,
						ico2conc[i].fnum[0],
						ico2conc[i].fnum[1],
						ico2conc[i].fnum[2],
						ico2conc[i].fnum[3],
						ico2conc[i].fnum[4],
						ico2conc[i].fnum[5],
						ico2conc[i].fnum[6],
						ico2conc[i].fnum[7],
						ico2conc[i].fnum[8],
						ico2conc[i].fnum[9],
						ico2conc[i].fnum[10],
						ico2conc[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 507:		// replaced card 530
		fputs("c507 mon-CO2 (groundwater)\n",fpin);
		fputs("c    only required if oxfg = 1 and maco2fg = 1 (see card 502)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    defid   parameter group id\n",fpin);
		fputs("c    deluid  landuse id\n",fpin);
		fputs("c    jan-dec groundwater carbon dioxide concentration at start of each month (mg/l)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	defid deluid   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(maco2fg  == 1 && oxfg == 1)
		{
			if(nlandp > 0 && ngroup > 0)
			{
				for(i = 0; i< nlandp*ngroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						aco2conc[i].gid,
						aco2conc[i].lid,
						aco2conc[i].fnum[0],
						aco2conc[i].fnum[1],
						aco2conc[i].fnum[2],
						aco2conc[i].fnum[3],
						aco2conc[i].fnum[4],
						aco2conc[i].fnum[5],
						aco2conc[i].fnum[6],
						aco2conc[i].fnum[7],
						aco2conc[i].fnum[8],
						aco2conc[i].fnum[9],
						aco2conc[i].fnum[10],
						aco2conc[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 510:		
		fputs("c510 DO/BOD control   \n",fpin);
		fputs("c\n",fpin);
		fputs("c    benrfg   benthic release flag (for benthic related parameters)\n",fpin);
		fputs("c    reamfg reaeration flag (indicates the method used to calculate the reaeration coefficient for free-flowing streams)\n",fpin);
		fputs("c    if = 1 then Tsivoglou method is used\n",fpin);
		fputs("c    if = 2 then Owens, Churchill, or O'Connor-Dobbins method is used depending on velocity and depth of water\n",fpin);
		fputs("c    if = 3 then Coefficient is calculated as a power function of velocity and/or depth\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	benrfg     reamfg\n",fpin);
		if(oxfg ==1)
		{
			strLine.Format("\t%d\t%d\n",benrfg, reamfg);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 511:		
		fputs("c511 ox-parm1\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameter group id\n",fpin);
		fputs("c    kbod20  bod decay rate at 20oC (1/hr)\n",fpin);
		fputs("c    tcbod   temperature adjustment coefficient for bod decay\n",fpin);
		fputs("c    kodset  bod settling rate (m/hr)\n",fpin);
		fputs("c    supsat  maximum allowable dissolved oxygen supersaturation (expressed as a multiple of the dissolved oxygen saturation concentration)\n",fpin);
		fputs("c    tcginv  temperature correction coefficient for surface gas invasion\n",fpin);
		fputs("c    reak    empirical constant in the equation\n",fpin);
		fputs("c            if reamfg = 1 then it is an escape coefficient (1/ft)\n",fpin);
		fputs("c            if reamfg = 3 then it is used to calculate the reaeration coefficient (1/hr)\n",fpin);
		fputs("c    expred  exponent to depth in the reaeration coefficient equation (for reamfg = 3)\n",fpin);
		fputs("c    exprev  exponent to velocity in the reaeration coefficient equation (for reamfg = 3)\n",fpin);
		fputs("c    cforea  correction factor in the lake reaeration equation; it accounts for good or poor circulation characteristics\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   kbod20   tcbod   kodset   supsat   tcginv   reak   expred   exprev   cforea\n",fpin);
		if(oxfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						ox_parm1[i].gid,
						ox_parm1[i].kbod20,
						ox_parm1[i].tcbod,
						ox_parm1[i].kodset,
						ox_parm1[i].supsat,
						ox_parm1[i].tcginv,
						ox_parm1[i].reak,
						ox_parm1[i].expred,
						ox_parm1[i].exprev,
						ox_parm1[i].cforea);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 512:		
		fputs("c512 ox-parm2\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid       stream parameter group id\n",fpin);
		fputs("c    benod      benthal oxygen demand at 20 degrees C (with unlimited DO concentration) (mg/m2/hr)\n",fpin);
		fputs("c    tcben      temperature correction coefficient for benthal oxygen demand\n",fpin);
		fputs("c    expod      exponential factor in the dissolved oxygen term of the benthal oxygen demand equation\n",fpin);
		fputs("c    brbod      benthal release rate of BOD under aerobic conditions.(mg/m2/hr)\n",fpin);
		fputs("c    brbod_inc  increment to benthal release of BOD under anaerobic conditions. (mg/m2/hr)\n",fpin);
		fputs("c    expre1     the exponent in the DO term of the benthal BOD release equation\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   benod   tcben   expod   brbod   brbod_inc   exprel\n",fpin);
		if(oxfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						ox_parm2[i].gid,
						ox_parm2[i].benod,
						ox_parm2[i].tcben,
						ox_parm2[i].expod,
						ox_parm2[i].brbod,
						ox_parm2[i].brbod_inc,
						ox_parm2[i].exprel);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 513:		
		fputs("c513 oxrx-initial conditions\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid   stream parameter group id\n",fpin);
		fputs("c    dox    DO initial condition. (mg/l)\n",fpin);
		fputs("c    bod    BOD initial condition in water column. (mg/l)\n",fpin);
		fputs("c    satdo  Initial DO saturation concentration. (mg/l)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   dox   bod   satdo\n",fpin);
		if(oxfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\n",
						oxrx_init[i].gid,
						oxrx_init[i].dox,
						oxrx_init[i].bod,
						oxrx_init[i].satdo);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 514:		
		fputs("c514 ox-scour parms\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid   stream parameter group id\n",fpin);
		fputs("c    scrvel threshold velocity above which the effect of scouring on benthal release rates is considered. (m/s)\n",fpin);
		fputs("c    scrmul multiplier by which benthal releases are increased during scouring.\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   scrvel   scrmul\n",fpin);
		if(oxfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\n",
						scour_parms[i].gid,
						scour_parms[i].scrvel,
						scour_parms[i].scrmul);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 520:		
		fputs("c520 nutrients control   \n",fpin);
		fputs("c\n",fpin);
		fputs("c    tamfg    total ammonia flag\n",fpin);
		fputs("c    no2fg    nitrite flag\n",fpin);
		fputs("c    po4fg    ortho-phosphorus flag\n",fpin);
		fputs("c    amvfg    ammonia volatilization flag\n",fpin);
		fputs("c    denfg    denitrification flag\n",fpin);
		fputs("c    adnhfg   NH4 adsorption flag\n",fpin);
		fputs("c    adpofg   PO4 adsorption flag\n",fpin);
		fputs("c    mphfg    monthly pH flag (not supported in this version)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	tamfg   no2fg   po4fg   amvfg   denfg   adnhfg   adpofg   mphfg\n",fpin);
		if(nutfg ==1)
		{
			strLine.Format("\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",tamfg, no2fg, po4fg, amvfg, denfg, adnhfg, adpofg, mphfg);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 521:		
		fputs("c521 nut-parm1\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameter group id\n",fpin);
		fputs("c    cvbo    conversion from milligrams biomass to milligrams oxygen (mg/mg)\n",fpin);
		fputs("c    cvbpc   conversion from biomass expressed as phosphorus to carbon (mols/mol)\n",fpin);
		fputs("c    cvbpn   conversion from biomass expressed as phosphorus to nitrogen (mols/mol)\n",fpin);
		fputs("c    bpcntc  percentage of biomass which is carbon (by weight)\n",fpin);
		fputs("c    ktam20  nitrification rate of ammonia at 20 degrees C (1/hr)\n",fpin);
		fputs("c    kno220  nitrification rate of nitrite at 20 degrees C (1/hr)\n",fpin);
		fputs("c    tcnit   temperature correction coefficient for nitrification\n",fpin);
		fputs("c    kno320  nitrate denitrification rate at 20 degrees C (1/hr)\n",fpin);
		fputs("c    tcden   temperature correction coefficient for denitrification\n",fpin);
		fputs("c    denoxt  dissolved oxygen concentration threshold for denitrification (mg/l)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   cvbo   cvbpc   cvbpn  bpcntc   ktam20  kno220  tcnit  kno320  tcden  denoxt\n",fpin);
		if(nutfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						nut_parm1[i].gid,
						nut_parm1[i].cvbo,
						nut_parm1[i].cvbpc,
						nut_parm1[i].cvbpn,
						nut_parm1[i].bpcntc,
						nut_parm1[i].ktam20,
						nut_parm1[i].kno220,
						nut_parm1[i].tcnit,
						nut_parm1[i].kno320,
						nut_parm1[i].tcden,
						nut_parm1[i].denoxt);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 522:		
		fputs("c522 nut-parm2\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid         stream parameter group id\n",fpin);
		fputs("c    brtam_1      benthal release rate of ammonia under aerobic condition (mg/m2/hr)\n",fpin);
		fputs("c    brtam_2      benthal release rates of ammonia under anaerobic conditions (mg/m2/hr)\n",fpin);
		fputs("c    brpo4_1      benthal release rate of ortho-phosphorus under aerobic condition (mg/m2/hr)\n",fpin);
		fputs("c    brpo4_2      benthal release rate of ortho-phosphorus under anaerobic condition (mg/m2/hr)\n",fpin);
		fputs("c    bnh4(1-3)    constant bed concentrations of ammonia-N adsorbed to sand, silt, and clay (mg/kg)\n",fpin);
		fputs("c    bpo4(1-3)    constant bed concentrations of ortho-phosphorus-P adsorbed to sand, silt, and clay (mg/kg)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   brtam_1   brtam_2   brpo4_1   brpo4_2   bnh4_1   bnh4_2   bnh4_3    bpo4_1   bpo4_2   bpo4_3\n",fpin);
		if(nutfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						nut_parm2[i].gid,
						nut_parm2[i].brtam_1,
						nut_parm2[i].brtam_2,
						nut_parm2[i].brpo4_1,
						nut_parm2[i].brpo4_2,
						nut_parm2[i].bnh4_1,
						nut_parm2[i].bnh4_2,
						nut_parm2[i].bnh4_3,
						nut_parm2[i].bpo4_1,
						nut_parm2[i].bpo4_2,
						nut_parm2[i].bpo4_3);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 523:		
		fputs("c523 nut-parm3\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid         stream parameter group id\n",fpin);
		fputs("c    anaer        concentration of dissolved oxygen below which anaerobic conditions are assumed to exist (mg/l)\n",fpin);
		fputs("c    adnhpm(1-3)  adsorption coefficients (Kd) for ammonia-N adsorbed to sand, silt, and clay (cm3/g)\n",fpin);
		fputs("c    adpopm(1-3)  adsorption coefficients for ortho-phosphorus-P adsorbed to sand, silt, and clay (cm3/g)\n",fpin);
		fputs("c    expnvg       exponent in the gas layer mass transfer coefficient equation for NH3 volatilization\n",fpin);
		fputs("c    expnvl       exponent in the liquid layer mass transfer coefficient equation for NH3 volatilization\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid  anaer    adnhpm_1   adnhpm_2   adnhpm_3   adpopm_1   adpopm_2   adpopm_3   expnvg   expnvl\n",fpin);
		if(nutfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						nut_parm3[i].gid,
						nut_parm3[i].anaer,
						nut_parm3[i].adnhpm_1,
						nut_parm3[i].adnhpm_2,
						nut_parm3[i].adnhpm_3,
						nut_parm3[i].adpopm_1,
						nut_parm3[i].adpopm_2,
						nut_parm3[i].adpopm_3,
						nut_parm3[i].expnvg,
						nut_parm3[i].expnvl);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 524:		
		fputs("c524 nut-initial conditions\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid       stream parameter group id\n",fpin);
		fputs("c    no3        initial concentration of nitrate (mg/l)\n",fpin);
		fputs("c    tam        initial concentration of total ammonia (mg/l)\n",fpin);
		fputs("c    no2        initial concentration of nitrite (as N) (mg/l)\n",fpin);
		fputs("c    po4        initial concentration of ortho-phosphorus (as P) (mg/l)\n",fpin);
		fputs("c    snh4(1-3)  initial suspended concentrations of ammonia-N adsorbed to sand, silt, and clay (mg/kg)\n",fpin);
		fputs("c    spo4(1-3)  initial suspended concentrations of ortho-phosphorus-P adsorbed to sand, silt, and clay (mg/kg)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   no3   tam   no2   po4   snh4_1   snh4_2   snh4_3   spo4_1   spo4_2   spo4_3\n",fpin);
		if(nutfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						nut_init[i].gid,
						nut_init[i].no3,
						nut_init[i].tam,
						nut_init[i].no2,
						nut_init[i].po4,
						nut_init[i].snh4_1,
						nut_init[i].snh4_2,
						nut_init[i].snh4_3,
						nut_init[i].spo4_1,
						nut_init[i].spo4_2,
						nut_init[i].spo4_3);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 530:		
		fputs("c530 plank flags   \n",fpin);
		fputs("c\n",fpin);
		fputs("c    phyfg    phytoplankton flag\n",fpin);
		fputs("c    zoofg    zooplankton flag\n",fpin);
		fputs("c    balfg    benthic algae flag\n",fpin);
		fputs("c    sdltfg   influence of sediment washload on light extinction flag\n",fpin);
		fputs("c    amrfg    ammonia retardation of nitrogen-limited growth flag\n",fpin);
		fputs("c    decfg    linkage between carbon dioxide and phytoplankton growth flag (if on, the linkage is decoupled)\n",fpin);
		fputs("c    nsfg     ammonia is included as part of available nitrogen supply in nitrogen limited growth calculations\n",fpin);
		fputs("c    orefg    indicates the oref parameter in card 534 as a flowrate (if = 0) otherwise velocity\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	phyfg   zoofg   balfg   sdltfg   amrfg   decfg   nsfg   orefg\n",fpin);
		if(plkfg ==1)
		{
			strLine.Format("\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",phyfg, zoofg, balfg, sdltfg, amrfg, decfg, nsfg, orefg);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 531:		
		fputs("c531 plank-parm1\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameter group id\n",fpin);
		fputs("c    ratclp  ratio of chlorophyll A content of biomass to phosphorus content\n",fpin);
		fputs("c    nonref  non-refractory fraction of algae and zooplankton biomass\n",fpin);
		fputs("c    litsed  multiplication factor to total sediment concentration to determine sediment contribution to light extinction (l/mg/ft)\n",fpin);
		fputs("c    alnpr   fraction of nitrogen requirements for phytoplankton growth that is satisfied by nitrate\n",fpin);
		fputs("c    extb    base extinction coefficient for light (1/m)\n",fpin);
		fputs("c    malgr   maximum unit algal growth rate (1/hr)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid    ratclp   nonref   litsed   alnpr   extb    malgr\n",fpin);
		if(plkfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						plank_parm1[i].gid,
						plank_parm1[i].ratclp,
						plank_parm1[i].nonref,
						plank_parm1[i].litsed,
						plank_parm1[i].alnpr,
						plank_parm1[i].extb,
						plank_parm1[i].malgr);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 532:		
		fputs("c532 plank-parm2\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameter group id\n",fpin);
		fputs("c    cmmlt   Michaelis-Menten constant for light limited growth (lay/min)\n",fpin);
		fputs("c    cmmn    nitrate Michaelis-Menten constant for nitrogen limited growth (mg/l)\n",fpin);
		fputs("c    cmmnp   nitrate Michaelis-Menten constant for phosphorus limited growth (mg/l)\n",fpin);
		fputs("c    cmmp    phosphate Michaelis-Menten constant for phosphorus limited growth (mg/l)\n",fpin);
		fputs("c    talgrh  temperature above which algal growth ceases (C)\n",fpin);
		fputs("c    talgrl  temperature below which algal growth ceases (C)\n",fpin);
		fputs("c    talgrm  temperature below which algal growth is retarded (C)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid    cmmlt    cmmn    cmmnp    cmmp    talgrh   talgrl   talgrm\n",fpin);
		if(plkfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						plank_parm2[i].gid,
						plank_parm2[i].cmmlt,
						plank_parm2[i].cmmn,
						plank_parm2[i].cmmnp,
						plank_parm2[i].cmmp,
						plank_parm2[i].talgrh,
						plank_parm2[i].talgrl,
						plank_parm2[i].talgrm);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 533:		
		fputs("c533 plank-parm3\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid   stream parameter group id\n",fpin);
		fputs("c    alr20  algal unit respiration rate at 20 degrees C (1/hr)\n",fpin);
		fputs("c    aldh   high algal unit death rate (1/hr)\n",fpin);
		fputs("c    aldl   low algal unit death rate (1/hr)\n",fpin);
		fputs("c    oxald  increment to phytoplankton unit death rate due to anaerobic conditions (1/hr)\n",fpin);
		fputs("c    naldh  inorganic nitrogen concentration below which high algal death rate occurs (as nitrogen) (mg/l)\n",fpin);
		fputs("c    paldh  inorganic phosphorus concentration below which high algal death rate occurs (as phosphorus) (mg/l)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid     alr20      aldh      aldl     oxald     naldh     paldh\n",fpin);
		if(plkfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						plank_parm3[i].gid,
						plank_parm3[i].alr20,
						plank_parm3[i].aldh,
						plank_parm3[i].aldl,
						plank_parm3[i].oxald,
						plank_parm3[i].naldh,
						plank_parm3[i].paldh);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 534:		
		fputs("c534 plank-parm4\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameter group id\n",fpin);
		fputs("c    phycon  constant inflow concentration of plankton from land to reach (mg/l)\n",fpin);
		fputs("c    seed    minimum concentration of plankton not subject to advection (i.e., at high flow) (mg/l)\n",fpin);
		fputs("c    mxstay  concentration of plankton not subject to advection at very low flow (mg/l)\n",fpin);
		fputs("c    oref    velocity/outflow at which the concentration of plankton not subject to advection is midway between SEED and MXSTAY, see card 530 (m/s or m3/s)\n",fpin);
		fputs("c    claldh  chlorophyll a concentration above which high algal death rate occurs (ug/l)\n",fpin);
		fputs("c    physet  phytoplankton settling rate (m/hr)\n",fpin);
		fputs("c    refset  settling rate for dead refractory organics (m/hr)\n",fpin);
		fputs("c    cfsaex  This factor is used to adjust the input solar radiation to make it applicable to the RCHRES;\n",fpin);
		fputs("c            for example, to account for shading of the surface by trees or buildings\n",fpin);
		fputs("c    mbal    maximum benthic algae density (as biomass) (mg/m2)\n",fpin);
		fputs("c    cfbalr  ratio of benthic algal to phytoplankton respiration rate\n",fpin);
		fputs("c    cfbalg  ratio of benthic algal to phytoplankton growth rate\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid   phycon   seed   mxstay   oref   claldh   physet   refset  cfsaex  mbal   cfbalr   cfbalg\n",fpin);
		if(plkfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						plank_parm4[i].gid,
						plank_parm4[i].phycon,
						plank_parm4[i].seed,
						plank_parm4[i].mxstay,
						plank_parm4[i].oref,
						plank_parm4[i].claldh,
						plank_parm4[i].physet,
						plank_parm4[i].refset,
						plank_parm4[i].cfsaex,
						plank_parm4[i].mbal,
						plank_parm4[i].cfbalr,
						plank_parm4[i].cfbalg);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 535:		
		fputs("c535 plank-initial conditions\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid   stream parameter group id\n",fpin);
		fputs("c    phyto  initial phytoplankton concentration, as biomass (mg/l)\n",fpin);
		fputs("c    benal  initial benthic algae density, as biomass (mg/m2)\n",fpin);
		fputs("c    orn    initial dead refractory organic nitrogen concentration (mg/l)\n",fpin);
		fputs("c    orp    initial dead refractory organic phosphorus concentration (mg/l)\n",fpin);
		fputs("c    orc    initial dead refractory organic carbon concentration (mg/l)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid    phyto    benal   orn    orp    orc\n",fpin);
		if(plkfg ==1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						plank_init[i].gid,
						plank_init[i].phyto,
						plank_init[i].benal,
						plank_init[i].orn,
						plank_init[i].orp,
						plank_init[i].orc);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 540:		
		fputs("c540 pH controls   \n",fpin);
		fputs("c\n",fpin);
		fputs("c    phffg1   value of 0 indicates that the removal factor for total inorganic carbon is constant, given as phfrc1\n",fpin);
		fputs("c			 a value of 1 indicates the monthly removal factors\n",fpin);
		fputs("c    phffg2   value of 0 indicates that the removal factor for dissolved carbon dioxide is constant, given as phfrc2\n",fpin);
		fputs("c             a value of 1 indicates the monthly removal factors\n",fpin);
		fputs("c    phfrc1   removal fraction for total inorganic carbon\n",fpin);
		fputs("c    phfrc2   removal fraction for dissolved carbon dioxide\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	phffg1   phffg2   phfrc1   phfrc2\n",fpin);
		if(phfg == 1)
		{
			strLine.Format("\t%d\t%d\t%lf\t%lf\n",phffg1,phffg2,phfrc1,phfrc2);
			fputs(LPCSTR(strLine),fpin);
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 541:		
		fputs("c541 pH-parm\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameter group id\n",fpin);
		fputs("c    phcnt	maximum number of iterations used to solve for the pH\n",fpin);
		fputs("c    alkcon	number of the conservative substance which is used to simulate alkalinity\n",fpin);
		fputs("c            Alkalinity must be simulated in order to obtain valid results\n",fpin);
		fputs("c    cfcinv	ratio of the carbon dioxide invasion rate to the oxygen reaeration rate\n",fpin);
		fputs("c    brco2_1	benthal release rate of CO2 (as carbon) for aerobic conditions (mg/m2/hr)\n",fpin);
		fputs("c    brco2_2 benthal release rate of CO2 (as carbon) for anaerobic conditions (mg/m2/hr)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid    phcnt   alkcon   cfcinv   brco2_1   brco2_2\n",fpin);
		if(phfg == 1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%d\t%d\t%lf\t%lf\t%lf\n",
						ph_para[i].gid,
						ph_para[i].phcnt,
						ph_para[i].alkcon,
						ph_para[i].cfcinv,
						ph_para[i].brco2_1,
						ph_para[i].brco2_2);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 542:		
		fputs("c542 pH-initial conditions\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid	stream parameter group id\n",fpin);
		fputs("c    tic		initial total inorganic carbon (mg/l)\n",fpin);
		fputs("c    co2		initial carbon dioxide (as carbon) (mg/l)\n",fpin);
		fputs("c    ph		initial pH\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	rgid    tic    co2   ph\n",fpin);
		if(phfg == 1)
		{
			if(nrgroup > 0)
			{
				for(i = 0; i< nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\n",
						ph_init[i].gid,
						ph_init[i].tic,
						ph_init[i].co2,
						ph_init[i].ph);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c------------------------------------------------------------------------------------\n",fpin);
		break;
	case 543:		
		fputs("c543 mon-tic (monthly removal fraction for total inorganic carbon)\n",fpin);
		fputs("c    only required if phfg = 1 and phffg1 = 1 (see card 502 and card 540)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameter group id\n",fpin);
		fputs("c    jan-dec total inorganic carbon removal fraction at the start of each month\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c  rgid	jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(phfg  == 1 && phffg1 == 1)
		{
			if(nrgroup > 0)
			{
				for(i=0; i<nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						mtic_rf[i].gid,
						mtic_rf[i].fnum[0],
						mtic_rf[i].fnum[1],
						mtic_rf[i].fnum[2],
						mtic_rf[i].fnum[3],
						mtic_rf[i].fnum[4],
						mtic_rf[i].fnum[5],
						mtic_rf[i].fnum[6],
						mtic_rf[i].fnum[7],
						mtic_rf[i].fnum[8],
						mtic_rf[i].fnum[9],
						mtic_rf[i].fnum[10],
						mtic_rf[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 544:		
		fputs("c544 mon-co2 (monthly removal fraction for dissolved carbon dioxide)\n",fpin);
		fputs("c    only required if phfg = 1 and phffg2 = 1 (see card 502 and card 540)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rgid    stream parameter group id\n",fpin);
		fputs("c    jan-dec dissolved carbon dioxide removal fraction at the start of each month\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c  rgid	jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
		if(phfg  == 1 && phffg2 == 1)
		{
			if(nrgroup > 0)
			{
				for(i=0; i<nrgroup; ++i)
				{
					strLine.Format("\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
						mco2_rf[i].gid,
						mco2_rf[i].fnum[0],
						mco2_rf[i].fnum[1],
						mco2_rf[i].fnum[2],
						mco2_rf[i].fnum[3],
						mco2_rf[i].fnum[4],
						mco2_rf[i].fnum[5],
						mco2_rf[i].fnum[6],
						mco2_rf[i].fnum[7],
						mco2_rf[i].fnum[8],
						mco2_rf[i].fnum[9],
						mco2_rf[i].fnum[10],
						mco2_rf[i].fnum[11]
						);
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 600:
		fputs("c600 TMDL control flags\n",fpin);
		fputs("c\n",fpin);
		fputs("c    ncpt        if > 0 then use point sources control card 660\n",fpin);
		fputs("c    ncland      if > 0 then use landuse control card 670\n",fpin); 
		fputs("c                if = 1 then apply reduction to only surface output\n",fpin);
		fputs("c                if = 2 then apply reduction to total land output\n",fpin);
		fputs("c    ncrch       if > 0 then use reach control card 685 and 690\n",fpin);
		fputs("c    ntrgp       number of threshold groups in Card 410 and 610\n",fpin);
		fputs("c    ntnum       number of defined thresholds for analysis\n",fpin);
		fputs("c                if > 0 then use threshold control cards 605 and 610\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   ncpt  ncland  ncrch  ntrgp  ntnum\n",fpin);
		strLine.Format("\t%d\t%d\t%d\t%d\t%d\n",ncpt,ncland,ncrch,ntrgp,ntnum);
		fputs(LPCSTR(strLine),fpin);
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 605:	 						
		fputs("c605 TMDL threshold mapping (used if ntnum > 0 in card 600)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    tnum       threshold ordinal number\n",fpin);
		fputs("c    tqsd       threshold qual (1 for dissolved only and 2 for total)\n",fpin);
		fputs("c    tcount     number of water quality constituent to aggregate\n",fpin);
		fputs("c    tqid       list of tqid to aggregate - number of tqid in list = tcount (GQUAL/RQUAL IDs)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c    tnum   tqsd    tcount   tqid1   tqid2   .......   tqidn\n",fpin);
		if (ntnum > 0)
		{
			for(i=0; i<ntnum; ++i)
			{
				strLine.Format("\t%d\t%d\t%d",
					pThreshold[i].tnum,
					pThreshold[i].tqsd,
					pThreshold[i].tqnum);
					if (pThreshold[i].tqid != NULL)
					{
						CString strTemp;
						for(j=0; j<pThreshold[i].tqnum; ++j)
						{
							strTemp.Format("\t%d",pThreshold[i].tqid[j]);
							strLine += strTemp;
						}
						strLine += "\n";
						fputs(LPCSTR(strLine),fpin);
					}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 610:
		fputs("c610 TMDL threshold definitions (used if ntnum > 0 in card 600)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    trgid      threshold reach group ID (corresponds to trgid on Card 410)\n",fpin);
		fputs("c    tnum       threshold number (corresponds to tnum on Card 605)\n",fpin);
		fputs("c    ttype      threshold type (possible values: 0, 1, 2, 3 or -1, -2, -3)\n",fpin);
		fputs("c                0 = no standard to be applied for the trgid\n",fpin);
		fputs("c                1 = instantaneous values > threshold\n",fpin);
		fputs("c                2 = arithmetic mean > threshold\n",fpin);
		fputs("c                3 = geometric mean > threshold\n",fpin);
		fputs("c               -1 = instantaneous values < threshold\n",fpin);
		fputs("c               -2 = arithmetic mean < threshold\n",fpin);
		fputs("c               -3 = geometric mean < threshold\n",fpin);
		fputs("c    tdays      number of days over model output is aggregated and/or is compared\n",fpin);
		fputs("c               if tdays = 0 then threshold becomes percent of time\n",fpin);
		fputs("c    jan-dec    twelve monthly values for threshold (for constant, use same value 12 times)\n",fpin);
		fputs("c               (units are same as in card 250)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    examples: ttype  tdays  description/interpretation\n",fpin);
		fputs("c                  1      1  at least one instantaneous value within a 1-day running period > threshold\n",fpin);
		fputs("c                 -1      1  at least one instantaneous value within a 1-day running period < threshold\n",fpin);
		fputs("c                  1      0  percent of time that instantaneous value > threshold\n",fpin);
		fputs("c                  2      4  4-day running arithmetic mean > threshold\n",fpin);
		fputs("c                  3     30  30-day running geometric mean > threshold (for previous 30-days)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c  trgid  tnum   ttype  tdays   jan   feb   mar   apr   may   jun   jul   aug   sep   oct   nov   dec\n",fpin);
			
		if (ntrgp > 0 && ntnum > 0)
		{
			for(i=0; i<ntrgp*ntnum; ++i)
			{
				strLine.Format("\t%d\t%d\t%d\t%d\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\t%lf\n",
					pMTDATA[i].trgid,
					pMTDATA[i].tnum,
					pMTDATA[i].ttype,
					pMTDATA[i].tdays,
					pMTDATA[i].fnum[0],
					pMTDATA[i].fnum[1],
					pMTDATA[i].fnum[2],
					pMTDATA[i].fnum[3],
					pMTDATA[i].fnum[4],
					pMTDATA[i].fnum[5],
					pMTDATA[i].fnum[6],
					pMTDATA[i].fnum[7],
					pMTDATA[i].fnum[8],
					pMTDATA[i].fnum[9],
					pMTDATA[i].fnum[10],
					pMTDATA[i].fnum[11]
					);
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c---------------------------------------------------------------------------------------\n",fpin);
		break;
	case 660:
		fputs("c660 TMDL point source control (used if ncpt > 0 on card 600)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid         reach id\n",fpin);
		fputs("c    permit        point source index (level1)\n",fpin);
		fputs("c    pipe          point source index qualifier (level2)\n",fpin);
		fputs("c    reduction     reduction of pollutant from point source (in fraction)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   rchid   permit   pipe   reduction_flow...reduction_qual1...reduction_qual2...reduction_qualn\n",fpin);
		if(nPtSource > 0 && pPSReduction != NULL)
		{
			for(i = 0; i < nPtSource; ++i)
			{
				pPSReduction[i].strPermitName.Replace(' ','_');
				pPSReduction[i].strPipeName.Replace(' ','_');
				strLine.Format("\t%d\t%s\t%s\t%lf",
					pPSReduction[i].rchid,
					pPSReduction[i].strPermitName,
					pPSReduction[i].strPipeName,
					pPSReduction[i].fReduction_flow);
				CString strTemp;
				for(j=0; j< nPtQuals; ++j)
				{
					strTemp.Format("\t%lf",pPSReduction[i].fReduction_qual[j]);
					strLine += strTemp;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 670:
		if (bRunNIMS == true)
			break;

		fputs("c670 TMDL land-based control (used if ncland > 0 on card 600)\n",fpin);
		fputs("c \n",fpin);
		fputs("c    subbasin   subwatershed id\n",fpin);
		fputs("c    deluid     land use id \n",fpin);
		fputs("c    luname     land use name\n",fpin);
		fputs("c    reduction  reduction of pollutant from corresponding landuse and subwatershed\n",fpin);
		fputs("c \n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c	subbasin  deluid pluname  reduction\n",fpin);

		if(ncland > 0 && pTMDLDistrib != NULL)
		{
			int Num = nQuals + 1;	// flow is always there
			if (sedfg == 1)
				Num += 3;			// sand, silt, and clay

			if(nsws*nlandp > 0)
			{
				CString strTemp;
				for(i=0; i<nsws*nlandp; ++i)
				{
					pTMDLDistrib[i*Num].strLUName.Replace(' ','_');
					strLine.Format("\t%d\t%d\t%s",
						pTMDLDistrib[i*Num].subbasin,
						pTMDLDistrib[i*Num].luid,
						pTMDLDistrib[i*Num].strLUName);
					for(j=0; j<Num; ++j)
					{
						strTemp.Format("\t%lf",
							pTMDLDistrib[i*Num+j].fRatio);
						strLine += strTemp;
					}
					strLine += "\n";
					fputs(LPCSTR(strLine),fpin);
				}
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 680:
		fputs("c680 TMDL reach control (used if ncrch > 0 on card 600)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid         controlled reach id\n",fpin);
		fputs("c    outlet        controlled reach outlet id\n",fpin);
		fputs("c    switch_mon    monthly switch to control conc limit or reduction of pollutant from the corresponding reach (0-off, 1-on)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   rchid   outlet   switch_1   switch_2......switch_12\n",fpin);
		if(ncrch > 0 && pMON_SWITCH != NULL)
		{
			CString strTemp;
			int nNum = ncrchOutlets; // number of controlled outlets
			int Num = 12;

			for(i = 0; i < nNum; ++i)
			{
				strLine.Format("\t%d\t%d",
					pBMPLimit[i].rchid,
					pBMPLimit[i].nOutletId);
				for(j=0; j<Num; ++j)
				{
					strTemp.Format("\t%d",pMON_SWITCH[i].nSwitch[j]);
					strLine += strTemp;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 685:
		fputs("c685 TMDL reach control (used if ncrch > 0 on card 600)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid         controlled reach id\n",fpin);
		fputs("c    outlet        controlled reach outlet id\n",fpin);
		fputs("c    limit-flow    flow limit from the corresponding reach (cfs)\n",fpin);
		fputs("c    limit_pol     concentration limit of pollutant from the corresponding reach (mg/l or ug/l or #/100ml)\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   rchid   outlet   limit_flow   limit_qual1...limit_qual2...limit_qualn\n",fpin);
		if(ncrch > 0 && pBMPLimit != NULL)
		{
			CString strTemp;
			int nNum = ncrchOutlets; // number of controlled outlets
			int Num = nQuals;

			if (sedfg == 1 || oxfg == 1)
				Num += 12;	// sand,silt,clay,RQuals 

			for(i = 0; i < nNum; ++i)
			{
				strLine.Format("\t%d\t%d\t%lf",
					pBMPLimit[i].rchid,
					pBMPLimit[i].nOutletId,
					pBMPLimit[i].fLimit_flow);
				for(j=0; j< Num; ++j)
				{
					strTemp.Format("\t%lf",pBMPLimit[i].fLimit_qual[j]);
					strLine += strTemp;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	case 690:
		fputs("c690 TMDL reach control (used if ncrch > 0 on card 600)\n",fpin);
		fputs("c\n",fpin);
		fputs("c    rchid         controlled reach id\n",fpin);
		fputs("c    outlet        controlled reach outlet id\n",fpin);
		fputs("c    reduction     reduction of pollutant from the corresponding reach (fraction)\n",fpin);
		fputs("c                  reduction in outflow will also reduce the pollutant mass from the outflow and \n",fpin);
		fputs("c                  any defined reduction to pollutant will be the additional\n",fpin);
		fputs("c\n",fpin);
		WriteCardComments(fpin,nSection);
		fputs("c   rchid   outlet   reduction_flow...reduction_qual1...reduction_qual2...reduction_qualn\n",fpin);
		if(ncrch > 0 && pBMPReduction != NULL)
		{
			CString strTemp;
			int nNum = ncrchOutlets; // number of controlled outlets
			int Num = nQuals;

			if (sedfg == 1 || oxfg == 1)
				Num += 12;	// sand,silt,clay,RQuals 

			for(i = 0; i < nNum; ++i)
			{
				strLine.Format("\t%d\t%d\t%lf",
					pBMPReduction[i].rchid,
					pBMPReduction[i].nOutletId,
					pBMPReduction[i].fReduction_flow);
				for(j=0; j< Num; ++j)
				{
					strTemp.Format("\t%lf",pBMPReduction[i].fReduction_qual[j]);
					strLine += strTemp;
				}
				strLine += "\n";
				fputs(LPCSTR(strLine),fpin);
			}
		}
		fputs("c--------------------------------------------------------------------------------------------\n",fpin);
		break;
	default:
		break;
	}
}

void CLSPCMODEL::SkipCommentLine(FILE *fp)
{
	char strLine[MAXLINE];
	long nStart = ftell (fp);
	CString strLDesc;

	while (fgets (strLine, MAXLINE, fp) != NULL)
    {
		CString str(strLine);
		CStringToken strToken(str);
		CString str0 = strToken.NextToken();

		if(str0[0] != 'C' && str0[0] != 'c')
		{
			fseek (fp, nStart, SEEK_SET);
			return;
		}
		else
		{
			if(str.GetLength() >= 2)
			{
				if(str[1] >= '0' && str[1] <= '9')
				{
					fseek (fp, nStart, SEEK_SET);
					return;
				}
				else if(str[1] == ':')
				{
					fseek (fp, nStart, SEEK_SET);
					return;
				}
				else
				{
					if(str.GetLength() >= 2)
						strLDesc += str.Right(str.GetLength()-2);
				}

				nStart = ftell (fp);
			}
		}
	}
}
/*
int CLSPCMODEL::ReadTimeSeries(CString strFileName,int nStation)
{
	Log("Read weather station data from file: "+strFileName);
	char strLine[MAXLINE];
	FILE *fpin = NULL;
	// open the file for reading
	fpin = fopen (strFileName, "rt");
	if(fpin == NULL)
	{
		AfxMessageBox("Cannot open file "+strFileName+" for reading");
		Log("Cannot open file "+strFileName+" for reading");
		return -1;
	}
	
	while(true)
	{
		memset (strLine, 0, MAXLINE);
		if(fgets(strLine, MAXLINE, fpin) == NULL)
		{
			AfxMessageBox("Check weather file: " + strFileName);
			Log("Check weather file: " + strFileName);
			return -1;
		}
		CString str(strLine);
		str.MakeLower();
		// skip anoter four lines once found "time series"
		if(str.Find("time series") != -1)
		{
			for(int i = 0; i < 3; ++i)
				if(fgets(strLine, MAXLINE, fpin) == NULL)
				{
					AfxMessageBox("Check weather file: " + strFileName);
					Log("Check weather file: " + strFileName);
					return -1;
				}
				break;	
		}
	}
	
	// count the time series numbers;
	tmList[nStation].nNum = 0;
	
    // scan the file to see how many elements are in the array
	long nStart = ftell (fpin);
	while (fgets(strLine, MAXLINE, fpin) != NULL)
    {
		CString str(strLine);
		str.TrimLeft();
		str.TrimRight();
		if(str.GetLength() < 3)
			continue;
		++tmList[nStation].nNum;
	}
    fseek (fpin, nStart, SEEK_SET);
	
	//TRACE("station %d record = %d\n",nStation,nTSNum[nStation]);
	//Log("station %d record = %d\n",nStation,nTSNum[nStation]);
	if(tmList[nStation].nNum <= 0)
	{
		fclose(fpin);
		AfxMessageBox("Check weather file: " + strFileName);
		Log("Check weather file: " + strFileName);
		return -1;
	}
	
	tmList[nStation].pRecord = new TimeSeries[tmList[nStation].nNum];
    
	// read the data
	int year,month,day,hour,mins;
    for (int i=0; i<tmList[nStation].nNum; i++)
    {
		// read on line
		if (fgets(strLine, MAXLINE, fpin) == NULL)
		{
			AfxMessageBox("Check weather file: " + strFileName);
			Log("Check weather file: " + strFileName);
			break;
		}
		// get the data
		CString str(strLine);
		str.TrimLeft();
		str.TrimRight();
		if(str.GetLength() < 3)
			continue;

		CStringToken strToken(str);
		strToken.NextToken();
		str = strToken.LeftOut();
		int nFields = 0;
		if(tempfg == 1)
		{
			nFields = sscanf(LPCSTR(str),"%d %d %d %d %d %lf %lf %lf %lf %lf %lf %lf",&year,&month,&day,&hour,&mins,
				&tmList[nStation].pRecord[i].fNum[0],	// precip
				&tmList[nStation].pRecord[i].fNum[1],	// pet
				&tmList[nStation].pRecord[i].fNum[2],	// airtemp
				&tmList[nStation].pRecord[i].fNum[3],	// wind
				&tmList[nStation].pRecord[i].fNum[4],	// solrad
				&tmList[nStation].pRecord[i].fNum[5],	// dewtemp
				&tmList[nStation].pRecord[i].fNum[6]);	// cloudcover
			if(nFields < 11)
			{
				CString strMessage = "Temperature/Snow is selected and the weather file ("+strFileName+") does not have required data. Turn off temperature/snow flag or change the weather file";
				AfxMessageBox(strMessage);
				fclose(fpin);
				return -1;
			}
		}
		else
		{
			nFields = sscanf(LPCSTR(str),"%d %d %d %d %d %lf %lf",&year,&month,&day,&hour,&mins,
				&tmList[nStation].pRecord[i].fNum[0],
				&tmList[nStation].pRecord[i].fNum[1]);
			if(nFields < 7)
			{
				CString strMessage = "The weather station time series format of file "+strFileName+" is possibly wrong.";
				AfxMessageBox(strMessage);
				fclose(fpin);
				return -1;
			}
		}

		if(hour == 24)																	
		{                          
			hour = 0;                  
			tmList[nStation].pRecord[i].tm = COleDateTime(year,month,day,hour,mins,0) + COleDateTimeSpan(1,0,0,0);  
		}
		else
		{
			tmList[nStation].pRecord[i].tm = COleDateTime(year,month,day,hour,mins,0);   
		}
	}

	if(tempfg == 1 && tmList[nStation].nNum > 0)
	{
		//assign first record value equal to the second record
		tmList[nStation].pRecord[0].fNum[0] = tmList[nStation].pRecord[1].fNum[0];	// precip
		tmList[nStation].pRecord[0].fNum[1] = tmList[nStation].pRecord[1].fNum[1];	// pet
		tmList[nStation].pRecord[0].fNum[2] = tmList[nStation].pRecord[1].fNum[2];	// airtemp
		tmList[nStation].pRecord[0].fNum[3] = tmList[nStation].pRecord[1].fNum[3];	// wind
		tmList[nStation].pRecord[0].fNum[4] = tmList[nStation].pRecord[1].fNum[4];	// solrad
		tmList[nStation].pRecord[0].fNum[5] = tmList[nStation].pRecord[1].fNum[5];	// dewtemp
		tmList[nStation].pRecord[0].fNum[6] = tmList[nStation].pRecord[1].fNum[6];	// cloudcover
	}
	else if (tmList[nStation].nNum > 0)
	{
		//assign first record value equal to the second record
		tmList[nStation].pRecord[0].fNum[0] = tmList[nStation].pRecord[1].fNum[0];	// precip
		tmList[nStation].pRecord[0].fNum[1] = tmList[nStation].pRecord[1].fNum[1];	// pet
	}
	
	fclose(fpin);

	twStart = tmList[0].pRecord[0].tm;	// find the start and end time from the weather file
	twEnd = tmList[0].pRecord[tmList[0].nNum-1].tm;
	for(i=0; i<nwst; i++)
		if(tmList[i].pRecord != NULL)
		{
			if(tmList[i].pRecord[0].tm > twStart)
				twStart = tmList[i].pRecord[0].tm;    
			if(tmList[i].pRecord[0].tm > tStart)
				tStart = tmList[i].pRecord[0].tm;  
//				tStart = tmList[i].pRecord[0].tm - COleDateTimeSpan(0,0,delt,0);    
			if (toStart < tStart)					
				toStart = tStart;
			
			if(tmList[i].pRecord[tmList[i].nNum-1].tm < twEnd)
				twEnd = tmList[i].pRecord[tmList[i].nNum-1].tm;
			if(tmList[i].pRecord[tmList[i].nNum-1].tm < tEnd)
				tEnd = tmList[i].pRecord[tmList[i].nNum-1].tm;
			if (toEnd > tEnd)					
				toEnd = tEnd;
		}
	return 0;
}

void CLSPCMODEL::AllocateTSSpace()
{
	if(tmList != NULL)
	{
		delete []tmList;
	}
	
	if(nwst > 0)
		tmList = new WeatherStationData[nwst];
}
*/
int CLSPCMODEL::qualsuro(int *dayfg, int *vsqcfg, double *suro, double *soqcm, int *mon, int *nxtmon, int *day, int *ndays, double *soqc, double *soqual)
{
	double unit = 1/LB_FT3_TO_MG_L;  // mg/l -> lb/ft^3   
	if (*vsqcfg > 0)
	{
		
		// modification to allow optional no interpolation of  
		// monthly values  (modified for chesapeake bay)  
		if (*vsqcfg == 2)
		{
			// no interpolation  
			*soqc = soqcm[*mon];
		}
		else
		{
			// concentrations are allowed to vary throughout the year  
			// interpolate for the daily value  
			// linearly interpolate soqc between two values from the  
			// monthly array soqcm(12) for this surface flow quality  
			// constituent (no. qsop)  
			*soqc = dayval(&soqcm[*mon], &soqcm[*nxtmon], day, ndays);
		}
	}
	else
	{
		// concentrations do not vary throughout the year. 
		// soqc value has been supplied by the run interpreter  
	}
	
	// simulate constituents carried by surface flow - units are qty/acre-ivl  
    if (*suro > 0.0)
	{
		if(*suro > 0.0)
			*soqual = *soqc * *suro*IN_ACRE_TO_FT3 * unit;
		//	else
		//	{
		//		double	d1;
		//		d1 =  *suro /0.02;
		//		pow(d1, 2) ;
		//		*soqual = *soqc * d1 * *suro*3630 * unit;
		//
		//	}
    }
	else
	{
		*soqual = 0.0;
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate quality constituents by fixed concentration in interflow */

/*     + + + KEYWORDS + + + */
/*     ??? */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     DAYFG  - flag for first day or day change */
/*     VIQCFG - ??? */
/*     IFWO   - ??? */
/*     IOQCM  - ??? */
/*     MON    - calendar month */
/*     NXTMON - next calendar month */
/*     DAY    - day of month */
/*     NDAYS  - no. of days in this month */
/*     IOQC   - ??? */
/*     IOQUAL - ??? */

/*     + + + FUNCTIONS + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   DAYVAL */

/*     + + + END SPECIFICATIONS + + + */

int CLSPCMODEL::qualif(int *dayfg, int *viqcfg, double *ifwo, double *ioqcm, int *mon, int *nxtmon, int *day, int *ndays, double *ioqc, double *ioqual)
{
	double unit = 1/LB_FT3_TO_MG_L;  /* mg/l -> lb/ft^3  */
    /*   */
	//    if (*dayfg == 1)
	//	{
	/*       it is the first interval of the day */
	if (*viqcfg > 0)
	{
		
		/*         modification to allow optional no interpolation of */
		/*         monthly values  (modified for chesapeake bay) */
		if (*viqcfg == 2)
		{
			/*           no interpolation */
			*ioqc = ioqcm[*mon];
		}
		else
		{
			/*           concentrations are allowed to vary throughout the year */
			/*           interpolate for the daily value */
			/*           linearly interpolate ioqc between two values from the */
			/*           monthly array ioqcm(12) for this interflow quality */
			/*           constituent (no. qifp) */
			*ioqc = dayval(&ioqcm[*mon], &ioqcm[*nxtmon], day, ndays);
		}
	}
	else
	{
		/*         concentrations do not vary throughout the year. */
		/*         ioqc value has been supplied by the run interpreter */
	}
	
	//    }
	
	/*     simulate constituents carried by interflow - units are */
	/*     qty/acre-ivl */
    if (*ifwo > 0.0)
	{
		if(*ifwo > 0.0)
			*ioqual = *ioqc * *ifwo*IN_ACRE_TO_FT3 * unit;	// lb/ft3 = 3630 lb/acre-in
		//	else
		//	{
		//		double	d1;
		//		d1 =  *ifwo /0.02;
		//		pow(d1, 2) ;
		//		*ioqual = *ioqc * d1 * *ifwo*3630 * unit;
		//
		//	}
    }
	else
	{
		*ioqual = 0.0;
    }
	
    return 0;
}

int CLSPCMODEL::proute(double *psur, int *rtopfg, double *delt60, double *dec, 
					   double *src, double *surs, double *suro)
{
    double r1 = 0., d1 = 0., a1 = 0., ratio = 0.;
    double fact = 0., dfact = 0., ffact = 0., dterm = 0., sterm = 0.;
	double dummy = 0., dsuro = 0., fsuro = 0., tsuro = 0., dfsuro = 0.;
	double change = 0., surse = 0., sursm = 0., ssupr = 0., sursnw = 0.;
	
    if (*psur > 2e-4)
	{
		// something is worth routing on the surface  
		if (*rtopfg != 1)	// this is not the case as it is hard coded as 1
		{
			// do routing the new way  
			// estimate the rate of supply to the overland flow surface - inches/hour  
			ssupr = (*psur - *surs) / *delt60;
			
			// determine equilibrium depth for this supply rate  
			surse = 0.0;
			
			if (ssupr > 0.0)
			{
				d1 = ssupr;
				surse = *dec * pow(d1, 0.6);
			}
			
			// determine runoff by iteration - newton's method  
			// estimate the new surface storage  
			sursnw = *psur;
			*suro = 0.0;

			// dountil relative error is small  
L10:
			if (ssupr > 0.0)
			{
				ratio = sursnw / surse;
				if (ratio <= 1.0)
				{
					// flow is increasing  
					// Computing 3rd power  
					r1 = ratio;
					fact = r1 * (r1 * r1) * 0.6 + 1.0;
				}
				else
				{
					fact = 1.6;
				}
			}
			else
			{
				// ratio is arbitrarily large for supply rate <= 0  
				ratio = 1e30;
				fact = 1.6;
			}
			
			// coefficient in outflow equation  
			d1 = fact;
			a1 = *delt60 * *src * pow(d1, 1.667);
			d1 = sursnw;
			sterm = pow(d1, 1.667);
			ffact = a1 * sterm;
			fsuro = ffact - *suro;
			dfact = -1.667 * ffact;
			dfsuro = dfact / sursnw - 1.0;
			if (ratio <= 1.0)
			{
				// additional term required in derivative wrt suro  
				// Computing 2nd power  
				r1 = ratio;
				dterm = dfact / (fact * surse) * 1.8 * (r1 * r1);
				dfsuro += dterm;
			}
			
			dsuro = fsuro / dfsuro;
			
			*suro -= dsuro;

			// boundary condition- don't let suro go negative  
			if (*suro <= 1e-10)
				*suro = 0.0;

			sursnw = *psur - *suro;
			change = 0.0;
			
			if (fabs(*suro) > 0.0)
			{
				r1 = dsuro / *suro;
				change = fabs(r1);
			}
			
			if (change >= 0.01)
				goto L10;

			*surs = sursnw;
		}
		else	// always this is the case
		{
			// do routing the way it is done in arm, nps, and hspx  
			// estimate the rate of supply to the overland flow surface - inches/ivl  
			ssupr = *psur - *surs;
			
			// estimate the mean surface detention storage over the interval  
			sursm = (*surs + *psur) * 0.5;
			
			// estimate the equilibrium detention depth for this supply rate - surse  
			if (ssupr > 0.0)
			{
				// preliminary estimate of surse  
				d1 = ssupr;
				dummy = *dec * pow(d1, 0.6);
				if (dummy > sursm)
				{
					// flow is increasing  
					surse = dummy;
					
					// Computing 3rd power  
					r1 = sursm / surse;
					dummy = sursm * (r1 * (r1 * r1) * 0.6 + 1.0);
				}
				else
				{
					// flow on surface is at equilibrium or receding  
					dummy = sursm * 1.6;
				}
			}
			else
			{
				// flow on the surface is receding - equilibrium detention is  
				// assumed equal to actual detention  
				dummy = sursm * 1.6;
			}
			
			d1 = dummy;
			tsuro = *delt60 * *src * pow(d1, 1.667);
			
			// check the temporary calculation of surface outflow  
			if (tsuro > *psur)
			{
				// too much surface runoff is estimated  
				*suro = *psur;
				*surs = 0.0;
			}
			else
			{
				*suro = tsuro;
				*surs = *psur - *suro;
			}
		}
    }
	else
	{
		// send what is on the overland flow plane straight to the channel  
		*suro = *psur;
		*surs = 0.0;
    }
	
    if (*suro <= 1e-10)
		// fix bug in on PC - underflow leads to "not a number"  
		*suro = 0.0;

    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate evaporation from interception storage. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     CEPS   - ??? */
/*     REMPET - ??? */
/*     TAET   - ??? */
/*     CEPE   - ??? */

/*     + + + END SPECIFICATIONS + + + */

int CLSPCMODEL::evicep(double *ceps, double *rempet, double *taet, double *cepe)
{
    if (*ceps > 0.0)
	{
		/*       there is something in interception storage to evaporate */
		if (*rempet > *ceps)
		{
			/*         evaporation from interception storage is limited */
			/*         by quantity available */
			*cepe = *ceps;
			*ceps = 0.0;
		}
		else
		{
			/*         interception evaporation will not exhaust storage, so */
			/*         empty at potential */
			*cepe = *rempet;
			*ceps -= *cepe;
		}
		
		/*       update totals */
		*taet += *cepe;
		*rempet -= *cepe;
    }
	else
	{
		/*       there is no evaporation from interception storage */
		*cepe = 0.0;
    }
	
    return 0;
	
}

/*     + + + PURPOSE + + + */
/*     Simulate quality constituents by fixed concentration in */
/*     groundwater flow */

/*     + + + KEYWORDS + + + */
/*     ??? */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     DAYFG  - flag for first day or day change */
/*     VAQCFG - ??? */
/*     AGWO   - ??? */
/*     AOQCM  - ??? */
/*     MON    - calendar month */
/*     NXTMON - next calendar month */
/*     DAY    - day of month */
/*     NDAYS  - no. of days in this month */
/*     AOQC   - ??? */
/*     AOQUAL - ??? */

/*     + + + FUNCTIONS + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   DAYVAL */

int CLSPCMODEL::qualgw(int *dayfg, int *vaqcfg, double *agwo, double *aoqcm, int *mon, int *nxtmon, int *day, int *ndays, double *aoqc, double *aoqual)
{
	double unit = 1/LB_FT3_TO_MG_L;  /* mg/l -> lb/ft^3  */
    /*   */
	//    if (*dayfg == 1)
	//	{
	/*       it is the first interval of the day */
	if (*vaqcfg > 0)
	{
		
		/*         modification to allow optional no interpolation of */
		/*         monthly values  (modified for chesapeake bay) */
		if (*vaqcfg == 2)
		{
			/*           no interpolation */
			*aoqc = aoqcm[*mon];
		}
		else
		{
			/*           concentrations are allowed to vary throughout the year */
			/*           interpolate for the daily value */
			/*           linearly interpolate aoqc between two values from the */
			/*           monthly array aoqcm(12) for this interflow quality */
			/*           constituent (no. qafp) */
			*aoqc = dayval(&aoqcm[*mon], &aoqcm[*nxtmon], day, ndays);
		}
	}
	else
	{
		/*         concentrations do not vary throughout the year. */
		/*         aoqc value has been supplied by the run interpreter */
	}
	
	//    }
	
	/*     simulate constituents carried by groundwater flow - units */
	/*     are qty/acre-ivl */
    if (*agwo > 0.0)
	{
		*aoqual = *aoqc * *agwo * IN_ACRE_TO_FT3 * unit;
    }
	else
	{
		*aoqual = 0.0;
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate lower zone behavior. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     IPERC  - inflow to lower zone
/*     LZRAT  - ??? */
/*     LZFRAC -  save at n-1
/*     LZS    - lower zone storage
/*     RLZRAT - save at n-1
/*     LZI    - fraction on inflow add in lower zone storage

/*     + + +   + + + */

/*     + + + INTRINSICS + + + */

/*     + + + END SPECIFICATIONS + + + */

int CLSPCMODEL::lzone(double *iperc, double *lzrat, double *lzfrac, double *lzs, double *rlzrat, double *lzi)
{
    double d1, d2;
    double indx = 0.0;
	
	
    if (*iperc > 0.0)
	{
		/*       if necessary, recalculate the fraction of infiltration plus */
		/*       percolation which will be taken by lower zone */
		if (fabs(*lzrat - *rlzrat) > 0.02)
		{
			/*         it is time to recalculate */
			*rlzrat = *lzrat;
			if (*lzrat <= 1.0)
			{
				indx = 2.5 - *lzrat * 1.5;
				d1 = 1.0 / (indx + 1.0);
				d2 = indx;
				*lzfrac = 1.0 - *lzrat * pow(d1, d2);
			}
			else
			{
				indx = *lzrat * 1.5 - 0.5;
				d1 = 1.0 / (indx + 1.0);
				d2 = indx;
				*lzfrac = pow(d1, d2);
			}
		}
		else
		{
			/*         keep the old value of lzfrac */
		}
		
		/*       lower zone inflow */
		*lzi = *lzfrac * *iperc;
		*lzs += *lzi;
    }
	else
	{
		/*       no inflow */
		*lzi = 0.0;
    }
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate interflow. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     DAYFG  - flag for first day or day change */
/*     VIRCFG - ??? */
/*     IRCM   - ??? */
/*     MON    - calendar month */
/*     NXTMON - next calendar month */
/*     DAY    - day of month */
/*     NDAYS  - no. of days in this month */
/*     DELT60 - simulation time interval in hours */   
/*     NBLKS  - number of blocks into which pls zones will be subdivided */
/*     IFWI   - ??? */
/*     IFWIB  - ??? */
/*     IFWLI  - ??? */
/*     NBLKSI - ??? */
/*     IRC    - ??? */
/*     IFWK1  - ??? */
/*     IFWK2  - ??? */
/*     IFWS   - ??? */
/*     IFWSB  - ??? */
/*     UZS    - initial upper zone storage */
/*     UZSB   - ??? */
/*     IFWO   - ??? */
/*     IFWOB  - ??? */

/*     + + +   + + + */

/*     + + + FUNCTIONS + + + */

/*     + + + INTRINSICS + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   DAYVAL */
int CLSPCMODEL::intflw(int *dayfg, int *vircfg, double *ircm, int *mon, int *nxtmon, int *day, int *ndays, double *delt60, int *nblks, double *ifwi, double *ifwli, double *irc, double *ifwk1, double *ifwk2, double *ifws, double *uzs, double *ifwo)
{
    double kifw = 0.0, stor = 0.0;
    double inflo = 0.0, value = 0.0, dummy = 0.0;
    double outflo = 0.0;
	
    if (*dayfg == 1)
	{
		/*       it is the first interval of the day */
		if (*vircfg == 1)
		{
			/*         interflow recession constant is allowed to vary */
			/*         throughout the year */
			/*         interpolate for the daily value */
			/*         linearly interpolate irc between two values from the */
			/*         monthly array ircm(12) */
			*irc = dayval(&ircm[*mon], &ircm[*nxtmon], day, ndays);
		}
		else
		{
			/*         interflow recession constant does not vary throughout the */
			/*         year.  irc value has been supplied by the run interpreter */
		}
		
		/*       derive parameters used in routing */
		dummy = 24.0 / *delt60;
		kifw = -log(*irc) / dummy;
		*ifwk2 = 1.0 - exp(-kifw);
		*ifwk1 = 1.0 - *ifwk2 / kifw;
    }
	
    if (*nblks == 1)
	{
		/*       surface and near-surface zones of the land segment have not */
		/*       been subdivided into blocks */
		inflo = *ifwi + *ifwli;
		value = inflo + *ifws;
		if (value > 2e-5)
		{
			/*         there is something worth routing */
			*ifwo = *ifwk1 * inflo + *ifwk2 * *ifws;
			*ifws = value - *ifwo;
		}
		else
		{
			/*         nothing worth routing-dump back to uzs */
			*ifwo = 0.0;
			*ifws = 0.0;
			*uzs += value;
		}
    }
	else
	{
		// comment out following option (sj)
		
		//		/*       surface and near-surface zones of the land segment have */
		//		/*       been subdivided into blocks */
		//		/*       initialize segment wide variables */
		//	*ifwo = 0.0;
		//	*ifws = 0.0;
		//
		//	for (i = 0; i < *nblks; ++i) {
		//	    stor = ifwsb[i];
		//	    inflo = ifwib[i] + *ifwli;
		//	    value = inflo + stor;
		//	    if (value > 2e-5) {
		// /*        there is something worth routing */
		//		outflo = *ifwk1 * inflo + *ifwk2 * stor;
		//		stor = value - outflo;
		//	    } else {
		// /*           nothing worth routing dump back to uzs */
		//		outflo = 0.0;
		//		stor = 0.0;
		//		uzsb[i] += value;
		//	    }
		//
		//	    ifwob[i] = outflo;
		//	    ifwsb[i] = stor;
		// /*         increment land segment wide variables */
		//	    *ifws += stor;
		//	    *ifwo += outflo;
		// /* L10: */
		//	}
		//
		// /*       mean response of whole segment */
		//	if (*ifwo > 0.0) {
		//	    *ifwo *= *nblksi;
		//	}
		
		//	if (*ifws > 0.0) {
		//	    *ifws *= *nblksi;
		//	}
		
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate the interception of moisture by vegetal or other */
/*     ground cover. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     VCSFG  - ??? */
/*     DAYFG  - flag for first day or day change */
/*     CEPSCM - ??? */
/*     MON    - calendar month */
/*     NXTMON - next calendar month */
/*     DAY    - day of month */
/*     NDAYS  - no. of days in this month */
/*     SUPY   - ??? */
/*     CEPSC  - ??? */
/*     CEPS   - ??? */
/*     CEPO   - ??? */

/*     + + + FUNCTIONS + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   DAYVAL */
int CLSPCMODEL::icept(int *vcsfg, int *dayfg, double *cepscm, int *mon, int *nxtmon, int *day, int *ndays, double *supy, double *cepsc, double *ceps, double *cepo)
{
    /*   */
    if (*dayfg == 1)
	{
		/*       it is the first interval of the day */
		if (*vcsfg == 1)
		{
			/* interception capacity allowed to vary throughout the year */
			/* interpolate for the daily value */
			/* linearly interpolate cepsc between two values from the */
			/* monthly array cepscm(12) */
			*cepsc = dayval(&cepscm[*mon], &cepscm[*nxtmon], day, ndays);
		}
    }

	/* add to interception storage */
    *ceps += *supy;
    if (*ceps > *cepsc)
	{
		/* there is outflow from interception storage */
		*cepo = *ceps - *cepsc;
		*ceps = *cepsc;
    }
	else
	{
		*cepo = 0.0;
    }
	
    return 0;
}

/**there should be no return value for this function*/

/*     + + + PURPOSE + + + */
/*     Simulate groundwater behavior. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     DEEPFR - the fraction of groundwater inflow which will enter deep groundwater
/*     GWI    - ground water inflow
/*     KVARY  - ??? */
/*     DAYFG  - flag for first day or day change */
/*     KGW    - calculate in initial subroutine  (sj)
/*     AGWLI  - Lateral inflow (set zero in pwater)
/*     AGWS   - return active ground storage
/*     GWVS   - ground water sloop
/*     IGWI   -  used in MSTLAY (it is a dummy sj)
/*     AGWI   -  used in MSTLAY (it is a dummy sj)
/*     AGWO   - return outflow

/*     + + +   + + + */

/*     + + + INTRINSICS + + + */
int CLSPCMODEL::gwater(double *deepfr, double *gwi, double *kvary, int *dayfg, double *kgw, double *agwli, double *agws, double *gwvs, double *igwi, double *agwi, double *agwo)
{
    double ainflo = 0.0;
	
    if (*gwi > 0.0)
	{
		/*       groundwater inflow components */
		*igwi = *deepfr * *gwi;
		*agwi = *gwi - *igwi;
	}
	else
	{
		*igwi = 0.0;
		*agwi = 0.0;
    }
	
	/*     active groundwater */
	/*     total inflow includes lateral inflow */
    ainflo = *agwi + *agwli;
    *agwo = 0.0;
	/*     evaluate groundwater recharge parameter */
    if (fabs(*kvary) > 0.0)
	{
		/*       update the index to variable groundwater slope */
		*gwvs += ainflo;
		if (*dayfg == 1)
		{
			/*         cut it back */
			if (*gwvs > 1e-4)
			{
				*gwvs *= 0.97;
			}
			else
			{
				*gwvs = 0.0;
			}
		}
		
		/*       groundwater outflow(baseflow) */
		if (*agws > 1e-20)
		{
			*agwo = *kgw * (*kvary * *gwvs + 1.0) * *agws;
		}
	}
	else
	{
		if (*agws > 1e-20)
		{
			*agwo = *kgw * *agws;
		}
	}
	
	*agws += ainflo - *agwo;
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate evaporation from retention storage. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     PET    - ??? */
/*     RETS   - ??? */
/*     IMPEV  - ??? */
int CLSPCMODEL::evretn(double *pet, double *rets, double *impev)
{
    if (*rets > 0.0)
	{
		/*       there is something in retention storage to evaporate */
		if (*pet > *rets)
		{
			/*         evaporation from retention storage is limited by */
			/*         quantity available */
			*impev = *rets;
			*rets = 0.0;
		}
		else
		{
			/*         evaporation will not exhaust storage, so empty at potential */
			*impev = *pet;
			*rets -= *impev;
		}
    }
	else
	{
		/*       there is no evaporation from retention storage */
		*impev = 0.0;
    }
	
    return 0;
}


/*     + + + PURPOSE + + + */
/*     Simulate evapotranspiration (ET) */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     PET    - ??? */
/*     BASETP - ??? */
/*     NBLKS  - number of blocks into which pls zones will be subdivided */
/*     UZSN   - upper zone nominal storage */
/*     UZSB   - ??? */
/*     AGWETP - ??? */
/*     KVARY  - ??? */
/*     DAYFG  - flag for first day or day change */
/*     VLEFG  - ??? */
/*     LZETPM - ??? */
/*     MON    - calendar month */
/*     NXTMON - next calendar month */
/*     DAY    - day of month */
/*     NDAYS  - no. of days in this month */
/*     LZSN   - ??? */
/*     DELT60 - simulation time interval in hours */
/*     NBLKSI - ??? */
/*     AGWO   - ??? */
/*     CEPS   - ??? */
/*     UZS    - initial upper zone storage */
/*     AGWS   - ??? */
/*     GWVS   - ??? */
/*     LZETP  - ??? */
/*     RPARM  - ??? */
/*     LZS    - ??? */
/*     REMPET - ??? */
/*     TAET   - ??? */
/*     BASET  - ??? */
/*     CEPE   - ??? */
/*     UZET   - ??? */
/*     UZETB  - ??? */
/*     AGWET  - ??? */
/*     LZET   - ??? */

/*     + + +   + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   ETBASE, EVICEP, ETUZON, ETLZON, ETAGW */
int CLSPCMODEL::evapt(double *pet, double *basetp, int *nblks, double *uzsn, double *agwetp, double *kvary, 
					  int *dayfg, int *vlefg, double *lzetpm, int *mon, int *nxtmon, int *day, int *ndays, 
					  double *lzsn, double *delt60, double *agwo, double *ceps, double *uzs, double *agws, 
					  double *gwvs, double *lzetp, double *rparm, double *lzs, double *rempet, double *taet, 
					  double *baset, double *cepe, double *uzet, double *agwet, double *lzet)
{
	
	/*     Taet is total actual et - inches/ivl */
	
    /*   */
    *taet = 0.0;
	/*     Rempet is remaining potential et - inches/ivl */
    *rempet = *pet;
    if (*rempet > 0.0)
	{
		/*       simulate et from baseflow */
		etbase(basetp, agwo, rempet, taet, baset);
		
		if (*rempet > 0.0)
		{
			/*         simulate evaporation from interception */
			evicep(ceps, rempet, taet, cepe);
			
			if (*rempet > 0.0)
			{
				/*           simulate et from the upper zone */
				etuzon(nblks, uzsn, rempet, uzs,taet,uzet);
				
				if (*rempet > 0.0)
				{
					/*               simulate et from active groundwater */
					etagw(agwetp, kvary, rempet, agws, taet, gwvs, agwet);
				}
				else
				{
					*agwet = 0.0;
				}
			}
			else
			{
				*uzet = 0.0;
				if (*nblks > 1)
				{
					// (sj)					for (i = 0; i < *nblks; ++i)
					//					{
					//						uzetb[i] = 0.0;
					//						/* L10: */
					//					}
				}
				
				*agwet = 0.0;
			}
		}
		else
		{
			*cepe = 0.0;
			*uzet = 0.0;
			if (*nblks > 1)
			{
				//(sj)				for (i = 0; i < *nblks; ++i)
				//				{
				//					uzetb[i] = 0.0;
				//					/* L20: */
				//				}
			}
			
			*agwet = 0.0;
		}
    }
	else
	{
		*baset = 0.0;
		*cepe = 0.0;
		*uzet = 0.0;
		if (*nblks > 1)
		{
			//			for (i = 0; i < *nblks; ++i)
			//(sj)			{
			//				uzetb[i] = 0.0;
			//				/* L30: */
			//			}
		}
		
		*agwet = 0.0;
    }
	
	/*     Et from lower zone is handled here because it must be called */
	/*     every interval to make sure that seasonal variation in */
	/*     parameter LZETP and recalculation of RPARM are correctly done */
	/*     simulate ET from the lower zone */
    etlzon(dayfg, vlefg, mon, day, &lzetpm[0], nxtmon, ndays, lzsn, delt60,
		lzetp, rempet, rparm, lzs, taet, lzet);
	
    return 0;
}


/*     + + + PURPOSE + + + */
/*     Simulate ET from the upper zone */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     NBLKS  - number of blocks into which pls zones will be subdivided */
/*     UZSN   - upper zone nominal storage */
/*     NBLKSI - ??? */
/*     REMPET - ??? */
/*     UZS    - initial upper zone storage */
/*     UZSB   - ??? */
/*     TAET   - ??? */
/*     UZET   - ??? */
/*     UZETB  - ??? */

/*     + + +   + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   ETUZS */
int CLSPCMODEL::etuzs(double *uzsn, double *rempet, double *uzs, double *uzet)
{
    double uzrat=0.0, uzpet=0.0;
	
    if (*uzs > 0.001)
	{
		/*       there is et from the upper zone */
		/*       estimate the uzet opportunity */
		uzrat = *uzs / *uzsn;
		if (uzrat > 2.0)
		{
			uzpet = *rempet;
		}
		else
		{
			uzpet = uzrat * 0.5 * *rempet;
		}
		
		/*       calculate the actual et */
		if (uzpet > *uzs)
		{
			/*         upper zone et is limited by quantity available */
			*uzet = *uzs;
			*uzs = 0.0;
		}
		else
		{
			/*         upper zone et will not exhaust storage, so empty at */
			/*         potential */
			*uzet = uzpet;
			*uzs -= *uzet;
		}
    }
	else
	{
		/*       there is no et from upper zone */
		*uzet = 0.0;
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate ET from the lower zone. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     DAYFG  - flag for first day or day change */
/*     VLEFG  - ??? */
/*     MON    - calendar month */
/*     DAY    - day of month */
/*     LZETPM - ??? */
/*     NXTMON - next calendar month */
/*     NDAYS  - no. of days in this month */
/*     LZSN   - ??? */
/*     DELT60 - simulation time interval in hours */  
/*     LZETP  - ??? */
/*     REMPET - ??? */
/*     RPARM  - ??? */
/*     LZS    - ??? */
/*     TAET   - ??? */
/*     LZET   - ??? */

/*     + + +   + + + */

/*     + + + FUNCTIONS + + + */

/*     + + + INTRINSICS + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   DAYVAL */
int CLSPCMODEL::etlzon(int *dayfg, int *vlefg, int *mon, int *day, double *lzetpm, int *nxtmon, int *ndays, double *lzsn, double *delt60, double *lzetp, double *rempet, double *rparm, double *lzs, double *taet, double *lzet)
{
    /*   */
    double lzpet;
	
    /*   */
    if (*dayfg == 1)
	{
		/*       it is the first interval of the day */
		if (*vlefg == 1)
		{
			/*         lower zone et parameter is allowed to vary throughout the */
			/*         year */
			/*         interpolate for the daily value */
			/*         linearly interpolate lzetp between two values from the */
			/*         monthly array lzetpm(12) */
			*lzetp = dayval(&lzetpm[*mon], &lzetpm[*nxtmon], day, ndays);
		}
		else
		{
			/*         lower zone et parameter does not vary throughout the year. */
			/*         lzetp value has been supplied by the run interpreter */
		}
		
		/*       it is time to recalculate et opportunity parameter */
		/*       rparm is max et opportunity - inches/ivl */
		*rparm = 0.25 / (1.0 - *lzetp) * (*lzs / *lzsn) * *delt60 / 24.0;
    }
	
    if (*rempet > 0.0)
	{
		/*       there remains an et demand */
		if (*lzs > 0.02)
		{
			/*         assume et can take place */
			if ((fabs(*lzetp - 1.0)) <= 1e-5)
			{
				/*           special case - will try to draw et from whole land */
				/*           segment at remaining potential rate */
				lzpet = *rempet;
			}
			else
			{
				/*           usual case - desired et will vary over the whole land seg */
				if (*rempet > *rparm)
				{
					/*potential exceeds opportunity */
					lzpet = *rparm * 0.5;
				}
				else
				{
					/*             potential exceeds opportunity over only part of the */
					/*             land segment */
					lzpet = *rempet * (1.0 - *rempet / (*rparm * 2.0));
				}
				
				if (*lzetp < 0.5)
				{
					/* reduce the et to account for area devoid of vegetation */
					lzpet = lzpet * 2.0 * *lzetp;
				}
				
			}
			
			if (lzpet < *lzs - 0.02)
			{
				/*           lower zone et will not exhaust storage, so empty at */
				/*           potential */
				*lzet = lzpet;
			}
			else
			{
				/*           lower zone et is limited by quantity available */
				*lzet = *lzs - 0.02;
			}
			
			/*         update variables */
			*lzs -= *lzet;
			*taet += *lzet;
			*rempet -= *lzet;
		}
		else
		{
			/*         assume no et can take place */
			*lzet = 0.0;
		}
	}
	else
	{
		/*       no more et demand */
		*lzet = 0.0;
    }
	
    return 0;
	
}

/*     + + + PURPOSE + + + */
/*     Simulate ET from baseflow. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     BASETP - ??? */
/*     AGWO   - ??? */
/*     REMPET - ??? */
/*     TAET   - ??? */
/*     BASET  - ??? */

/*     + + +   + + + */

int CLSPCMODEL::etbase(double *basetp, double *agwo, double *rempet, double *taet, double *baset)
{
    double baspet = 0.0;
	
    if (*basetp > 0.0)
	{
		/*       there is et from baseflow */
		baspet = *basetp * *rempet;
		if (baspet > *agwo)
		{
			/*         baseflow et is limited by quantity available */
			*baset = *agwo;
			*agwo = 0.0;
		}
		else
		{
			/*         baseflow et will not exhaust storage, so empty at potential */
			*baset = baspet;
			*agwo -= *baset;
		}
		
		/*       update totals */
		*taet += *baset;
		*rempet -= *baset;
    }
	else
	{
		/*       no et from baseflow */
		*baset = 0.0;
    }
	
    return 0;
}


/*     + + + PURPOSE + + + */
/*     Simulate ET from active groundwater storage. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     AGWETP - ??? */
/*     KVARY  - ??? */
/*     REMPET - ??? */
/*     AGWS   - ??? */
/*     TAET   - ??? */
/*     GWVS   - ??? */
/*     AGWET  - ??? */

/*     + + +   + + + */

/*     + + + INTRINSICS + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::etagw(double *agwetp, double *kvary, double *rempet, double *agws, double *taet, double *gwvs, double *agwet)
{
    double gwpet = 0.0;
	
	
	
	/*     Agwetp is the input parameter governing et from active groundwater */
    if (*agwetp > 0.0)
	{
		/*       there is et from groundwater */
		/*       determine remaining capacity */
		gwpet = *rempet * *agwetp;
		
		if (gwpet > *agws)
		{
			/*         groundwater et is limited by quantity available */
			*agwet = *agws;
			*agws = 0.0;
		}
		else
		{
			/*         groundwater et will not exhaust storage, so empty at */
			/*         potential */
			*agwet = gwpet;
			*agws -= *agwet;
		}
		
		/*       update variables */
		if (fabs(*kvary) > 0.0)
		{
			*gwvs -= *agwet;
		}
		*taet += *agwet;
		*rempet -= *agwet;
    }
	else
	{
		/*       there is no et from groundwater */
		*agwet = 0.0;
    }
	
    return 0;
}


//     + + + PURPOSE + + +  
//     Determine the divisions of the quantities of the moisture supply  
//     above and below the "infiltration" line or the "infiltration +  
//     interflow" line in the infiltration/interflow/surface runoff  
//     figure.  This routine is used either to simulate the behavior of  
//     an individual block of the land segment or the entire land  
//     segment.  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     MIN    - ???  
//     MAX    - ??? 
//     MSUPY  - ??? 
//     OVER   - ??? 
//     UNDER  - ??? 

int CLSPCMODEL::divisn(double *min, double *max, double *msupy, double *over, double *under)
{
    if (*msupy <= *min)
	{
		/* msupy line is entirely below other line */
		*under = *msupy;
		*over =  0.0;
    }
	else
	{
		if (*msupy > *max)
		{
			/*msupy line is entirely above other line */
			*under = (*min + *max) * 0.5;
			*over = *msupy - *under;
		}
		else
		{
			/*msupy line crosses the other line */
			/* Computing 2nd power */
			*over = (*msupy - *min)*(*msupy - *min)* 0.5 / (*max - *min);
			*under = *msupy - *over;
		}
    }
    return 0;
}

//     + + + PURPOSE + + +  
//     This is a subsidiary subroutine for computing upper zone behavior  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     UZSN   - upper zone nominal storage  
//     UZI    - ???  
//     INFILT - ??? 
//     INFFAC - ??? 
//     LZRAT  - ??? 
//     UZS    - initial upper zone storage  
//     PERC   - ???  

int CLSPCMODEL::uzones(double *uzsn, double *uzi, double *infilt, double *inffac, double *lzrat, double *uzs, double *perc)
{
    double uzrat = 0.0;
	
	// percolation will be based on UZRAT at the start of the interval  
    uzrat = *uzs / *uzsn;
	
	// add inflow to UZS  
    *uzs += *uzi;
	
	// percolation  
    if (uzrat - *lzrat > 0.01)
	{
		// simulate percolation  
		// units of perc are inches/ivl 
		// Computing 3rd power  
		
		*perc = *infilt * 0.1 * *inffac * *uzsn * ((uzrat - *lzrat) * ((uzrat - *lzrat) * (uzrat - *lzrat)));
		
		if (*perc > *uzs)
		{
			// computed value is too high so merely empty storage  
			*perc = *uzs;
			*uzs = 0.0;
		}
		else
		{
			// computed value is ok  
			*uzs -= *perc;
		}
    }
	else
	{
		// assume there is no percolation  
		*perc = 0.0;
    }
	
    return 0;
	
}

//     + + + PURPOSE + + +  
//     Dispose of moisture supply on either an individual block of  
//     the land segment or on an entire land segment.  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     IMIN   - ??? 
//     IMAX   - ??? 
//     RATIO  - ??? 
//     MSUPY  - ??? 
//     UZSN   - upper zone nominal storage  
//     UZS    - initial upper zone storage  
//     DELT60 - simulation time interval in hours     
//     DEC    - ??? 
//     SRC    - ??? 
//     UZRA   - ??? 
//     INTGRL - Table used to do integration in upzone, not used if UZINF is not called  
//     RTOPFG - ??? 
//     UZFG   - ??? 
//     LSNO   - line number in the opn sequence block of uci  
//     MESSU  - ftn unit no. to be used for printout of messages  
//     MSGFL  - fortran unit number of error message file  
//     SURS   - ??? 
//     ECNT1  - ??? 
//     INFIL  - ??? 
//     UZI    - ??? 
//     IFWI   - ??? 
//     SURO   - ??? 
//     DATIM  - date and time of day  

int CLSPCMODEL::dispos(double *imin, double *imax, double *ratio, double *msupy, 
					   double *uzsn, double *uzs, double *delt60, double *dec, 
					   double *src, int *rtopfg, int *uzfg, double *surs, 
					   double *infil, double *uzi, double *ifwi, double *suro)
{
    double undri = 0.;
	double overi = 0.;
	
	// determine how much of the MSUPY falls above and below the  
	// infiltration line in the infiltration/interflow/surface runoff  
	// figure  

    divisn(imin, imax, msupy, &overi, &undri);
	
	// the quantity under I is infiltrated moisture  
    *infil = undri;
    if (overi > 0.0)
	{
		// there is some potential interflow inflow and maybe surface  
		// detention/outflow -- the sum of these is potential direct  
		// runoff  
		double pdro = overi;
		// determine how much of this potential direct runoff will  
		// be taken by the upper zone  
		// force uzfg = 1, comment call uzinf. We will deal with uzfg = 0 later (sj)  
		
		if (*uzfg == 0)
		{
			//	uzinf(&pdro, uzsn, uzs, &uzra[0], &intgrl[0], lsno, messu, msgfl,
			//			 &datim[0], ecnt1, uzi);
		}
		else
		{
			uzinf2(&pdro, uzsn, uzs, uzi);
		}
		
		if (*uzi > pdro)
			*uzi = pdro;
		
		double uzfrac = *uzi / pdro;
		
		// determine how much of the msupy falls above and below the  
		// "infiltration + interflow" line in the infiltration/  
		// interflow/surface runoff figure. the prefix "ii" is used on  
		// variables associated with this line  
		double iimin = *imin * *ratio;
		double iimax = *imax * *ratio;
		double undrii = 0.;
		double overii = 0.;
		divisn(&iimin, &iimax, msupy, &overii, &undrii);
		
		// psur is potential surface detention/runoff  
		double psur = overii;
		// pifwi is potential interflow inflow  
		double pifwi = pdro - psur;
		*ifwi = pifwi * (1.0 - uzfrac);
		
		if (psur > 0.0)
		{
			// there will be something on or running off the surface  
			// reduce it to account for the upper zone's share  
			psur *= (1.0 - uzfrac);
			
			// determine how much of this potential surface detention/  
			// outflow will run off in this time interval  
			proute(&psur, rtopfg, delt60, dec, src, surs,suro);
		}
		else
		{
			// there is nothing to store on the surface or to run off  
			*surs = 0.0;
			*suro = 0.0;
		}
    }
	else
	{
		// there is no potential direct runoff or contribution to the  
		// upper zone  
		*surs = 0.0;
		*suro = 0.0;
		*ifwi = 0.0;
		*uzi =  0.0;
    }
	
    return 0;
}

// + + + PURPOSE + + + 
// Distribute the water available for infiltration and runoff -  
// units of fluxes are in./ivl  

// + + + DUMMY ARGUMENTS + + +  

// + + + ARGUMENT DEFINITIONS + + +  
// LZRAT  - ???  
// INFILT - ??? 
// INFEXP - ??? 
// INFFAC - ??? 
// INFILD - ??? 
// FSMSFG - ??? 
// DAYFG  - flag for first day or day change  
// VNNFG  - ???  
// NSURM  - ??? 
// LSUR   - ??? 
// SLSUR  - ??? 
// VIFWFG - ??? 
// INTFWM - ??? 
// NBLKS  - number of blocks into which pls zones will be subdivided  
// MSUPY  - ???  
// MSUPYB - ???  
// UZSN   - upper zone nominal storage  
// UZS    - initial upper zone storage  
// DELT60 - simulation time interval in hours      
// UZRA   - ???  
// INTGRL - ??? 
// RTOPFG - ??? 
// UZFG   - ??? 
// UZSB   - ??? 
// MON    - calendar month  
// NXTMON - next calendar month  
// DAY    - day of month  
// NDAYS  - no. of days in this month  
// NBLKSI - ???  
// LSNO   - line number in the opn sequence block of uci  
// MESSU  - ftn unit no. to be used for printout of messages  
// MSGFL  - fortran unit number of HSPF message file  
// DEC    - ???  
// SRC    - ??? 
// NSUR   - ??? 
// INTFW  - ??? 
// SURS   - ??? 
// SURSB  - ??? 
// ECNT1  - ??? 
// INFIL  - ??? 
// UZI    - ??? 
// IFWI   - ??? 
// SURO   - ??? 
// INFILB - ??? 
// UZIB   - ??? 
// IFWIB  - ??? 
// SUROB  - ??? 
// DATIM  - date and time of day  

// + + +   + + +  

// + + + FUNCTIONS + + +  

// + + + INRINSICS + + +  

// + + + C   EXTERNALALS + + +  
// EXTERNAL   DAYVAL,DISPOS  

int CLSPCMODEL::surfac(double *lzrat, double *infilt, double *infexp, double *inffac, 
					double *infild, int *fsmsfg, int *dayfg, int *vnnfg, double *nsurm, 
					double *lsur, double *slsur, int *vifwfg, double *intfwm, int *nblks, 
					double *msupy, double *uzsn, double *uzs, double *delt60, int *rtopfg, 
					int *uzfg, int *mon, int *nxtmon, int *day, int *ndays, double *dec, 
					double *src, double *nsur, double *intfw, double *surs, double *infil, 
					double *uzi, double *ifwi, double *suro)
{
	// Establish locations of sloping lines on infiltration/inflow/sur  
	// runoff figure.  Prefix "I" refers to "infiltration" line  
	// Ibar is the mean infiltration capacity over the segment  
	// internal units of INFILT are inches/ivl  
	
    double d1   = *lzrat;
    double d2   = *infexp;
    double ibar = *infilt / (pow(d1, d2)+1.0e-9);
	
    if (*inffac < 1.0)
		// adjust ibar to account for frozen ground  
		ibar *= *inffac;
	
	// find the maximum and minimum infiltration capacities  
    double imax = ibar * *infild;
	
	// Infild is an input parameter - ratio of maximum to mean  
	// infiltration capacity  
    double imin = ibar - (imax - ibar);
	
	if (*fsmsfg == 1 || *dayfg == 1)
	{
		// it is time to recompute any varying parameters  
		if (*vnnfg == 1)
			// mannings n is allowed to vary throughout the year  
			// interpolate for the daily value  
			// linearly interpolate nsur between two values from the  
			// monthly array nsurm(12)  
			*nsur = dayval(&nsurm[*mon], &nsurm[*nxtmon], day, ndays);
		
		// calculate parameters for routing surface runoff  
		d1 =  (*nsur * *lsur / sqrt(*slsur));
		*dec = pow(d1, 0.6) * 0.00982;
		*src = (sqrt(*slsur) / (*nsur * *lsur)) * 1020.0;
		
		if (*vifwfg == 1)
		{
			// interflow parmeters are allowed to vary throughout the year  
			// interpolate for the daily value  
			// linearly interpolate intfw between two values from the  
			// monthly array intfwm(12)  
			*intfw = dayval(&intfwm[*mon], &intfwm[*nxtmon], day, ndays);
		}
		else
		{
			// interflow parameter does not vary throughout the year.  
			// intfw value has been supplied by the run interpreter  
		}
    }
	
	// Ratio is the ratio of the ordinates of the "infiltration + interflow" 
	// line to those of the "infiltration" line  
    d1 = *lzrat;
    double ratio = *intfw * pow(2.0, d1);
	
    if (ratio <= 1.0)
		ratio = 1.0001;
	
	// now allocate the water among the alternative destinations  
    if (*nblks == 1)
	{
		if(*infilt > LIMITNUM)	// pervious land
		{
			// surface and near-surface zones of the land-segment have  
			// not been subdivided into blocks  
			// determine what happens to the moisture supply  
			dispos(&imin, &imax, &ratio, msupy, uzsn, uzs, delt60, dec, src,
				rtopfg, uzfg, surs, infil, uzi, ifwi, suro);
        }
		else	// impervious land
		{
			double psur = *msupy;
			proute(&psur, rtopfg, delt60, dec, src, surs,suro);
		}
    }
	else
	{
		// surface and near surface zones of the land segment have  
		// been subdivided into blocks - handle them one at a time and  
		// use mean values to indicate overall response of the land  
		// segment  
		// initialize variables which indicate overall behavior  
		//
		// comment out following option (sj)
		//
		//	*infil = 0.0;
		//	*uzi = 0.0;
		//	*ifwi = 0.0;
		//	*surs = 0.0;
		//	*suro = 0.0;
		
		//	for (int ii = 0; ii < *nblks; ++ii)
		//	{
		//		// find, by interpolation, the minimum and maximum values  
		//		// of the "infiltration" line in the infiltration/interflow/  
		//		// surface runoff figure, for this block  
		//		double delti = (imax - imin) * *nblksi;
		//		int i4 = ii - 1;
		//		double imnb = imin +  i4 * delti;
		//		double imxb = imnb + delti;
		
		//		// determine what happens to the moisture supply on this block  
		//		dispos(&imnb, &imxb, &ratio, &msupyb[ii], uzsn, &uzsb[ii],
		//			delt60, dec, src, &uzra[0], &intgrl[0], rtopfg, uzfg,
		//			/* lsno, messu, msgfl, */ &datim[0], &sursb[ii], /* ecnt1, */ &
		//			infilb[ii], &uzib[ii], &ifwib[ii], &surob[ii]);
		
		//		// accumulate values across the various blocks  
		//		*infil += infilb[ii];
		//		*uzi += uzib[ii];
		//		*ifwi += ifwib[ii];
		//		*surs += sursb[ii];
		//		*suro += surob[ii];
		//	}
		
		//	// convert accumulated values to mean values  
		//	*infil *= *nblksi;
		//	*uzi *= *nblksi;
		//	*ifwi *= *nblksi;
		//	*surs *= *nblksi;
		//	*suro *= *nblksi;
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Linearly interpolate a value for this day (DAYVAL), given */
/*     values for the start of this month and next month (MVAL1 and */
/*     MVAL2).  ndays is the number of days in this month. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     MVAL1  - ??? */
/*     MVAL2  - ??? */
/*     DAY    - day of month */
/*     NDAYS  - no. of days in this month */
double CLSPCMODEL::dayval(double *mval1, double *mval2, int *day, int *ndays)
{
    double rday, rndays;
	
    rday = *day;
    rndays = *ndays;
    return *mval1 + (*mval2 - *mval1) * (rday - 1) / rndays;
}

/*     + + + PURPOSE + + + */
/*     Simulate ET from the upper zone */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     NBLKS  - number of blocks into which pls zones will be subdivided */
/*     UZSN   - upper zone nominal storage */
/*     NBLKSI - ??? */
/*     REMPET - ??? */
/*     UZS    - initial upper zone storage */
/*     UZSB   - ??? */
/*     TAET   - ??? */
/*     UZET   - ??? */
/*     UZETB  - ??? */


/*     + + +   + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   ETUZS */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::etuzon(int *nblks, double *uzsn, double *rempet, double *uzs, double *taet, double *uzet)
{
    /*   */
	
    /*   */
    if (*nblks == 1)
	{
		/*       surface and near-surface zones of the land segment have not */
		/*       been subdivided into blocks */
		etuzs(uzsn, rempet, uzs, uzet);
		
		/*       update totals */
		*taet += *uzet;
		*rempet -= *uzet;
    }
	else
	{
		/*       surface and near-surface zones of the land segment have */
		/*       been subdivided into blocks */
		/*       initialize segment-wide variables */
		//		*uzet = 0.0;
		//		*uzs = 0.0;
		//
		//		for (i = 0; i < *nblks; ++i)
		//		{
		//			etuzs(uzsn, rempet, &uzsb[i], &uzetb[i]);
		//
		//			*uzs += uzsb[i];
		//			*uzet += uzetb[i];
		//			/* L10: */
		//		}
		//
		//		/*       convert total to segment average */
		//		*uzs *= *nblksi;
		//		*uzet *= *nblksi;
		//
		//		/*       update totals */
		//		*taet += *uzet;
		//		*rempet -= *uzet;
    }
	
    return 0;
	
}

/*     + + + PURPOSE + + + */
/*     Compute inflow to upper zone during this interval, using */
/*     "fully forward" type algorithm  as used in HSPX,ARM and NPS. */
/*     Note:  although this method should give results closer to those */
/*     produced by HSPX, etc , its output will be more sensitive to */
/*     Delt than that given by subroutine uzinf */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     PDRO   - ??? */
/*     UZSN   - upper zone nominal storage */
/*     UZS    - initial upper zone storage */
/*     UZI    - ??? */
int CLSPCMODEL::uzinf2(double *pdro, double *uzsn, double *uzs, double *uzi)
{
    /*   */
    double k1, k2, uzrat, uzfrac;
	
    uzrat = *uzs / *uzsn;
	
    if (uzrat < 2.0)
	{
		k1 = 3.0 - uzrat;
		uzfrac = 1.0 - uzrat * 0.5 * pow(1.0 / (k1 + 1.0),k1);
    }
	else
	{
		k2 = uzrat * 2.0 - 3.;
		uzfrac = pow(1.0/(k2 + 1.0), k2);
    }
	
    *uzi = *pdro * uzfrac;
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate upper zone behavior. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     NBLKS  - number of blocks into which pls zones will be subdivided */
/*     UZSN   - upper zone nominal storage */
/*     UZI    - ??? */
/*     UZIB   - ??? */
/*     INFILT - ??? */
/*     INFFAC - ??? */
/*     LZRAT  - ??? */
/*     NBLKSI - ??? */
/*     UZS    - initial upper zone storage */
/*     UZSB   - ??? */
/*     PERC   - ??? */
/*     PERCB  - ??? */

/*     + + +   + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   UZONES */
int CLSPCMODEL::uzone(int *nblks, double *uzsn, double *uzi, double *infilt, double *inffac, double *lzrat, double *uzs, double *perc)
{
    /*   */
    /*   */
    if (*nblks == 1)
	{
		/*       surface and near-surface zones of the land segment have not */
		/*       been subdivided into blocks */
		uzones(uzsn, uzi, infilt, inffac, lzrat, uzs, perc);
    }
	else
	{
		// comment out following option (sj)
		
		//		/*       surface and near-surface zones of the land segment have */
		//		/*       been subdivided into blocks */
		//		/*       initialize segment-wide variables */
		//		*uzs = 0.0;
		//		*perc = 0.0;
		//
		//
		//		for (i = 0; i < *nblks; ++i)
		//		{
		//			uzones(uzsn, &uzib[i], infilt, inffac, lzrat, &uzsb[i], &percb[i]);
		//			*uzs += uzsb[i];
		//			*perc += percb[i];
		//		/* L10: */
		//		}
		//		/*       convert totals to averages */
		//		*uzs *= *nblksi;
		//		*perc *= *nblksi;
    }
	
    return 0;
}

	//SUBROUTINE TOPLAY

	//+ + + PURPOSE + + +
	//Estimate the moisture and the fraction of solutes being
	//transported in the topsoil (surface layer and upper
	//layer)

	//+ + + DUMMY ARGUMENTS + + +
	//REAL       CFINMA,FRAC(5),IFWI,IFWO,IFWS,INFIL,MST(3),
	//$           PERC,SLMPF,SURI,SURO,SURSS,ULPF,UZI,UZS,UZSN

	//+ + + ARGUMENT DEFINITIONS + + +
	//SURSS  - ???
	//SURI   - ???
	//CFINMA - ???
	//SURO   - surface output
	//INFIL  - ???
	//IFWI   - ???
	//UZI    - ???
	//SLMPF  - ???
	//UZS    - initial upper zone storage
	//ULPF   - ???
	//PERC   - ???
	//UZSN   - upper zone nominal storage
	//IFWS   - ???
	//IFWO   - ???
	//MST    - ???
	//FRAC   - ???

	//+ + + END SPECIFICATIONS + + +

	//note that this subroutine only affects elements 1-3 of mst and
	//elements 1-5 of frac

	//******************************************************
	//warning,  the equations in this subroutine are based
	//on those in the arm model.  some of the equations are
	//not dimensionally homogeneous.  for example:
	//	smst( )= surss(inches) + suri(inches/interval)
	//thus, the results obtained for solute movement,
	//particularly in the surface & upper layers, will
	//probably be highly dependent on the simulation time
	//interval (delt).  the arm model used delt of 5 mins
	//and (occasionally) of 15 mins.
	//******************************************************
/* 
int CLSPCMODEL::TOPLAY(double SURSS,double SURI,double CFINMA,double SURO,double INFIL,
					double IFWI,double UZI,double SLMPF,double UZS,double ULPF,double PERC,
					double UZSN,double IFWS,double IFWO,double *MST,double *FRAC)
{
	//find the surface layer moisture storage
	double SMST = SURSS + SURI;
	double SMSTM = 0.0;
	double FSO = 0.0;
	double SDOWN = 0.0;
	double FSP = 0.0;
	double UMSTM = 0.0;
	double FII = 0.0;
	double UDOWN = 0.0;
	double ULMPF = 0.0;
	double FUP = 0.0;
	double FIO = 0.0;
 
    if (SMST > 0.0) 
	{
        //there is surface layer moisture storage
        //convert surface layer moisture storage to mass/area units
        SMSTM = SMST * CFINMA;
 
        //determine the fraction of the surface layer solute in
        //storage being removed in surface runoff
        FSO = SURO / SMST;
 
        //total downward water flux from the surface layer
        SDOWN = INFIL + IFWI + UZI;
 
        //determine the fraction of the surface layer solute in
        //storage being percolated
        //the percolation multiplier factor (slmpf) is inputed not
        //calculated
        FSP = SLMPF * SDOWN / SMST;
	}
	else
	{
        //there is no surface moisture storage, so zero variables
        SMSTM = 0.0;
        FSO   = 0.0;
        FSP   = 0.0;
	}
 
	//find the upper layer principal moisture storage
	double UMST = UZS + (IFWI + PERC + INFIL);
 
    if (UMST > 0.0) 
	{
        //there is upper layer principal moisture storage
        //convert moisture storage to mass/area units
        UMSTM = UMST * CFINMA;
 
        //determine the fraction of the upper layer solute in principal
        //storage going to upper layer transitory (interflow) storage
        FII = IFWI / UMST;
 
        //total downward water flux from the upper layer
        UDOWN = INFIL + PERC;
 
        //calculate the percolating solutes retardation factor
        //for uzs < (uzsn*ulpf)
        ULMPF = UZS / (UZSN * ULPF);
        if (ULMPF > 1.0)  ULMPF = 1.0;
 
        //determine the fraction of the upper layer solute in storage
        //being percolated
        FUP = ULMPF * UDOWN / UMST;
	}
	else
	{
        //there is no upper layer moisture storage, so zero variables
        UMSTM = 0.0;
        FII   = 0.0;
        FUP   = 0.0;
	}
 
	//find upper layer transitory (interflow) moisture storage
	double ISMST = IFWS + IFWO;
	double IMSTM = ISMST * CFINMA;
 
    if (ISMST > 0.0) 
	{
        //there is upper layer transitory (interflow) moisture storage
        //determine the fraction of the upper layer transitory
        //(interflow) solute in storage being removed by interflow
        //outflow
        FIO = IFWO / ISMST;
	}
	else
	{
        FIO = 0.0;
	}
 
	//place computed values in groups
	MST[0]  = SMSTM;
	MST[1]  = UMSTM;
	MST[2]  = IMSTM;
	FRAC[0] = FSO;
	FRAC[1] = FSP;
	FRAC[2] = FII;
	FRAC[3] = FUP;
	FRAC[4] = FIO;
 
	return 0;
}
*/
	//SUBROUTINE SUBLAY

	//+ + + PURPOSE + + +
	//Estimate the moisture and the fraction of solutes being
	//transported in the subsurface layers (lower layer and
	//groundwater layer)

	//+ + + DUMMY ARGUMENTS + + +
	//REAL       AGWI,AGWO,AGWS,CFINMA,FRAC(8),IGWI,LLPF,LZS,LZSN,MST(5)

	//+ + + ARGUMENT DEFINITIONS + + +
	//LZS    - ???
	//IGWI   - ???
	//AGWI   - ???
	//CFINMA - ???
	//LZSN   - ???
	//LLPF   - ???
	//AGWS   - ???
	//AGWO   - ???
	//MST    - ???
	//FRAC   - ???

	//+ + + LOCAL VARIABLES + + +
	//REAL       AMST,AMSTM,FAO,FLDP,FLP,LLMPF,LMST,LMSTM

	//+ + + END SPECIFICATIONS + + +

	//note that this subroutine only affects elements 4 & 5 of mst,
	//elements 6-8 of frac

	//******************************************************
	//warning,  the equations in this subroutine are based
	//on those in the arm model.  some of the equations are
	//not dimensionally homogeneous.  for example:
	//	amst( )= agws(inches) + agwo(inches/interval)
	//thus, the results obtained for solute movement,
	//particularly in the surface & upper layers, will
	//probably be highly dependent on the simulation time
	//interval (delt).  the arm model used delt of 5 mins
	//and (occasionally) of 15 mins.
	//******************************************************
/* 
int CLSPCMODEL::SUBLAY(double LZS,double IGWI,double AGWI,double CFINMA,double LZSN,
					double LLPF,double AGWS,double AGWO,double *MST,double *FRAC)
{
	//find the lower layer moisture storage
	double LMST = LZS + (IGWI + AGWI);
	double LMSTM = 0.0;
	double LLMPF = 0.0;
	double FLP = 0.0;
	double FLDP = 0.0;
	double AMSTM = 0.0;
	double FAO = 0.0;

	if (LMST > 0.0)
	{
		//there is lower layer moisture storage
        //convert lower layer moisture storage to mass/area units
        LMSTM = LMST * CFINMA;
 
        //calculate the percolating solutes retardation factor
        //for lzs < (lzsn*llpf)
		LLMPF = LZS / (LZSN * LLPF);
        if (LLMPF > 1.0)  LLMPF = 1.0;
 
        //determine the fraction of the lower layer solute
        //in storage being percolated
        //to active groundwater
        FLP = LLMPF * AGWI / LMST;
        //to inactive groundwater by deep percolation
        FLDP = LLMPF * IGWI / LMST;
	}
	else
	{
        //there is no lower layer moisture storage so zero variables
        LMSTM= 0.0;
        FLP  = 0.0;
        FLDP = 0.0;
	}
 
	//find the active groundwater moisture storage
	double AMST = AGWS + AGWO;
 
    if (AMST > 0.0)
	{
        //there is active groundwater moisture storage
        //convert to mass units
        AMSTM = AMST * CFINMA;
 
        //determine the fraction of the active groundwater solute
        //in storage being removed by groundwater outflow
        FAO = AGWO / AMST;
	}
	else
	{        
		//there is no active groundwater moisture storage
        AMSTM = 0.0;
        FAO   = 0.0;
	} 

	//place computed values in groups
	MST[3]  = LMSTM;
	MST[4]  = AMSTM;
	FRAC[5] = FLP;
	FRAC[6] = FLDP;
	FRAC[7] = FAO;

	return 0;
}
*/
	//SUBROUTINE   TOPMOV

	//+ + + PURPOSE + + +
	//Move solutes with the water in the topsoil (surface and
	//upper layers) and update storages
/*
int CLSPCMODEL::TOPMOV(double *FRAC, double& SSCM, double& USCM, double& ISCM, double *TSCM)
{

	double DUMMY,FII,FIO,FSO,FSP,FUP,IICM,IOCM,SOCM,SPCM,UPCM;

	//units of fluxes are mass/area-ivl and storages are mass/area,
	//i.e. lbs/acre for english units and kg/ha for metric units

	//assign fractional fluxes to local variables
	FSO= FRAC[0];
	FSP= FRAC[1];
	FII= FRAC[2];
	FUP= FRAC[3];
	FIO= FRAC[4];

	//surface layer
	DUMMY= FSO+ FSP;

	if (SSCM > 1.0E-8 && DUMMY > 0.0) 
	{
		//there is sufficient solute in surface layer storage that is to
		//be moved by water determine the amount in surface (runoff) outflow
		SOCM= SSCM*FSO;

		//determine the amount (leached) percolated from the
		//surface layer storage to upper layer storage
		SPCM= SSCM*FSP;

		//remove from the surface layer storage
		SSCM= SSCM- (SOCM+SPCM);

		if (SSCM < 1.0E-10) 
			//adjust, in case round-off has made storage negative
			SSCM= 1.0E-10;
	}
	else
	{
		//there is either very little solute in the surface layer
		//storage, or there is no water moving from that layer that
		//will transport solute
		SOCM= 0.0;
		SPCM= 0.0;
	}

	//upper layer
	//add solute leached from the surface layer to the upper layer storage
	USCM= USCM+ SPCM;

	DUMMY= USCM+ ISCM;

	if (DUMMY > 1.0E-7) 
	{
		//there is some solute in the upper layer storages (principal
		//and interflow)
		//determine the amount (leached) percolated from the
		//upper layer storage to lower layer storage
		UPCM= USCM*FUP;

		//determine transfer from the upper layer principal storage
		//to the upper layer transitory (interflow) storage
		IICM= USCM*FII;

		//add to interflow storage
		ISCM= ISCM+ IICM;

		//determine amount carried in interflow outflow
		IOCM= ISCM*FIO;

		//remove from interflow storage
		ISCM= ISCM- IOCM;

		if (ISCM < 0.0) 
			//adjust, in case round-off has made storage negative
			ISCM= 0.0;

		//remove solutes from the upper layer principal storage
		USCM= USCM- (IICM+UPCM);

		if (USCM < 0.0) 
			//adjust, in case round-off has made storage negative
			USCM= 0.0;
	}
	else
	{
		//there is very little solute in the upper layer (principal
		//and interflow) storages so zero fluxes
		UPCM= 0.0;
		IICM= 0.0;
		IOCM= 0.0;
	}

	//assign chemical fluxes to "permanent" storage
	TSCM[0]= SOCM;
	TSCM[1]= SPCM;
	TSCM[2]= UPCM;
	TSCM[3]= IICM;
	TSCM[4]= IOCM;

	return 0;
}
*/
	//SUBROUTINE   SUBMOV

	//+ + + PURPOSE + + +
	//Move solutes with the water in the subsurface layers (lower
	//and groundwater layers) and update storages
/*
int CLSPCMODEL::SUBMOV(double UPCM,double FLP,double FLDP,double FAO,double& LSCM,
					   double& ASCM,double *SSCM)
{

	double AOCM,DUMMY,LDPCM,LPCM;

	//units of fluxes are mass/area-ivl and storages are mass/area,
	//i.e. lbs/acre for english units and kg/ha for metric units

	//lower layer

	//add solute percolated (leached) from the upper layer storage
	//to the lower layer
	LSCM= LSCM+ UPCM;

	DUMMY= FLP+ FLDP;

	if (LSCM > LIMITNUM && DUMMY > 0.0) 
	{
		//there is sufficient solute in the lower layer storage that is to
		//be leached determine the amount percolated (leached) from the
		//lower layer storage to the active groundwater storage
		LPCM= LSCM*FLP;

		//determine the amount percolated (leached) from the lower
		//layer storage to the deep (inactive) groundwater sink
		LDPCM= LSCM*FLDP;

		//remove solutes leached from the lower layer
		LSCM= LSCM- (LPCM+LDPCM);

		if (LSCM < 0.0) 
			//adjust, in case round-off has made storage negative
			LSCM= 0.0;
	}
	else
	{
		//there is insufficient solute in the lower layer storage
		//that is leached
		LPCM = 0.0;
		LDPCM= 0.0;
	}

	//groundwater layer
	//inactive groundwater is lost from the system
	//add solute leached from the lower layer to the active
	//groundwater storage
	ASCM= ASCM+ LPCM;

	if (ASCM > LIMITNUM && FAO > 0.0) 
	{
		//there is sufficient solute in the active groundwater storage
		//that is to be moved with water
		//determine solute in active groundwater (baseflow) outflow
		AOCM= ASCM*FAO;

		//remove outflow solutes from storage
		ASCM= ASCM- AOCM;

		if (ASCM < 0.0) 
			//adjust, in case round-off has made storage negative
			ASCM= 0.0;
	}
	else
	{
		//there is insufficient solute in the active groundwater
		//storage that is moved with water
		AOCM= 0.0;
	}

	//assign fluxes to "permanent" array
	SSCM[0]= LPCM;
	SSCM[1]= LDPCM;
	SSCM[2]= AOCM;

	return 0;
}
*/
	//SUBROUTINE   SEDMOV

	//+ + + PURPOSE + + +
	//Move the chemical on/with sediment from the land surface
/*
int CLSPCMODEL::SEDMOV(double FSD,double& SSCM,double& SDCM)
{

	if (SSCM > 0.0) 
	{
		//there is sufficient chemical in the surface storage to
		//be removed on or with the sediment

		//determine the amount of the surface layer chemical
		//removed on sediment - units are mass/area-ivl
		SDCM= SSCM*FSD;

		//remove from the surface layer
		SSCM= SSCM- SDCM;
	}
	else
	{
		//there is insufficient chemical to be removed from the
		//surface storage on or with the sediment
		SDCM= 0.0;
	}

	return 0;
}
*/
	//SUBROUTINE   SDFRAC

	//+ + + PURPOSE + + +
	//Calculate the fraction of the surface layer that is eroding -
	//units are tons/acre-ivl for the amount eroded, sosed, and
	//tons/acre for the amount of surface layer soil, slme
/*
int CLSPCMODEL::SDFRAC(double SOSED,double SLME,double& FSD)
{

     FSD = SOSED/SLME;

     if (FSD > 1.0) 
	 {
       //issue a warning that the amount of eroded soil/sediment
       //is more than the surface layer can supply, and that fsd
       //has been arbitrarily reduced to 1.0
       FSD= 1.0;
	 }
     else if (FSD < 1.0E-05) 
	 {
       //issue a warning that the calculated value of fsd
       //was < 1/100000, so it has been set to zero to avoid
       //problems of continuity errors due to the use of single
       //precision variables
       FSD= 0.0;
     }

	return 0;
}
*/
	//SUBROUTINE   FIRORD

	//+ + + PURPOSE + + +
	//Calculate the adsorption and desorption fluxes using
	//temperature dependent first order kinetics
	//internal units for first order reaction rate parameters
	//(kds,kad) are per interval
/*
int CLSPCMODEL::FIRORD(double TMP,double MOISTM,double KDS,double KAD,double THKDS,
					   double THKAD,double CMSU,double CMAD,double& ADS,double& DES)
{

	double DIF35,KADK,KDSK;

	if (TMP >= 0.0 && MOISTM >= 0.001) 
	{
		//soil layer temperature in deg c is warm enough, and soil
		//moisture in mass/area is sufficient to adsorb/desorb

		if (TMP < 35.0) 
		{
			//soil layer temperature is less than optimum,
			//modify inputted reaction rate parameter
			//decrease inputted reaction rate parameter by use of the
			//modified arrenhius equation
			DIF35= TMP- 35.0;
			KDSK = KDS * pow(THKDS,DIF35);
			KADK = KAD * pow(THKAD,DIF35);
		}
		else
		{
			//temperature is optimum,use inputted reaction rate parameter
			KDSK= KDS;
			KADK= KAD;
		}

		//calculate the actual adsorption and desorption fluxes - units
		//are mass/area-ivl
		ADS= CMSU*KADK;
		DES= CMAD*KDSK;
	}
	else
	{
		//either soil temperature is too cold or the soil layer is
		//too dry, zero fluxes
		ADS= 0.0;
		DES= 0.0;
	}

	return 0;
}
*/
    //SUBROUTINE   PSTEMP

    //+ + + PURPOSE + + +
    //Estimate soil temperatures in a pervious land segment

    //+ + + EXTERNALS + + +
    //EXTERNAL  DAYVAL

    //+ + + END SPECIFICATIONS + + +

int CLSPCMODEL::pstemp(int hrfg,int dayfg,int tsopfg,int msltfg,int miftfg,
					int mgwtfg,int *mon,int *nxtmon,int *day,int *ndays,
					double& aslt,double *asltm,double& bslt,double *bsltm,
					double& aift,double *aiftm,double& bift,double *biftm,
					double& agwt,double *agwtm,double& bgwt,double *bgwtm,
					double airtmp,double& sltmp,double& iftmp,double& gwtmp)
{
	//obtain latest values for temperature calculation parameters
	if (dayfg == 1) 
	{
		//it is the first interval of the day
        if (msltfg == 1) 
		{
			//surface layer temperature regression parameters are
			//allowed to vary throughout the year
			//interpolate for the daily values
			//linearly interpolate aslt between two values from the
			//monthly array asltm(12)
			aslt = dayval(&asltm[*mon],&asltm[*nxtmon],day,ndays);

			//linearly interpolate bslt between two values from the
			//monthly array bsltm(12)
			bslt = dayval(&bsltm[*mon],&bsltm[*nxtmon],day,ndays);
        }
		else
		{
			//surface temperature regression parameters do not vary
			//throughout the year. values for aslt and bslt have been
			//supplied by the run interpreter
        }

        if (miftfg == 1) 
		{
			//upper layer temperature parameters are allowed to
			//vary throughout the year
			//interpolate for the daily values
			//linearly interpolate ultp1 between two values from the
			//monthly array ultp1m(12)
			aift = dayval(&aiftm[*mon],&aiftm[*nxtmon],day,ndays);

			//linearly interpolate ultp2 between two values from the
			//monthly array ultp2m(12)
			bift = dayval(&biftm[*mon],&biftm[*nxtmon],day,ndays);
        }
		else
		{
			//upper layer temperature parameters do not vary throughout
			//the year. values for ultp1 and ultp2 have been supplied by
			//the run interpreter
        }

        if (mgwtfg == 1) 
		{
			//lower layer and groundwater temperature parameters are
			//allowed to vary throughout the year
			//interpolate for the daily value
			//linearly interpolate lgtp1 between two values from the
			//monthly array lgtp1m(12)
			agwt = dayval(&agwtm[*mon],&agwtm[*nxtmon],day,ndays);

			if (tsopfg != 1) 
				//second parameter is needed
				//linearly interpolate lgtp2 between two values from the
				//monthly array lgtp2m(12)
				bgwt = dayval(&bgwtm[*mon],&bgwtm[*nxtmon],day,ndays);
		}
        else
		{
			//lower layer and groundwater temperature parameters do not
			//vary throughout the year. lgtp1 value and lgtp2 value if
			//needed have been supplied by the run interpreter
        }
	}
	//determine soil temperatures - units are deg c
	//temperature of surface layer is always estimated using a
	//linear regression with air temperature

	if (hrfg == 1) 
		//it is time to update surface layer temperature
		sltmp = aslt + bslt * airtmp;

	if (tsopfg == 1) 
	{
		//compute subsurface temperature using regression and
		//monthly values
		if (hrfg == 1) 
		{
			//it is time to update subsurface temperatures
			//temperature of upper layer is computed by regression
			//with air temperature
			iftmp = aift + bift * airtmp;

			//temperature of lower layer and groundwater were
			//interpolated from monthly values
			gwtmp = agwt;
		}
	}
    else
	{
		//tsopfg is 0 or 2
		//compute subsurface temperatures using a mean departure
		//from air temperature plus a smoothing factor -
		//if tsopfg is 2, the lower/gw layer temperature is
		//a function of upper layer temperature instead of
		//air temperature
		iftmp = iftmp + bift*(airtmp + aift - iftmp);

		if (tsopfg == 0) 
			//original method - lower/gw temp based on air temp
			gwtmp = gwtmp + bgwt * (airtmp + agwt - gwtmp);
		else
			//new method for corps of engineers 10/93 -
			//lower/gw temp based on upper temp
			gwtmp = gwtmp + bgwt * (iftmp + agwt - gwtmp);
    }
    return 0;
}


void CLSPCMODEL::pwater()
{
	// increase the number of files to open 
	_setmaxstdio(2048);

	int i,j,k;
	bCalcEnd = false;
	counter = 0;

	CProgressWnd wndProgress(NULL,"LSPC Progress", TRUE);

	if(!NetworkProcess())
		return;

	if (cLU.nLUchangeFlag == 1)
	{
		if(!ProcessLanduseData())
			return;
	}

	if (nPSsummary > 0 && nPtSource > 0)
	{
		if(!ProcessPointSourceSummaryData())
			return;
	}

	int maxEtDays = 1;

	if(irrigfg == 1)	//Irrigation Application Options
	{
		if(curPeriodET != NULL)
			delete []curPeriodET;
		if(curPeriodPrec != NULL)
			delete []curPeriodPrec;
		if(irrigDemand != NULL)
			delete []irrigDemand;
		if(wsIrrigDemand != NULL)
			delete []wsIrrigDemand;
		if(cumulativePrec != NULL)
			delete []cumulativePrec;
		if(cumulativeET != NULL)
			delete []cumulativeET;
		if(nsws > 0 )
		{
			curPeriodET = new double[nsws];
			curPeriodPrec = new double[nsws];
			wsIrrigDemand = new double[nsws];
			for(i=0; i<nsws; i++)
			{
				curPeriodET[i] = 0.0;
				curPeriodPrec[i] = 0.0;
				wsIrrigDemand[i] = 0.0;
			}
			if(nlandp > 0) 
			{
				irrigDemand = new double[nsws*nlandp];				
				for(i=0; i<nsws*nlandp; i++)
				{
					irrigDemand[i] = 0.0;
				}
			}
			
			for(i=0; i<ngroup*nlandp; i++)
				maxEtDays = (maxEtDays < pirriginfop[i].etdays)?pirriginfop[i].etdays:maxEtDays;

			if(nsws * maxEtDays > 0)
			{
				cumulativePrec = new double[nsws * maxEtDays];
				cumulativeET = new double[nsws * maxEtDays];
				for(i=0; i<nsws*maxEtDays; i++)
				{		
					cumulativePrec[i] = 0.0;
					cumulativeET[i] = 0.0;
				}
			}
		}
	}		//Irrigation Application Options End

	double Years = 1;
	double Days = 1;
	double dt = 1;

	COleDateTimeSpan tspan;
	COleDateTimeSpan span;
	ETA *eta = NULL;

	CMainFrame *pWnd = (CMainFrame *)AfxGetMainWnd();
	AssignIndex();
	
	InitialControls();
	
	int nNum = nsws*nlandp;
	double lzsn = 0.,infilt = 0.,kvary = 0.,agwrc = 0.,agwetp = 0.;
	double petmax = 0.,petmin = 0.,infexp = 0.,infild = 0.,deepfr = 0.,basetp = 0.;
	double cepsc = 0.,uzsn = 0.,nsur = 0.,intfw = 0.,irc = 0.,lzetp = 0.;
	double ceps = 0.,surs = 0.,uzs = 0.,ifws = 0.,lzs = 0.,agws = 0.,gwvs = 0.,pers = 0.; 
	double suro = 0.,ifwo = 0.,agwo = 0.,pero = 0.,watin = 0.,watdif = 0.;
	double slsur = 0.,lsur = 0.;
	
	// monthly vary parmaters (global pointers only)
	double *cepscm = NULL;
	double *uzsnm  = NULL;
	double *nsurm  = NULL;
	double *intfwm = NULL;
	double *ircm   = NULL;
	double *lzetpm = NULL;
	
	double remqom[12];
	
    int    *smsfg_p  = NULL;
    int    *fsmsfg_p = NULL;
	double *ifwk1_p = NULL;
	double *ifwk2_p = NULL;
	double *lzfrac_p = NULL;
	double *rlzrat_p = NULL;
	double *rparm_p  = NULL;
	double *dec_p    = NULL;
	double *src_p    = NULL;
	double *ceps_p = NULL;
	double *surs_p = NULL;
	double *uzs_p  = NULL;
	double *ifws_p = NULL;
	double *lzs_p  = NULL;
	double *agws_p = NULL;
	double *gwvs_p = NULL;

	//SUSTAIN external timeseries
	double *suro_sustain = NULL;
	double *ifwo_sustain = NULL;
	double *agwo_sustain = NULL;
	double *agwi_sustain = NULL;
	double *sosed_sustain = NULL;
	double *iosed_sustain = NULL;
	double *aosed_sustain = NULL;
	double *soqual_sustain = NULL;
	double *ioqual_sustain = NULL;
	double *aoqual_sustain = NULL;

	// landuse summary
	double *area_s  = NULL;
	double *precip_s = NULL;
	double *suro_s  = NULL;
	double *ifwo_s  = NULL;
	double *agwo_s  = NULL;
	double *pero_s  = NULL;
	double *taet_s  = NULL;
	double *sedload_s = NULL;
	double *sedwssd_s = NULL;
	double *sedscrs_s = NULL;
	double *sedsuro_s = NULL;
	double *sedifwo_s = NULL;
	double *sedagwo_s = NULL;
	double *suroload_s = NULL;
	double *ifwoload_s = NULL;
	double *agwoload_s = NULL;
	double *uniload_s = NULL;
	double *suniload_s = NULL;
	double *washqsload_s = NULL;
	double *scrqsload_s = NULL;
	double *rqload_s = NULL;

	if (rqname_s != NULL)
	{
		delete []rqname_s;
		rqname_s = NULL;
	}
	if (rqflag_s != NULL)		// to get the selecetd rquals
	{
		delete []rqflag_s;
		rqflag_s = NULL;
	}
	if (q_bfd != NULL)
	{
		delete []q_bfd;
		q_bfd = NULL;
	}

	if(nNum > 0)
	{
		smsfg_p  = new int[nNum];
		fsmsfg_p = new int[nNum];
		ifwk1_p  = new double[nNum];
		ifwk2_p  = new double[nNum];
		lzfrac_p = new double[nNum];
		rlzrat_p = new double[nNum];
		rparm_p  = new double[nNum];
		dec_p    = new double[nNum];
		src_p    = new double[nNum];
		ceps_p   = new double[nNum];
		surs_p   = new double[nNum];
		uzs_p    = new double[nNum];
		ifws_p   = new double[nNum];
		lzs_p    = new double[nNum];
		agws_p   = new double[nNum];
		gwvs_p   = new double[nNum];

		//SUSTAIN external timeseries
		if (nSUSTAIN == 1)
		{
			//baseflow at subwatershed level
			ifwo_sustain = new double[nsws];
			agwo_sustain = new double[nsws];
			//unit-area timeseries at landuse level
			suro_sustain = new double[nNum];
			agwi_sustain = new double[nNum];
			if (sedfg == 1)
			{
				sosed_sustain = new double[nNum];
				//baseflow at subwatershed level
				iosed_sustain = new double[nsws];
				aosed_sustain = new double[nsws];
			}
			if (nQuals > 0 && pqalfg == 1)
			{
				soqual_sustain = new double[nNum*nQuals];
				//baseflow at subwatershed level
				ioqual_sustain = new double[nsws*nQuals];
				aoqual_sustain = new double[nsws*nQuals];
			}
		}

		// landuse summary 
		if(nLUsummary > 0)
		{
			area_s  = new double[nNum];
			precip_s = new double[nNum];
			suro_s  = new double[nNum];
			ifwo_s  = new double[nNum];
			agwo_s  = new double[nNum];
			pero_s  = new double[nNum];
			taet_s  = new double[nNum];

			if (sedfg == 1)
			{
				sedload_s = new double[nNum];
				sedwssd_s = new double[nNum];
				sedscrs_s = new double[nNum];
				sedsuro_s = new double[nNum];
				sedifwo_s = new double[nNum];
				sedagwo_s = new double[nNum];
			}

			if (nQuals > 0 && pqalfg == 1)
			{
				suroload_s = new double[nNum*nQuals];
				ifwoload_s = new double[nNum*nQuals];
				agwoload_s = new double[nNum*nQuals];
				uniload_s = new double[nNum*nQuals];
				suniload_s = new double[nNum*nQuals];
				washqsload_s = new double[nNum*nQuals];
				scrqsload_s = new double[nNum*nQuals];
			}
			if (oxfg == 1)
			{
				rqload_s = new double[nNum*11];	// rqual numbers are 11
				rqname_s = new CString[11];		// rqual name for land summary
				rqflag_s = new int[11];
			}
		}

		// initialized to zero
		for(i=0; i<nNum; i++)
		{
			smsfg_p[i]  = 0;
			fsmsfg_p[i] = 0;
			ifwk1_p[i]  = 0.0;
			ifwk2_p[i]  = 0.0;
			lzfrac_p[i] = 0.0;
			rlzrat_p[i] = 0.0;
			rparm_p[i]  = 0.0;
			dec_p[i]    = 0.0;
			src_p[i]    = 0.0;
			ceps_p[i]	= 0.0;
			surs_p[i]   = 0.0;
			uzs_p[i]    = 0.0;
			ifws_p[i]   = 0.0;
			lzs_p[i]    = 0.0;
			agws_p[i]   = 0.0;
			gwvs_p[i]   = 0.0;
		}

		//SUSTAIN external timeseries
		if (nSUSTAIN == 1)
		{
			for(i=0; i<nsws; i++)
			{
				ifwo_sustain[i] = 0.0;
				agwo_sustain[i] = 0.0;
				if (sedfg == 1)
				{
					iosed_sustain[i] = 0.0;
					aosed_sustain[i] = 0.0;
				}
				if (nQuals > 0 && pqalfg == 1)
				{
					for(j=0; j<nQuals; j++)
					{
						ioqual_sustain[i*nQuals+j] = 0.0;
						aoqual_sustain[i*nQuals+j] = 0.0;
					}
				}
			}

			for(i=0; i<nNum; i++)
			{
				suro_sustain[i] = 0.0;
				agwi_sustain[i] = 0.0;
				
				if (sedfg == 1)
					sosed_sustain[i] = 0.0;

				if (nQuals > 0 && pqalfg == 1)
				{
					for(j=0; j<nQuals; j++)
						soqual_sustain[i*nQuals+j] = 0.0;
				}
			}
		}

		// landuse summary
		if(nLUsummary > 0)
		{
			for(i=0; i<nNum; i++)
			{
				area_s[i] = 0.0;
				precip_s[i] = 0.0;
				suro_s[i]  = 0.0;
				ifwo_s[i]  = 0.0;
				agwo_s[i]  = 0.0;
				pero_s[i]  = 0.0;
				taet_s[i]  = 0.0;

				if (sedfg == 1)
				{
					sedload_s[i] = 0.0;
					sedwssd_s[i] = 0.0;
					sedscrs_s[i] = 0.0;
					sedsuro_s[i] = 0.0;
					sedifwo_s[i] = 0.0;
					sedagwo_s[i] = 0.0;
				}
			}
			if (nQuals > 0 && pqalfg == 1)
			{
				for(i=0; i<nNum*nQuals; i++)
				{
					suroload_s[i]  = 0.0;
					ifwoload_s[i]  = 0.0;
					agwoload_s[i]  = 0.0;
					uniload_s[i]  = 0.0;
					suniload_s[i] = 0.0;
					washqsload_s[i] = 0.0;
					scrqsload_s[i] = 0.0;
				}
			}
			if (oxfg == 1)
			{
				for(i=0; i<nNum*11; i++)
					rqload_s[i]  = 0.0;
				rqname_s[0] = "BOD";
				rqname_s[1] = "NOX";
				rqname_s[2] = "TAM";
				rqname_s[3] = "SNH4";
				rqname_s[4] = "PO4";
				rqname_s[5] = "SPO4";
				rqname_s[6] = "ORN";
				rqname_s[7] = "ORP";
				rqname_s[8] = "ORC";
				rqname_s[9] = "DO";
				rqname_s[10] = "CO2";
				for(i=0; i<11; i++)
					rqflag_s[i] = 0;

				for(j=0; j<nsws; j++)
				{
					int rgroup = pReachInfo[j].rgid - 1;	// nsws=nch  
					for(k=0; k<nlandp; k++)
					{
						for(int m=0; m<nQuals; m++)	
						{
							for(int n=0; n<4; n++)	
							{
								if (land_mapp[rgroup*nQuals*4+m*4+n].bod > 0)
									rqflag_s[0]++;
								if (land_mapp[rgroup*nQuals*4+m*4+n].nox > 0)
									rqflag_s[1]++;
								if (land_mapp[rgroup*nQuals*4+m*4+n].tam > 0)
									rqflag_s[2]++;
								if (land_mapp[rgroup*nQuals*4+m*4+n].snh4 > 0)
									rqflag_s[3]++;
								if (land_mapp[rgroup*nQuals*4+m*4+n].po4 > 0)
									rqflag_s[4]++;
								if (land_mapp[rgroup*nQuals*4+m*4+n].spo4 > 0)
									rqflag_s[5]++;
								if (land_mapp[rgroup*nQuals*4+m*4+n].orn > 0)
									rqflag_s[6]++;
								if (land_mapp[rgroup*nQuals*4+m*4+n].orp > 0)
									rqflag_s[7]++;
								if (land_mapp[rgroup*nQuals*4+m*4+n].orc > 0)
									rqflag_s[8]++;
									rqflag_s[9]++;
									rqflag_s[10]++;
							}
						}
					}
				}
			}
		}
	}

	// stream summary 
	double *usif_s  = NULL;		// total upstream inflow (ft^3)
	double *luif_s  = NULL;		// total land inflow (ft^3) 
	double *usifbp_s  = NULL;	// total upstream bypass inflow (ft^3)
	double *luifbp_s  = NULL;	// total land bypass inflow (ft^3) 
	double *psif_s  = NULL;		// pointsource inflow (ft^3)
	double *pswd_s  = NULL;		// pointsource withdrawal (ft^3)
	double *pswddi_s  = NULL;	// pointsource withdrawal diverted (ft^3)
	double *irwd_s  = NULL;		// irrigation withdrawal (ft^3)
	double *ivol_s  = NULL;		// total inflow (ft^3)
	double *ustemp_s   = NULL;
	double *lutemp_s   = NULL;
	double *ustempbp_s   = NULL;
	double *lutempbp_s   = NULL;
	double *pstemp_s   = NULL;
	double *pswdtemp_s = NULL;
	double *pswdtempdi_s = NULL;
	double *irwdtemp_s = NULL;
	double *itemp_s    = NULL;
	double *bersed_s   = NULL;
	double *ussed_s   = NULL;
	double *lused_s   = NULL;
	double *ussedbp_s   = NULL;
	double *lusedbp_s   = NULL;
	double *pssed_s   = NULL;
	double *pswdsed_s = NULL;
	double *pswdseddi_s = NULL;
	double *irwdsed_s = NULL;
	double *ised_s    = NULL;
	double *depscr_ss = NULL;
	double *depmass_ss = NULL;
	double *scrmass_ss = NULL;
	double *bedsed_s  = NULL;
	double *berqual_s = NULL;
	double *usqual_s   = NULL;
	double *luqual_s   = NULL;
	double *usqualbp_s   = NULL;
	double *luqualbp_s   = NULL;
	double *psqual_s   = NULL;
	double *pswdqual_s = NULL;
	double *pswdqualdi_s = NULL;
	double *irwdqual_s = NULL;
	double *adtot_s    = NULL;
	double *iqual_s    = NULL;
	double *adqal_s    = NULL;
	double *dsqal_s    = NULL;
	double *depqal_s    = NULL;
	double *scrqal_s    = NULL;
	double *usrqual_s   = NULL;
	double *lurqual_s   = NULL;
	double *atmsrqual_s = NULL;
	double *usrqualbp_s   = NULL;
	double *lurqualbp_s   = NULL;
	double *psrqual_s   = NULL;
	double *pswdrqual_s = NULL;
	double *pswdrqualdi_s = NULL;
	double *irwdrqual_s = NULL;
	double *irqual_s    = NULL;

	double *usSNH4_s = NULL;
	double *luSNH4_s = NULL;
	double *iSNH4_s = NULL;
	double *DSNH4_s = NULL;
	double *DEPNH4_s = NULL;
	double *SCRNH4_s = NULL;
	double *usSPO4_s = NULL;
	double *luSPO4_s = NULL;
	double *iSPO4_s = NULL;
	double *DSPO4_s = NULL;
	double *DEPPO4_s = NULL;
	double *SCRPO4_s = NULL;
	//benthic release
	double *benNH4_s = NULL;
	double *benPO4_s = NULL;

	if (rqual_s != NULL)
	{
		delete []rqual_s;
		rqual_s = NULL;
	}

	if (nCHsummary > 0)
	{
		int nNumStr = nch;
		if (nNumStr > 0)
		{
			usif_s = new double[nNumStr];
			luif_s = new double[nNumStr];
			usifbp_s = new double[nNumStr];
			luifbp_s = new double[nNumStr];

			if (nPtSource > 0)
			{
				psif_s = new double[nNumStr];
				pswd_s = new double[nNumStr];
				pswddi_s = new double[nNumStr];
			}

			if (irrigfg == 1)
				irwd_s = new double[nNumStr];

			ivol_s = new double[nNumStr];

			if (tempfg == 1)
			{
				ustemp_s   = new double[nNumStr];
				lutemp_s   = new double[nNumStr];
				ustempbp_s   = new double[nNumStr];
				lutempbp_s   = new double[nNumStr];

				if (nPtSource > 0)
				{
					pstemp_s   = new double[nNumStr];
					pswdtemp_s = new double[nNumStr];
					pswdtempdi_s = new double[nNumStr];
				}

				if (irrigfg == 1)
					irwdtemp_s = new double[nNumStr];

				itemp_s  = new double[nNumStr];
			}
			// initialize
			for(i=0; i<nNumStr; i++)
			{
				usif_s[i] = 0.0;
				luif_s[i] = 0.0;
				usifbp_s[i] = 0.0;
				luifbp_s[i] = 0.0;

				if (nPtSource > 0)
				{
					psif_s[i] = 0.0;
					pswd_s[i] = 0.0;
					pswddi_s[i] = 0.0;
				}

				if (irrigfg == 1)
					irwd_s[i] = 0.0;

				ivol_s[i] = 0.0;

				if (tempfg == 1)
				{
					ustemp_s[i] = 0.0;
					lutemp_s[i] = 0.0;
					ustempbp_s[i] = 0.0;
					lutempbp_s[i] = 0.0;

					if (nPtSource > 0)
					{
						pstemp_s[i] = 0.0;
						pswdtemp_s[i] = 0.0;
						pswdtempdi_s[i] = 0.0;
					}

					if (irrigfg == 1)
						irwdtemp_s[i] = 0.0;

					itemp_s[i] = 0.0;
				}
			}
		}
		if (sedfg == 1)
		{
			nNumStr = nch*NumSed;
			if (nNumStr > 0)
			{
				ussed_s   = new double[nNumStr];
				lused_s   = new double[nNumStr];
				ussedbp_s   = new double[nNumStr];
				lusedbp_s   = new double[nNumStr];

				if (nPtSource > 0)
				{
					pssed_s   = new double[nNumStr];
					pswdsed_s = new double[nNumStr];
					pswdseddi_s = new double[nNumStr];
				}

				if (irrigfg == 1)
					irwdsed_s = new double[nNumStr];

				if (sedber == 1)
					bersed_s   = new double[nNumStr];

				ised_s    = new double[nNumStr];
				depscr_ss = new double[nNumStr];
				depmass_ss = new double[nNumStr];
				scrmass_ss = new double[nNumStr];
				bedsed_s  = new double[nNumStr];

				// initialize
				for(i=0; i<nNumStr; i++)
				{
					ussed_s[i] = 0.0;
					lused_s[i] = 0.0;
					ussedbp_s[i] = 0.0;
					lusedbp_s[i] = 0.0;

					if (nPtSource > 0)
					{
						pssed_s[i] = 0.0;
						pswdsed_s[i] = 0.0;
						pswdseddi_s[i] = 0.0;
					}

					if (irrigfg == 1)
						irwdsed_s[i] = 0.0;

					if (sedber == 1)
						bersed_s[i] = 0.0;
		
					ised_s[i] = 0.0;
					depscr_ss[i] = 0.0;
					depmass_ss[i] = 0.0;
					scrmass_ss[i] = 0.0;
					bedsed_s[i] = 0.0;
				}
			}
		}
		if (pqalfg == 1)
		{
			nNumStr = nch*nQuals;
			if (nNumStr > 0)
			{
				berqual_s  = new double[nNumStr];
				usqual_s   = new double[nNumStr];
				luqual_s   = new double[nNumStr];
				usqualbp_s   = new double[nNumStr];
				luqualbp_s   = new double[nNumStr];

				if (nPtSource > 0)
				{
					psqual_s   = new double[nNumStr];
					pswdqual_s = new double[nNumStr];
					pswdqualdi_s = new double[nNumStr];
				}

				if (irrigfg == 1)
					irwdqual_s = new double[nNumStr];
		
				adtot_s = new double[nNumStr];
				iqual_s = new double[nNumStr];
				adqal_s = new double[nNumStr];
				dsqal_s = new double[nNumStr];
				depqal_s = new double[nNumStr];
				scrqal_s = new double[nNumStr];

				// initialize
				for(i=0; i<nNumStr; i++)
				{
					berqual_s[i] = 0.0;
					usqual_s[i] = 0.0;
					luqual_s[i] = 0.0;
					usqualbp_s[i] = 0.0;
					luqualbp_s[i] = 0.0;

					if (nPtSource > 0)
					{
						psqual_s[i] = 0.0;
						pswdqual_s[i] = 0.0;
						pswdqualdi_s[i] = 0.0;
					}

					if (irrigfg == 1)
						irwdqual_s[i] = 0.0;
			
					adtot_s[i] = 0.0;
					iqual_s[i] = 0.0;
					adqal_s[i] = 0.0;
					dsqal_s[i] = 0.0;
					depqal_s[i] = 0.0;
					scrqal_s[i] = 0.0;
				}
			}
		}
		if (oxfg == 1)
		{
			nNumStr = nch*11;
			if (nNumStr > 0)
			{
				rqual_s = new CString[11];		// rqual name for stream summary
				rqual_s[0]  = "DO";
				rqual_s[1]  = "BOD";
				rqual_s[2]  = "NO3";
				rqual_s[3]  = "TAM";
				rqual_s[4]  = "NO2";
				rqual_s[5]  = "PO4";
				rqual_s[6]  = "ORN";
				rqual_s[7]  = "ORP";
				rqual_s[8]  = "ORC";
				rqual_s[9]  = "TIC";
				rqual_s[10] = "CO2";

				usrqual_s   = new double[nNumStr];
				lurqual_s   = new double[nNumStr];
				atmsrqual_s = new double[nNumStr];
				usrqualbp_s   = new double[nNumStr];
				lurqualbp_s   = new double[nNumStr];

				if (nutfg == 1 && sedfg == 1)
				{
					usSNH4_s  = new double[nch*3];
					luSNH4_s  = new double[nch*3];
					iSNH4_s   = new double[nch*3];
					DSNH4_s   = new double[nch*3];
					DEPNH4_s   = new double[nch*3];
					SCRNH4_s   = new double[nch*3];
					usSPO4_s  = new double[nch*3];
					luSPO4_s  = new double[nch*3];
					iSPO4_s   = new double[nch*3];
					DSPO4_s   = new double[nch*3];
					DEPPO4_s   = new double[nch*3];
					SCRPO4_s   = new double[nch*3];
				}

				//benthic release
				if (nutfg == 1 && benrfg == 1)
				{
					benNH4_s  = new double[nch];
					benPO4_s  = new double[nch];
				}

				if (nPtSource > 0)
				{
					psrqual_s   = new double[nNumStr];
					pswdrqual_s = new double[nNumStr];
					pswdrqualdi_s = new double[nNumStr];
				}

				if (irrigfg == 1)
					irwdrqual_s = new double[nNumStr];
		
				irqual_s    = new double[nNumStr];
				
				// initialize
				for(i=0; i<nNumStr; i++)
				{
					usrqual_s[i] = 0.0;
					lurqual_s[i] = 0.0;
					atmsrqual_s[i] = 0.0;
					usrqualbp_s[i] = 0.0;
					lurqualbp_s[i] = 0.0;

					if (nPtSource > 0)
					{
						psrqual_s[i] = 0.0;
						pswdrqual_s[i] = 0.0;
						pswdrqualdi_s[i] = 0.0;
					}

					if (irrigfg == 1)
						irwdrqual_s[i] = 0.0;
			
					irqual_s[i] = 0.0;
				}

				if (nutfg == 1 && sedfg == 1)
				{
					for(i=0; i<nch*3; i++)
					{
						usSNH4_s[i] = 0.0;
						luSNH4_s[i] = 0.0;
						iSNH4_s[i] = 0.0;
						DSNH4_s[i] = 0.0;
						DEPNH4_s[i] = 0.0;
						SCRNH4_s[i] = 0.0;
						usSPO4_s[i] = 0.0;
						luSPO4_s[i] = 0.0;
						iSPO4_s[i] = 0.0;
						DSPO4_s[i] = 0.0;
						DEPPO4_s[i] = 0.0;
						SCRPO4_s[i] = 0.0;
					}
				}
				//benthic release
				if (nutfg == 1 && benrfg == 1)
				{
					for(i=0; i<nch; i++)
					{
						benNH4_s[i] = 0.0;
						benPO4_s[i] = 0.0;
					}
				}
			}
		}
	}

	// Threshold Statistics
	if (pTHR_RESULTS != NULL)
	{
		delete[]pTHR_RESULTS;
		pTHR_RESULTS = NULL;
	}

	if (nch*ntnum > 0)
	{
		pTHR_RESULTS = new THR_RESULTS[nch*ntnum];

		for (i=0; i<nch; i++)
		{
			int trgp = pReachInfo[i].trgid - 1;
			if (trgp < 0)
				continue;
			for (j=0; j<ntnum; j++)
			{
				double value1 = 0.0;
				int qsize = pMTDATA[trgp*ntnum+j].tdays/deltd;
				while (pTHR_RESULTS[i*ntnum+j].q.size() != qsize)
					pTHR_RESULTS[i*ntnum+j].q.push(value1);
				pTHR_RESULTS[i*ntnum+j].trigcount = qsize + 1;
				// monthly statistics
				pTHR_RESULTS[i*ntnum+j].count = 0;
				pTHR_RESULTS[i*ntnum+j].min = 0.0;
				pTHR_RESULTS[i*ntnum+j].max = 0.0;
				pTHR_RESULTS[i*ntnum+j].sum = 0.0;
				pTHR_RESULTS[i*ntnum+j].sumofmean = 0.0;
				pTHR_RESULTS[i*ntnum+j].listmonth.clear();
				// simulation period statistics
				pTHR_RESULTS[i*ntnum+j].simcount = 0;
				pTHR_RESULTS[i*ntnum+j].simmin = 0.0;
				pTHR_RESULTS[i*ntnum+j].simmax = 0.0;
				pTHR_RESULTS[i*ntnum+j].simsum = 0.0;
				pTHR_RESULTS[i*ntnum+j].simsumofmean = 0.0;
				pTHR_RESULTS[i*ntnum+j].listsim.clear();
			}
		}
	}

	double *fsuro_s = NULL;
	double *fifwo_s = NULL;
	double *fagwo_s  = NULL;
	double *fSum_s  = NULL;
	double *cepe_s  = NULL;
	double *uzet_s  = NULL;
	double *baset_s = NULL;
	double *lzet_s  = NULL;
	double *agwet_s = NULL;
	double *perc_s  = NULL;
	double *infil_s = NULL;					
	double *gwi_s   = NULL;					
	double *igwi_s  = NULL;					
	double *agwi_s  = NULL;					
	double *prec_s  = NULL;					
	double *snowf_s = NULL;					
	double *rainf_s = NULL;					
	double *prain_s = NULL;					
	double *melt_s  = NULL;					
	double *snowe_s = NULL;					
	double *wyield_s = NULL;				
//	double *wyield_sws = NULL;				
	double *pack_s = NULL;					
	double *packf_s = NULL;					
	double *packw_s = NULL;					
	double *packi_s = NULL;					
	double *pdepth_s = NULL;				
//	double *pdepth_sws = NULL;				
	double *covindx_s = NULL;				
	double *neghts_s = NULL;				
	double *xlnmelt_s = NULL;				
	double *rdenpkf_s = NULL;				
	double *skyclear_s = NULL;				
	double *snocov_s = NULL;				
	double *dullness_s = NULL;				
	double *albedo_s = NULL;				
	double *paktemp_s = NULL;				
	double *dewtmp_s = NULL;				
	double *DEP_s   = NULL;					
	double *AVDEP_s = NULL;					
	double *HRAD_s  = NULL;					
	double *AVVEL_s = NULL;					
	double *SA_s    = NULL;					
	double *sqo_s   = NULL;

	if(nsws > 0)
	{
		fsuro_s = new double[nsws];
		fifwo_s = new double[nsws];
		fagwo_s = new double[nsws];
		fSum_s  = new double[nsws];
		cepe_s  = new double[nsws];
		uzet_s  = new double[nsws];
		baset_s = new double[nsws];
		lzet_s  = new double[nsws];
		agwet_s = new double[nsws];
		perc_s  = new double[nsws];
		infil_s = new double[nsws];			
		gwi_s   = new double[nsws];			
		igwi_s  = new double[nsws];			
		agwi_s  = new double[nsws];			
		prec_s  = new double[nsws];			
		snowf_s = new double[nsws];			
		rainf_s = new double[nsws];			
		prain_s = new double[nsws];			
		melt_s  = new double[nsws];			
		snowe_s = new double[nsws];			
		wyield_s = new double[nsws];		
//		wyield_sws = new double[nsws];		
		pack_s = new double[nsws];			
		packf_s = new double[nsws];			
		packw_s = new double[nsws];			
		packi_s = new double[nsws];			
		pdepth_s = new double[nsws];		
//		pdepth_sws = new double[nsws];		
		covindx_s = new double[nsws];		
		neghts_s = new double[nsws];		
		xlnmelt_s = new double[nsws];		
		rdenpkf_s = new double[nsws];		
		skyclear_s = new double[nsws];		
		snocov_s = new double[nsws];		
		dullness_s = new double[nsws];		
		albedo_s = new double[nsws];		
		paktemp_s = new double[nsws];		
		dewtmp_s = new double[nsws];		
		DEP_s   = new double[nsws];			
		AVDEP_s = new double[nsws];			
		HRAD_s  = new double[nsws];			
		AVVEL_s = new double[nsws];			
		SA_s    = new double[nsws];			

		for(i=0; i<nsws; i++)
		{
			fsuro_s[i] = 0.0;
			fifwo_s[i] = 0.0;
			fagwo_s[i]  = 0.0;
			fSum_s[i]  = 0.0;
			cepe_s[i]  = 0.0;
			uzet_s[i]  = 0.0;
			baset_s[i] = 0.0;
			lzet_s[i]  = 0.0;
			agwet_s[i] = 0.0;
			perc_s[i]  = 0.0;
			infil_s[i] = 0.0;			
			gwi_s[i]   = 0.0;			
			igwi_s[i]  = 0.0;			
			agwi_s[i]  = 0.0;			
			prec_s[i]  = 0.0;			
			snowf_s[i] = 0.0;			
			rainf_s[i] = 0.0;			
			prain_s[i] = 0.0;			
			melt_s[i]  = 0.0;			
			snowe_s[i] = 0.0;			
			wyield_s[i] = 0.0;			
//			wyield_sws[i] = 0.0;			
			pack_s[i] = 0.0;			
			packf_s[i] = 0.0;			
			packw_s[i] = 0.0;			
			packi_s[i] = 0.0;			
			pdepth_s[i] = 0.0;			
//			pdepth_sws[i] = 0.0;			
			covindx_s[i] = 0.0;			
			neghts_s[i] = 0.0;			
			xlnmelt_s[i] = 0.0;			
			rdenpkf_s[i] = 0.0;			
			skyclear_s[i] = 0.0;		
			snocov_s[i] = 0.0;			
			dullness_s[i] = 0.0;		
			albedo_s[i] = 0.0;			
			paktemp_s[i] = 0.0;			
			dewtmp_s[i] = 0.0;			
			DEP_s[i]   = 0.0;			
			AVDEP_s[i] = 0.0;			
			HRAD_s[i]  = 0.0;			
			AVVEL_s[i] = 0.0;			
			SA_s[i]	   = 0.0;		 
		}
	}

	if(nNum*nQuals > 0)
	{
		sqo_s = new double[nNum*nQuals];
		for (i=0; i<nNum*nQuals; i++)
			sqo_s[i] = 0.0;
	}

	double *ftaet_p  = NULL;

	double *fsurs_s  = NULL;
	double *fuzs_s   = NULL;
	double *flzs_s   = NULL;
	double *fagws_s  = NULL;
	double *ftaet_s  = NULL;
	double *fwssd_s  = NULL;
	double *fscrsd_s = NULL;
	double *washqs_s = NULL;
	double *scrqs_s  = NULL;
	double *soqo_s   = NULL;


	if(nNum > 0)
		ftaet_p = new double[nNum];

	if(nsws > 0)
	{
		fsurs_s  = new double[nsws];
		fuzs_s   = new double[nsws];
		flzs_s   = new double[nsws];
		fagws_s  = new double[nsws];
		ftaet_s  = new double[nsws];
		fwssd_s  = new double[nsws];
		fscrsd_s = new double[nsws];

		for(i=0; i<nsws; i++)
		{
			fsurs_s[i] = 0;
			fuzs_s[i]  = 0;
			flzs_s[i]  = 0;
			fagws_s[i] = 0;
			ftaet_s[i] = 0;
			fwssd_s[i] = 0;
			fscrsd_s[i]= 0;
		}
	}
	
	if(nNum*nQuals > 0)
	{
		washqs_s = new double[nNum*nQuals];
		scrqs_s  = new double[nNum*nQuals];
		soqo_s   = new double[nNum*nQuals];

		for(i=0; i<nNum*nQuals; i++)
		{
			washqs_s[i] = 0.0;
			scrqs_s[i]  = 0.0;
			soqo_s[i]   = 0.0;
		}
	}
	
	// J.S. for sediment

	double *dets_s  = NULL;
    double *slds_s  = NULL;
	double *wssd_p  = NULL;
	double *scrs_p  = NULL;
	double *soqs_p  = NULL;
	double *washqs_p  = NULL;
	double *scrqs_p  = NULL;
	double *uniflow = NULL;
	double *sosed_s = NULL;
	double *sober_s = NULL;
	double *moveavg = NULL;

	//land sweeping
    double *fr_sand_bs = NULL;	//fraction of sand (before sweeping) 
    double *fr_silt_bs = NULL;	//fraction of silt (before sweeping) 
    double *fr_clay_bs = NULL;	//fraction of clay (before sweeping)
    double *fr_sand = NULL;		//fraction of sand (after sweeping)
    double *fr_silt = NULL;		//fraction of silt (after sweeping)
    double *fr_clay = NULL;		//fraction of clay (after sweeping)
	COleDateTime *tLastSwept = NULL;
	COleDateTime *tLastSwept_GQ = NULL;
	
	if(nNum > 0)
	{
		dets_s  = new double[nNum];
		fr_sand_bs = new double[nNum];
		fr_silt_bs = new double[nNum];
		fr_clay_bs = new double[nNum];
		fr_sand = new double[nNum];
		fr_silt = new double[nNum];
		fr_clay = new double[nNum];
		slds_s  = new double[nNum];
		wssd_p  = new double[nNum];
		scrs_p  = new double[nNum];
		uniflow = new double[nNum*3];

		tLastSwept = new COleDateTime[nNum];

		for(i=0; i<nNum; i++)
		{
			dets_s[i]  = 0.0;
			fr_sand_bs[i] = 0.0;
			fr_silt_bs[i] = 0.0;
			fr_clay_bs[i] = 0.0;
			fr_sand[i] = 0.0;
			fr_silt[i] = 0.0;
			fr_clay[i] = 0.0;
			slds_s[i]  = 0.0;
			wssd_p[i]  = 0.0;
			scrs_p[i]  = 0.0;
			tLastSwept[i] = COleDateTime(1900,1,1,0,0,0);
		}

		for(i=0; i<nNum*3; i++)
			uniflow[i] = 0.0;
	}

	if(nNum*nQuals > 0)
	{
		soqs_p = new double[nNum*nQuals];
		washqs_p = new double[nNum*nQuals];
		scrqs_p = new double[nNum*nQuals];
		tLastSwept_GQ = new COleDateTime[nNum*nQuals];
		for(i=0; i<nNum*nQuals; i++)
		{
			soqs_p[i] = 0.0;
			washqs_p[i] = 0.0;
			scrqs_p[i] = 0.0;
			tLastSwept_GQ[i] = COleDateTime(1900,1,1,0,0,0);
		}
	}

	if(nsws > 0)
	{
		sosed_s = new double[nsws];
		moveavg = new double[nsws*4];   

		for(i=0; i<nsws; i++)
			sosed_s[i] = 0.0;

		for(i=0; i<nsws*4; i++)
			moveavg[i] = 0.0;
	}

	if (nch > 0)
	{
		sober_s = new double[nch];
		for (i=0; i<nch; i++)
			sober_s[i] = 0.0;
	}

    double krer,jrer,affix,cover,nvsi,kser,jser,kger,jger;
	double accsdp,remsdp;

	// sediment 
	double *sed2		= NULL;  
	double *rssed		= NULL;		
	double *rbsed		= NULL;		
	double *vbsed		= NULL;		
	double *sedbed		= NULL;
	double *matsed		= NULL;
	double *totsed		= NULL;
	double *totsed_route = NULL;
	double *totsed_bypass = NULL;
	double *qualsed		= NULL;	 
	double *qualsed_route = NULL;	 
	double *qualsed_bypass = NULL;	 
	double *rbsedtot	= NULL;		
	double *vbsedtot	= NULL;		
	double *tau_s		= NULL;
	double *ssed_s      = NULL;	
	double *rossed_s	= NULL;	//for total sediment
	double *rsed_s		= NULL;
	double *beddep_s	= NULL;		
	double *depscr_s	= NULL;
	double *rosed_s		= NULL;
	double *ssedc_s     = NULL;	
	double *rossedc_s   = NULL;	//for each sediment class
	double *rosed1_s    = NULL;	
	double *rbedsed_s   = NULL;
	double *rdepscr_s   = NULL;
	

	if(nsws*NumSed > 0)
	{
		totsed		= new double[nsws*NumSed];
		totsed_route = new double[nsws*NumSed];
		totsed_bypass = new double[nsws*NumSed];
		qualsed		= new double[nsws*NumSed];
		qualsed_route = new double[nsws*NumSed];
		qualsed_bypass = new double[nsws*NumSed];
		sed2		= new double[nsws*NumSed];  
		rssed		= new double[nsws*NumSed];		
		rbsed		= new double[nsws*NumSed];		
		vbsed		= new double[nsws*NumSed];		
		sedbed		= new double[nsws*NumSed];
		matsed		= new double[nsws*NumSed];
		ssedc_s     = new double[nsws*NumSed];		
		rossedc_s   = new double[nsws*NumSed];		
		rosed1_s    = new double[nsws*NumSed];		
		rbedsed_s   = new double[nsws*NumSed];		
		rdepscr_s   = new double[nsws*NumSed];		

		tau_s		= new double[nsws];
		ssed_s      = new double[nsws];		
		rossed_s	= new double[nsws];
		rsed_s		= new double[nsws];
		beddep_s	= new double[nsws];	
		depscr_s	= new double[nsws];
		rosed_s		= new double[nsws];
		rbsedtot	= new double[nsws];		
		vbsedtot	= new double[nsws];		

		if(sedfg == 1)
		{
			//calculate sand, silt, clay fractions
			CalculateSandSiltClayFractions(fr_sand,fr_silt,fr_clay,fr_sand_bs,fr_silt_bs,fr_clay_bs);

			//find the mean relative density of the sediment particles
			for (i=0; i<nch; i++)		 
			{
				int rgroup = pReachInfo[i].rgid - 1;

				//initialize
				rbsedtot[i] = 0.0;
				vbsedtot[i] = 0.0;
				
				//find the total volume of sediment particles - m3
				double volsediment = pReachInfo[i].length*MILE_TO_METER*rsd_genparam[rgroup].bedwid*FT_TO_M*rsd_genparam[rgroup].beddep*FT_TO_M*(1.0 - rsd_genparam[rgroup].por);
				double rhomn = 0.0;
				for (j=0; j<NumSed; j++)
				{
					//check if sand is simulated or not
					if(sandfg == 0 && rsd_param[rgroup*NumSed+j].sedflg == 0)
						continue;
					rhomn += rsd_param[rgroup*NumSed+j].sedfrac*rsd_param[rgroup*NumSed+j].rho;
				}

				for (j=0; j<NumSed; j++)
				{
					//check if sand is simulated or not
					if(sandfg == 0 && rsd_param[rgroup*NumSed+j].sedflg == 0)
					{
						sed2[i*NumSed+j] = 0.0;	 
						rssed[i*NumSed+j] = 0.0;	
						rbsed[i*NumSed+j] = 0.0;
						vbsed[i*NumSed+j] = 0.0;
					}
					else
					{
						sed2[i*NumSed+j] = rsd_param[rgroup*NumSed+j].sedo;	// mg/l 
						rssed[i*NumSed+j] = sed2[i*NumSed+j]*pReachInfo[i].length*MILE_TO_METER*pReachInfo[i].width*FT_TO_M*pReachInfo[i].idepth*FT_TO_M;	// mg/l*m3
						//total weight relative to water- rhomn is in parts/part - units are (mg/l)*m3
						rbsed[i*NumSed+j] = rsd_param[rgroup*NumSed+j].sedfrac*volsediment*rhomn/CM3_TO_M3;	
						vbsed[i*NumSed+j] = rbsed[i*NumSed+j]/(rsd_param[rgroup*NumSed+j].rho/CM3_TO_M3);	//m3 
						rbsedtot[i]	+= rbsed[i*NumSed+j];	//mg/l * m3
						vbsedtot[i]	+= vbsed[i*NumSed+j];	// m3
					}
					totsed[i*NumSed+j] = 0.0;
					totsed_route[i*NumSed+j] = 0.0;
					totsed_bypass[i*NumSed+j] = 0.0;
					qualsed[i*NumSed+j]	= 0.0;
					qualsed_route[i*NumSed+j] = 0.0;
					qualsed_bypass[i*NumSed+j] = 0.0;
					sedbed[i*NumSed+j] = 0.0;
					matsed[i*NumSed+j] = 0.0;
					ssedc_s[i*NumSed+j]	= 0.0;		
					rossedc_s[i*NumSed+j] = 0.0;		
					rosed1_s[i*NumSed+j] = 0.0;		
					rbedsed_s[i*NumSed+j] = 0.0;		
					rdepscr_s[i*NumSed+j] = 0.0;		
				}

				//output variables
				tau_s[i]		= 0.0;
				ssed_s[i]		= 0.0;
				rossed_s[i]		= 0.0;
				rsed_s[i]		= 0.0;
				beddep_s[i]		= 0.0;	
				depscr_s[i]		= 0.0;
				rosed_s[i]		= 0.0;
			}
		}
	}

	// J.S for temperature
	//double elev, eldat,cfsaex,katrad,kcond,kevap;
	double *temp1   = NULL;
	double *temp2   = NULL;
	double *temp2_min = NULL;
	double *temp2_max = NULL;
	double *temp2_s = NULL;
	double *matoutp = NULL;

	if(nsws > 0)
	{
		temp1   = new double[nsws];
		temp2   = new double[nsws];
		temp2_min = new double[nsws];
		temp2_max = new double[nsws];
		temp2_s = new double[nsws];
		matoutp = new double[nsws];

		for(i=0; i<nsws; i++)
		{
			temp1[i]   = 24.0;	//degree C
			temp2[i]   = 24.0;
			temp2_min[i] = -999;
			temp2_max[i] = -999;
			temp2_s[i] = 0.0;
			matoutp[i] = 0.0;
		}
	}

	// soil temperature
	int tsopfg;
	double aslt,bslt,aift, bift,agwt,bgwt,airtmp,sltmp,iftmp,gwtmp;
	double *asltm_p = NULL;	// pointer
	double *bsltm_p = NULL;	// pointer
	double *aiftm_p = NULL;	// pointer
	double *biftm_p = NULL;	// pointer
	double *agwtm_p = NULL;	// pointer
	double *bgwtm_p = NULL;	// pointer

	double *soilts  = NULL;
	double *soiltu  = NULL;
	double *soiltl  = NULL;

	if(nNum > 0)
	{
		soilts  = new double[nNum];
		soiltu  = new double[nNum];
		soiltl  = new double[nNum];

		for (j=0; j < nsws; j++)
		{
			for (k=0; k<nlandp; k++)
			{
				int nOrder = pswsinfo[j].gindex * nlandp + k;
				if (tempfg == 1)	
				{
					soilts[j*nlandp+k]  = pstmp_parm1[nOrder].islt;
					if (soilts[j*nlandp+k] < 0.5)
						// don't let water temp drop below 0.5 degree C (09-07-05)
						soilts[j*nlandp+k] = 0.5;

					soiltu[j*nlandp+k]  = pstmp_parm1[nOrder].iift;
					soiltl[j*nlandp+k]  = pstmp_parm1[nOrder].igwt;
				}
			}
		}
	}

//	double *soiltm = NULL;
	double *soiltm_route = NULL;
	double *soiltm_bypass = NULL;

	if(nsws > 0)
	{
//		soiltm = new double[nsws];
		soiltm_route = new double[nsws];
		soiltm_bypass = new double[nsws];
	}

	// sediment associated gquals
	double *RDQAL = NULL;
	double *RRQAL = NULL;
	double *CSQAL = NULL;

	if (nch*nQuals > 0 && sedfg == 1)
	{
		RDQAL = new double[nch*nQuals];
		RRQAL = new double[nch*nQuals];
		for (i=0; i<nch*nQuals; i++)
		{
			RDQAL[i] = 0.0;
			RRQAL[i] = 0.0;
		}

		CSQAL = new double[nch*nQuals*6];
		for (i=0; i<nch; i++)
		{
			int rgroup = pReachInfo[i].rgid - 1;
			for (j=0; j<nQuals; j++)
				for (k=0; k<6; k++)
					CSQAL[i*nQuals*6+j*6+k] = pGQ_SEDCONC[rgroup*nQuals+j].sqal[k];
		}
	}

	// do-cos
//	double *pdox = NULL;
	double *pdox_route = NULL;
	double *pdox_bypass = NULL;
//	double *pco2 = NULL;
	double *pco2_route = NULL;
	double *pco2_bypass = NULL;
//	double *co21   = NULL;
//	double *co22   = NULL;
//	double *matco2 = NULL;
//	double *co2s   = NULL;
	double *pdop = NULL;
	double *pdop_route = NULL;
	double *pdop_bypass = NULL;
	double *pco2p = NULL;
	double *pco2p_route  = NULL;
	double *pco2p_bypass  = NULL;
	// oxrx input parameters	 
	double *dox = NULL;			
	double *bod = NULL;
	double *satdo = NULL;
	double *matdox = NULL;			
	double *matbod = NULL;
 	double *concno3 = NULL;			
	double *conctam = NULL;			
	double *concno2 = NULL;			
	double *concpo4 = NULL;			
	double *snh4 = NULL;			
	double *spo4 = NULL;			

	double *matno3 = NULL;				
	double *mattam = NULL;			
	double *matno2 = NULL;			
	double *matpo4 = NULL;			
	double *matosnh4 = NULL;			
	double *matospo4 = NULL;			

	double *conctic = NULL;				
	double *concco2 = NULL;			
	double *mattic = NULL;			
	double *matco2 = NULL;			
	double *ph = NULL;			
	double *alk = NULL;			

	double *concphy = NULL;			
	double *conczoo = NULL;			
	double *concphycla = NULL;			
	double *concbenal = NULL;			
	double *concorn = NULL;			
	double *concorp = NULL;			
	double *concorc = NULL;			
	double *concTORN = NULL;			
	double *concTORP = NULL;			
	double *concTORC = NULL;			
	double *matphy = NULL;				
	double *matzoo = NULL;			
	double *matorn = NULL;			
	double *matorp = NULL;			
	double *matorc = NULL;			

	// oxrx output parameters
	double *dox_s    = NULL;	 			
	double *bod_s	 = NULL;
	double *no3_s    = NULL;				
	double *tam_s	 = NULL;
	double *no2_s    = NULL;	
	double *po4_s	 = NULL;
	double *snh4_s	 = NULL;	
	double *spo4_s	 = NULL;
	double *phy_s    = NULL;				
	double *zoo_s	 = NULL;
	double *phycla_s = NULL;			
	double *benal_s  = NULL;				
	double *orn_s    = NULL;				
	double *orp_s	 = NULL;
	double *orc_s    = NULL;				
	double *TORN_s   = NULL;				
	double *TORP_s	 = NULL;
	double *TORC_s   = NULL;				
	double *ph_s     = NULL;				
	double *alk_s	 = NULL;
	double *tic_s    = NULL;				
	double *co2_s	 = NULL;
	// arithmetic average concentration  
	double *doxmin_s  = NULL;			
	double *doxmax_s  = NULL;			
	double *doxav_s  = NULL;			
	
	// ouflow concentrations
	double *doxout_s  = NULL;	 			
	double *bodout_s  = NULL;
	double *no3out_s  = NULL;				
	double *tamout_s  = NULL;
	double *no2out_s  = NULL;	
	double *po4out_s  = NULL;
	double *phyout_s  = NULL;				
	double *zooout_s  = NULL;
	double *ornout_s  = NULL;				
	double *orpout_s  = NULL;
	double *orcout_s  = NULL;				
	double *ticout_s  = NULL;				
	double *co2out_s  = NULL;

	// outflow mass
	double *matdox_s = NULL;	 			
	double *matbod_s = NULL;
	double *matno3_s = NULL;			
	double *mattam_s = NULL;	
	double *matno2_s = NULL;	
	double *matpo4_s = NULL;
	double *matsnh4_s= NULL;	
	double *matspo4_s= NULL;
	double *matosnh4_s= NULL;	
	double *matospo4_s= NULL;
	double *matphy_s = NULL;			
	double *matzoo_s = NULL;		
	double *matorn_s = NULL;		
	double *matorp_s = NULL;		
	double *matorc_s = NULL;			
	double *mattic_s = NULL;			
	double *matco2_s = NULL;
	
	// intermediate variables
	double *readox = NULL;		

	if(nsws > 0)
	{
//		pdox = new double[nsws];
		pdox_route = new double[nsws];
		pdox_bypass = new double[nsws];
//		pco2 = new double[nsws];
		pco2_route = new double[nsws];
		pco2_bypass = new double[nsws];
//		co21   = new double[nsws];
//		co22   = new double[nsws];
//		matco2 = new double[nsws];
//		co2s   = new double[nsws];
		// oxrx input parameters	 
		dox = new double[nsws];
		bod = new double[nsws];
		satdo = new double[nsws];
		matdox = new double[nsws];
		matbod = new double[nsws];

		concno3 = new double[nsws];	
		conctam = new double[nsws];
		concno2 = new double[nsws];
		concpo4 = new double[nsws];
		snh4 = new double[nsws*4];
		spo4 = new double[nsws*4];

		matno3 = new double[nsws];	
		mattam = new double[nsws];
		matno2 = new double[nsws];
		matpo4 = new double[nsws];
		matosnh4 = new double[nsws*4];
		matospo4 = new double[nsws*4];

		conctic = new double[nsws];
		concco2 = new double[nsws];
		mattic = new double[nsws];	
		matco2 = new double[nsws];
		ph = new double[nsws];
		alk = new double[nsws];

		concphy = new double[nsws];	 
		conczoo = new double[nsws];
		concphycla = new double[nsws];
		concbenal = new double[nsws];
		concorn = new double[nsws];
		concorp = new double[nsws];
		concorc = new double[nsws];
		concTORN = new double[nsws];
		concTORP = new double[nsws];
		concTORC = new double[nsws];
		matphy = new double[nsws];	 
		matzoo = new double[nsws];
		matorn = new double[nsws];
		matorp = new double[nsws];
		matorc = new double[nsws];

		// oxrx output parameters	
		dox_s = new double[nsws];		 
		bod_s = new double[nsws];
		no3_s = new double[nsws];		
		tam_s = new double[nsws];
		no2_s = new double[nsws];
		po4_s = new double[nsws];
		snh4_s = new double[nsws*4];
		spo4_s = new double[nsws*4];
		phy_s = new double[nsws];		
		zoo_s = new double[nsws];
		phycla_s = new double[nsws];
		benal_s = new double[nsws];		
		orn_s = new double[nsws];
		orp_s = new double[nsws];
		orc_s = new double[nsws];		
		TORN_s = new double[nsws];
		TORP_s = new double[nsws];
		TORC_s = new double[nsws];		
		ph_s = new double[nsws];
		alk_s = new double[nsws];
		tic_s = new double[nsws];
		co2_s = new double[nsws];

		doxmin_s = new double[nsws];	
		doxmax_s = new double[nsws];	
		doxav_s = new double[nsws];		

		doxout_s = new double[nsws];		 
		bodout_s = new double[nsws];
		no3out_s = new double[nsws];		
		tamout_s = new double[nsws];
		no2out_s = new double[nsws];
		po4out_s = new double[nsws];
		phyout_s = new double[nsws];		
		zooout_s = new double[nsws];
		ornout_s = new double[nsws];
		orpout_s = new double[nsws];
		orcout_s = new double[nsws];		
		ticout_s = new double[nsws];
		co2out_s = new double[nsws];

		matdox_s = new double[nsws];	
		matbod_s = new double[nsws];
		matno3_s = new double[nsws];	
		mattam_s = new double[nsws];
		matno2_s = new double[nsws];
		matpo4_s = new double[nsws];
		matsnh4_s = new double[nsws*13];
		matspo4_s = new double[nsws*13];
		matosnh4_s = new double[nsws*4];
		matospo4_s = new double[nsws*4];
		matphy_s = new double[nsws];	
		matzoo_s = new double[nsws];
		matorn_s = new double[nsws];
		matorp_s = new double[nsws];
		matorc_s = new double[nsws];	
		mattic_s = new double[nsws];
		matco2_s = new double[nsws];

		// intermediate 
		readox = new double[nsws];
		//for(i=0; i<nsws; i++)
		for(i=0; i<nch; i++)	 
		{
//			co21[i]   = 0.0;
//			co22[i]   = 0.0;
//			matco2[i] = 0.0;	
//			co2s[i]   = 0.0;
			int rgroup = pReachInfo[i].rgid - 1;	 
			if (oxfg == 1)		// initialize variables
			{
				//card513 ox-init
				dox[i] = oxrx_init[rgroup].dox;
				bod[i] = oxrx_init[rgroup].bod;
				satdo[i] = oxrx_init[rgroup].satdo;
			}
			else
			{
				dox[i] = 0.0;
				bod[i] = 0.0;
				satdo[i] = 10.0;		// default (mg/l)
			}
			if (nutfg == 1)		// initialize variables
			{
				concno3[i] = nut_init[rgroup].no3;
				conctam[i] = nut_init[rgroup].tam;
				concno2[i] = nut_init[rgroup].no2;
				concpo4[i] = nut_init[rgroup].po4;
				snh4[i*4+0] = 0.0;
				snh4[i*4+1] = nut_init[rgroup].snh4_1 / 1.0e6;	// mg/mg
				snh4[i*4+2] = nut_init[rgroup].snh4_2 / 1.0e6;	// mg/mg
				snh4[i*4+3] = nut_init[rgroup].snh4_3 / 1.0e6;	// mg/mg
				spo4[i*4+0] = 0.0;
				spo4[i*4+1] = nut_init[rgroup].spo4_1 / 1.0e6;	// mg/mg
				spo4[i*4+2] = nut_init[rgroup].spo4_2 / 1.0e6;	// mg/mg
				spo4[i*4+3] = nut_init[rgroup].spo4_3 / 1.0e6;	// mg/mg
			}
			else
			{
				concno3[i] = 0.0;
				conctam[i] = 0.0;
				concno2[i] = 0.0;
				concpo4[i] = 0.0;
				snh4[i*4+0] = 0.0;
				snh4[i*4+1] = 0.0;
				snh4[i*4+2] = 0.0;
				snh4[i*4+3] = 0.0;
				spo4[i*4+0] = 0.0;
				spo4[i*4+1] = 0.0;
				spo4[i*4+2] = 0.0;
				spo4[i*4+3] = 0.0;
			}
			if (plkfg == 1)		// initialize variables
			{
				concphy[i] = plank_init[rgroup].phyto;
				concbenal[i] = plank_init[rgroup].benal;
				conczoo[i] = plank_init[rgroup].zoo;
				concorn[i] = plank_init[rgroup].orn;
				concorp[i] = plank_init[rgroup].orp;
				concorc[i] = plank_init[rgroup].orc;
			}
			else
			{
				concphy[i] = 0.96e-6;	// default values
				concbenal[i] = 1.0e-8;
				conczoo[i] = 0.03;
				concorn[i] = 0.0;
				concorp[i] = 0.0;
				concorc[i] = 0.0;
				concTORN[i] = 0.0;
				concTORP[i] = 0.0;
				concTORC[i] = 0.0;
			}
			if (phfg == 1)		// initialize variables
			{
				conctic[i] = ph_init[rgroup].tic;
				concco2[i] = ph_init[rgroup].co2;
				ph[i] = ph_init[rgroup].ph;
			}
			else
			{
				conctic[i] = 0.0;
				concco2[i] = 0.0;
				ph[i] = 7.0;
			}
			concphycla[i] = 0.0; // ug/l
			matdox[i] = 0.0;
			matbod[i] = 0.0;
			matno3[i] = 0.0;
			mattam[i] = 0.0;
			matno2[i] = 0.0;
			matpo4[i] = 0.0;
			matphy[i] = 0.0;
			matzoo[i] = 0.0;
			matorn[i] = 0.0;
			matorp[i] = 0.0;
			matorc[i] = 0.0;
			mattic[i] = 0.0;
			matco2[i] = 0.0;
			alk[i] = 0.0;
			// oxrx output parameters
			dox_s[i] = 0.0;			 
			bod_s[i] = 0.0;
			no3_s[i] = 0.0;			
			tam_s[i] = 0.0;
			no2_s[i] = 0.0;			
			po4_s[i] = 0.0;
			phy_s[i] = 0.0;			
			zoo_s[i] = 0.0;
			phycla_s[i] = 0.0;		
			benal_s[i] = 0.0;		
			orn_s[i] = 0.0;			
			orp_s[i] = 0.0;
			orc_s[i] = 0.0;			
			TORN_s[i] = 0.0;			
			TORP_s[i] = 0.0;
			TORC_s[i] = 0.0;			
			ph_s[i] = 0.0;
			alk_s[i] = 0.0;			
			tic_s[i] = 0.0;
			co2_s[i] = 0.0;

			doxmin_s[i] = 0.0;					
			doxmax_s[i] = 0.0;		
			doxav_s[i] = 0.0;		

			doxout_s[i] = 0.0;			 
			bodout_s[i] = 0.0;
			no3out_s[i] = 0.0;			
			tamout_s[i] = 0.0;
			no2out_s[i] = 0.0;			
			po4out_s[i] = 0.0;
			phyout_s[i] = 0.0;			
			zooout_s[i] = 0.0;
			ornout_s[i] = 0.0;			
			orpout_s[i] = 0.0;
			orcout_s[i] = 0.0;			
			ticout_s[i] = 0.0;
			co2out_s[i] = 0.0;

			matdox_s[i] = 0.0;		
			matbod_s[i] = 0.0;
			matno3_s[i] = 0.0;		
			mattam_s[i] = 0.0;
			matno2_s[i] = 0.0;
			matpo4_s[i] = 0.0;
			matphy_s[i] = 0.0;		
			matzoo_s[i] = 0.0;
			matorn_s[i] = 0.0;
			matorp_s[i] = 0.0;
			matorc_s[i] = 0.0;		
			mattic_s[i] = 0.0;
			matco2_s[i] = 0.0;
			// intermediate
			readox[i] = 0.0;
		}
		for(i=0; i<nch*4; i++)
		{
			snh4_s[i] = 0.0;
			spo4_s[i] = 0.0;
			matosnh4[i] = 0.0;
			matospo4[i] = 0.0;
			matosnh4_s[i] = 0.0;
			matospo4_s[i] = 0.0;
		}
		for(i=0; i<nch*13; i++)
		{
			matsnh4_s[i] = 0.0;
			matspo4_s[i] = 0.0;
		}
	}

	if(nNum > 0)
	{
		pdop = new double[nNum];
		pdop_route = new double[nNum];
		pdop_bypass = new double[nNum];
		pco2p = new double[nNum];
		pco2p_route = new double[nNum];
		pco2p_bypass = new double[nNum];
		// initialize
		for(i=0; i<nNum; i++)
		{
			pdop[i] = 0.0;
			pdop_route[i] = 0.0;
			pdop_bypass[i] = 0.0;
			pco2p[i] = 0.0;
			pco2p_route[i] = 0.0;
			pco2p_bypass[i] = 0.0;
		}
	}

	// monthly vary parmaters
	double *idoconcm = NULL;	// pointer
	double *adoconcm = NULL;
	double *ico2concm = NULL;	// pointer
	double *aco2concm = NULL;
	// pH
//	double *ioc   = NULL;
//	double *ph    = NULL;
//	double *ioc_s = NULL;

//	if(nsws > 0)
//	{
//		ioc   = new double[nsws];
//		ph    = new double[nsws];
//		ioc_s = new double[nsws];

//		for(i=0; i<nsws; i++)
//		{
//			ph[i]     = 7;
//			ioc_s[i]  = 0.0;
//		}
//	}
	
	// Set initial conditions
	for(i=0; i<nsws; i++)
	{
		int lgroup = pswsinfo[i].gindex;

		for(j=0; j<nlandp; j++)
		{
			int nOrder2 = i * nlandp + j;
			int nOrder  = lgroup * nlandp + j;

			ceps_p[nOrder2] = ppw_state[nOrder].ceps_p;
			surs_p[nOrder2] = ppw_state[nOrder].surs_p;
			uzs_p[nOrder2]  = ppw_state[nOrder].uzs_p;
			ifws_p[nOrder2] = ppw_state[nOrder].ifws_p;
			lzs_p[nOrder2]  = ppw_state[nOrder].lzs_p;
			agws_p[nOrder2] = ppw_state[nOrder].agws_p;
			gwvs_p[nOrder2] = ppw_state[nOrder].gwvs_p;

			if(pluinfop[nOrder2].piid == 1) // impervious land 
			{
				uzs_p[nOrder2]  = 0.0;
				ifws_p[nOrder2] = 0.0;
				lzs_p[nOrder2]  = 0.0;
				agws_p[nOrder2] = 0.0;
			}

			for (k=0; k<nQuals; k++)
			{
				int nOrder4 = i*nlandp*nQuals + j*nQuals + k;
				int nOrder3 = lgroup*nQuals*nlandp + k*nlandp + j;	
				sqo_s[nOrder4] = pQualInput[nOrder3].sqo;
			}
		}
	}	
	// the following parameters are used to save the result
	double *f_suro    = NULL;
	double *f_ifwo    = NULL;
	double *f_agwo    = NULL;
	double *f_cepe    = NULL;           
	double *f_uzet    = NULL;           
	double *f_baset   = NULL;           
	double *f_lzet    = NULL;           
	double *f_agwet   = NULL;           
	double *f_perc    = NULL;           
	double *f_prec    = NULL;			      
	double *f_snowf   = NULL;			     
	double *f_rainf   = NULL;			     
	double *f_prain   = NULL;			     
	double *f_melt    = NULL;			     
	double *f_snowe   = NULL;			     
	double *f_wyield  = NULL;			     
	double *f_infil   = NULL;			
	double *f_gwi     = NULL;			
	double *f_igwi    = NULL;			
	double *f_agwi    = NULL;			

	// to following arraies are used to save qual results
	double *f_poqual  = NULL;			 
	double *f_poqual_route = NULL;			 
	double *f_poqual_bypass = NULL;			 
//	double *f_roqual  = NULL;			
	double *f_roqual_route  = NULL;			
	double *f_roqual_bypass  = NULL;			
	double *f_posqual = NULL;			
	double *f_posqual_route = NULL;			
	double *f_posqual_bypass = NULL;			
	double *f_soqual  = NULL;           
	double *f_ioqual  = NULL;           
	double *f_goqual  = NULL;           
	double *poqual_s  = NULL;
	double *soqual_s  = NULL;           
	double *ioqual_s  = NULL;           
	double *goqual_s  = NULL;           

	double *f_suroqo  = NULL;
	double *f_ifoqual = NULL;           
	double *f_aoqual  = NULL;
	double *fSum      = NULL;
	double *froute    = NULL;
	double *fbypass   = NULL;
	double *fgwo      = NULL;
	double *froute_gwo = NULL;
	double *fbypass_gwo = NULL;
	
	if(nNum > 0)
	{
		f_suro	= new double[nNum];
		f_ifwo	= new double[nNum];
		f_agwo	= new double[nNum];
		f_cepe  = new double[nNum];		    
		f_uzet  = new double[nNum];		    
		f_baset = new double[nNum];		    
		f_lzet  = new double[nNum];		    
		f_agwet = new double[nNum];		    
		f_perc  = new double[nNum];		    
		f_prec  = new double[nNum];		   
		f_snowf = new double[nNum];		  
		f_rainf = new double[nNum];		  
		f_prain = new double[nNum];		  
		f_melt  = new double[nNum];		  
		f_snowe = new double[nNum];		  
		f_wyield = new double[nNum];	  
		f_infil = new double[nNum];     
		f_gwi   = new double[nNum];     
		f_igwi  = new double[nNum];     
		f_agwi  = new double[nNum];     

		for(i=0; i<nNum; i++)
		{
			f_suro[i]   = 0.0;
			f_ifwo[i]   = 0.0;
			f_agwo[i]   = 0.0;
			f_cepe[i]	= 0.0;           
			f_uzet[i]	= 0.0;           
			f_baset[i]	= 0.0;           
			f_lzet[i]	= 0.0;           
			f_agwet[i]	= 0.0;           
			f_perc[i]	= 0.0;           
			f_prec[i]	= 0.0;		     
			f_snowf[i]	= 0.0;		    
			f_rainf[i]	= 0.0;		    
			f_prain[i]	= 0.0;		    
			f_melt[i]	= 0.0;		    
			f_snowe[i]	= 0.0;		    
			f_wyield[i]	= 0.0;		    
			f_infil[i]	= 0.0;      
			f_gwi[i]	= 0.0;      
			f_igwi[i]	= 0.0;      
			f_agwi[i]	= 0.0;      
		}
	}

	// 0-bod, 1-nox, 2-tam, 3-snh4_sand, 4-snh4_silt, 5-snh4_clay, 6-po4,
	// 7-spo4_sand, 8-spo4_silt, 9-spo4_clay, 10-orn, 11-orp, 12-orc
	if (nsws > 0)
	{
//		f_roqual = new double[nsws*13];	//changed from 9 to 13 (02-2008)
		f_roqual_route = new double[nsws*13];
		f_roqual_bypass = new double[nsws*13];
		for (j=0; j<nsws*13; ++j)
		{
//			f_roqual[j] = 0.0;
			f_roqual_route[j] = 0.0;
			f_roqual_bypass[j] = 0.0;
		}
	}
	if(nsws*nQuals > 0)
	{
		f_poqual = new double[nsws*nQuals];
		f_poqual_route = new double[nsws*nQuals];
		f_poqual_bypass = new double[nsws*nQuals];
		f_posqual= new double[nsws*nQuals];
		f_posqual_route = new double[nsws*nQuals];
		f_posqual_bypass = new double[nsws*nQuals];
		f_soqual = new double[nsws*nQuals];          
		f_ioqual = new double[nsws*nQuals];         
		f_goqual = new double[nsws*nQuals];         
		poqual_s = new double[nsws*nQuals];
		soqual_s = new double[nsws*nQuals];         
		ioqual_s = new double[nsws*nQuals];         
		goqual_s = new double[nsws*nQuals];         

		for(i=0; i<nsws*nQuals; i++)
		{	
			poqual_s [i] = 0.0;
			soqual_s [i] = 0.0;						
			ioqual_s [i] = 0.0;						
			goqual_s [i] = 0.0;						
		}
	}

	if(nNum*nQuals > 0)
	{
		f_suroqo  = new double[nNum*nQuals];
		f_ifoqual = new double[nNum*nQuals];       
		f_aoqual  = new double[nNum*nQuals];

		for(i=0; i<nNum*nQuals; i++)
		{
			f_suroqo[i] = 0.0;
			f_ifoqual[i] = 0.0;
			f_aoqual[i] = 0.0;
		}
	}

	if(nsws > 0)
	{
		fSum = new double[nsws];
		froute = new double[nsws];
		fbypass = new double[nsws];
		fgwo = new double[nsws];
		froute_gwo = new double[nsws];
		fbypass_gwo = new double[nsws];

		for(i=0; i<nsws; i++)
		{
			fSum[i] = 0.0;
			froute[i] = 0.0;
			fbypass[i] = 0.0;
			fgwo[i] = 0.0;
			froute_gwo[i] = 0.0;
			fbypass_gwo[i] = 0.0;
		}
	}

	// added for newly required debugging information
	// determine the following dimension later
	double *fsqo_s    = NULL; 
	double *fwashqs_s = NULL;
	double *fscrqs_s  = NULL;
	double *fsoqo_s   = NULL;
	double *fpoqc_s   = NULL;

	if(nsws*nQuals > 0)
	{
		fsqo_s    = new double[nsws*nQuals]; 
		fwashqs_s = new double[nsws*nQuals];
		fscrqs_s  = new double[nsws*nQuals];
		fsoqo_s   = new double[nsws*nQuals];
		fpoqc_s   = new double[nsws*nQuals];

		for(i=0; i<nsws*nQuals; i++)
		{	
			fsqo_s[i]    = 0.0;
			fwashqs_s[i] = 0.0;
			fscrqs_s[i]  = 0.0;
			fsoqo_s[i]   = 0.0;
			fpoqc_s[i]   = 0.0;
		}
	}
	double *fArea = NULL;
	if (nsws > 0)
	{
		fArea = new double[nsws];

		for(i=0; i<nsws; i++)
		{
			fArea[i] = 0.0;
			for(j=0; j<nlandp; j++)
				fArea[i] += pluinfop[i*nlandp+j].area;
		}
	}
	
	//  ----Results variable
//	double surss = 0.0;
//	double ifwk1 = 0.0;
//	double ifwk2 = 0.0;
	
	int minfg,hrfg,dayfg,mofg,yrfg;
	int drydfg = 1;

	// Initial data
	double petadj = 1;  // no snow adjust at this time  
	double inffac = 1;  // no ice adjust   
	int slifp = 0;      // no lateral inflow,set flag to 0  
	double surli = 0;   // lateral inplow   
	int nblks = 1;		// only one layer for each layer  
	int ilifp = 0;		// no interflow lateral inflow timseries  
	
	uzfg = 1;			// old method, integrated method will be added later  
	int rtopfg = 1;		// new method to do routing  

	double supy=0, atem=0, wind=0 ,solr=0, dewp=0, clou=0;

	double *prec_p = NULL;
	double *supy_p = NULL;
	double *atem_p = NULL;
	double *wind_p = NULL;
	double *solr_p = NULL;
	double *dewp_p = NULL;
	double *clou_p = NULL;
	double *pet_p  = NULL;
	double *airtmp_p = NULL;		 
	double *snotmp_p = NULL;		
	double *airtmp_min = NULL;		
	double *airtmp_max = NULL;		
	double *airtmp_s = NULL;		
	double *snotmp_s = NULL;		
	double *pet_irr  = NULL;

	double *tmud_p = NULL;
	double *tmuddt_p = NULL;

	if(nsws > 0)
	{
		prec_p = new double[nsws];
		supy_p = new double[nsws];
		atem_p = new double[nsws];
		wind_p = new double[nsws];
		solr_p = new double[nsws];
		dewp_p = new double[nsws];
		clou_p = new double[nsws];
		pet_p  = new double[nsws];
		airtmp_p = new double[nsws];		 
		snotmp_p = new double[nsws];		
		airtmp_min = new double[nsws];		
		airtmp_max = new double[nsws];		
		airtmp_s = new double[nsws];		
		snotmp_s = new double[nsws];		
		pet_irr  = new double[nsws];

		tmud_p = new double[nsws];
		tmuddt_p = new double[nsws];
	}

	for(i=0; i<nsws; i++)
	{
		airtmp_p[i] = 0;		 
		snotmp_p[i] = 0;		
		airtmp_min[i] = -999;		
		airtmp_max[i] = -999;		
		airtmp_s[i] = 0;		
		snotmp_s[i] = 0;		

		tmud_p[i] = 24;	//degree C	 
		tmuddt_p[i] = 0;		 
	}

	//double pet, petinp;
	double pet  = 0;
	int nOrder  = 0;
	int nOrder2 = 0;
	int nCount  = 0;
	COleDateTime tCurrent;

	//Variables for irrigation options s
	COleDateTime tPrevious ; //Added by Sabu (9-2004)
	int prevDay ;
	int curDay ;

	// parameters for ftable
	int fnt = 60;
	double *fh = NULL;
	double *fv = NULL;
	double *fq = NULL;
	double *fs = NULL;
	double *fa = NULL;
	double *fr = NULL;
	double *fb = NULL;
	double *fp = NULL;
	double *qk = NULL;
	double *fsa = NULL;					 

	if(nsws > 0)
	{
		fh = new double[nsws*fnt];
		fv = new double[nsws*fnt];
		fq = new double[nsws*fnt];
		fs = new double[nsws*fnt];
		fa = new double[nsws*fnt];
		fr = new double[nsws*fnt];
		fb = new double[nsws*fnt];
		fp = new double[nsws*fnt];
		qk = new double[nsws*fnt];
		fsa = new double[nsws*fnt];		 

		// initialize the upper parameters
		for(i=0; i<nsws*fnt; i++)
		{
			fh[i] = 0.0;
			fv[i] = 0.0;
			fq[i] = 0.0;
			fs[i] = 0.0;
			fa[i] = 0.0;
			fr[i] = 0.0;
			fb[i] = 0.0;
			fp[i] = 0.0;
			qk[i] = 0.0;
			fsa[i] = 0.0;					 
		}
	}

	// save result
	int *avcount = NULL;		// counting wet period instream concentration for daily output
	double *v1   = NULL;
	double *v2   = NULL;
	double *v2_s = NULL;		 
	double *q1   = NULL;
	double *q2   = NULL;
//	double *q2_frozen = NULL;
	double *q2_s = NULL;
	double *vols = NULL;
	double *vol  = NULL;
	double *qh   = NULL;
	double *XA   = NULL;		
	double *HR   = NULL;		
	double *SA   = NULL;
	
	// for irrigation 
	double *v_bip = NULL;		// volume below irrigation withdrawal pipe	
	
	// bank erosion sediment
	double *xa_thr  = NULL;	
	double *hr_thr  = NULL;		
	double *ber_sd  = NULL;	
	double *v_bfd	= NULL;	// volume at the bank full depth

	if(nch > 0)
	{
		avcount = new int[nch];
		v1   = new double[nch];
		v2   = new double[nch];
		v2_s = new double[nch];
		q1   = new double[nch];
		q2   = new double[nch];
//		q2_frozen = new double[nch];
		q2_s = new double[nch];
		vols = new double[nch];
		vol  = new double[nch];
		qh   = new double[nch];
		XA   = new double[nch];		
		HR   = new double[nch];		
		SA   = new double[nch];
		
		// for irrigation 
		if (irrigfg == 1)
			v_bip = new double[nch];		

		// bank erosion sediment
		if (sedfg == 1 && sedber == 1)
		{
			xa_thr = new double[nch];		
			hr_thr = new double[nch];		
			ber_sd = new double[nch];		
			q_bfd  = new double[nch];		
			v_bfd  = new double[nch];		
		}

		for(i=0; i<nch; i++)
		{
			v1[i] = 0.0;
			if (irrigfg == 1)
				v_bip[i] = 0.0;
			if (pReachInfo[i].depth > 0 && pReachInfo[i].lkfg == 0)
			{
				v1[i] = ((1-pReachInfo[i].r1)*pReachInfo[i].idepth
						/(2*pReachInfo[i].depth)+pReachInfo[i].r1)
						*pReachInfo[i].idepth*pReachInfo[i].width
						*pReachInfo[i].length*MILE_TO_FEET;	// ft^3
				if (irrigfg == 1)
					v_bip[i] = ((1-pReachInfo[i].r1)*pirrigwdinfo[i].irrigdep
							   /(2*pReachInfo[i].depth)+pReachInfo[i].r1)
							   *pirrigwdinfo[i].irrigdep*pReachInfo[i].width
							   *pReachInfo[i].length*MILE_TO_FEET;	// ft^3
			}
			else // lake
			{
				v1[i] = pReachInfo[i].idepth*pReachInfo[i].width
						*pReachInfo[i].length*MILE_TO_FEET;	// ft^3
				if (irrigfg == 1)
					v_bip[i] = pirrigwdinfo[i].irrigdep*pReachInfo[i].width
							   *pReachInfo[i].length*MILE_TO_FEET;	// ft^3
			}

			int nStart = pReachFtable[i].nFTstart;
			int nRecord = pReachFtable[i].nFTrecord;

			if (nRecord > 0)
			{
				for(int j=nStart; j<nStart+nRecord-1; j++)
				{
					if(pFtable[j].rchid == pChannelInfo[i].rchid)										
					{
						//calculate the initial volume from the external F-table
						if((pReachInfo[i].idepth >= pFtable[j].depth) && (pReachInfo[i].idepth <= pFtable[j+1].depth))
						{
							v1[i] = pFtable[j].vol + (pReachInfo[i].idepth - pFtable[j].depth) * (pFtable[j+1].vol - pFtable[j].vol) / (pFtable[j+1].depth - pFtable[j].depth);
							if (irrigfg == 1)
								v_bip[i] = pFtable[j].vol + (pirrigwdinfo[i].irrigdep - pFtable[j].depth) * (pFtable[j+1].vol - pFtable[j].vol) / (pFtable[j+1].depth - pFtable[j].depth);
							break;
						}
					}
				}
				
//				v1[i] = pReachInfo[i].length*MILE_TO_FEET*pReachInfo[i].width*pReachInfo[i].idepth;		// ft^3
//				if(pReachInfo[i].slope > 0.1)
//					v1[i] += pReachInfo[i].idepth*pReachInfo[i].slope*pReachInfo[i].idepth*pReachInfo[i].length*MILE_TO_FEET;
			}

			v2[i]   = v1[i];
			v2_s[i] = 0.0;
			q1[i]   = 0.0;
			q2[i]   = q1[i];
//			q2_frozen[i] = 0.0;
			q2_s[i] = 0.0;
			vols[i] = v1[i];
			vol[i]  = v2[i];
			qh[i]   = pReachInfo[i].idepth;
			XA[i]   = 0.0;
			if (pReachInfo[i].length > 0)
				XA[i] = v2[i] / (pReachInfo[i].length*MILE_TO_FEET);	// ft2		
			SA[i]   = pReachInfo[i].length*MILE_TO_FEET*pReachInfo[i].width;	// ft2		
			double avdepth = 0.0;
			if (SA[i] > 0)
				avdepth = v2[i] / SA[i];	// ft
			double topwidth = 0.0;
			if (pReachInfo[i].length > 0)
				topwidth = SA[i] / (pReachInfo[i].length * MILE_TO_FEET);	// ft
			HR[i]   = 0.0;		
			if (avdepth > 0 && topwidth > 0)
				HR[i] = (topwidth * avdepth) / (2.0 * avdepth + topwidth);	// ft

			avcount[i] = 0;
			
			// bank erosion sediment
			if (sedfg == 1 && sedber == 1)
			{
				xa_thr[i] = 0.0;		
				hr_thr[i] = 0.0;		
				ber_sd[i] = 0.0;		
				q_bfd[i]  = -1.0;		
//				v_bfd[i]  = pReachInfo[i].length*MILE_TO_FEET*pReachInfo[i].width*pReachInfo[i].depth;		
				v_bfd[i]  = (1+pReachInfo[i].r1)/2
					*pReachInfo[i].depth*pReachInfo[i].width
					*pReachInfo[i].length*MILE_TO_FEET;					// ft^3
			}
		}
	}
	
	double *conc_dis   = NULL;	// dissolved phase
	double *conc_tot   = NULL;	// dissolved phase + suspended sediment associated
	double *matout     = NULL;
	double *matsedout  = NULL;
	double *conc_s     = NULL;			 
	double *concout_s  = NULL;			 
	double *matsqal_s  = NULL;
	double *matout_s   = NULL;
	double *matosqal_s = NULL;
	double *matin_s    = NULL;

	if(nsws*nQuals > 0)
	{
		conc_dis   = new double[nsws*nQuals];	
		conc_tot   = new double[nsws*nQuals];	
		matout     = new double[nsws*nQuals];
		matsedout  = new double[nsws*nQuals*3];	 // sand,silt,clay
		conc_s     = new double[nsws*nQuals];			 
		concout_s  = new double[nsws*nQuals];			 
		matsqal_s  = new double[nsws*nQuals*8];	 // sand, silt, clay, total in suspension and bed
		matout_s   = new double[nsws*nQuals];
		matosqal_s = new double[nsws*nQuals*4];  // sand,silt,clay,total
		matin_s    = new double[nsws*nQuals];

		double unit = 1.0;

		for(i=0; i<nch; i++)
		{
			int rgroup = pReachInfo[i].rgid - 1;
			int lgroup = pswsinfo[i].gindex;

			for(j=0; j<nQuals; j++)
			{
					if(pQual[lgroup*nQuals+j].qunit == "(ug/l)")
						unit = 16018460;
					else if(pQual[lgroup*nQuals+j].qunit == "(#/100ml)")
						unit = 1601.846;
					else
						unit = LB_FT3_TO_MG_L;

				conc_dis[i*nQuals+j] = pQualwq[rgroup*nQuals+j].inicon/unit; // converted to lb/ft^3	
				conc_tot[i*nQuals+j] = 0.0;
			}
		}

		for(i=0; i<nsws*nQuals; i++)
		{
			matout[i] = 0.0;
			for (j=0; j<3; j++)
				matsedout[i*3+j] = 0.0;
			for (j=0; j<4; j++)
				matosqal_s[i*4+j] = 0.0;
			for (j=0; j<8; j++)
				matsqal_s[i*8+j] = 0.0;

			conc_s[i]   = 0.0;			 
			concout_s[i] = 0.0;			 
			matout_s[i] = 0.0;
			matin_s[i] = 0.0;
		}
	}

//	int *phviolation = NULL;
//	if(nsws > 0)
//	{
//		phviolation = new int[nsws];
//		for(i=0; i<nsws; i++)
//			phviolation[i] = 0;
//	}

	//begin ---snow module related
	double svp[40] = {1.005, 1.005, 1.005, 1.005, 1.005, 1.005, 1.005, 1.005, 1.005, 1.005,
					1.01, 1.01, 1.015, 1.02, 1.03, 1.04, 1.06, 1.08, 1.1, 1.29,
					1.66, 2.13, 2.74, 3.49, 4.4, 5.55, 6.87, 8.36, 10.1, 12.2,
					14.6, 17.5, 20.9, 24.8, 29.3, 34.6, 40.7, 47.7, 55.7, 64.9};

	//snow
	double *packf_p  = NULL;
	double *pdepth_p = NULL;
	double *rdenpf_p = NULL;
	double *snocov_p = NULL;
	double *packw_p  = NULL;
	double *packi_p  = NULL;
	double *paktmp_p = NULL;
	double *pack_p   = NULL;
//	double *pack_sws = NULL;
	double *dull_p   = NULL;
	double *covinx_p = NULL;
	double *xlnmlt_p = NULL;
	double *skyclr_p = NULL;
	double *snowep_p = NULL;
	double *covind_p = NULL;
	double snotmp = 32.0;
	
	double *neghts_p = NULL;
	double *mneghs_p = NULL;
	double *packwc_p = NULL;
	double *neght_p  = NULL;
	double *gmeltr_p = NULL;
	double *compct_p = NULL;
	double *mostht_p = NULL;
	double *vap_p    = NULL;
	double *albedo_p = NULL;					 
	double *dewtmp_p = NULL;					

	if(nNum > 0)
	{
		packf_p  = new double[nNum];
		pdepth_p = new double[nNum];
		rdenpf_p = new double[nNum];
		snocov_p = new double[nNum];
		packw_p  = new double[nNum];
		packi_p  = new double[nNum];
		paktmp_p = new double[nNum];
		pack_p   = new double[nNum];
//		pack_sws = new double[nNum];
		dull_p   = new double[nNum];
		covinx_p = new double[nNum];
		xlnmlt_p = new double[nNum];
		skyclr_p = new double[nNum];
		snowep_p = new double[nNum];
		covind_p = new double[nNum];
		neghts_p = new double[nNum];
		mneghs_p = new double[nNum];
		packwc_p = new double[nNum];
		neght_p  = new double[nNum];
		gmeltr_p = new double[nNum];
		compct_p = new double[nNum];
		mostht_p = new double[nNum];
		vap_p    = new double[nNum];
		albedo_p = new double[nNum];					 
		dewtmp_p = new double[nNum];					
	}
	
	if(snowfg == 1)                   
	{
		// run snow module
		for(i=0; i<nsws; i++)
		{
			for(j=0; j<nlandp; j++)
			{
				k = i*nlandp + j;
				nOrder = pswsinfo[i].gindex * nlandp + j;
	
				packf_p[k]  = pSnowInit1[nOrder].packsnow + pSnowInit1[nOrder].packice;
				rdenpf_p[k] = pSnowInit1[nOrder].RDENPF;
				packw_p[k]  = pSnowInit1[nOrder].packwatr;
				packi_p[k]  = pSnowInit1[nOrder].packice;
				paktmp_p[k] = pSnowInit1[nOrder].PAKTMP;
				pack_p[k]   = packf_p[k] + packw_p[k];
//				pack_sws[k] = 0.0;
				dull_p[k]   = pSnowInit1[nOrder].DULL;
				covinx_p[k] = pSnowInit1[nOrder].COVINX;
				xlnmlt_p[k] = pSnowInit1[nOrder].XLNMLT;
				skyclr_p[k] = pSnowInit1[nOrder].SKYCLR;
				
				if(fabs(pack_p[k]) <= 1e-5) 
				{
					// Set state variables to values for no pack 
					int hr6fg = 0;
					double albedo;
					nopack(&covind_p[k], &hr6fg, &packf_p[k], &packi_p[k], &packw_p[k],
						&pack_p[k], &pdepth_p[k], &rdenpf_p[k], &covinx_p[k], &snocov_p[k],
						&dull_p[k], &albedo, &xlnmlt_p[k], &mneghs_p[k], &paktmp_p[k],
						&neghts_p[k], &packwc_p[k], &neght_p[k], &gmeltr_p[k], &compct_p[k],
						&snowep_p[k], &mostht_p[k], &vap_p[k]);
				} 
				else 
				{
					// if (covinx.eq.0.0) covinx= 0.1*covind 
					if(fabs(covinx_p[k]) <= 1e-5)
						covinx_p[k] = covind_p[k] * 0.1;

					// calculate derived variables 
					pdepth_p[k] = packf_p[k] / rdenpf_p[k];

					if(packf_p[k] < covinx_p[k]) 
						snocov_p[k] = packf_p[k] / covinx_p[k];
					else 
						snocov_p[k] = 1.0;
					
					// initialize albedo 
					//int mon = nSMonth - 1;
					//albed(&mon, &lat, &dull, &albedo);
					
					// initialize neghts based on initial pack temperature and storage
					neghts_p[k] = (32.0 - paktmp_p[k]) * 0.00695 * packf_p[k];
				}
			}
		}
	}
	//End   ---snow module related

	for(i=0; i<nch; i++)
	{
//		double b0 = pReachInfo[i].width;
		double dx = pReachInfo[i].length*MILE_TO_FEET;
		double h0 = pReachInfo[i].depth;
		double r1 = pReachInfo[i].r1;
		double r2 = pReachInfo[i].r2;
		double w1 = pReachInfo[i].w1;
		double s  = pReachInfo[i].slope;
		double mn = pReachInfo[i].mann;

		// add code here, if cross section not defined, use the above
		// otherwise, use the following instead
		bool bInserted = false;
		if(pReachInfo[i].poly.pointList.GetCount() < 3)
		{
			pReachInfo[i].BuildDefaultPoly();
			bInserted = true;
		}

		pReachInfo[i].ftable(&fh[i*fnt], &fv[i*fnt], &fq[i*fnt], &qk[i*fnt], &fa[i*fnt], &fp[i*fnt], &fr[i*fnt], &fsa[i*fnt]);	//   (04-28-04)
		if(bInserted)
		{
			pReachInfo[i].poly.CPoly_Free();
			pReachInfo[i].poly.bCustomized = false;
		}
		// allocate memory here
		if (pChannelInfo != NULL)
		{
			int nDSch = pChannelInfo[i].nDSchan;
			if (nDSch > 0)
			{
				pChannelInfo[i].down_flow = new double[nDSch];//cfs
				pChannelInfo[i].bypass_flow = new double[nDSch];//cfs
				if (nCHsummary > 0)
				{
					pChannelInfo[i].down_flow_s = new double[nDSch];
					pChannelInfo[i].bypass_flow_s = new double[nDSch];
				}
				if (tempfg == 1)
				{
					pChannelInfo[i].down_temp = new double[nDSch];//degreeC*ft3
					pChannelInfo[i].bypass_temp = new double[nDSch];//degreeC*ft3
					if (nCHsummary > 0)
					{
						pChannelInfo[i].down_temp_s = new double[nDSch];
						pChannelInfo[i].bypass_temp_s = new double[nDSch];
					}
				}

				if (pqalfg == 1 && nQuals > 0)
				{
					pChannelInfo[i].down_matqal = new double[nDSch*nQuals];//lb
					pChannelInfo[i].bypass_matqal = new double[nDSch*nQuals];//lb
					pChannelInfo[i].down_sedqal = new double[nDSch*nQuals*3];//lb (sand, silt, clay)
					pChannelInfo[i].bypass_sedqal = new double[nDSch*nQuals*3];//lb (sand, silt, clay)
					if (nCHsummary > 0)
					{
						pChannelInfo[i].down_matqal_s = new double[nDSch*nQuals];
						pChannelInfo[i].bypass_matqal_s = new double[nDSch*nQuals];
					}
				}
				if (oxfg == 1)
				{
					pChannelInfo[i].down_dox = new double[nDSch];//g
					pChannelInfo[i].bypass_dox = new double[nDSch];//g
					pChannelInfo[i].down_bod = new double[nDSch];//g
					pChannelInfo[i].bypass_bod = new double[nDSch];//g
					if (nCHsummary > 0)
					{
						pChannelInfo[i].down_dox_s = new double[nDSch];
						pChannelInfo[i].down_bod_s = new double[nDSch];
						pChannelInfo[i].bypass_dox_s = new double[nDSch];
						pChannelInfo[i].bypass_bod_s = new double[nDSch];
					}
				}
				if (nutfg == 1)
				{
					pChannelInfo[i].down_no3 = new double[nDSch];//g
					pChannelInfo[i].bypass_no3 = new double[nDSch];//g
					pChannelInfo[i].down_tam = new double[nDSch];//g
					pChannelInfo[i].bypass_tam = new double[nDSch];//g
					pChannelInfo[i].down_no2 = new double[nDSch];//g
					pChannelInfo[i].bypass_no2 = new double[nDSch];//g
					pChannelInfo[i].down_po4 = new double[nDSch];//g
					pChannelInfo[i].bypass_po4 = new double[nDSch];//g
					pChannelInfo[i].down_spo4 = new double[nDSch*3];//g
					pChannelInfo[i].bypass_spo4 = new double[nDSch*3];//g
					pChannelInfo[i].down_snh4 = new double[nDSch*3];//g
					pChannelInfo[i].bypass_snh4 = new double[nDSch*3];//g
					if (nCHsummary > 0)
					{
						pChannelInfo[i].down_no3_s = new double[nDSch];
						pChannelInfo[i].down_tam_s = new double[nDSch];
						pChannelInfo[i].down_no2_s = new double[nDSch];
						pChannelInfo[i].down_po4_s = new double[nDSch];
						pChannelInfo[i].down_SNH4_s = new double[nDSch*3];
						pChannelInfo[i].down_SPO4_s = new double[nDSch*3];
						pChannelInfo[i].bypass_no3_s = new double[nDSch];
						pChannelInfo[i].bypass_tam_s = new double[nDSch];
						pChannelInfo[i].bypass_no2_s = new double[nDSch];
						pChannelInfo[i].bypass_po4_s = new double[nDSch];
						pChannelInfo[i].bypass_SNH4_s = new double[nDSch*3];
						pChannelInfo[i].bypass_SPO4_s = new double[nDSch*3];
					}
				}
				if (plkfg == 1)
				{
					pChannelInfo[i].down_phy = new double[nDSch];//g
					pChannelInfo[i].bypass_phy = new double[nDSch];//g
					pChannelInfo[i].down_zoo = new double[nDSch];//g
					pChannelInfo[i].bypass_zoo = new double[nDSch];//g
					pChannelInfo[i].down_orn = new double[nDSch];//g
					pChannelInfo[i].bypass_orn = new double[nDSch];//g
					pChannelInfo[i].down_orp = new double[nDSch];//g
					pChannelInfo[i].bypass_orp = new double[nDSch];//g
					pChannelInfo[i].down_orc = new double[nDSch];//g
					pChannelInfo[i].bypass_orc = new double[nDSch];//g
					if (nCHsummary > 0)
					{
						pChannelInfo[i].down_orn_s = new double[nDSch];
						pChannelInfo[i].down_orp_s = new double[nDSch];
						pChannelInfo[i].down_orc_s = new double[nDSch];
						pChannelInfo[i].bypass_orn_s = new double[nDSch];
						pChannelInfo[i].bypass_orp_s = new double[nDSch];
						pChannelInfo[i].bypass_orc_s = new double[nDSch];
					}
				}
				if (phfg == 1)
				{
					pChannelInfo[i].down_tic = new double[nDSch];//g
					pChannelInfo[i].bypass_tic = new double[nDSch];//g
					pChannelInfo[i].down_co2 = new double[nDSch];//g
					pChannelInfo[i].bypass_co2 = new double[nDSch];//g
					if (nCHsummary > 0)
					{
						pChannelInfo[i].down_tic_s = new double[nDSch];
						pChannelInfo[i].down_co2_s = new double[nDSch];
						pChannelInfo[i].bypass_tic_s = new double[nDSch];
						pChannelInfo[i].bypass_co2_s = new double[nDSch];
					}
				}
				if(sedfg == 1 && NumSed > 0)
				{
					pChannelInfo[i].down_matsed = new double[nDSch*NumSed];//g
					pChannelInfo[i].bypass_matsed = new double[nDSch*NumSed];//g
					if (nCHsummary > 0)	// stream summary
					{
						pChannelInfo[i].down_matsed_s = new double[nDSch*NumSed];
						pChannelInfo[i].bypass_matsed_s = new double[nDSch*NumSed];
					}
				}
				
				// initialize
				for(j=0; j<nDSch; j++)
				{
					pChannelInfo[i].down_flow[j] = 0.0;
					pChannelInfo[i].bypass_flow[j] = 0.0;
					if (nCHsummary > 0)
					{
						pChannelInfo[i].down_flow_s[j] = 0.0;
						pChannelInfo[i].bypass_flow_s[j] = 0.0;
					}

					if (pqalfg == 1)
					{
						for (k=0; k<nQuals; k++)
						{
							pChannelInfo[i].down_matqal[j*nQuals+k] = 0.0;
							pChannelInfo[i].bypass_matqal[j*nQuals+k] = 0.0;
							if (nCHsummary > 0)
							{
								pChannelInfo[i].down_matqal_s[j*nQuals+k] = 0.0;
								pChannelInfo[i].bypass_matqal_s[j*nQuals+k] = 0.0;
							}
							for (int s=0; s<3; s++)
							{
								pChannelInfo[i].down_sedqal[j*nQuals*3+k*3+s] = 0.0;
								pChannelInfo[i].bypass_sedqal[j*nQuals*3+k*3+s] = 0.0;
							}
						}
					}
					if (tempfg == 1)
					{
						pChannelInfo[i].down_temp[j] = 0.0;
						pChannelInfo[i].bypass_temp[j] = 0.0;
						if (nCHsummary > 0)
						{
							pChannelInfo[i].down_temp_s[j] = 0.0;
							pChannelInfo[i].bypass_temp_s[j] = 0.0;
						}
					}
					if (oxfg == 1)
					{
						pChannelInfo[i].down_dox[j] = 0.0;
						pChannelInfo[i].bypass_dox[j] = 0.0;
						pChannelInfo[i].down_bod[j] = 0.0;
						pChannelInfo[i].bypass_bod[j] = 0.0;
						if (nCHsummary > 0)
						{
							pChannelInfo[i].down_dox_s[j] = 0.0;
							pChannelInfo[i].down_bod_s[j] = 0.0;
							pChannelInfo[i].bypass_dox_s[j] = 0.0;
							pChannelInfo[i].bypass_bod_s[j] = 0.0;
						}
					}
					if (nutfg == 1)
					{
						pChannelInfo[i].down_no3[j] = 0.0;
						pChannelInfo[i].bypass_no3[j] = 0.0;
						pChannelInfo[i].down_tam[j] = 0.0;
						pChannelInfo[i].bypass_tam[j] = 0.0;
						pChannelInfo[i].down_no2[j] = 0.0;
						pChannelInfo[i].bypass_no2[j] = 0.0;
						pChannelInfo[i].down_po4[j] = 0.0;
						pChannelInfo[i].bypass_po4[j] = 0.0;
						for (int s=0; s<3; s++)
						{
							pChannelInfo[i].down_spo4[j*3+s] = 0.0;
							pChannelInfo[i].bypass_spo4[j*3+s] = 0.0;
							pChannelInfo[i].down_snh4[j*3+s] = 0.0;
							pChannelInfo[i].bypass_snh4[j*3+s] = 0.0;
						}
						if (nCHsummary > 0)
						{
							pChannelInfo[i].down_no3_s[j] = 0.0;
							pChannelInfo[i].down_tam_s[j] = 0.0;
							pChannelInfo[i].down_no2_s[j] = 0.0;
							pChannelInfo[i].down_po4_s[j] = 0.0;
							pChannelInfo[i].bypass_no3_s[j] = 0.0;
							pChannelInfo[i].bypass_tam_s[j] = 0.0;
							pChannelInfo[i].bypass_no2_s[j] = 0.0;
							pChannelInfo[i].bypass_po4_s[j] = 0.0;
							for (s=0; s<3; s++)
							{
								pChannelInfo[i].down_SNH4_s[j*3+s] = 0.0;
								pChannelInfo[i].down_SPO4_s[j*3+s] = 0.0;
								pChannelInfo[i].bypass_SNH4_s[j*3+s] = 0.0;
								pChannelInfo[i].bypass_SPO4_s[j*3+s] = 0.0;
							}
						}
					}
					if (plkfg == 1)
					{
						pChannelInfo[i].down_phy[j] = 0.0;
						pChannelInfo[i].down_zoo[j] = 0.0;
						pChannelInfo[i].down_orn[j] = 0.0;
						pChannelInfo[i].down_orp[j] = 0.0;
						pChannelInfo[i].down_orc[j] = 0.0;
						pChannelInfo[i].bypass_phy[j] = 0.0;
						pChannelInfo[i].bypass_zoo[j] = 0.0;
						pChannelInfo[i].bypass_orn[j] = 0.0;
						pChannelInfo[i].bypass_orp[j] = 0.0;
						pChannelInfo[i].bypass_orc[j] = 0.0;
						if (nCHsummary > 0)
						{
							pChannelInfo[i].down_orn_s[j] = 0.0;
							pChannelInfo[i].down_orp_s[j] = 0.0;
							pChannelInfo[i].down_orc_s[j] = 0.0;
							pChannelInfo[i].bypass_orn_s[j] = 0.0;
							pChannelInfo[i].bypass_orp_s[j] = 0.0;
							pChannelInfo[i].bypass_orc_s[j] = 0.0;
						}
					}
					if (phfg == 1)
					{
						pChannelInfo[i].down_tic[j] = 0.0;
						pChannelInfo[i].down_co2[j] = 0.0;
						pChannelInfo[i].bypass_tic[j] = 0.0;
						pChannelInfo[i].bypass_co2[j] = 0.0;
						if (nCHsummary > 0)
						{
							pChannelInfo[i].down_tic_s[j] = 0.0;
							pChannelInfo[i].down_co2_s[j] = 0.0;
							pChannelInfo[i].bypass_tic_s[j] = 0.0;
							pChannelInfo[i].bypass_co2_s[j] = 0.0;
						}
					}
					if (sedfg == 1)
					{
						for (k=0; k<NumSed; k++)
						{
							pChannelInfo[i].down_matsed[j*NumSed+k] = 0.0;
							pChannelInfo[i].bypass_matsed[j*NumSed+k] = 0.0;
							if (nCHsummary > 0)
							{
								pChannelInfo[i].down_matsed_s[j*NumSed+k] = 0.0;
								pChannelInfo[i].bypass_matsed_s[j*NumSed+k] = 0.0;
							}
						}
					}
				}
			}
		}
	}

	// find the weather data shift
	// Review the code again--
	// recalculate the tstart and tend 

/*	for(i=0; i<nwst; i++)
	{
		if(tmList[i].pRecord != NULL)
		{
			if(tmList[i].pRecord[0].tm > tStart)
				tStart = tmList[i].pRecord[0].tm;  
//				tStart = tmList[i].pRecord[0].tm - COleDateTimeSpan(0,0,delt,0);   
			if (toStart < tStart)					
				toStart = tStart;
			
			if(tmList[i].pRecord[tmList[i].nNum-1].tm < tEnd)
				tEnd = tmList[i].pRecord[tmList[i].nNum-1].tm;
			if (toEnd > tEnd)					
				toEnd = tEnd;
		}
	}
		
	for(i=0; i<nwst; i++)
	{
		if(tmList[i].pRecord != NULL)
		{
			for(j=0; j<tmList[i].nNum; j++)
			{
				if(tmList[i].pRecord[j].tm >= tStart)
				{
					tmList[i].nShift = j;
					break;
				}
			}
		}
	}
*/			
	// CREATE the output directory if it is necessary
	if (!FolderExists(m_strModelResultLocation))
	{
		TRY
		{
			_mkdir(LPCSTR(m_strModelResultLocation));
		}
		CATCH_ALL(e)
		{
			//open dialog box to select the folder
			CDirDialog dlg;
			dlg.m_strSelDir = m_strModelResultLocation;
			dlg.m_strTitle = "Model Results Directory:";
			if(dlg.DoBrowse() == 1)
				m_strModelResultLocation = dlg.m_strPath;

			if(m_strModelResultLocation.GetAt(m_strModelResultLocation.GetLength()-1) != '\\'
				&& m_strModelResultLocation.GetAt(m_strModelResultLocation.GetLength()-1) != '/')
				m_strModelResultLocation += "\\";
		}
		END_CATCH_ALL
	}

	// open timeseries files for writing
	for(i=0; i<nsws; i++)
	{
		// open linkage files
		if(nLinkFiles > 0)
		{
			//read the input timeseries files
			if(!pChannelInfo[i].cListUpStream.IsEmpty())
			{
				POSITION pos = pChannelInfo[i].cListUpStream.GetHeadPosition();
				while (pos != NULL)
				{
					Link435& plink435 = (Link435&) pChannelInfo[i].cListUpStream.GetNext(pos);

					if(!ReadLinkageFile(plink435.strFilePath, plink435))
					{
						AfxMessageBox("Cannot read the file" + plink435.strFilePath);
						Log("Cannot read the file" + plink435.strFilePath);
						goto L001;
					}
				}
			}

			//open the output timeseries files
			if(!pChannelInfo[i].cListDownStream.IsEmpty())
			{
				POSITION pos = pChannelInfo[i].cListDownStream.GetHeadPosition();
				while (pos != NULL)
				{
					Link435& plink435 = (Link435&) pChannelInfo[i].cListDownStream.GetNext(pos);

					if(!WriteLinkageFileHeader(plink435.strFilePath, plink435))
					{
						AfxMessageBox("Cannot write to file" + plink435.strFilePath);
						Log("Cannot write to file" + plink435.strFilePath);
						goto L001;
					}
				}
			}
		}

		if (pChannelInfo[i].comp == 0)
			continue;

		if(nDefault || nHydro || nSnow || nSed || nGQUAL || nRQUAL || nCustom)
		{
			pswsinfo[i].m_fileOut = NULL;
			CString strFileName;
			CString strFilePath = m_strModelResultLocation;
			strFileName.Format("%d.out",pswsinfo[i].subbasin);
			strFilePath += strFileName;

			if(!WriteOutputHeader(strFilePath, i))
			{
				AfxMessageBox("Cannot write to file" + strFilePath);
				Log("Cannot write to file" + strFilePath);
				goto L001;
			}
		}

		//land unit-area output for SUSTAIN model (Jan 2013)
		if (nSUSTAIN == 1)		 
		{
			//create a folder named as subwatershed ID
			CString strFolderName;
			CString strFolderPath = m_strModelResultLocation;
			strFolderName.Format("subbasin_%d",pswsinfo[i].subbasin);
			strFolderPath += strFolderName;
			if (!FolderExists(strFolderPath))
			{
				TRY
				{
					_mkdir(LPCSTR(strFolderPath));
				}
				CATCH_ALL(e)
				{
					//open dialog box to select the folder
					CDirDialog dlg;
					dlg.m_strSelDir = strFolderPath;
					dlg.m_strTitle = "Model Land-Based Results Directory:";
					if(dlg.DoBrowse() == 1)
						strFolderPath = dlg.m_strPath;
				}
				END_CATCH_ALL
			}

			if(strFolderPath.GetAt(strFolderPath.GetLength()-1) != '\\'
				&& strFolderPath.GetAt(strFolderPath.GetLength()-1) != '/')
				strFolderPath += "\\";

			//ifwo outflow file 
			CString strFileName,strFilePath;
			pswsinfo[i].m_file_IFWO = NULL;
			strFileName.Format("%d_IFWO.txt",pswsinfo[i].subbasin);
			strFilePath.Format(strFolderPath + strFileName);
			if(!WriteBaseFlowOutputHeader(strFilePath, i, 1))
			{
				AfxMessageBox("Cannot write to file" + strFilePath);
				Log("Cannot write to file" + strFilePath);
				goto L001;
			}

			// agwo outflow file
			pswsinfo[i].m_file_AGWO = NULL;
			strFileName.Format("%d_AGWO.txt",pswsinfo[i].subbasin);
			strFilePath.Format(strFolderPath + strFileName);
			if(!WriteBaseFlowOutputHeader(strFilePath, i, 0))
			{
				AfxMessageBox("Cannot write to file" + strFilePath);
				Log("Cannot write to file" + strFilePath);
				goto L001;
			}

			//write header info for each land output file
			for(k=0; k<nlandp; k++)
			{
//				if (pluinfop[i*nlandp+k].area == 0)
//					continue;

//				CString strFileName,strFilePath;
				pluinfop[i*nlandp+k].m_fileOut = NULL;
				strFileName.Format("%d_%s.txt",pluinfop[i*nlandp+k].luid,pluinfop[i*nlandp+k].luname);
				strFilePath.Format(strFolderPath + strFileName);
				
				if(!WriteLandOutputHeader(strFilePath, i, k))
				{
					AfxMessageBox("Cannot write to file" + strFilePath);
					Log("Cannot write to file" + strFilePath);
					goto L001;
				}
			}
		}
	}
	
	// open landuse summary file for writing
	if (nLUsummary > 0)
	{
		m_filelanduse = NULL;
		CString strFileName = m_strModelResultLocation + "landuse.csv";
		if(!WriteLanduseSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
		strFileName = m_strModelResultLocation + "landuse.out";
		if(!WriteLanduseSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
	}
	
	// open stream summary file for writing
	if (nCHsummary > 0)
	{
		m_filestream = NULL;
		CString strFileName = m_strModelResultLocation + "stream.csv";
		if(!WriteStreamSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
		strFileName = m_strModelResultLocation + "stream.out";
		if(!WriteStreamSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
	}

	// open point source summary file for writing
	if (nPSsummary > 0 && nPtSource > 0)
	{
		m_filepointsource = NULL;
		CString strFileName = m_strModelResultLocation + "pointsource.csv";
		if(!WritePointSourceSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
		strFileName = m_strModelResultLocation + "pointsource.out";
		if(!WritePointSourceSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
	}

	// open threshold analysis summary file for writing
	if (nThreshold > 0)
	{
		m_filethreshold = NULL;
		CString strFileName = m_strModelResultLocation + "threshold.csv";
		if(!WriteThresholdAnalysisSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
		strFileName = m_strModelResultLocation + "threshold.out";
		if(!WriteThresholdAnalysisSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
	}

	// open threshold statistics file for writing
	if (nThreshold > 0)
	{
		m_filethresholdstat = NULL;
		CString strFileName = m_strModelResultLocation + "thresholdstat.csv";
		if(!WriteThresholdStatSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
		strFileName = m_strModelResultLocation + "thresholdstat.out";
		if(!WriteThresholdStatSummaryHeader(strFileName,toStart,toEnd))
		{
			AfxMessageBox("Cannot write to file" + strFileName);
			Log("Cannot write to file"+strFileName);
			goto L001;
		}
	}

	eta = ETA_create();
	span = tEnd-tStart;
	ETA_begin(eta, 0, span.GetTotalSeconds());
	
	// original year, month, day
	tCurrent = tStart;
	tPrevious = tStart ; //Irrigation options Added by Sabu (9-2004)

	curDay = tCurrent.GetDay(); //Irrigation options Added by Sabu (9-2004)
	prevDay = tPrevious.GetDay(); //Irrigation options Added by Sabu (9-2004)

	// Model Start
	wndProgress.SetRange(0, 100);
	wndProgress.SetText("");
	// Minimize the main window
	pWnd->ShowWindow(SW_HIDE);

	int hr6fg;			
	int dryfg;			

//hspf - compute discharge rate(s) at start of run, based on init cond
 	for (i=0; i<nch; i++)
	{
		// find the stream index
		int nIndex = stream[i].index;
		int rgroup = pReachInfo[nIndex].rgid - 1;  

		double KS = pReachInfo[nIndex].ks;
		if (KS > 0)
		{
			int nFTindex = 0;
			double CONVF = 1.0;
			double LEN = pReachInfo[nIndex].length * MILE_TO_FEET;	// ft

			if (pReachFtable[nIndex].nFTrecord > 0)	// user defined FTABLE
			{
				int nRet = DISCH(nIndex, CONVF, &nFTindex, v2[nIndex], &q2[nIndex]);
				if (nRet == 2)
					goto L001;

				//compute depth, surface area, cross-sectional area and hydraulic radius
				//at start of run, based on init cond
 				nRet = AUXIL(nFTindex, v2[nIndex], LEN, &qh[nIndex], &SA[nIndex], &XA[nIndex], 
							 &HR[nIndex]);
				
				if(nRet == 2)	
					goto L001;
			}
		}

		//stream temperature 
		if (tempfg > 0)
		{
			//compute initial tmud and tmuddt for brock/caupp model
			//assume tmud= tw and tmuddt is small + negative (at midnight)
			if (ptmps_param2 != NULL)
			{
				int bedflg = ptmps_param2[rgroup].bedflg;	
				if (bedflg == 2) 
				{
					tmud_p[nIndex] = temp2[nIndex];	//degree C
					tmuddt_p[nIndex] = -0.1;		//degree C / ivl
				}
			}
		}

		// stream bank erosion (gram)
		if (sedfg == 1 && sedber == 1 && pReachInfo[nIndex].lkfg == 0)
		{
			int st1 = 0;
			int nRecord = pReachFtable[nIndex].nFTrecord;
			double qber = rsd_berparam[nIndex].qber;	// cfs

			// call berflow
			if (berflow(nIndex,delts,nRecord,fnt,v_bfd[nIndex],&fv[nIndex*fnt], 
				&fq[nIndex*fnt],&fa[nIndex*fnt],&fr[nIndex*fnt],&st1,
				&xa_thr[nIndex],&hr_thr[nIndex],&qber) == 2)	goto L001;
			if(st1 < 0)
			{
				CString strError;
				strError.Format("Check channel %d", pChannelInfo[nIndex].rchid);
				AfxMessageBox(strError);
				Log(strError);
				goto L001;
			}
			if (rsd_berparam[nIndex].qber < 0)
			{
				q_bfd[nIndex] = qber;
//				rsd_berparam[nIndex].qber = qber;
			}
		}
	}

	for(j=0; j<nsws; j++)
	{
		// linkage files
		if(nLinkFiles > 0)
		{
			//open the output timeseries files
			if(!pChannelInfo[j].cListDownStream.IsEmpty())
			{
				POSITION pos = pChannelInfo[j].cListDownStream.GetHeadPosition();
				while (pos != NULL)
				{
					Link435& plink435 = (Link435&) pChannelInfo[j].cListDownStream.GetNext(pos);

					CString strTemp,strRecord;
					int nYear = tStart.GetYear();
					int nMonth = tStart.GetMonth();
					int nDay = tStart.GetDay();
					int nYear1 = tEnd.GetYear();
					int nMonth1 = tEnd.GetMonth();
					int nDay1 = tEnd.GetDay();

					strRecord.Format("C ReachID:%d   OutletID:%d\nC Date/time					Values\nC\n",plink435.nrchid, plink435.nOutlet);  
					strTemp.Format("%d/%d/%d\t%d/%d/%d\t%d\t%d\t%d\n",nMonth,nDay,nYear,nMonth1,nDay1,nYear1,deltm,nQuals,NumSed);
					strRecord += strTemp;
					strTemp.Format("%d\t%d\t%d\t%d\t%d\t%d\t%d\n",tempfg,sedfg,pqalfg,oxfg,nutfg,plkfg,phfg);
					strRecord += strTemp;
				
					if(!WriteOutputLine(strRecord, plink435.m_linkfile))                      
					{
						AfxMessageBox("Cannot write to file" + plink435.strFilePath);
						Log("Cannot write to file" + plink435.strFilePath);
						goto L001;
					}
				}
			}
		}

		if(pChannelInfo[j].comp == 0)
			continue;

		if(nDefault || nHydro || nSnow || nSed || nGQUAL || nRQUAL || nCustom)
		{
			CString strFileName;
			CString strFilePath = m_strModelResultLocation;
			strFileName.Format("%d.out",pswsinfo[j].subbasin);
			strFilePath += strFileName;

			CString strRecord1 = "",strRecord2 = "";
			if (sedfg == 1 && sedber == 1 && pReachInfo[j].lkfg == 0 && rsd_berparam[j].qber < 0)
				strRecord1.Format("TT REACH_%d qber at the bank full depth: %8.3f (cfs)\n",pReachInfo[j].rchid,q_bfd[j]); 
			
			strRecord2.Format("TT WATERSHED_%d Area: %8.3f (acres)\nTT Date/time					Values\nTT",pswsinfo[j].subbasin,fArea[j]);  
		
			strRecord1 += strRecord2;
			if(!WriteOutputLine(strRecord1, pswsinfo[j].m_fileOut))                      
			{
				AfxMessageBox("Cannot write to file" + strFilePath);
				Log("Cannot write to file" + strFilePath);
				goto L001;
			}
		}

		// land unit-area output for SUSTAIN model
		if(nSUSTAIN == 1)
		{
			CString strFolderName,strFileName,strFilePath,strRecord;
			CString strFolderPath = m_strModelResultLocation;
			strFolderName.Format("subbasin_%d",pswsinfo[j].subbasin);
			strFolderPath += strFolderName;
			strFolderPath += "\\";

			//ifwo outflow file 
			strFileName.Format("%d_IFWO.txt",pswsinfo[j].subbasin);
			strFilePath.Format(strFolderPath + strFileName);

			strRecord.Format("TT WATERSHED_%d Area: %8.3f (acres)\nTT Date/time					Values\nTT",pswsinfo[j].subbasin,fArea[j]);  
		
			if(!WriteOutputLine(strRecord, pswsinfo[j].m_file_IFWO))                      
			{
				AfxMessageBox("Cannot write to file" + strFilePath);
				Log("Cannot write to file" + strFilePath);
				goto L001;
			}

			//agwo outflow file 
			strFileName.Format("%d_AGWO.txt",pswsinfo[j].subbasin);
			strFilePath.Format(strFolderPath + strFileName);

			strRecord.Format("TT WATERSHED_%d Area: %8.3f (acres)\nTT Date/time					Values\nTT",pswsinfo[j].subbasin,fArea[j]);  
		
			if(!WriteOutputLine(strRecord, pswsinfo[j].m_file_AGWO))                      
			{
				AfxMessageBox("Cannot write to file" + strFilePath);
				Log("Cannot write to file" + strFilePath);
				goto L001;
			}

			//write header info for each land output file
			for(k=0; k<nlandp; k++)
			{
//				if (pluinfop[j*nlandp+k].area == 0)
//					continue;

				strFileName.Format("%d_%s.txt",pluinfop[j*nlandp+k].luid,pluinfop[j*nlandp+k].luname);
				strFilePath.Format(strFolderPath + strFileName);

				strRecord.Format("TT Landuse_%d Area: %8.3f (acres)\nTT Date/time					Values\nTT",pluinfop[j*nlandp+k].luid,1.0);  
			
				if(!WriteOutputLine(strRecord, pluinfop[j*nlandp+k].m_fileOut))                      
				{
					AfxMessageBox("Cannot write to file" + strFilePath);
					Log("Cannot write to file" + strFilePath);
					goto L001;
				}
			}
		}
	}

	//check the monthly flag
	int mon, nxtmon, ndays, nYear, day;
	mon = tStart.GetMonth() - 1;
	nxtmon = mon + 1;
	if(nxtmon >= 12)
		nxtmon = 0;

	if(mon == 0 || mon == 2 || mon == 4 || mon == 6 || mon == 7 || mon == 9 || mon == 11)
		ndays = 31;
	if(mon == 3 || mon == 5 || mon == 8 || mon == 10)
		ndays = 30;

	nYear = tStart.GetYear();
	
	if(mon == 1)
	{
		if(nYear%400 == 0)
			ndays = 29;
		else if(nYear%100 == 0)
			ndays = 28;
		else if(nYear%4 == 0)
			ndays = 29;
		else
			ndays = 28;
	}
	
	day = tStart.GetDay();

	for(j=0; j<nsws; j++)
	{
		int lgroup = pswsinfo[j].gindex;
		for(k=0; k<nlandp; k++)
		{
			nOrder = lgroup*nlandp+k;

			if(vcsfg == 1)
			{
				cepscm = cepscm_p[nOrder].fnum;
				cepsc = dayval(&cepscm[mon], &cepscm[nxtmon], &day, &ndays);
				ppw_param4[nOrder].cepsc_p = cepsc;
			}
			if(vuzfg == 1)
			{
				uzsnm = uzsnm_p[nOrder].fnum;
				uzsn = dayval(&uzsnm[mon], &uzsnm[nxtmon], &day, &ndays);
				ppw_param4[nOrder].uzsn_p = uzsn;
			}
			if(vnnfg == 1)
			{
				nsurm = nsurm_p[nOrder].fnum;
				nsur = dayval(&nsurm[mon], &nsurm[nxtmon], &day, &ndays);
				ppw_param4[nOrder].nsur_p = nsur;
			}
			if(vifwfg == 1)
			{
				intfwm = intfwm_p[nOrder].fnum;
				intfw = dayval(&intfwm[mon], &intfwm[nxtmon], &day, &ndays);
				ppw_param4[nOrder].intfw_p = intfw;
			}
			if(vircfg == 1)
			{
				ircm = ircm_p[nOrder].fnum;
				irc = dayval(&ircm[mon], &ircm[nxtmon], &day, &ndays);
				ppw_param4[nOrder].irc_p = irc;
			}
			if(vlefg == 1)
			{
				lzetpm = lzetpm_p[nOrder].fnum;
				lzetp = dayval(&lzetpm[mon], &lzetpm[nxtmon], &day, &ndays);
				ppw_param4[nOrder].lzetp_p = lzetp;
			}
		}
	}

	// ++++++++ SIMULATION ++++++++
	  
TRY
{
	for(i=0;;i++)		                                   
	{
		if(bCalcEnd)
			goto L001;

		tspan = COleDateTimeSpan(0, 0, i*deltm,0);                    
		tPrevious = tCurrent ; //Irrigation option
		tCurrent = tStart + tspan;

		int nSYear = tCurrent.GetYear();
		int nSMonth = tCurrent.GetMonth();
		int nSDay = tCurrent.GetDay();
		int nSHour = tCurrent.GetHour();
		int nSMinute = tCurrent.GetMinute();                          

		//Irrigation options Added by Sabu (9-2004)
		curDay = tCurrent.GetDay(); 
		prevDay = tPrevious.GetDay();  

		bool b_Month = (tCurrent.GetMonth() == toStart.GetMonth());
		bool bMonth = (tCurrent.GetMonth() == 1);
		bool bDay = (tCurrent.GetDay() == 1);
		bool bHour = (tCurrent.GetHour() == 0);
		bool bMinute = (tCurrent.GetMinute() == 0);
		bool bSecond = (tCurrent.GetSecond() == 0);
	
		minfg = (bSecond)?1:0;                                                         
		hrfg  = (bMinute && bSecond)?1:0;
		dayfg = (bHour && bMinute && bSecond)?1:0;
		mofg  = (bDay && bHour && bMinute && bSecond)?1:0;
		yrfg = (b_Month && bDay && bHour && bMinute && bSecond)?1:0;

		// linkage files
		if(nLinkFiles > 0)
		{
			for(j=0; j<nsws; j++)
			{
				//output timeseries files
				if(!pChannelInfo[j].cListDownStream.IsEmpty())
				{
					POSITION pos = pChannelInfo[j].cListDownStream.GetHeadPosition();
					while (pos != NULL)
					{
						Link435& plink435 = (Link435&) pChannelInfo[j].cListDownStream.GetNext(pos);

						int nIndex = plink435.nOutlet - 1;
						if(nIndex >= pChannelInfo[j].nDSchan)
						{
							CString strError1;
							strError1.Format("Outlet index:%d for reach:%d is not correct in card 435",plink435.nOutlet, plink435.nrchid);
							AfxMessageBox(strError1);
							Log(strError1);
							goto L001;
						}

						CString str;
						CString strRecord;
						strRecord.Format("%d\t%d\t%d\t%d\t%d",
							nSYear, nSMonth, nSDay, nSHour, nSMinute);    

						str.Format("\t%12.12e", pChannelInfo[j].down_flow[nIndex]+pChannelInfo[j].bypass_flow[nIndex]);
						strRecord += str;

						if (tempfg == 1)
						{
							str.Format("\t%12.12e", pChannelInfo[j].down_temp[nIndex]+pChannelInfo[j].bypass_temp[nIndex]);
							strRecord += str;
						}

						if (sedfg == 1)
						{
							for (int jk=0; jk<NumSed; jk++)
							{
								str.Format("\t%12.12e", pChannelInfo[j].down_matsed[nIndex*NumSed+jk]+pChannelInfo[j].bypass_matsed[nIndex*NumSed+jk]);
								strRecord += str;
							}
						}

						if (pqalfg == 1)
						{
							for (int jk=0; jk<nQuals; jk++)
							{
								str.Format("\t%12.12e", pChannelInfo[j].down_matqal[nIndex*nQuals+jk]+pChannelInfo[j].bypass_matqal[nIndex*nQuals+jk]);
								strRecord += str;
								for (int s=0; s<3; s++)
								{
									str.Format("\t%12.12e", pChannelInfo[j].down_sedqal[nIndex*nQuals*3+jk*3+s]+pChannelInfo[j].bypass_sedqal[nIndex*nQuals*3+jk*3+s]);
									strRecord += str;
								}
							}
						}

						if (oxfg == 1)
						{
							str.Format("\t%12.12e", pChannelInfo[j].down_dox[nIndex]+pChannelInfo[j].bypass_dox[nIndex]);
							strRecord += str;
							str.Format("\t%12.12e", pChannelInfo[j].down_bod[nIndex]+pChannelInfo[j].bypass_bod[nIndex]);
							strRecord += str;
						}

						if (nutfg == 1)
						{
							str.Format("\t%12.12e", pChannelInfo[j].down_no3[nIndex]+pChannelInfo[j].bypass_no3[nIndex]);
							strRecord += str;
							str.Format("\t%12.12e", pChannelInfo[j].down_tam[nIndex]+pChannelInfo[j].bypass_tam[nIndex]);
							strRecord += str;
							str.Format("\t%12.12e", pChannelInfo[j].down_no2[nIndex]+pChannelInfo[j].bypass_no2[nIndex]);
							strRecord += str;
							str.Format("\t%12.12e", pChannelInfo[j].down_po4[nIndex]+pChannelInfo[j].bypass_po4[nIndex]);
							strRecord += str;
							for (int s=0; s<3; s++)
							{
								str.Format("\t%12.12e", pChannelInfo[j].down_snh4[nIndex*3+s]+pChannelInfo[j].bypass_snh4[nIndex*3+s]);
								strRecord += str;
							}
							for (s=0; s<3; s++)
							{
								str.Format("\t%12.12e", pChannelInfo[j].down_spo4[nIndex*3+s]+pChannelInfo[j].bypass_spo4[nIndex*3+s]);
								strRecord += str;
							}
						}

						if (plkfg == 1)
						{
							str.Format("\t%12.12e", pChannelInfo[j].down_phy[nIndex]+pChannelInfo[j].bypass_phy[nIndex]);
							strRecord += str;
							str.Format("\t%12.12e", pChannelInfo[j].down_zoo[nIndex]+pChannelInfo[j].bypass_zoo[nIndex]);
							strRecord += str;
							str.Format("\t%12.12e", pChannelInfo[j].down_orn[nIndex]+pChannelInfo[j].bypass_orn[nIndex]);
							strRecord += str;
							str.Format("\t%12.12e", pChannelInfo[j].down_orp[nIndex]+pChannelInfo[j].bypass_orp[nIndex]);
							strRecord += str;
							str.Format("\t%12.12e", pChannelInfo[j].down_orc[nIndex]+pChannelInfo[j].bypass_orc[nIndex]);
							strRecord += str;
						}

						if (phfg == 1)
						{
							str.Format("\t%12.12e", pChannelInfo[j].down_tic[nIndex]+pChannelInfo[j].bypass_tic[nIndex]);
							strRecord += str;
							str.Format("\t%12.12e", pChannelInfo[j].down_co2[nIndex]+pChannelInfo[j].bypass_co2[nIndex]);
							strRecord += str;
						}

						if(!WriteOutputLine(strRecord, plink435.m_linkfile))                      
						{
							AfxMessageBox("Cannot write to file" + plink435.strFilePath);
							Log("Cannot write to file" + plink435.strFilePath);
							goto L001;
						}
					}
				}
			}
		}		

		// Output Result
		int printfg = dayfg;           

		if(optlevel == 2)
			printfg = minfg;                          

		if(printfg > 0 && i > 0)
		{
			//Output Manager
			if (tCurrent > toStart && tCurrent <= (toEnd+COleDateTimeSpan(0, 0, deltm, 0)))
			{
				COleDateTimeSpan tspan1, tspan2;

				if(optlevel == 2) 
					tspan1 = COleDateTimeSpan(0, 0, deltm, 0);						 
				else
					tspan1 = COleDateTimeSpan(1, 0, 0, 0);							 

				COleDateTime tTemp = tCurrent - tspan1;
				int nMyYear    = tTemp.GetYear();
				int nMyMonth   = tTemp.GetMonth();
				int nMyDay     = tTemp.GetDay();
				int nMyHour    = tTemp.GetHour();
				int nMyMinute  = tTemp.GetMinute();								 

				int ndays = 28;
				if(nMyMonth == 2)
				{
					if(nMyYear%4 == 0 || nMyYear%400 == 0)
						ndays = 29;
				}
				else if(nMyMonth == 4 || nMyMonth == 6 || nMyMonth == 9 || nMyMonth == 11)
					ndays = 30;
				else
					ndays = 31;

				if(nLUsummary == 2 || nLUsummary == 3)
				{
					//dt = 1.0;
					
					int timefg = 0;
					if (nLUsummary == 2)
					{
						//dt = 365/deltd;			// ivl/year
						timefg = yrfg;
					}
					else if (nLUsummary == 3)
					{
						//dt = ndays/deltd;		// ivl/month
						timefg = mofg;
					}

					if(timefg == 1 || tCurrent >= toEnd)
					{
						dt = max(0,counter);
						counter = 0;//reset the counter

						tspan2 = COleDateTimeSpan(1, 0, 0, 0);
						COleDateTime tTemp2 = tCurrent- tspan2;
						int nYear    = tTemp2.GetYear();
						int nMonth   = tTemp2.GetMonth();
						int nDay   = tTemp2.GetDay();
						CString strFileName = m_strModelResultLocation + "landuse.csv";
						CString str,strRecord;

						for(j=0; j<nsws; j++)
						{
							strRecord = "";
							int lgroup = pswsinfo[j].gindex;
							for(k=0; k<nlandp; k++)
							{
								str.Format("%d,%d,AREA,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,area_s[j*nlandp+k]/dt);
								strRecord += str;
								str.Format("%d,%d,PREC,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,precip_s[j*nlandp+k]);
								strRecord += str;
								str.Format("%d,%d,SURO,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,suro_s[j*nlandp+k]);
								strRecord += str;
								str.Format("%d,%d,IFWO,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,ifwo_s[j*nlandp+k]);
								strRecord += str;
								str.Format("%d,%d,AGWO,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,agwo_s[j*nlandp+k]);
								strRecord += str;
								str.Format("%d,%d,PERO,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,pero_s[j*nlandp+k]);
								strRecord += str;
								str.Format("%d,%d,TAET,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,taet_s[j*nlandp+k]);
								strRecord += str;

								area_s[j*nlandp+k] = 0.0;
								precip_s[j*nlandp+k] = 0.0;
								suro_s[j*nlandp+k] = 0.0;
								ifwo_s[j*nlandp+k] = 0.0;
								agwo_s[j*nlandp+k] = 0.0;
								pero_s[j*nlandp+k] = 0.0;
								taet_s[j*nlandp+k] = 0.0;
								
								if (sedfg == 1)
								{
									str.Format("%d,%d,SEDLOAD,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,sedload_s[j*nlandp+k]);  
									strRecord += str;
									str.Format("%d,%d,SEDWSSD,%d/%d/%d,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,sedwssd_s[j*nlandp+k]);  
									strRecord += str;
									str.Format("%d,%d,SEDSCRS,%d/%d/%d,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,sedscrs_s[j*nlandp+k]);  
									strRecord += str;
									str.Format("%d,%d,SEDSURO,%d/%d/%d,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,sedsuro_s[j*nlandp+k]);  
									strRecord += str;
									str.Format("%d,%d,SEDIFWO,%d/%d/%d,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,sedifwo_s[j*nlandp+k]);  
									strRecord += str;
									str.Format("%d,%d,SEDAGWO,%d/%d/%d,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,nMonth,nDay,nYear,sedagwo_s[j*nlandp+k]);  
									strRecord += str;
									sedload_s[j*nlandp+k] = 0.0;
									sedwssd_s[j*nlandp+k] = 0.0;
									sedscrs_s[j*nlandp+k] = 0.0;
									sedsuro_s[j*nlandp+k] = 0.0;
									sedifwo_s[j*nlandp+k] = 0.0;
									sedagwo_s[j*nlandp+k] = 0.0;
								}
								
								if (pqalfg == 1)
								{
									for(int m=0; m<nQuals; m++)
									{
										double unit = 1.0;
										if(pQual[m].qunit == "(#/100ml)")
											unit = 453592.0; 

										str.Format("%d,%d,%s,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,nMonth,nDay,nYear,uniload_s[j*nlandp*nQuals+k*nQuals+m]*unit);
										strRecord += str;
										uniload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
										if (pQual[m].qsdfg > 0 && sedfg == 1)
										{
											str.Format("%d,%d,SED_%s,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,nMonth,nDay,nYear,suniload_s[j*nlandp*nQuals+k*nQuals+m]*unit);  
											strRecord += str;
											suniload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
											str.Format("%d,%d,SEDWSSD_%s,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,nMonth,nDay,nYear,washqsload_s[j*nlandp*nQuals+k*nQuals+m]*unit);  
											strRecord += str;
											washqsload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
											str.Format("%d,%d,SEDSCRS_%s,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,nMonth,nDay,nYear,scrqsload_s[j*nlandp*nQuals+k*nQuals+m]*unit);  
											strRecord += str;
											scrqsload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
										}
									}
								}
								if (oxfg == 1)
								{
									for(int m=0; m<11; m++)
									{
										if (rqflag_s[m] > 0)
										{
											str.Format("%d,%d,RQ_%s,%d/%d/%d,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,rqname_s[m],nMonth,nDay,nYear,rqload_s[j*nlandp*11+k*11+m]);
											strRecord += str;
										}
										rqload_s[j*nlandp*11+k*11+m] = 0.0;
									}
								}
							}
							// output to the landuse summary file
							if(!WriteOutputLine(strRecord, m_filelanduse))                      
							{
								AfxMessageBox("Cannot write to file" + strFileName);
								Log("Cannot write to file" + strFileName);
								goto L001;
							}
						}
					}
				}

				if(nCHsummary == 2 || nCHsummary == 3)
				{
					int timefg = 0;
					if (nCHsummary == 2)
						timefg = yrfg;
					else if (nCHsummary == 3)
						timefg = mofg;

					if(timefg == 1 || tCurrent >= toEnd)
					{
						tspan2 = COleDateTimeSpan(1, 0, 0, 0);
						COleDateTime tTemp2 = tCurrent - tspan2;
						int nYear    = tTemp2.GetYear();
						int nMonth   = tTemp2.GetMonth();
						int nDay     = tTemp2.GetDay();
						CString strFileName = m_strModelResultLocation + "stream.csv";
						CString str,strRecord;

						for(j=0; j<nch; j++)
						{
							// find the stream index
							int nIndex = stream[j].index;
							int lgroup = pswsinfo[nIndex].gindex;		
							int rgroup = pReachInfo[nIndex].rgid - 1;  

							strRecord = "";
							str.Format("%d,-1,USIF,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,usif_s[nIndex]);
							strRecord += str;
							usif_s[nIndex] = 0.0;

							str.Format("%d,-2,LUIF,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,luif_s[nIndex]);
							strRecord += str;
							luif_s[nIndex] = 0.0;

							str.Format("%d,-1,USBP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,usifbp_s[nIndex]);
							strRecord += str;
							usifbp_s[nIndex] = 0.0;

							str.Format("%d,-2,LUBP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,luifbp_s[nIndex]);
							strRecord += str;
							luifbp_s[nIndex] = 0.0;

							if (nPtSource > 0)
							{
								str.Format("%d,-3,PSIF,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,psif_s[nIndex]);
								strRecord += str;
								psif_s[nIndex] = 0.0;

								str.Format("%d,-4,PSWD,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,pswd_s[nIndex]);
								strRecord += str;
								pswd_s[nIndex] = 0.0;

								str.Format("%d,-4,PSDT,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,pswddi_s[nIndex]);
								strRecord += str;
								pswddi_s[nIndex] = 0.0;
							}

							if (irrigfg == 1)
							{
								str.Format("%d,-5,IRWD,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,irwd_s[nIndex]);
								strRecord += str;
								irwd_s[nIndex] = 0.0;
							}

							str.Format("%d,0,IVOL,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,ivol_s[nIndex]);
							strRecord += str;
							ivol_s[nIndex] = 0.0;

							for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,RO,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,nMonth,nDay,nYear,pChannelInfo[nIndex].down_flow_s[j2]);
								strRecord += str;
								pChannelInfo[nIndex].down_flow_s[j2] = 0.0;
							}

							for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,BP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_flow_s[j2]);
								strRecord += str;
								pChannelInfo[nIndex].bypass_flow_s[j2] = 0.0;
							}

							if (tempfg == 1)
							{
								str.Format("%d,-1,USTEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,ustemp_s[nIndex]);
								strRecord += str;
								ustemp_s[nIndex] = 0.0;

								str.Format("%d,-2,LUTEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,lutemp_s[nIndex]);
								strRecord += str;
								lutemp_s[nIndex] = 0.0;

								str.Format("%d,-1,USTEBP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,ustempbp_s[nIndex]);
								strRecord += str;
								ustempbp_s[nIndex] = 0.0;

								str.Format("%d,-2,LUTEBP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,lutempbp_s[nIndex]);
								strRecord += str;
								lutempbp_s[nIndex] = 0.0;

								if (nPtSource > 0)
								{
									str.Format("%d,-3,PSTEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,pstemp_s[nIndex]);
									strRecord += str;
									pstemp_s[nIndex] = 0.0;

									str.Format("%d,-4,PSWDTEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,pswdtemp_s[nIndex]);
									strRecord += str;
									pswdtemp_s[nIndex] = 0.0;

									str.Format("%d,-4,PSDTTEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,pswdtempdi_s[nIndex]);
									strRecord += str;
									pswdtempdi_s[nIndex] = 0.0;
								}

								if (irrigfg == 1)
								{
									str.Format("%d,-5,IRWDTEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,irwdtemp_s[nIndex]);
									strRecord += str;
									irwdtemp_s[nIndex] = 0.0;
								}

								str.Format("%d,0,ITEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,itemp_s[nIndex]);
								strRecord += str;
								itemp_s[nIndex] = 0.0;

								for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									str.Format("%d,%d,ROTEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,nMonth,nDay,nYear,pChannelInfo[nIndex].down_temp_s[j2]);
									strRecord += str;
									pChannelInfo[nIndex].down_temp_s[j2] = 0.0;
								}

								for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									str.Format("%d,%d,BPTEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_temp_s[j2]);
									strRecord += str;
									pChannelInfo[nIndex].bypass_temp_s[j2] = 0.0;
								}
							}

							if (sedfg == 1)
							{
								for(int m=0; m<NumSed; m++)
								{
									if (sandfg == 0 && rsd_param[rgroup*NumSed+m].sedflg == 0) // sand is not simulated
										continue;

									str.Format("%d,-1,USSED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,ussed_s[nIndex*NumSed+m]);
									strRecord += str;
									ussed_s[nIndex*NumSed+m] = 0.0;

									str.Format("%d,-2,LUSED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,lused_s[nIndex*NumSed+m]);
									strRecord += str;
									lused_s[nIndex*NumSed+m] = 0.0;

									str.Format("%d,-1,USSBP_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,ussedbp_s[nIndex*NumSed+m]);
									strRecord += str;
									ussedbp_s[nIndex*NumSed+m] = 0.0;

									str.Format("%d,-2,LUSBP_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,lusedbp_s[nIndex*NumSed+m]);
									strRecord += str;
									lusedbp_s[nIndex*NumSed+m] = 0.0;

									if (nPtSource > 0)
									{
										str.Format("%d,-3,PSSED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,pssed_s[nIndex*NumSed+m]);
										strRecord += str;
										pssed_s[nIndex*NumSed+m] = 0.0;

										str.Format("%d,-4,PSWDSED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,pswdsed_s[nIndex*NumSed+m]);
										strRecord += str;
										pswdsed_s[nIndex*NumSed+m] = 0.0;

										str.Format("%d,-4,PSDTSED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,pswdseddi_s[nIndex*NumSed+m]);
										strRecord += str;
										pswdseddi_s[nIndex*NumSed+m] = 0.0;
									}

									if (irrigfg == 1)
									{
										str.Format("%d,-5,IRWDSED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,irwdsed_s[nIndex*NumSed+m]);
										strRecord += str;
										irwdsed_s[nIndex*NumSed+m] = 0.0;
									}

									if (sedber == 1 && pReachInfo[nIndex].lkfg == 0)
									{
										str.Format("%d,-6,SEDBER_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,bersed_s[nIndex*NumSed+m]);  
										strRecord += str;
										bersed_s[nIndex*NumSed+m] = 0.0;
									}

									str.Format("%d,0,ISED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,ised_s[nIndex*NumSed+m]);
									strRecord += str;
									ised_s[nIndex*NumSed+m] = 0.0;

									str.Format("%d,0,DEPSCR_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,depscr_ss[nIndex*NumSed+m]);
									strRecord += str;
									depscr_ss[nIndex*NumSed+m] = 0.0;

									str.Format("%d,0,DEPMASS_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,depmass_ss[nIndex*NumSed+m]);
									strRecord += str;
									depmass_ss[nIndex*NumSed+m] = 0.0;

									str.Format("%d,0,SCRMASS_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,scrmass_ss[nIndex*NumSed+m]);
									strRecord += str;
									scrmass_ss[nIndex*NumSed+m] = 0.0;

									str.Format("%d,0,BEDSED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,nMonth,nDay,nYear,bedsed_s[nIndex*NumSed+m]);
									strRecord += str;
									bedsed_s[nIndex*NumSed+m] = 0.0;

									for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
									{
										str.Format("%d,%d,ROSED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,m+1,nMonth,nDay,nYear,pChannelInfo[nIndex].down_matsed_s[j2*NumSed+m]);
										strRecord += str;
										pChannelInfo[nIndex].down_matsed_s[j2*NumSed+m] = 0.0;
									}

									for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
									{
										str.Format("%d,%d,BPSED_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,m+1,nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_matsed_s[j2*NumSed+m]);
										strRecord += str;
										pChannelInfo[nIndex].bypass_matsed_s[j2*NumSed+m] = 0.0;
									}
								}
							}

							if (pqalfg == 1)
							{
								for(int m=0; m<nQuals; m++)
								{
									double unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0; 

									str.Format("%d,-1,USQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,usqual_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									usqual_s[nIndex*nQuals+m] = 0.0;

									str.Format("%d,-2,LUQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,luqual_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									luqual_s[nIndex*nQuals+m] = 0.0;

									str.Format("%d,-1,USQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,usqualbp_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									usqualbp_s[nIndex*nQuals+m] = 0.0;

									str.Format("%d,-2,LUQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,luqualbp_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									luqualbp_s[nIndex*nQuals+m] = 0.0;

									if (nPtSource > 0)
									{
										str.Format("%d,-3,PSQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,psqual_s[nIndex*nQuals+m]*unit);
										strRecord += str;
										psqual_s[nIndex*nQuals+m] = 0.0;

										str.Format("%d,-4,PSWDQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,pswdqual_s[nIndex*nQuals+m]*unit);
										strRecord += str;
										pswdqual_s[nIndex*nQuals+m] = 0.0;

										str.Format("%d,-4,PSDTQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,pswdqualdi_s[nIndex*nQuals+m]*unit);
										strRecord += str;
										pswdqualdi_s[nIndex*nQuals+m] = 0.0;
									}

									if (irrigfg == 1)
									{
										str.Format("%d,-5,IRWDQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,irwdqual_s[nIndex*nQuals+m]*unit);
										strRecord += str;
										irwdqual_s[nIndex*nQuals+m] = 0.0;
									}

									if (sedfg == 1 && sedber == 1 && pReachInfo[nIndex].lkfg == 0 && pQualwq[rgroup*nQuals+m].qsdfg > 0)
									{
										str.Format("%d,-6,BERQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,berqual_s[nIndex*nQuals+m]*unit);
										strRecord += str;
										berqual_s[nIndex*nQuals+m] = 0.0;
									}

									str.Format("%d,0,ADTOT_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,adtot_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									adtot_s[nIndex*nQuals+m] = 0.0;

									str.Format("%d,0,IQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,iqual_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									iqual_s[nIndex*nQuals+m] = 0.0;

									str.Format("%d,0,ADQAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,adqal_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									adqal_s[nIndex*nQuals+m] = 0.0;

									str.Format("%d,0,DSQAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,dsqal_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									dsqal_s[nIndex*nQuals+m] = 0.0;

									str.Format("%d,0,DEPQAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,depqal_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									depqal_s[nIndex*nQuals+m] = 0.0;

									str.Format("%d,0,SCRQAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,nMonth,nDay,nYear,scrqal_s[nIndex*nQuals+m]*unit);
									strRecord += str;
									scrqal_s[nIndex*nQuals+m] = 0.0;

									for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
									{
										str.Format("%d,%d,QUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,pQual[m].qname,nMonth,nDay,nYear,pChannelInfo[nIndex].down_matqal_s[j2*nQuals+m]*unit);
										strRecord += str;
										pChannelInfo[nIndex].down_matqal_s[j2*nQuals+m] = 0.0;
									}

									for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
									{
										str.Format("%d,%d,QUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,pQual[m].qname,nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_matqal_s[j2*nQuals+m]*unit);
										strRecord += str;
										pChannelInfo[nIndex].bypass_matqal_s[j2*nQuals+m] = 0.0;
									}
								}
							}
							if (oxfg == 1)
							{
								int nNumRqual = 11;
								for(int m=0; m<2; m++)
								{
									str.Format("%d,-1,USRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,usrqual_s[nIndex*nNumRqual+m]);
									strRecord += str;
									usrqual_s[nIndex*nNumRqual+m] = 0.0;

									str.Format("%d,-2,LURQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,lurqual_s[nIndex*nNumRqual+m]);
									strRecord += str;
									lurqual_s[nIndex*nNumRqual+m] = 0.0;

									str.Format("%d,-2,ATMSRQUAL_%s,%d/%d/%d,%12.5e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,atmsrqual_s[nIndex*nNumRqual+m]);
									strRecord += str;
									atmsrqual_s[nIndex*nNumRqual+m] = 0.0;

									str.Format("%d,-1,USRQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,usrqualbp_s[nIndex*nNumRqual+m]);
									strRecord += str;
									usrqualbp_s[nIndex*nNumRqual+m] = 0.0;

									str.Format("%d,-2,LURQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,lurqualbp_s[nIndex*nNumRqual+m]);
									strRecord += str;
									lurqualbp_s[nIndex*nNumRqual+m] = 0.0;

									if (nPtSource > 0)
									{
										str.Format("%d,-3,PSRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,psrqual_s[nIndex*nNumRqual+m]);
										strRecord += str;
										psrqual_s[nIndex*nNumRqual+m] = 0.0;

										str.Format("%d,-4,PSWDRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,pswdrqual_s[nIndex*nNumRqual+m]);
										strRecord += str;
										pswdrqual_s[nIndex*nNumRqual+m] = 0.0;

										str.Format("%d,-4,PSDTRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,pswdrqualdi_s[nIndex*nNumRqual+m]);
										strRecord += str;
										pswdrqualdi_s[nIndex*nNumRqual+m] = 0.0;
									}

									if (irrigfg == 1)
									{
										str.Format("%d,-5,IRWDRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,irwdrqual_s[nIndex*nNumRqual+m]);
										strRecord += str;
										irwdrqual_s[nIndex*nNumRqual+m] = 0.0;
									}

									str.Format("%d,0,IRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,irqual_s[nIndex*nNumRqual+m]);
									strRecord += str;
									irqual_s[nIndex*nNumRqual+m] = 0.0;

									if (m == 0)
									{
										for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
										{
											str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_dox_s[j2]);
											strRecord += str;
											pChannelInfo[nIndex].down_dox_s[j2] = 0.0;
										}
										for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
										{
											str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_dox_s[j2]);
											strRecord += str;
											pChannelInfo[nIndex].bypass_dox_s[j2] = 0.0;
										}
									}
									else if(m == 1)
									{
										for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
										{
											str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_bod_s[j2]);
											strRecord += str;
											pChannelInfo[nIndex].down_bod_s[j2] = 0.0;
										}
										for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
										{
											str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_bod_s[j2]);
											strRecord += str;
											pChannelInfo[nIndex].bypass_bod_s[j2] = 0.0;
										}
									}
								}
								if (nutfg == 1)
								{
									for(int m=2; m<6; m++)
									{
										str.Format("%d,-1,USRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,usrqual_s[nIndex*nNumRqual+m]);
										strRecord += str;
										usrqual_s[nIndex*nNumRqual+m] = 0.0;

										str.Format("%d,-2,LURQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,lurqual_s[nIndex*nNumRqual+m]);
										strRecord += str;
										lurqual_s[nIndex*nNumRqual+m] = 0.0;

										str.Format("%d,-2,ATMSRQUAL_%s,%d/%d/%d,%12.5e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,atmsrqual_s[nIndex*nNumRqual+m]);
										strRecord += str;
										atmsrqual_s[nIndex*nNumRqual+m] = 0.0;

										str.Format("%d,-1,USRQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,usrqualbp_s[nIndex*nNumRqual+m]);
										strRecord += str;
										usrqualbp_s[nIndex*nNumRqual+m] = 0.0;

										str.Format("%d,-2,LURQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,lurqualbp_s[nIndex*nNumRqual+m]);
										strRecord += str;
										lurqualbp_s[nIndex*nNumRqual+m] = 0.0;

										if (nPtSource > 0)
										{
											str.Format("%d,-3,PSRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,psrqual_s[nIndex*nNumRqual+m]);
											strRecord += str;
											psrqual_s[nIndex*nNumRqual+m] = 0.0;

											str.Format("%d,-4,PSWDRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,pswdrqual_s[nIndex*nNumRqual+m]);
											strRecord += str;
											pswdrqual_s[nIndex*nNumRqual+m] = 0.0;

											str.Format("%d,-4,PSDTRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,pswdrqualdi_s[nIndex*nNumRqual+m]);
											strRecord += str;
											pswdrqualdi_s[nIndex*nNumRqual+m] = 0.0;
										}

										if (irrigfg == 1)
										{
											str.Format("%d,-5,IRWDRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,irwdrqual_s[nIndex*nNumRqual+m]);
											strRecord += str;
											irwdrqual_s[nIndex*nNumRqual+m] = 0.0;
										}

										str.Format("%d,0,IRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,irqual_s[nIndex*nNumRqual+m]);
										strRecord += str;
										irqual_s[nIndex*nNumRqual+m] = 0.0;

										if (m == 2)
										{
											for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
											{
												str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_no3_s[j2]);
												strRecord += str;
												pChannelInfo[nIndex].down_no3_s[j2] = 0.0;
											}
											for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
											{
												str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_no3_s[j2]);
												strRecord += str;
												pChannelInfo[nIndex].bypass_no3_s[j2] = 0.0;
											}
										}
										else if(m == 3)
										{
											for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
											{
												str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_tam_s[j2]);
												strRecord += str;
												pChannelInfo[nIndex].down_tam_s[j2] = 0.0;
											}
											for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
											{
												str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_tam_s[j2]);
												strRecord += str;
												pChannelInfo[nIndex].bypass_tam_s[j2] = 0.0;
											}
											if(sedfg == 1)
											{
												for (int j3=0; j3<3; j3++)
												{
													str.Format("%d,-1,USRQUAL_SNH4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,usSNH4_s[nIndex*3+j3]);
													strRecord += str;
													usSNH4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,-2,LURQUAL_SNH4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,luSNH4_s[nIndex*3+j3]);
													strRecord += str;
													luSNH4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,0,IRQUAL_SNH4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,iSNH4_s[nIndex*3+j3]);
													strRecord += str;
													iSNH4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,0,DSRQUAL_SNH4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,DSNH4_s[nIndex*3+j3]);
													strRecord += str;
													DSNH4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,0,DEPRQUAL_SNH4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,DEPNH4_s[nIndex*3+j3]);
													strRecord += str;
													DEPNH4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,0,SCRRQUAL_SNH4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,SCRNH4_s[nIndex*3+j3]);
													strRecord += str;
													SCRNH4_s[nIndex*3+j3] = 0.0;
												}
												for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													for (j3=0; j3<3; j3++)
													{
														str.Format("%d,%d,RQUAL_SNH4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,j3+1,nMonth,nDay,nYear,pChannelInfo[nIndex].down_SNH4_s[j2*3+j3]);
														strRecord += str;
														pChannelInfo[nIndex].down_SNH4_s[j2*3+j3] = 0.0;
													}
												}
												for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													for (j3=0; j3<3; j3++)
													{
														str.Format("%d,%d,RQUAL_SNH4BP_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,j3+1,nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_SNH4_s[j2*3+j3]);
														strRecord += str;
														pChannelInfo[nIndex].bypass_SNH4_s[j2*3+j3] = 0.0;
													}
												}
											}
							
											//add benthic
											if (benrfg != 0)
											{
												str.Format("%d,0,BENRQUAL_NH4,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,benNH4_s[nIndex]);
												strRecord += str;
												benNH4_s[nIndex] = 0.0;
											}
										}
										else if(m == 4)
										{
											for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
											{
												str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_no2_s[j2]);
												strRecord += str;
												pChannelInfo[nIndex].down_no2_s[j2] = 0.0;
											}
											for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
											{
												str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_no2_s[j2]);
												strRecord += str;
												pChannelInfo[nIndex].bypass_no2_s[j2] = 0.0;
											}
										}
										else if(m == 5)
										{
											for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
											{
												str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_po4_s[j2]);
												strRecord += str;
												pChannelInfo[nIndex].down_po4_s[j2] = 0.0;
											}
											for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
											{
												str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_po4_s[j2]);
												strRecord += str;
												pChannelInfo[nIndex].bypass_po4_s[j2] = 0.0;
											}

											if(sedfg == 1)
											{
												for (int j3=0; j3<3; j3++)
												{
													str.Format("%d,-1,USRQUAL_SPO4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,usSPO4_s[nIndex*3+j3]);
													strRecord += str;
													usSPO4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,-2,LURQUAL_SPO4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,luSPO4_s[nIndex*3+j3]);
													strRecord += str;
													luSPO4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,0,IRQUAL_SPO4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,iSPO4_s[nIndex*3+j3]);
													strRecord += str;
													iSPO4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,0,DSRQUAL_SPO4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,DSPO4_s[nIndex*3+j3]);
													strRecord += str;
													DSPO4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,0,DEPRQUAL_SPO4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,DEPPO4_s[nIndex*3+j3]);
													strRecord += str;
													DEPPO4_s[nIndex*3+j3] = 0.0;
													str.Format("%d,0,SCRRQUAL_SPO4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,nMonth,nDay,nYear,SCRPO4_s[nIndex*3+j3]);
													strRecord += str;
													SCRPO4_s[nIndex*3+j3] = 0.0;
												}
												for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													for (j3=0; j3<3; j3++)
													{
														str.Format("%d,%d,RQUAL_SPO4_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,j3+1,nMonth,nDay,nYear,pChannelInfo[nIndex].down_SPO4_s[j2*3+j3]);
														strRecord += str;
														pChannelInfo[nIndex].down_SPO4_s[j2*3+j3] = 0.0;
													}
												}
												for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													for (j3=0; j3<3; j3++)
													{
														str.Format("%d,%d,RQUAL_SPO4BP_%d,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,j3+1,nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_SPO4_s[j2*3+j3]);
														strRecord += str;
														pChannelInfo[nIndex].bypass_SPO4_s[j2*3+j3] = 0.0;
													}
												}
											}
											
											//add benthic
											if (benrfg != 0)
											{
												str.Format("%d,0,BENRQUAL_PO4,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,nMonth,nDay,nYear,benPO4_s[nIndex]);
												strRecord += str;
												benPO4_s[nIndex] = 0.0;
											}
										}
									}
									if (plkfg == 1)
									{
										for(int m=6; m<9; m++)
										{
											str.Format("%d,-1,USRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,usrqual_s[nIndex*nNumRqual+m]);
											strRecord += str;
											usrqual_s[nIndex*nNumRqual+m] = 0.0;

											str.Format("%d,-2,LURQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,lurqual_s[nIndex*nNumRqual+m]);
											strRecord += str;
											lurqual_s[nIndex*nNumRqual+m] = 0.0;

											str.Format("%d,-2,ATMSRQUAL_%s,%d/%d/%d,%12.5e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,atmsrqual_s[nIndex*nNumRqual+m]);
											strRecord += str;
											atmsrqual_s[nIndex*nNumRqual+m] = 0.0;

											str.Format("%d,-1,USRQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,usrqualbp_s[nIndex*nNumRqual+m]);
											strRecord += str;
											usrqualbp_s[nIndex*nNumRqual+m] = 0.0;

											str.Format("%d,-2,LURQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,lurqualbp_s[nIndex*nNumRqual+m]);
											strRecord += str;
											lurqualbp_s[nIndex*nNumRqual+m] = 0.0;

											if (nPtSource > 0)
											{
												str.Format("%d,-3,PSRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,psrqual_s[nIndex*nNumRqual+m]);
												strRecord += str;
												psrqual_s[nIndex*nNumRqual+m] = 0.0;

												str.Format("%d,-4,PSWDRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,pswdrqual_s[nIndex*nNumRqual+m]);
												strRecord += str;
												pswdrqual_s[nIndex*nNumRqual+m] = 0.0;

												str.Format("%d,-4,PSDTRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,pswdrqualdi_s[nIndex*nNumRqual+m]);
												strRecord += str;
												pswdrqualdi_s[nIndex*nNumRqual+m] = 0.0;
											}

											if (irrigfg == 1)
											{
												str.Format("%d,-5,IRWDRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,irwdrqual_s[nIndex*nNumRqual+m]);
												strRecord += str;
												irwdrqual_s[nIndex*nNumRqual+m] = 0.0;
											}

											str.Format("%d,0,IRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,irqual_s[nIndex*nNumRqual+m]);
											strRecord += str;
											irqual_s[nIndex*nNumRqual+m] = 0.0;

											if (m == 6)
											{
												for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_orn_s[j2]);
													strRecord += str;
													pChannelInfo[nIndex].down_orn_s[j2] = 0.0;
												}
												for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_orn_s[j2]);
													strRecord += str;
													pChannelInfo[nIndex].bypass_orn_s[j2] = 0.0;
												}
											}
											else if(m == 7)
											{
												for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_orp_s[j2]);
													strRecord += str;
													pChannelInfo[nIndex].down_orp_s[j2] = 0.0;
												}
												for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_orp_s[j2]);
													strRecord += str;
													pChannelInfo[nIndex].bypass_orp_s[j2] = 0.0;
												}
											}
											else if(m == 8)
											{
												for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_orc_s[j2]);
													strRecord += str;
													pChannelInfo[nIndex].down_orc_s[j2] = 0.0;
												}
												for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
												{
													str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_orc_s[j2]);
													strRecord += str;
													pChannelInfo[nIndex].bypass_orc_s[j2] = 0.0;
												}
											}
										}
										if (phfg == 1)
										{
											for(int m=9; m<11; m++)
											{
												str.Format("%d,-1,USRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,usrqual_s[nIndex*nNumRqual+m]);
												strRecord += str;
												usrqual_s[nIndex*nNumRqual+m] = 0.0;

												str.Format("%d,-2,LURQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,lurqual_s[nIndex*nNumRqual+m]);
												strRecord += str;
												lurqual_s[nIndex*nNumRqual+m] = 0.0;

												str.Format("%d,-2,ATMSRQUAL_%s,%d/%d/%d,%12.5e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,atmsrqual_s[nIndex*nNumRqual+m]);
												strRecord += str;
												atmsrqual_s[nIndex*nNumRqual+m] = 0.0;

												str.Format("%d,-1,USRQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,usrqualbp_s[nIndex*nNumRqual+m]);
												strRecord += str;
												usrqualbp_s[nIndex*nNumRqual+m] = 0.0;

												str.Format("%d,-2,LURQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,lurqualbp_s[nIndex*nNumRqual+m]);
												strRecord += str;
												lurqualbp_s[nIndex*nNumRqual+m] = 0.0;

												if (nPtSource > 0)
												{
													str.Format("%d,-3,PSRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,psrqual_s[nIndex*nNumRqual+m]);
													strRecord += str;
													psrqual_s[nIndex*nNumRqual+m] = 0.0;

													str.Format("%d,-4,PSWDRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,pswdrqual_s[nIndex*nNumRqual+m]);
													strRecord += str;
													pswdrqual_s[nIndex*nNumRqual+m] = 0.0;

													str.Format("%d,-4,PSDTRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,pswdrqualdi_s[nIndex*nNumRqual+m]);
													strRecord += str;
													pswdrqualdi_s[nIndex*nNumRqual+m] = 0.0;
												}

												if (irrigfg == 1)
												{
													str.Format("%d,-5,IRWDRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,irwdrqual_s[nIndex*nNumRqual+m]);
													strRecord += str;
													irwdrqual_s[nIndex*nNumRqual+m] = 0.0;
												}

												str.Format("%d,0,IRQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],nMonth,nDay,nYear,irqual_s[nIndex*nNumRqual+m]);
												strRecord += str;
												irqual_s[nIndex*nNumRqual+m] = 0.0;

												if (m == 9)
												{
													for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
													{
														str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_tic_s[j2]);
														strRecord += str;
														pChannelInfo[nIndex].down_tic_s[j2] = 0.0;
													}
													for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
													{
														str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_tic_s[j2]);
														strRecord += str;
														pChannelInfo[nIndex].bypass_tic_s[j2] = 0.0;
													}
												}
												else if(m == 10)
												{
													for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
													{
														str.Format("%d,%d,RQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].down_co2_s[j2]);
														strRecord += str;
														pChannelInfo[nIndex].down_co2_s[j2] = 0.0;
													}
													for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
													{
														str.Format("%d,%d,RQUBP_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],nMonth,nDay,nYear,pChannelInfo[nIndex].bypass_co2_s[j2]);
														strRecord += str;
														pChannelInfo[nIndex].bypass_co2_s[j2] = 0.0;
													}
												}
											}
										}
									}
								}
							}

							// output to the summary file
							if(!WriteOutputLine(strRecord, m_filestream))                      
							{
								AfxMessageBox("Cannot write to file" + strFileName);
								Log("Cannot write to file" + strFileName);
								goto L001;
							}
						}
					}
				}

				//point source summary file
				if (nPSsummary > 0 && nPtSource > 0)
				{
					if(nPSsummary == 2 || nPSsummary == 3)
					{
						int timefg = 0;
						if (nPSsummary == 2)
							timefg = yrfg;
						else if (nPSsummary == 3)
							timefg = mofg;

						if(timefg == 1 || tCurrent >= toEnd)
						{
							tspan2 = COleDateTimeSpan(1, 0, 0, 0);
							COleDateTime tTemp2 = tCurrent - tspan2;
							int nYear    = tTemp2.GetYear();
							int nMonth   = tTemp2.GetMonth();
							int nDay     = tTemp2.GetDay();
							CString strFileName = m_strModelResultLocation + "pointsource.csv";
							CString str,strRecord;

							for(j=0; j<nch; j++)
							{
								// find the stream index
								int nIndex = stream[j].index;
								int lgroup = pswsinfo[nIndex].gindex;		
								
								if(!pChannelInfo[nIndex].cListPointSources.IsEmpty())
								{
									POSITION pos = pChannelInfo[nIndex].cListPointSources.GetHeadPosition();
									while (pos != NULL)
									{
										PS_SUMMARY& pPS_SUMMARY = (PS_SUMMARY&) pChannelInfo[nIndex].cListPointSources.GetNext(pos);

										strRecord = "";
										str.Format("%d,%s,%s,PS_FLOW,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.lfFlow);
										strRecord += str;
										pPS_SUMMARY.lfFlow = 0.0;

										if (tempfg == 1)
										{
											str.Format("%d,%s,%s,PS_TEMP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_TEMP]);
											strRecord += str;
											pPS_SUMMARY.psQual[Index_TEMP] = 0.0;
										}
										if (sedfg == 1)
										{
											str.Format("%d,%s,%s,PS_SAND,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_SAND]);
											strRecord += str;
											pPS_SUMMARY.psQual[Index_SAND] = 0.0;
											str.Format("%d,%s,%s,PS_SILT,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_SILT]);
											strRecord += str;
											pPS_SUMMARY.psQual[Index_SILT] = 0.0;
											str.Format("%d,%s,%s,PS_CLAY,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_CLAY]);
											strRecord += str;
											pPS_SUMMARY.psQual[Index_CLAY] = 0.0;
										}
										if (pqalfg == 1)
										{
											for(int m=0; m<nQuals; m++)
											{
												double unit = 1.0;
												if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
													unit = 453592.0; 

												str.Format("%d,%s,%s,PS_GQUAL_%s,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pQual[m].qname,nMonth,nDay,nYear,pPS_SUMMARY.pGQual[m]*unit);
												strRecord += str;
												pPS_SUMMARY.pGQual[m] = 0.0;
											}
										}
										if (oxfg == 1)
										{
											str.Format("%d,%s,%s,PS_DOX,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_DOX]);
											strRecord += str;
											pPS_SUMMARY.psQual[Index_DOX] = 0.0;

											str.Format("%d,%s,%s,PS_BOD,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_BOD]);
											strRecord += str;
											pPS_SUMMARY.psQual[Index_BOD] = 0.0;

											if (nutfg == 1)
											{
												str.Format("%d,%s,%s,PS_NOX,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_NOX]);
												strRecord += str;
												pPS_SUMMARY.psQual[Index_NOX] = 0.0;

												str.Format("%d,%s,%s,PS_TAM,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_TAM]);
												strRecord += str;
												pPS_SUMMARY.psQual[Index_TAM] = 0.0;

												str.Format("%d,%s,%s,PS_PO4,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_PO4]);
												strRecord += str;
												pPS_SUMMARY.psQual[Index_PO4] = 0.0;

												if (plkfg == 1)
												{
													str.Format("%d,%s,%s,PS_ORN,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_ORN]);
													strRecord += str;
													pPS_SUMMARY.psQual[Index_ORN] = 0.0;

													str.Format("%d,%s,%s,PS_ORP,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_ORP]);
													strRecord += str;
													pPS_SUMMARY.psQual[Index_ORP] = 0.0;

													str.Format("%d,%s,%s,PS_ORC,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_ORC]);
													strRecord += str;
													pPS_SUMMARY.psQual[Index_ORC] = 0.0;

													if (phyfg == 1)
													{
														str.Format("%d,%s,%s,PS_CLA,%d/%d/%d,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,nMonth,nDay,nYear,pPS_SUMMARY.psQual[Index_CLA]);
														strRecord += str;
														pPS_SUMMARY.psQual[Index_CLA] = 0.0;
													}
												}
											}
										}

										// output to the summary file
										if(!WriteOutputLine(strRecord, m_filepointsource))                      
										{
											AfxMessageBox("Cannot write to file" + strFileName);
											Log("Cannot write to file" + strFileName);
											goto L001;
										}
									}
								}
							}
						}
					}
				}

				// Threshold Statistics
				if (nThreshold > 0)
				{
					if(mofg == 1 || tCurrent >= toEnd)
					{
						// monthly statistics
						tspan2 = COleDateTimeSpan(0, 0, deltm, 0);
						COleDateTime tTemp2 = tCurrent - tspan2;
						int nYear    = tTemp2.GetYear();
						int nMonth   = tTemp2.GetMonth();
						int nDay     = tTemp2.GetDay();
						int ndays = 28;
						if(nMonth == 2)
						{
							if(nYear%400 == 0)
								ndays = 29;
							else if(nYear%100 == 0)
								ndays = 28;
							else if(nYear%4 == 0)
								ndays = 29;
						}
						else if(nMonth == 4 || nMonth == 6 || nMonth == 9 || nMonth == 11)
							ndays = 30;
						else
							ndays = 31;

						CString strFileName = m_strModelResultLocation + "threshold.csv";
						CString str,strRecord;

						for(j=0; j<nch; j++)
						{
							// find the stream index
							int nIndex = stream[j].index;
							int trgp = pReachInfo[nIndex].trgid - 1; 
							if (trgp < 0)
								// skip the reach
								continue;
							strRecord = "";

							for (k=0; k<ntnum; k++)
							{
								int ttype = pMTDATA[trgp*ntnum+k].ttype;
								if (ttype == 0)
									// no standard applied (skip)
									continue;

								int listsize = pTHR_RESULTS[nIndex*ntnum+k].listmonth.size();
								if (listsize <= 0)
									continue;

								double *stat = NULL;
								stat = new double[listsize];

								double mean = 0.0;
								if (ttype == 1 || ttype == -1)
									mean = pTHR_RESULTS[nIndex*ntnum+k].sum/listsize;
								else
									mean = pTHR_RESULTS[nIndex*ntnum+k].sumofmean/listsize;

								pTHR_RESULTS[nIndex*ntnum+k].listmonth.sort();

								int Index = 0;
								double sdsum = 0.0;
								while (!pTHR_RESULTS[nIndex*ntnum+k].listmonth.empty())
								{
									double front = pTHR_RESULTS[nIndex*ntnum+k].listmonth.front();
									stat[Index] = front;
									sdsum += pow((front - mean),2);
									pTHR_RESULTS[nIndex*ntnum+k].listmonth.pop_front();
									Index ++;
								}

								double sd = sqrt(sdsum/(listsize-1));

								// calculate the percentile rank
								// R = 1 + p * (N -1)
								// R = rank
								// p = percentile (in fraction)
								// N = number of values

								int pos;
								double rank,dec,pct;
								double lfdays = ndays;
								double Timesteps = listsize;

								for (int n=0; n<=ndays; n++)
								{
									rank = 1 + (n/lfdays) * (listsize - 1);
									pos = int(rank);
									dec = rank - pos;
									pct = stat[pos-1];
									if(dec > 0)
										pct += (dec*(stat[pos]-stat[pos-1]));
									pTHR_RESULTS[nIndex*ntnum+k].listsim.push_back(pct);
								}

								double rank25 = 1 + 0.25 * (listsize - 1);
								double rank50 = 1 + 0.50 * (listsize - 1);
								double rank75 = 1 + 0.75 * (listsize - 1);

								int pos25 = int(rank25);	
								int pos50 = int(rank50);
								int pos75 = int(rank75);

								double dec25 = rank25 - pos25;
								double dec50 = rank50 - pos50;
								double dec75 = rank75 - pos75;

								double p25th  = stat[pos25-1];	// array starts from 0
								if (dec25 > 0)
								{
									p25th += (dec25*(stat[pos25]-stat[pos25-1]));
								}
								double median = stat[pos50-1];
								if (dec50 > 0)
								{
									median += (dec50*(stat[pos50]-stat[pos50-1]));
								}
								double p75th  = stat[pos75-1];
								if (dec75 > 0)
								{
									p75th += (dec75*(stat[pos75]-stat[pos75-1]));
								}

								//release memory
								if (stat != NULL)
									delete[]stat;

								str.Format("%d,%d,%d/%d/%d,%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf\n",
									pChannelInfo[nIndex].rchid,
									pMTDATA[trgp*ntnum+k].tnum,
									nMonth,
									nDay,
									nYear,
									pTHR_RESULTS[nIndex*ntnum+k].count/Timesteps,
									pTHR_RESULTS[nIndex*ntnum+k].min,
									pTHR_RESULTS[nIndex*ntnum+k].max,
									mean,
									sd,
									p25th,
									median,
									p75th
									);
								strRecord += str;
								pTHR_RESULTS[nIndex*ntnum+k].count = 0;
								pTHR_RESULTS[nIndex*ntnum+k].min = 0.0;
								pTHR_RESULTS[nIndex*ntnum+k].max = 0.0;
								pTHR_RESULTS[nIndex*ntnum+k].sumofmean = 0.0;
							}

							// output to the summary file
							if(!WriteOutputLine(strRecord, m_filethreshold))                      
							{
								AfxMessageBox("Cannot write to file" + strFileName);
								Log("Cannot write to file" + strFileName);
								goto L001;
							}
						}
					}
				}

				for(j=0; j<nsws; j++)
				{
					if(pChannelInfo[j].comp == 0)
						continue;

					if(nDefault || nHydro || nSnow || nSed || nGQUAL || nRQUAL || nCustom)
					{
						dt = 1.0;
						int lgroup = pswsinfo[j].gindex;
						int rgroup = pReachInfo[j].rgid - 1;  

						if(optlevel < 3)
						{
							if(optlevel == 1)	// daily output
								dt = 1/deltd; 
							
							DEP_s[j]   /= dt;					
							AVDEP_s[j] /= dt;					
							HRAD_s[j]  /= dt;					
							AVVEL_s[j] /= dt;					
							SA_s[j]    /= dt;					
							fsurs_s[j] /= dt;     
							fuzs_s[j]  /= dt;     
							flzs_s[j]  /= dt;     
							fagws_s[j] /= dt;     

							// save output value per output interval
							//fsuro_s[j] /= dt;     
							//fifwo_s[j] /= dt;     
							//fagwo_s[j] /= dt;    
							//cepe_s[j]  /= dt;     
							//uzet_s[j]  /= dt;     
							//baset_s[j] /= dt;     
							//lzet_s[j]  /= dt;     
							//agwet_s[j] /= dt;     
							//perc_s[j]  /= dt;     
							//infil_s[j] /= dt;     
							//gwi_s[j]   /= dt;     
							//igwi_s[j]  /= dt;     
							//agwi_s[j]  /= dt;     
							//fSum_s[j]  /= dt;     
							//v2_s[j]    /= dt;
							//ftaet_s[j] /= dt;     
							//fwssd_s[j] /= dt;     
							//fscrsd_s[j]/= dt;     

							if(tempfg == 1)
							{
								temp2_s[j]  /= dt;	//degree C
							}
							
							if(snowfg == 1)			
							{
								airtmp_s[j]		/= dt;			
								snotmp_s[j]		/= dt;			
								pack_s[j]		/= dt;			
								packf_s[j]		/= dt;			
								packw_s[j]		/= dt;			
								packi_s[j]		/= dt;			
								pdepth_s[j]		/= dt;			
								covindx_s[j]	/= dt;			
								neghts_s[j]		/= dt;			
								xlnmelt_s[j]	/= dt;			
								rdenpkf_s[j]	/= dt;			
								skyclear_s[j]	/= dt;			
								snocov_s[j]		/= dt;			
								dullness_s[j]	/= dt;			
								albedo_s[j]		/= dt;			
								paktemp_s[j]	/= dt;			
								dewtmp_s[j]		/= dt;			
							}

							if(oxfg ==1)		 
							{
								dox_s[j] /= dt;
								if (avcount[j] > 0) 
									doxav_s[j] /= avcount[j];
								bod_s[j]  /= dt;

								// flow weighted average conc. in outflow
								if (q2_s[j] > 0)
								{
									double unit = 1.E6 / 28.31685;  // from kg/ft3 to mg/l
									doxout_s[j] = matdox_s[j] / (q2_s[j]*delts) * unit;
									bodout_s[j] = matbod_s[j] / (q2_s[j]*delts) * unit;
								}

								// save output value per output interval
								//matdox_s[j] /= dt;			 
								//matbod_s[j] /= dt;
							}

							if(nutfg ==1)		 
							{
								no3_s[j] /= dt;
								tam_s[j] /= dt;
								no2_s[j] /= dt;
								po4_s[j] /= dt;

								// flow weighted average conc. in outflow
								if (q2_s[j] > 0)
								{
									double unit = 1.E6 / 28.31685;  // from kg/ft3 to mg/l
									no3out_s[j] = matno3_s[j] / (q2_s[j]*delts) * unit;
									tamout_s[j] = mattam_s[j] / (q2_s[j]*delts) * unit;
									no2out_s[j] = matno2_s[j] / (q2_s[j]*delts) * unit;
									po4out_s[j] = matpo4_s[j] / (q2_s[j]*delts) * unit;
								}

								// save output value per output interval
								//matno3_s[j] /= dt;			
								//mattam_s[j] /= dt;			
								//matno2_s[j] /= dt;			
								//matpo4_s[j] /= dt;
								
								for(k=1; k<4; k++)
								{
									snh4_s[j*4+k] /= dt;
									spo4_s[j*4+k] /= dt;

									// save output value per output interval
									//matosnh4_s[j*4+k] /= dt;
									//matospo4_s[j*4+k] /= dt;
								}
								for(k=1; k<13; k++)
								{
									matsnh4_s[j*13+k] /= dt;	//storage (lb)
									matspo4_s[j*13+k] /= dt;
								}
							}

							if(plkfg ==1)		
							{
								phy_s[j]	/= dt;		// mg/l
								zoo_s[j]	/= dt;		// mg/l
								phycla_s[j] /= dt;		// ug/l
								benal_s[j]	/= dt;		// mg/m2
								orn_s[j]	/= dt;
								orp_s[j]	/= dt;
								orc_s[j]	/= dt;
								TORN_s[j]	/= dt;
								TORP_s[j]	/= dt;
								TORC_s[j]	/= dt;

								// flow weighted average conc. in outflow
								if (q2_s[j] > 0)
								{
									double unit = 1.E6 / 28.31685;  // from kg/ft3 to mg/l
									phyout_s[j] = matphy_s[j] / (q2_s[j]*delts) * unit;
									zooout_s[j] = matzoo_s[j] / (q2_s[j]*delts) * unit;
									ornout_s[j] = matorn_s[j] / (q2_s[j]*delts) * unit;
									orpout_s[j] = matorp_s[j] / (q2_s[j]*delts) * unit;
									orcout_s[j] = matorc_s[j] / (q2_s[j]*delts) * unit;
								}

								// save output value per output interval
								//matphy_s[j] /= dt;		
								//matzoo_s[j] /= dt;		
								//matorn_s[j] /= dt;		
								//matorp_s[j] /= dt;		
								//matorc_s[j] /= dt;		
							}

							if(phfg == 1)
							{
								ph_s[j]  /= dt;
								alk_s[j] /= dt;
								tic_s[j] /= dt;
								co2_s[j] /= dt;

								// flow weighted average conc. in outflow
								if (q2_s[j] > 0)
								{
									double unit = 1.E6 / 28.31685;  // from kg/ft3 to mg/l
									ticout_s[j] = mattic_s[j] / (q2_s[j]*delts) * unit;
									co2out_s[j] = matco2_s[j] / (q2_s[j]*delts) * unit;
								}

								// save output value per output interval
								//mattic_s[j] /= dt;		
								//matco2_s[j] /= dt;		
							}
							
							if(sedfg == 1)
							{
								for(int m=0; m<NumSed; m++)
								{
									ssedc_s[j*NumSed+m] /= dt;
//									rossedc_s[j*NumSed+m] /= dt;
									rbedsed_s[j*NumSed+m] /= dt;
									//rdepscr_s[j*NumSed+m] /= dt;

									// save output value per output interval
									//rosed_s[j] /= dt;

									// flow weighted average conc. in outflow (06-20-08)
									rossedc_s[j*NumSed+m] = 0;
									if (q2_s[j] > 0)
										rossedc_s[j*NumSed+m] = (rosed1_s[j*NumSed+m]*TONS_TO_GRAM) / (q2_s[j]*FT3_TO_M3*delts);// mg/l
									
									rosed1_s[j*NumSed+m] = 0;
								}

								// flow weighted average conc. in outflow (06-20-08)
								rossed_s[j] = 0;
								if (q2_s[j] > 0)
									rossed_s[j] = (rosed_s[j]*TONS_TO_GRAM) / (q2_s[j]*FT3_TO_M3*delts);// mg/l

//								rossed_s[j] /= dt;	(06-20-08)
								tau_s[j]  /= dt;
								ssed_s[j] /= dt;
								rsed_s[j]   /= dt;
								beddep_s[j] /= dt;			
							}
							
							if(pqalfg == 1)
							{
								for(int m=0; m<nQuals; m++)
								{
									// save output value per output interval
									//fqual_s[j*nQuals+m]   /= dt;	
									//poqual_s[j*nQuals+m]  /= dt;	
									//soqual_s[j*nQuals+m]  /= dt;	
									//ioqual_s[j*nQuals+m]  /= dt;	
									//goqual_s[j*nQuals+m]  /= dt;	
									//matout_s[j*nQuals+m]  /= dt;	
									//matin_s[j*nQuals+m]  /= dt;		
									//fwashqs_s[j*nQuals+m] /= dt;
									//fscrqs_s[j*nQuals+m]  /= dt;
									//fsoqo_s[j*nQuals+m]   /= dt;
									//fpoqc_s[j*nQuals+m]   /= dt;
									
									for (int mm=0; mm<8; mm++)
										matsqal_s[j*nQuals*8+m*8+mm]  /= dt;	

									conc_s[j*nQuals+m] /= dt;		// lb/ft3			 
									
									// flow weighted average conc. in outflow
									if (q2_s[j] > 0)
										//concout_s[j*nQuals+m] = (matout_s[j*nQuals+m]/dt) / (q2_s[j]*delts);// lb/ft3
										concout_s[j*nQuals+m] = (matout_s[j*nQuals+m]+matosqal_s[j*nQuals*4+m*4+3]) / (q2_s[j]*delts);// lb/ft3

									fsqo_s[j*nQuals+m] /= dt;    

									if (fSum_s[j] > 0)
										// flow weighted average concentration 
										fpoqc_s[j*nQuals+m] = poqual_s[j*nQuals+m] / (fSum_s[j]*IN_ACRE_TO_FT3);// lb/ft3	
								}
							}

							v2_s[j] /= dt;
							q2_s[j] /= dt;
						}
										
						CString str;
						CString strRecord;
						strRecord.Format("%d\t%d\t%d\t%d\t%d\t%d\t",
							pswsinfo[j].subbasin, nMyYear, nMyMonth, nMyDay, nMyHour, nMyMinute);    

						if(cOP.blistOutput[PRECP])					// (07-23-08)						 
						{
							str.Format("\t%12.12e", prec_s[j]);
							strRecord += str;
						}

						if(snowfg == 1)							
						{
							if(cOP.blistOutput[AIRTMP])						
							{
								if(optlevel == 1)	//daily output
								{
									str.Format("\t%7.2f", airtmp_min[j]);
									strRecord += str;
									str.Format("\t%7.2f", airtmp_max[j]);
									strRecord += str;
								}
								str.Format("\t%7.2f", airtmp_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[SNOTMP])						
							{
								str.Format("\t%7.2f", snotmp_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[SNOWF])						
							{
								str.Format("\t%12.12e", snowf_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[RAINF])						
							{
								str.Format("\t%12.12e", rainf_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[PRAIN])						
							{
								str.Format("\t%12.12e", prain_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[MELT])						
							{
								str.Format("\t%12.12e", melt_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[SNOWE])						
							{
								str.Format("\t%12.12e", snowe_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[WYIELD])						
							{
								str.Format("\t%12.12e", wyield_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[PACK])						
							{
								str.Format("\t%12.12e", pack_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[PACKF])						
							{
								str.Format("\t%12.12e", packf_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[PACKW])						
							{
								str.Format("\t%12.12e", packw_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[PACKI])						
							{
								str.Format("\t%12.12e", packi_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[PDEPTH])						
							{
								str.Format("\t%12.12e", pdepth_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[COVINDX])					
							{
								str.Format("\t%12.12e", covindx_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[NEGHTS])						
							{
								str.Format("\t%12.12e", neghts_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[XLNMELT])					
							{
								str.Format("\t%12.12e", xlnmelt_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[RDENPKF])					
							{
								str.Format("\t%12.12e", rdenpkf_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[SKYCLEAR])					
							{
								str.Format("\t%12.12e", skyclear_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[SNOCOV])						
							{
								str.Format("\t%12.12e", snocov_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[DULLNESS])					
							{
								str.Format("\t%12.12e", dullness_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[ALBEDO])						
							{
								str.Format("\t%12.12e", albedo_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[PAKTEMP])					
							{
								str.Format("\t%7.2f", paktemp_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[DEWTMP])						
							{
								str.Format("\t%7.2f", dewtmp_s[j]);
								strRecord += str;
							}
						}

						if(cOP.blistOutput[SURS])
						{
							str.Format("\t%12.12e", fsurs_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[UZS])
						{
							str.Format("\t%12.12e", fuzs_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[LZS])
						{
							str.Format("\t%12.12e", flzs_s[j]);
							strRecord += str;
						}
						
						if(cOP.blistOutput[AGWS])
						{
							str.Format("\t%12.12e", fagws_s[j]);
							strRecord += str;
						}
						
						if(cOP.blistOutput[SURO])
						{
							str.Format("\t%12.12e", fsuro_s[j]);
							strRecord += str;
						}
						
						if(cOP.blistOutput[IFWO])
						{
							str.Format("\t%12.12e", fifwo_s[j]);
							strRecord += str;
						}
						
						if(cOP.blistOutput[AGWO])
						{
							str.Format("\t%12.12e", fagwo_s[j]);
							strRecord += str;
						}
						
						if(cOP.blistOutput[PERO])
						{
							str.Format("\t%12.12e", fSum_s[j]);
							strRecord += str;
						}
						
						if(cOP.blistOutput[TAET])
						{
							str.Format("\t%12.12e", ftaet_s[j]);
							strRecord += str;
							str.Format("\t%12.12e", cepe_s[j]);
							strRecord += str;
							str.Format("\t%12.12e", uzet_s[j]);
							strRecord += str;
							str.Format("\t%12.12e", baset_s[j]);
							strRecord += str;
							str.Format("\t%12.12e", lzet_s[j]);
							strRecord += str;
							str.Format("\t%12.12e", agwet_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[PERC])
						{
							str.Format("\t%12.12e", perc_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[INFIL])                      
						{
							str.Format("\t%12.12e", infil_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[GWI])                        
						{
							str.Format("\t%12.12e", gwi_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[IGWI])                       
						{
							str.Format("\t%12.12e", igwi_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[AGWI])                       
						{
							str.Format("\t%12.12e", agwi_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[DEP])						
						{
							str.Format("\t%12.12e", DEP_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[AVDEP])						
						{
							str.Format("\t%12.12e", AVDEP_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[HRAD])						
						{
							str.Format("\t%12.12e", HRAD_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[AVVEL])						
						{
							str.Format("\t%12.12e", AVVEL_s[j]);
							strRecord += str;
						}
						
						if(cOP.blistOutput[SAREA])						
						{
							str.Format("\t%12.12e", SA_s[j]);
							strRecord += str;
						}
						
						if(cOP.blistOutput[TAU])
						{
							if(sedfg == 1)
							{
								str.Format("\t%12.12e", tau_s[j]);
								strRecord += str;
								tau_s[j] = 0.0;
							}
						}

						if(cOP.blistOutput[VOLUME])
						{
							str.Format("\t%12.12e", v2_s[j]);
							strRecord += str;
						}

						if(cOP.blistOutput[RO])
						{
							str.Format("\t%12.12e", q2_s[j]);
							strRecord += str;
						}

						if(sedfg == 1)
						{
							if(cOP.blistOutput[WSSD])
							{
								str.Format("\t%12.12e", fwssd_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[SCRSD])
							{
								str.Format("\t%12.12e", fscrsd_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[SOSED])
							{
								str.Format("\t%12.12e", sosed_s[j]);
								strRecord += str;
							}
						
							if(cOP.blistOutput[SOBER])
							{
								if (sedber == 1 && pReachInfo[j].lkfg == 0)
								{
									str.Format("\t%12.12e", sober_s[j]);
									strRecord += str;
								}
							}
							
							if(cOP.blistOutput[SSEDC])	
							{
 								for(int m=0; m<NumSed; m++)								
								{
									if (sandfg == 0  && rsd_param[rgroup*NumSed+m].sedflg == 0)
									{
										ssedc_s[j*NumSed+m] = 0.0;
										continue;
									}
 									str.Format("\t%12.12e", ssedc_s[j*NumSed+m]);
 									strRecord += str;

									ssedc_s[j*NumSed+m] = 0.0;
								}
								// output total sediment conc (sand + silt + clay)
								str.Format("\t%12.12e", ssed_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[LSSED])	
							{
								for(int m=0; m<NumSed; m++)
								{
									if (sandfg == 0  && rsd_param[rgroup*NumSed+m].sedflg == 0)
									{
										rossedc_s[j*NumSed+m] = 0.0;
										continue;
									}
									str.Format("\t%12.12e", rossedc_s[j*NumSed+m]);
									strRecord += str;

									rossedc_s[j*NumSed+m] = 0.0;
								}
								//output total sediment conc (sand + silt + clay)
								str.Format("\t%12.12e", rossed_s[j]);
								strRecord += str;
							}
							
							if(cOP.blistOutput[LRSED])
							{
								for(int m=0; m<NumSed; m++)
								{
									if (sandfg == 0  && rsd_param[rgroup*NumSed+m].sedflg == 0)
									{
										rbedsed_s[j*NumSed+m] = 0.0;
										continue;
									}
									str.Format("\t%12.12e", rbedsed_s[j*NumSed+m]);
									strRecord += str;

									rbedsed_s[j*NumSed+m] = 0.0;
								}
								// output total bed sediment storage (sand + silt + clay)
								str.Format("\t%12.12e", rsed_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[LBEDDEP])
							{
								str.Format("\t%12.12e", beddep_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[LDEPSCR])								
							{
								for(int m=0; m<NumSed; m++)
								{
									if (sandfg == 0  && rsd_param[rgroup*NumSed+m].sedflg == 0)
									{
										rdepscr_s[j*NumSed+m] = 0.0;
										continue;
									}
									str.Format("\t%12.12e", rdepscr_s[j*NumSed+m]);
									strRecord += str;

									rdepscr_s[j*NumSed+m] = 0.0;
								}
								// output total bed sediment storage (sand + silt + clay)
								str.Format("\t%12.12e", depscr_s[j]);
								strRecord += str;
							}

							if(cOP.blistOutput[LROSED])
							{
								str.Format("\t%12.12e", rosed_s[j]);					
								strRecord += str;
							}

							sosed_s[j] = 0.0;
							sober_s[j] = 0.0;
							ssed_s[j] = 0.0;
							rossed_s[j] = 0.0;
							rsed_s[j] = 0.0;
							beddep_s[j] = 0.0;			
							depscr_s[j] = 0.0;			
							rosed_s[j] = 0.0;			
						}

						fsuro_s[j] = 0;
						fifwo_s[j] = 0;
						fagwo_s[j]  = 0;
						fSum_s[j]  = 0;
						fsurs_s[j] = 0;
						fuzs_s[j]  = 0;
						flzs_s[j]  = 0;
						fagws_s[j] = 0;
						ftaet_s[j] = 0;
						fwssd_s[j] = 0;
						fscrsd_s[j]= 0;
						prec_s[j]  = 0;				
						airtmp_min[j] = -999;			
						airtmp_max[j] = -999;			
						airtmp_s[j] = 0;			
						snotmp_s[j] = 0;			
						snowf_s[j] = 0;				
						rainf_s[j] = 0;				
						prain_s[j] = 0;				
						melt_s[j]  = 0;				
						snowe_s[j] = 0;				
						wyield_s[j] = 0;			
						pack_s[j] = 0.0;			
						packf_s[j] = 0.0;			
						packw_s[j] = 0.0;			
						packi_s[j] = 0.0;			
						pdepth_s[j] = 0.0;			
						covindx_s[j] = 0.0;			
						neghts_s[j] = 0.0;			
						xlnmelt_s[j] = 0.0;			
						rdenpkf_s[j] = 0.0;			
						skyclear_s[j] = 0.0;		
						snocov_s[j] = 0.0;			
						dullness_s[j] = 0.0;		
						albedo_s[j] = 0.0;			
						paktemp_s[j] = 0.0;			
						dewtmp_s[j] = 0.0;			
						cepe_s[j]  = 0;
						uzet_s[j]  = 0;
						baset_s[j] = 0;
						lzet_s[j]  = 0;
						agwet_s[j] = 0;
						perc_s[j]  = 0;
						infil_s[j] = 0;				
						gwi_s[j]   = 0;				
						igwi_s[j]  = 0;				
						agwi_s[j]  = 0;				
						CString strAttach;
						if(pqalfg == 1)
						{
							int m, mm;
							double unit = 1.0;
							if(cOP.blistOutput[SQO])
							{
								for(m=0; m<nQuals; m++)					
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0;

									str.Format("\t%12.12e", fsqo_s[j*nQuals+m]*unit);	 
									strRecord += str;
								}
							}
							if(cOP.blistOutput[WASHQS])
							{
								for(m=0; m<nQuals; m++)
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0;

									str.Format("\t%12.12e", fwashqs_s[j*nQuals+m]*unit);
									strRecord += str;
								}
							}

							if(cOP.blistOutput[SCRQS])
							{
								for(m=0; m<nQuals; m++)
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0; 

									str.Format("\t%12.12e", fscrqs_s[j*nQuals+m]*unit);
									strRecord += str;
								}
							}

							if(cOP.blistOutput[SOQO])
							{
								for(m=0; m<nQuals; m++)
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0;

									str.Format("\t%12.12e", fsoqo_s[j*nQuals+m]*unit);
									strRecord += str;
								}
							}

							if(cOP.blistOutput[POQUAL])
							{
								for(m=0; m<nQuals; m++)
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0; 

									str.Format("\t%12.12e", poqual_s[j*nQuals+m]*unit);
									strRecord += str;
								}
							}

							if(cOP.blistOutput[SOQUAL])
							{
								for(m=0; m<nQuals; m++)                                   
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0; 

//									str.Format("\t%12.12e", soqual_s[j*nQuals+m]*unit);
									//added sediment associated qual (5/14/2013)
									str.Format("\t%12.12e", (soqual_s[j*nQuals+m]+fscrqs_s[j*nQuals+m]+fwashqs_s[j*nQuals+m])*unit);
									strRecord += str;
								}
							}

							if(cOP.blistOutput[IOQUAL])
							{
								for(m=0; m<nQuals; m++)                                   
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0; 

									str.Format("\t%12.12e", ioqual_s[j*nQuals+m]*unit);
									strRecord += str;
								}
							}

							if(cOP.blistOutput[GOQUAL])
							{
								for(m=0; m<nQuals; m++)                                   
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0; 

									str.Format("\t%12.12e", goqual_s[j*nQuals+m]*unit);
									strRecord += str;
								}
							}

							if(cOP.blistOutput[POQC])
							{
								for(m=0; m<nQuals; m++)
								{
									if(pQual[lgroup*nQuals+m].qunit == "(ug/l)")
										unit = 16018460;
									else if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 1601.846;
									else
										unit = LB_FT3_TO_MG_L;	// lb/ft3 to mg/l

									str.Format("\t%12.12e", fpoqc_s[j*nQuals+m]*unit);	 
									strRecord += str;
								}
							}

							if(cOP.blistOutput[CONC])
							{
								for(m=0; m<nQuals; m++)
								{
									if(pQual[lgroup*nQuals+m].qunit == "(ug/l)")
										unit = 16018460;
									else if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 1601.846;
									else
										unit = LB_FT3_TO_MG_L;	// lb/ft3 to mg/l
													
									if (v2_s[j] > 0)
										strAttach.Format("\t%12.12e", conc_s[j*nQuals+m]*unit); 
									else
										strAttach.Format("\t%12.12e", concout_s[j*nQuals+m]*unit);        
									
									strRecord += strAttach;
								}
							}

							if(cOP.blistOutput[CONCSQAL])
							{
								for(m=0; m<nQuals; m++)
								{
									// convert from lb/ft3 to user defined unit
									if(pQual[lgroup*nQuals+m].qunit == "(ug/l)")
										unit = 16018460;
									else if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 1601.846;
									else
										unit = LB_FT3_TO_MG_L; //mg/l
							
									//output total sediment-associated qual in suspension (sand+silt+clay)
									if (v2_s[j] > 0)
										strAttach.Format("\t%12.12e", matsqal_s[j*nQuals*8+m*8+3]/v2_s[j]*unit); 
									else
										strAttach.Format("\t%12.12e", 0.0);
									strRecord += strAttach;
								}
							}

							if(cOP.blistOutput[CONCOUT])
							{
								for(m=0; m<nQuals; m++)
								{
									if(pQual[lgroup*nQuals+m].qunit == "(ug/l)")
										unit = 16018460;
									else if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 1601.846;
									else
										unit = LB_FT3_TO_MG_L;
													
									strAttach.Format("\t%12.12e", concout_s[j*nQuals+m]*unit);        
									strRecord += strAttach;
								}
							}

							if(cOP.blistOutput[MATSQAL])
							{
								for(m=0; m<nQuals; m++)
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0;

									for (mm=0; mm<8; mm++)
									{
										strAttach.Format("\t%12.12e", matsqal_s[j*nQuals*8+m*8+mm]*unit);       
										strRecord += strAttach;
									}
								}
							}

							if(cOP.blistOutput[MATIN])
							{
								for(m=0; m<nQuals; m++)
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0;

									strAttach.Format("\t%12.12e", matin_s[j*nQuals+m]*unit);       
									strRecord += strAttach;
								}
							}

							if(cOP.blistOutput[MATOUT])
							{
								for(m=0; m<nQuals; m++)
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0;

									strAttach.Format("\t%12.12e", matout_s[j*nQuals+m]*unit);       
									strRecord += strAttach;
								}
							}

							if(cOP.blistOutput[MATOSQAL])
							{
								for(m=0; m<nQuals; m++)
								{
									unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0;

									for (mm=0; mm<4; mm++)
									{
										strAttach.Format("\t%12.12e", matosqal_s[j*nQuals*4+m*4+mm]*unit);       
										strRecord += strAttach;
									}
								}
							}

							for(m=0; m<nQuals; m++)
							{
								poqual_s[j*nQuals+m]  = 0.0;
								soqual_s[j*nQuals+m]  = 0.0;
								ioqual_s[j*nQuals+m]  = 0.0;
								goqual_s[j*nQuals+m]  = 0.0;
								fsqo_s[j*nQuals+m]    = 0.0;
								fwashqs_s[j*nQuals+m] = 0.0;
								fscrqs_s[j*nQuals+m]  = 0.0;
								fsoqo_s[j*nQuals+m]   = 0.0;
								fpoqc_s[j*nQuals+m]   = 0.0;
								conc_s[j*nQuals+m]    = 0.0;			
								concout_s[j*nQuals+m] = 0.0;			
								matout_s[j*nQuals+m]  = 0.0;
								matin_s[j*nQuals+m]   = 0.0;
								for (mm=0; mm<4; mm++)
									matosqal_s[j*nQuals*4+m*4+mm] = 0.0;
								for (mm=0; mm<8; mm++)
									matsqal_s[j*nQuals*8+m*8+mm] = 0.0;
							}
						}

						// write to the output file
						if(oxfg == 1)		
						{
							if(cOP.blistOutput[DOXC])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", dox_s[j]);   
								else
									strAttach.Format("\t%12.12e", doxout_s[j]);   

								strRecord += strAttach;
							}
							if(cOP.blistOutput[DOXCMIN] && optlevel == 1)
							{
								strAttach.Format("\t%12.12e", doxmin_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[DOXCMAX] && optlevel == 1)
							{
								strAttach.Format("\t%12.12e", doxmax_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[DOXCAV] && optlevel == 1)
							{
								strAttach.Format("\t%12.12e", doxav_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[DOXL])
							{
								strAttach.Format("\t%12.12e", matdox_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[BODC])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", bod_s[j]); 
								else
									strAttach.Format("\t%12.12e", bodout_s[j]); 
								
								strRecord += strAttach;
							}
							if(cOP.blistOutput[BODL])
							{
								strAttach.Format("\t%12.12e", matbod_s[j]);        
								strRecord += strAttach;
							}
							dox_s[j]	= 0.0;
							doxout_s[j]	= 0.0;
							doxmin_s[j]	= dox[j];
							doxmax_s[j]	= dox[j];
							doxav_s[j]	= 0.0;
							matdox_s[j] = 0.0;
							bod_s[j]	= 0.0;
							bodout_s[j]	= 0.0;
							matbod_s[j] = 0.0;
						}
						if(nutfg == 1)		 
						{
							if(cOP.blistOutput[NO3C])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", no3_s[j]); 
								else
									strAttach.Format("\t%12.12e", no3out_s[j]);

								strRecord += strAttach;
							}
							if(cOP.blistOutput[NO3L])
							{
								strAttach.Format("\t%12.12e", matno3_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[TAMC])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", tam_s[j]);   
								else
									strAttach.Format("\t%12.12e", tamout_s[j]); 

								strRecord += strAttach;
							}
							if(cOP.blistOutput[TAML])
							{
								strAttach.Format("\t%12.12e", mattam_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[NO2C])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", no2_s[j]);
								else
									strAttach.Format("\t%12.12e", no2out_s[j]);

								strRecord += strAttach;
							}
							if(cOP.blistOutput[NO2L])
							{
								strAttach.Format("\t%12.12e", matno2_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[PO4C])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", po4_s[j]);
								else
									strAttach.Format("\t%12.12e", po4out_s[j]);

								strRecord += strAttach;
							}
							if(cOP.blistOutput[PO4L])
							{
								strAttach.Format("\t%12.12e", matpo4_s[j]);        
								strRecord += strAttach;
							}

							if(cOP.blistOutput[SNH4C])
							{
								//particulate NH4-N total (sand+silt+clay) concentration in RCHRES (mg/l)
								double unit = LB_FT3_TO_MG_L; //lb/ft3 to mg/l
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", matsnh4_s[j*13+4]/v2_s[j]*unit); 
								else
									strAttach.Format("\t%12.12e", 0.0);
								strRecord += strAttach;
							}
							if(cOP.blistOutput[SNH4L])
							{
								for(int m=1; m<4; m++)
								{
									if (sandfg == 0 && m == 1)
										continue;
									strAttach.Format("\t%12.12e", matosnh4_s[j*4+m]);        
									strRecord += strAttach;
								}
							}
							if(cOP.blistOutput[SPO4C])
							{
								//particulate PO4-P total (sand+silt+clay) concentration in RCHRES (mg/l)
								double unit = LB_FT3_TO_MG_L; //lb/ft3 to mg/l
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", matspo4_s[j*13+4]/v2_s[j]*unit); 
								else
									strAttach.Format("\t%12.12e", 0.0);
								strRecord += strAttach;
							}
							if(cOP.blistOutput[SPO4L])
							{
								for(int m=1; m<4; m++)
								{
									if (sandfg == 0 && m == 1)
										continue;
									strAttach.Format("\t%12.12e", matospo4_s[j*4+m]);        
									strRecord += strAttach;
								}
							}
							no3_s[j]	= 0.0;
							no3out_s[j]	= 0.0;
							matno3_s[j] = 0.0;
							tam_s[j]	= 0.0;
							tamout_s[j]	= 0.0;
							mattam_s[j] = 0.0;
							no2_s[j]	= 0.0;
							no2out_s[j]	= 0.0;
							matno2_s[j] = 0.0;
							po4_s[j]	= 0.0;
							po4out_s[j]	= 0.0;
							matpo4_s[j] = 0.0;
							for (int m=0; m<4; m++)
							{
								snh4_s[j*4+m]	= 0.0;
								spo4_s[j*4+m]	= 0.0;
								matosnh4_s[j*4+m] = 0.0;
								matospo4_s[j*4+m] = 0.0;
							}
							for (m=0; m<13; m++)
							{
								matsnh4_s[j*13+m] = 0.0;
								matspo4_s[j*13+m] = 0.0;
							}
						}
						if(plkfg == 1)		 
						{
							if(cOP.blistOutput[PHYC])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", phy_s[j]);
								else
									strAttach.Format("\t%12.12e", phyout_s[j]);

								strRecord += strAttach;
							}
							if(cOP.blistOutput[PHYL])
							{
								strAttach.Format("\t%12.12e", matphy_s[j]);        
								strRecord += strAttach;
							}
							//if(cOP.blistOutput[ZOOC])
							//{
							//  if (v2_s[j] > 0)
							//		strAttach.Format("\t%12.12e", zoo_s[j]);
							//  else
							//      strAttach.Format("\t%12.12e", zooout_s[j]);
							//
							//	strRecord += strAttach;
							//}
							//if(cOP.blistOutput[ZOOL])
							//{
							//	strAttach.Format("\t%12.12e", matzoo_s[j]);        
							//	strRecord += strAttach;
							//}
							if(cOP.blistOutput[PHYCLAC])
							{
								strAttach.Format("\t%12.12e", phycla_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[BENALC])
							{
								strAttach.Format("\t%12.12e", benal_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[ORNC])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", orn_s[j]); 
								else
									strAttach.Format("\t%12.12e", ornout_s[j]); 
								strRecord += strAttach;
									
								strAttach.Format("\t%12.12e", TORN_s[j]); 
								strRecord += strAttach;
							}
							if(cOP.blistOutput[ORNL])
							{
								strAttach.Format("\t%12.12e", matorn_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[ORPC])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", orp_s[j]);
								else
									strAttach.Format("\t%12.12e", orpout_s[j]);
								strRecord += strAttach;

								strAttach.Format("\t%12.12e", TORP_s[j]); 
								strRecord += strAttach;
							}
							if(cOP.blistOutput[ORPL])
							{
								strAttach.Format("\t%12.12e", matorp_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[ORCC])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", orc_s[j]);
								else
									strAttach.Format("\t%12.12e", orcout_s[j]);
								strRecord += strAttach;

								strAttach.Format("\t%12.12e", TORC_s[j]); 
								strRecord += strAttach;
							}
							if(cOP.blistOutput[ORCL])
							{
								strAttach.Format("\t%12.12e", matorc_s[j]);        
								strRecord += strAttach;
							}
							phy_s[j]	= 0.0;
							phyout_s[j]	= 0.0;
							matphy_s[j] = 0.0;
							zoo_s[j]	= 0.0;
							zooout_s[j]	= 0.0;
							matzoo_s[j] = 0.0;
							phycla_s[j]	= 0.0;
							benal_s[j]	= 0.0;
							orn_s[j]	= 0.0;
							TORN_s[j]	= 0.0;
							ornout_s[j]	= 0.0;
							matorn_s[j] = 0.0;
							orp_s[j]	= 0.0;
							TORP_s[j]	= 0.0;
							orpout_s[j]	= 0.0;
							matorp_s[j] = 0.0;
							orc_s[j]	= 0.0;
							TORC_s[j]	= 0.0;
							orcout_s[j]	= 0.0;
							matorc_s[j] = 0.0;
						}
						if(phfg == 1)
						{
							if(cOP.blistOutput[LPH])
							{
								strAttach.Format("\t%12.12e", ph_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[LALK])
							{
								strAttach.Format("\t%12.12e", alk_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[TICC])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", tic_s[j]);
								else
									strAttach.Format("\t%12.12e", ticout_s[j]);

								strRecord += strAttach;
							}
							if(cOP.blistOutput[TICL])
							{
								strAttach.Format("\t%12.12e", mattic_s[j]);        
								strRecord += strAttach;
							}
							if(cOP.blistOutput[CO2C])
							{
								if (v2_s[j] > 0)
									strAttach.Format("\t%12.12e", co2_s[j]);
								else
									strAttach.Format("\t%12.12e", co2out_s[j]);

								strRecord += strAttach;
							}
							if(cOP.blistOutput[CO2L])
							{
								strAttach.Format("\t%12.12e", matco2_s[j]);        
								strRecord += strAttach;
							}
						
							ph_s[j]  = 0.0;
							alk_s[j] = 0.0;
							tic_s[j]  = 0.0;
							ticout_s[j]  = 0.0;
							mattic_s[j] = 0.0;
							co2_s[j]  = 0.0;
							co2out_s[j]  = 0.0;
							matco2_s[j] = 0.0;
						}

						if(tempfg == 1)
						{
							if(cOP.blistOutput[TEMPC])
							{
								if(optlevel == 1)	//daily output
								{
									strAttach.Format("\t%7.2f", temp2_min[j]);
									strRecord += strAttach;
									strAttach.Format("\t%7.2f", temp2_max[j]);
									strRecord += strAttach;
								}
								strAttach.Format("\t%7.2f", temp2_s[j]);
								strRecord += strAttach;
							}
							temp2_min[j] = -999;               
							temp2_max[j] = -999;               
							temp2_s[j]  = 0.0;  
						}

						avcount[j] = 0;
						v2_s[j] = 0.0;
						q2_s[j] = 0.0;
						DEP_s[j] = 0.0;						 
						AVDEP_s[j] = 0.0;					
						HRAD_s[j] = 0.0;					
						AVVEL_s[j] = 0.0;					
						SA_s[j]    = 0.0;					
					
						strRecord += "\n";

						CString strFileName;
						CString strFilePath = m_strModelResultLocation;
						strFileName.Format("%d.out",pswsinfo[j].subbasin);
						strFilePath += strFileName;

						if(!WriteOutputLine(strRecord, pswsinfo[j].m_fileOut))                      
						{
							AfxMessageBox("Cannot write to file" + strFilePath);
							Log("Cannot write to file" + strFilePath);
							goto L001;
						}
					}

					// land unit-area output for SUSTAIN model
					if(nSUSTAIN == 1)
					{
						int lgroup = pswsinfo[j].gindex;
						CString str,strFolderName,strFileName,strFilePath,strRecord;
						CString strFolderPath = m_strModelResultLocation;
						strFolderName.Format("subbasin_%d",pswsinfo[j].subbasin);
						strFolderPath += strFolderName;
						strFolderPath += "\\";

						//ifwo outflow file 
						strFileName.Format("%d_IFWO.txt",pswsinfo[j].subbasin);
						strFilePath.Format(strFolderPath + strFileName);

						strRecord.Format("%d\t%d\t%d\t%d\t%d\t%d\t",
							pswsinfo[j].subbasin, nMyYear, nMyMonth, nMyDay, nMyHour, nMyMinute);    

						str.Format("\t%12.12e", ifwo_sustain[j]);
						strRecord += str;

						//initialize
						ifwo_sustain[j] = 0.0;

						if(sedfg == 1)
						{
							str.Format("\t%12.12e", iosed_sustain[j]);
							strRecord += str;

							//initialize
							iosed_sustain[j] = 0.0;
						}
						if(pqalfg == 1)
						{
							for(int m=0; m<nQuals; m++)                                   
							{
								double unit = 1.0;
								if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
									unit = 453592.0; 

								str.Format("\t%12.12e", ioqual_sustain[j*nQuals+m]*unit);
								strRecord += str;
								
								//initialize
								ioqual_sustain[j*nQuals+m] = 0.0;
							}
						}

						if(!WriteOutputLine(strRecord, pswsinfo[j].m_file_IFWO))                      
						{
							AfxMessageBox("Cannot write to file" + strFilePath);
							Log("Cannot write to file" + strFilePath);
							goto L001;
						}

						//agwo outflow file 
						strFileName.Format("%d_AGWO.txt",pswsinfo[j].subbasin);
						strFilePath.Format(strFolderPath + strFileName);

						strRecord.Format("%d\t%d\t%d\t%d\t%d\t%d\t",
							pswsinfo[j].subbasin, nMyYear, nMyMonth, nMyDay, nMyHour, nMyMinute);    

						str.Format("\t%12.12e", agwo_sustain[j]);
						strRecord += str;

						//initialize
						agwo_sustain[j] = 0.0;

						if(sedfg == 1)
						{
							str.Format("\t%12.12e", aosed_sustain[j]);
							strRecord += str;

							//initialize
							aosed_sustain[j] = 0.0;
						}
						if(pqalfg == 1)
						{
							for(int m=0; m<nQuals; m++)                                   
							{
								double unit = 1.0;
								if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
									unit = 453592.0; 

								str.Format("\t%12.12e", aoqual_sustain[j*nQuals+m]*unit);
								strRecord += str;
								
								//initialize
								aoqual_sustain[j*nQuals+m] = 0.0;
							}
						}

						if(!WriteOutputLine(strRecord, pswsinfo[j].m_file_AGWO)) 
						{
							AfxMessageBox("Cannot write to file" + strFilePath);
							Log("Cannot write to file" + strFilePath);
							goto L001;
						}

						for(k=0; k<nlandp; k++)
						{
//							if (pluinfop[j*nlandp+k].area == 0)
//								continue;

							strFileName.Format("%d_%s.txt",pluinfop[j*nlandp+k].luid,pluinfop[j*nlandp+k].luname);
							strFilePath.Format(strFolderPath + strFileName);
							
							strRecord.Format("%d\t%d\t%d\t%d\t%d\t%d\t",
								pluinfop[j*nlandp+k].luid, nMyYear, nMyMonth, nMyDay, nMyHour, nMyMinute);    

							str.Format("\t%12.12e", suro_sustain[j*nlandp+k]);
							strRecord += str;
							str.Format("\t%12.12e", agwi_sustain[j*nlandp+k]);
							strRecord += str;

							//initialize
							suro_sustain[j*nlandp+k] = 0.0;
							agwi_sustain[j*nlandp+k] = 0.0;

							if(sedfg == 1)
							{
								str.Format("\t%12.12e", sosed_sustain[j*nlandp+k]);
								strRecord += str;

								//initialize
								sosed_sustain[j*nlandp+k] = 0.0;
							}
							if(pqalfg == 1)
							{
								for(int m=0; m<nQuals; m++)                                   
								{
									double unit = 1.0;
									if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
										unit = 453592.0; 

									str.Format("\t%12.12e", soqual_sustain[j*nlandp*nQuals+k*nQuals+m]*unit);
									strRecord += str;
									
									//initialize
									soqual_sustain[j*nlandp*nQuals+k*nQuals+m] = 0.0;
								}
							}
							if(!WriteOutputLine(strRecord, pluinfop[j*nlandp+k].m_fileOut)) 
							{
								AfxMessageBox("Cannot write to file" + strFilePath);
								Log("Cannot write to file" + strFilePath);
								goto L001;
							}
						}
					}
				}
			}
			else
			{
				for(j=0; j<nsws; j++)
				{
					fsuro_s[j] = 0;
					fifwo_s[j] = 0;
					fagwo_s[j]  = 0;
					fSum_s[j]  = 0;
					fsurs_s[j] = 0;
					fuzs_s[j]  = 0;
					flzs_s[j]  = 0;
					fagws_s[j] = 0;
					ftaet_s[j] = 0;
					fwssd_s[j] = 0;
					fscrsd_s[j]= 0;
					prec_s[j]  = 0;				
					airtmp_min[j] = -999;			
					airtmp_max[j] = -999;			
					airtmp_s[j] = 0;			
					snotmp_s[j] = 0;			
					snowf_s[j] = 0;				
					rainf_s[j] = 0;				
					prain_s[j] = 0;				
					melt_s[j]  = 0;				
					snowe_s[j] = 0;				
					wyield_s[j] = 0;			
					pack_s[j] = 0.0;			
					packf_s[j] = 0.0;			
					packw_s[j] = 0.0;			
					packi_s[j] = 0.0;			
					pdepth_s[j] = 0.0;			
					covindx_s[j] = 0.0;			
					neghts_s[j] = 0.0;			
					xlnmelt_s[j] = 0.0;			
					rdenpkf_s[j] = 0.0;			
					skyclear_s[j] = 0.0;		
					snocov_s[j] = 0.0;			
					dullness_s[j] = 0.0;		
					albedo_s[j] = 0.0;			
					paktemp_s[j] = 0.0;			
					dewtmp_s[j] = 0.0;			
					cepe_s[j]  = 0;
					uzet_s[j]  = 0;
					baset_s[j]  = 0;
					lzet_s[j]  = 0;
					agwet_s[j]  = 0;
					perc_s[j]  = 0;
					infil_s[j] = 0;				
					gwi_s[j]   = 0;				
					igwi_s[j]  = 0;				
					agwi_s[j]  = 0;				
					avcount[j] = 0;
					v2_s[j] = 0.0;
					q2_s[j] = 0.0;
					DEP_s[j] = 0.0;					
					AVDEP_s[j] = 0.0;					
					HRAD_s[j] = 0.0;					
					AVVEL_s[j] = 0.0;					
					SA_s[j]    = 0.0;					
					
					if(sedfg == 1)
					{
						sosed_s[j] = 0.0;
						sober_s[j] = 0.0;
						ssed_s[j] = 0.0;
						rossed_s[j] = 0.0;
						rsed_s[j] = 0.0;
						beddep_s[j] = 0.0;			
						depscr_s[j] = 0.0;			
						rosed_s[j] = 0.0;			

						for(int m=0; m<NumSed; m++)
						{
							ssedc_s[j*NumSed+m] = 0.0;
							rossedc_s[j*NumSed+m] = 0.0;
							rosed1_s[j*NumSed+m] = 0.0;
							rbedsed_s[j*NumSed+m] = 0.0;
							rdepscr_s[j*NumSed+m] = 0.0;
						}
					}
					if(pqalfg == 1)
					{
						for(int m=0; m<nQuals; m++)
						{
							poqual_s[j*nQuals+m]   = 0.0;
							soqual_s[j*nQuals+m]   = 0.0;             
							ioqual_s[j*nQuals+m]   = 0.0;             
							goqual_s[j*nQuals+m]   = 0.0;             
							fsqo_s[j*nQuals+m]    = 0.0;
							fwashqs_s[j*nQuals+m] = 0.0;
							fscrqs_s[j*nQuals+m]  = 0.0;
							fsoqo_s[j*nQuals+m]   = 0.0;
							fpoqc_s[j*nQuals+m]   = 0.0;
							conc_s[j*nQuals+m]    = 0.0;			
							concout_s[j*nQuals+m] = 0.0;			
							matout_s[j*nQuals+m] = 0.0;
							matin_s[j*nQuals+m] = 0.0;
							for (int mm=0; mm<4; mm++)
								matosqal_s[j*nQuals*4+m*4+mm] = 0.0;
							for (mm=0; mm<8; mm++)
								matsqal_s[j*nQuals*8+m*8+mm] = 0.0;
						}
					}
					if(tempfg == 1)
					{
						temp2_min[j] = -999;               
						temp2_max[j] = -999;               
						temp2_s[j]  = 0.0;  
					}
					if(oxfg == 1)			// after writing output variables 
					{
						dox_s[j]	= 0.0;
						doxout_s[j]	= 0.0;
						doxmin_s[j]	= dox[j];
						doxmax_s[j]	= dox[j];
						doxav_s[j]	= 0.0;
						matdox_s[j] = 0.0;
						bod_s[j]	= 0.0;
						bodout_s[j]	= 0.0;
						matbod_s[j] = 0.0;
					}
					if(nutfg == 1)			// after writing output variables 
					{
						no3_s[j]	= 0.0;
						no3out_s[j]	= 0.0;
						matno3_s[j] = 0.0;
						tam_s[j]	= 0.0;
						tamout_s[j]	= 0.0;
						mattam_s[j] = 0.0;
						no2_s[j]	= 0.0;
						no2out_s[j]	= 0.0;
						matno2_s[j] = 0.0;
						po4_s[j]	= 0.0;
						po4out_s[j]	= 0.0;
						matpo4_s[j] = 0.0;
						for (int m=0; m<4; m++)
						{
							snh4_s[j*4+m]	= 0.0;
							spo4_s[j*4+m]	= 0.0;
							matosnh4_s[j*4+m] = 0.0;
							matospo4_s[j*4+m] = 0.0;
						}
						for (m=0; m<13; m++)
						{
							matsnh4_s[j*13+m] = 0.0;
							matspo4_s[j*13+m] = 0.0;
						}
					}
					if(plkfg == 1)			// after writing output variables 
					{
						phy_s[j]	= 0.0;
						phyout_s[j]	= 0.0;
						matphy_s[j] = 0.0;
						zoo_s[j]	= 0.0;
						zooout_s[j]	= 0.0;
						matzoo_s[j] = 0.0;
						phycla_s[j]	= 0.0;
						benal_s[j]	= 0.0;
						orn_s[j]	= 0.0;
						TORN_s[j]	= 0.0;
						ornout_s[j]	= 0.0;
						matorn_s[j] = 0.0;
						orp_s[j]	= 0.0;
						TORP_s[j]	= 0.0;
						orpout_s[j]	= 0.0;
						matorp_s[j] = 0.0;
						orc_s[j]	= 0.0;
						TORC_s[j]	= 0.0;
						orcout_s[j]	= 0.0;
						matorc_s[j] = 0.0;
					}
					if(phfg == 1)
					{
						ph_s[j]  = 0.0;
						alk_s[j] = 0.0;
						tic_s[j]	= 0.0;
						ticout_s[j]	= 0.0;
						mattic_s[j] = 0.0;
						co2_s[j]	= 0.0;
						co2out_s[j]	= 0.0;
						matco2_s[j] = 0.0;
					}
					if (nThreshold > 0)
					{
						if(mofg == 1 || tCurrent >= toEnd)
						{
							for (k=0; k<ntnum; k++)
							{
								pTHR_RESULTS[j*ntnum+k].count = 0;
								pTHR_RESULTS[j*ntnum+k].min = 0.0;
								pTHR_RESULTS[j*ntnum+k].max = 0.0;
								pTHR_RESULTS[j*ntnum+k].sumofmean = 0.0;
							}
						}
					}
				}
			}
		}

		if(tCurrent > tEnd)
			goto L000;  

		// loop for all watersheds
		for(j=0; j<nsws; j++)
		{
			if(pswsinfo[j].lksws == 0)
			{
				//get the weather data
				double w_prec = 0.0;	//PRECIPITATION (IN/TIMESTEP)
				double w_pet  = 0.0;	//POT ET (IN/TIMESTEP)   
				double w_temp = 0.0;	//AIR TEMP (DEG F)
				double w_wind = 0.0;	//WIND SPEED (MI/TIMESTEP)
				double w_srad = 0.0;	//SOLAR RAD (LY/TIMESTEP)
				double w_dewp = 0.0;	//DEW POINT (DEG F) 
				double w_clou = 0.0;	//CLOUD COVER (TENTHS) 
				
				for(int n=0; n<pswsinfo[j].nwst; n++)
				{
					int nFileIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[0].nFileIndex;
					int nParamIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[0].nParmIndex;
					double lfMultiplier = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].m_lfMultiplier[0];
					w_prec += cWD.pWFILEINFO[nFileIndex].pWEATHERDATA[cWD.pWFILEINFO[nFileIndex].lIndex+nCount].lfVALUE[nParamIndex]*lfMultiplier*pswsinfo[j].wti[n];
					
					nFileIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[1].nFileIndex;
					nParamIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[1].nParmIndex;
					lfMultiplier = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].m_lfMultiplier[1];
					w_pet += cWD.pWFILEINFO[nFileIndex].pWEATHERDATA[cWD.pWFILEINFO[nFileIndex].lIndex+nCount].lfVALUE[nParamIndex]*lfMultiplier*pswsinfo[j].wti[n];

					if(snowfg == 1 || tempfg == 1)
					{
						nFileIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[2].nFileIndex;
						nParamIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[2].nParmIndex;
						lfMultiplier = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].m_lfMultiplier[2];
						w_temp += cWD.pWFILEINFO[nFileIndex].pWEATHERDATA[cWD.pWFILEINFO[nFileIndex].lIndex+nCount].lfVALUE[nParamIndex]*lfMultiplier*pswsinfo[j].wti[n];

						nFileIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[3].nFileIndex;
						nParamIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[3].nParmIndex;
						lfMultiplier = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].m_lfMultiplier[3];
						w_wind += cWD.pWFILEINFO[nFileIndex].pWEATHERDATA[cWD.pWFILEINFO[nFileIndex].lIndex+nCount].lfVALUE[nParamIndex]*lfMultiplier*pswsinfo[j].wti[n];

						nFileIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[4].nFileIndex;
						nParamIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[4].nParmIndex;
						lfMultiplier = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].m_lfMultiplier[4];
						w_srad += cWD.pWFILEINFO[nFileIndex].pWEATHERDATA[cWD.pWFILEINFO[nFileIndex].lIndex+nCount].lfVALUE[nParamIndex]*lfMultiplier*pswsinfo[j].wti[n];

						nFileIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[5].nFileIndex;
						nParamIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[5].nParmIndex;
						lfMultiplier = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].m_lfMultiplier[5];
						w_dewp += cWD.pWFILEINFO[nFileIndex].pWEATHERDATA[cWD.pWFILEINFO[nFileIndex].lIndex+nCount].lfVALUE[nParamIndex]*lfMultiplier*pswsinfo[j].wti[n];

						nFileIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[6].nFileIndex;
						nParamIndex = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].nWDATA[6].nParmIndex;
						if (nFileIndex >= 0 && nParamIndex >= 0)
						{
							lfMultiplier = cWD.pWSTATIONINFO[pswsinfo[j].wstindex[n]].m_lfMultiplier[6];
							w_clou += cWD.pWFILEINFO[nFileIndex].pWEATHERDATA[cWD.pWFILEINFO[nFileIndex].lIndex+nCount].lfVALUE[nParamIndex]*lfMultiplier*pswsinfo[j].wti[n];
						}
					}
					
//					w_prec += cWD.GetParamValue(delt,W_PREC,pswsinfo[j].wstindex[n],tCurrent)*pswsinfo[j].wti[n];
//					w_pet  += cWD.GetParamValue(delt,W_PET, pswsinfo[j].wstindex[n],tCurrent)*pswsinfo[j].wti[n];
					
//					if(snowfg == 1 || tempfg == 1)
//					{
//						w_temp	+= cWD.GetParamValue(delt,W_TEMP,pswsinfo[j].wstindex[n],tCurrent)*pswsinfo[j].wti[n];
//						w_wind	+= cWD.GetParamValue(delt,W_WIND,pswsinfo[j].wstindex[n],tCurrent)*pswsinfo[j].wti[n];
//						w_srad	+= cWD.GetParamValue(delt,W_SRAD,pswsinfo[j].wstindex[n],tCurrent)*pswsinfo[j].wti[n];
//						w_dewp 	+= cWD.GetParamValue(delt,W_DEWP,pswsinfo[j].wstindex[n],tCurrent)*pswsinfo[j].wti[n];
//						w_clou 	+= cWD.GetParamValue(delt,W_CLOU,pswsinfo[j].wstindex[n],tCurrent)*pswsinfo[j].wti[n];
//					}
				}

				int lgroup = pswsinfo[j].gindex;
				int impindex = 0;
				int impindex_GQ = 0;

				for(k=0; k<nlandp; k++)
				{
					double prec = 0.;		 				
					double snowf = 0.;						
					double rainf = 0.;					
					double prain  = 0.;					
					double snowe  = 0.;					
					double wyield = 0.;					
					double melt   = 0.;				
					double albedo = 0.;			
					double dewtmp = 0.;		
					double iperc = 0.;
					double lzrat = 0.;
					double msupy = 0.;
					double rempet = 0.;
					double gwi = 0.;
					double snocov = 0.;		 

					if(snowfg == 1)
					{
						// initialize other variables  
						hr6fg = (nSHour>7)?0:1;							  

						nOrder = lgroup*nlandp+k;		  
						int icefg = pSnowCtl2[nOrder].ICEFLAG;			  
						
						if(icefg == 1 && deltm > 360)			
						{
							// error - snow simulation cannot function properly with delt > 360 min 
							//         if ice flag is on  
							TRACE("Error:icefg == 1 && deltm > 360");
						}
						
						// process values in table - type snow-parm1  
						double lat    = pSnowParam1[nOrder].LAT;
						double covind = pSnowParam1[nOrder].COVIND;
						double snowcf = pSnowParam1[nOrder].SNOWCF;
						double melev  = pSnowParam1[nOrder].MELEV;
						double shade  = pSnowParam1[nOrder].SHADE;

						// process values in table-type snow-parm2  
						double tsnow  = pSnowParam2[nOrder].TSNOW;
						double rdcsn  = pSnowParam2[nOrder].RDCSN;
						double snoevp = pSnowParam2[nOrder].SNOEVP;
						double ccfact = pSnowParam2[nOrder].CCFACT;
						double mwater = pSnowParam2[nOrder].MWATER;
						double mgmelt = pSnowParam2[nOrder].MGMELT* deltd;		
						
						// process values in table-type snow-init1  
						double packf  = packf_p[j*nlandp+k];
						double packi  = packi_p[j*nlandp+k];
						double packw  = packw_p[j*nlandp+k];
						double rdenpf = rdenpf_p[j*nlandp+k];
						double dull   = dull_p[j*nlandp+k];
						double paktmp = paktmp_p[j*nlandp+k]; 
						double pack   = packf + packw;
						
						// special case (1-21-2013)
//						double pack_start = pack;

						// process values in snow-init2  
						double covinx = covinx_p[j*nlandp+k];
						double xlnmlt = xlnmlt_p[j*nlandp+k];
						double skyclr = skyclr_p[j*nlandp+k];
						double snowep = snowep_p[j*nlandp+k];
						double pdepth = pdepth_p[j*nlandp+k];
							   snocov = snocov_p[j*nlandp+k];			 

//						int mon = nSMonth-1;
						int mon = nSMonth;
						albed(&mon, &lat, &dull, &albedo);
						
						double neghts = neghts_p[j*nlandp+k];
						double mneghs = mneghs_p[j*nlandp+k];
						double packwc = packwc_p[j*nlandp+k];
						double neght  = neght_p[j*nlandp+k];
						double gmeltr = gmeltr_p[j*nlandp+k];
						double compct = compct_p[j*nlandp+k];
						double mostht = mostht_p[j*nlandp+k];
						double vap    = vap_p[j*nlandp+k];
						
						/////////////////////////////////////////////////
						// HERE GOES THE SNOW MODULE
						/////////////////////////////////////////////////
						static double rnsht, rnfrz, sumht;
						// get input time series  
						double airtmp = w_temp;	//degree F
						double dtmpg  = w_dewp;
						double winmov = w_wind;
						double solrad = w_srad;
						double clou   = w_clou;
						supy = w_prec * ppluinfo[k].luPREmult;
						pet = w_pet * ppluinfo[k].luPETmult;

						// get weather data
//						int wdata = GetWeatherData(j,tempfg,tCurrent,&supy,&pet,&airtmp,&winmov,&solrad,&dtmpg,&clou);
//						if (wdata == -1)
//							goto L001;
/* 						for(int n=0; n<pswsinfo[j].nwst; n++)
						{
							if(tmList != NULL && tmList[pswsinfo[j].wsti[n]-1].pRecord != NULL)
							{
								supy   += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[0]*pswsinfo[j].wti[n];
								pet    += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[1]*pswsinfo[j].wti[n]; 
								airtmp += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[2]*pswsinfo[j].wti[n]; 
								winmov += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[3]*pswsinfo[j].wti[n]; 
								solrad += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[4]*pswsinfo[j].wti[n];
								dtmpg  += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[5]*pswsinfo[j].wti[n]; 
								clou   += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[6]*pswsinfo[j].wti[n];
							}
						}
*/
						prec   = supy;
						dewtmp = dtmpg;
						pet_irr[j] = pet;

						//*******************************************
						// air temperature adjustment
						atem_p[j]    = (airtmp-32)/1.8;	//degree C
						double eldat = ptmp_param1[j].eldat;
						double perc  = supy;
						
						adjtemp(&eldat, &atem_p[j], &airtmp, hrfg, &perc, &deltm, nSHour);	

						atem_p[j] = airtmp;	//degree C
						wind_p[j] =	winmov;
						solr_p[j] =	solrad;
						dewp_p[j] =	(dewtmp-32)/1.8;	//degree C										
						clou_p[j] =	clou;
						//convert to Farenheit for the snow module (locally)
						airtmp = airtmp*1.8 + 32;	//degree F
						
						// estimate meteorological conditions  
						int snoffg   = 0;
						int ccfp = 0;

						if (clou > 0)
							ccfp = 1; //whether cloud cover time series is available

						int rainfg   = 0;
						double rdnsn = 0;

						meteor(&prec, &hrfg, &airtmp, &tsnow, &dtmpg,
							&snowcf, &rdcsn, &deltm, &ccfp, 
							&snotmp, &dryfg, &skyclr, &dewtmp, &snoffg,
							&snowf, &rainfg, &rainf, &rdnsn, &clou);
						
						airtmp_p[j] = airtmp;											 
						snotmp_p[j] = snotmp;											

						int iregfg    = 0;

						// do the pack simulation if a pack already exists  
						// or if it is snowing  
						if(packf > 0.0 || snoffg == 1) 
						{
							int icefg = pSnowCtl2[nOrder].ICEFLAG;
							// there is a snowpack or it is snowing,  
							// simulate snow accumulation and melt  
							if(fabs(packf) <= 0.0)
							{
								// a pack is just starting to accumulate  
								// initialize variables  
								// iregfg is set on to trigger intermittent calculations  
								iregfg = 1;
								// dull was previously undefined  
								dull = 0.0;
							} 
							else 
							{
								// iregfg governs intermittently performed calculations  
								iregfg = (hrfg != 0)?1:0;
							}
							
							// start the calculations by simulating the effect of precipitation on the pack  
							effprc(&snoffg, &snowf, &rainfg, &rainf, &rdnsn,
								&covind, &delt60, &snocov, &covinx, &packf,
								&pdepth, &dull, &prain);
							
							// simulate compaction of the pack  
							compac(&iregfg, &delt60, &packf, &pdepth, &compct);
							
							//ecnt1 = snecnt[0];
							// estimate vapor pressures and rate of evaporation from snow  
							snowev(&iregfg, svp, &dewtmp, &airtmp, &snocov,
								&snoevp, &winmov, /*&lsno, */ &snowep, &packf,
								&pdepth, &packi, /*&ecnt1,*/ &snowe, &vap);
							
							// estimate the rate of heat exchange, except for contributions  
							// from groundmelt and rain  - this is done intermittently  
							if(iregfg != 0) 
							{
//								int mon = nSMonth-1;
								int mon = nSMonth;
								hexchr(&ccfact, &winmov, &vap, &airtmp, &melev,
									&mon, &lat, &dull, &solrad, &shade,
									&delt60, &skyclr, &mostht, &albedo);
							}
							
							// find sensible heat available from rain -- done  
							// every interval  
							if(rainf > 0.0)
								rnsht = (airtmp - 32.0) * rainf / 144.0;
							else
								rnsht = 0.0;
							
							// sum the heat components calculated so far and correct for  
							// incomplete areal snowcover, if necessary - units are  
							// inches of water with equivalent latent heat/ivl -- done  
							// every interval  
							sumht = mostht + rnsht;
							if(snocov < 1.0)
								sumht *= snocov;
							
							// simulate the heating or cooling of the pack  
							// find the current temperature of the pack (paktmp)  
							if(fabs(neghts) <= 0.0)
								paktmp = 32.0;
							else
								paktmp = 32.0 - neghts / (packf * 0.00695);
							
							// when heat transfer (sumht) is negative,  
							// simulate loss of heat from the pack  
							cooler(&iregfg, &airtmp, &packf, &paktmp, &delt60,
								&sumht, &mneghs, &neght, &neghts);
							
							// when sumht is positive, use some or all of it and  
							// latent heat of rain to warm the pack towards 32 deg f  
							if(neghts > 0.0) 
							{
								// there is negative heat storage in the pack,  
								// so it can be warmed up  
								warmup(&prain, &sumht, &neghts, &pdepth, &packf, &rnfrz);
							} 
							else 
							{
								// pack cannot be warmed up, so no rain can freeze  
								rnfrz = 0.0;
							}
							
							// when there is still unused heat, melt some of the pack  
							melter(&sumht, &packf, &packi, &pdepth, &melt);
							
							// handle liquid water  
							liquid(&iregfg, &pdepth, &mwater, &packf, &melt,
								&prain, &rnfrz, &delt60, &packw, &packwc, &wyield);

							if(icefg != 0) 
							{
								// simulate the effects of frozen ground  
								int hr = nSHour + 1;	// (08-31-05)
								icing(&hr, &snocov, &airtmp, &hr6fg, &xlnmlt,
									&wyield, &packf, &packi, &pdepth);
							}
							
							// the component of ice in the pack cannot exceed the  
							// total frozen contents  
							if(packi > packf) 
							{
								// this condition should never occur.  after the code  
								// has shaken down, remove the test from the module  
								// ice content of pack exceeds total content of pack.  
								TRACE("Error:packi > packf.");
							}
							
							// simulate ground melt  
							gmelt(&iregfg, &paktmp, &mgmelt, &packf, &wyield,
								&packw, &pdepth, &packi, &gmeltr, &neghts);

							// final exercises  
							if(packf > 0.005) 
							{
								// total storage in the pack  
								pack = packf + packw;
								// find relative density of the pack  
								rdenpf = packf / pdepth;
								
								paktmp = (fabs(neghts)<=0.0)?32.0:(32.0-neghts/(packf*0.00695));
								snocov = (packf<covinx)?(packf/covinx):1.0;
							} 
							else 
							{
								// assume pack is gone.  
								melt += packf;
								wyield += packf + packw;
								nopack(&covind, &hr6fg, &packf, &packi, &packw,
									&pack, &pdepth, &rdenpf, &covinx, &snocov,
									&dull, &albedo, &xlnmlt, &mneghs, &paktmp,
									&neghts, &packwc, &neght, &gmeltr, &compct,
									&snowep, &mostht, &vap);
							}
						}
						else 
						{
							// there is no snow or pack                   
							prain  = 0.0;
							snowe  = 0.0;
							wyield = 0.0;
							melt   = 0.0;
						}
						
						// total moisture supplied to the pack  
						double pakin = snowf + prain;
						
//						pack_start += pakin;
						
						// net moisture change in the pack  
						double pakdif = pakin - (snowe + wyield);
						
						f_snowf[j*nlandp+k]	= snowf;		
						f_rainf[j*nlandp+k]	= rainf;		
						f_prain[j*nlandp+k]	= prain;		
						f_melt[j*nlandp+k]	= melt;			
						f_snowe[j*nlandp+k]	= snowe;		
						f_wyield[j*nlandp+k]= wyield;		

						packf_p[j*nlandp+k]  = packf;
						pdepth_p[j*nlandp+k] = pdepth;
						rdenpf_p[j*nlandp+k] = rdenpf;
						snocov_p[j*nlandp+k] = snocov;
						packw_p[j*nlandp+k]  = packw;
						packi_p[j*nlandp+k]  = packi;
						paktmp_p[j*nlandp+k] = paktmp;
						pack_p[j*nlandp+k]   = pack;				
//						pack_sws[j*nlandp+k] = pack_start;				
						dull_p[j*nlandp+k]   = dull;
						covinx_p[j*nlandp+k] = covinx;
						xlnmlt_p[j*nlandp+k] = xlnmlt;
						skyclr_p[j*nlandp+k] = skyclr;
						snowep_p[j*nlandp+k] = snowep;
						neghts_p[j*nlandp+k] = neghts;
						mneghs_p[j*nlandp+k] = mneghs;
						packwc_p[j*nlandp+k] = packwc;
						neght_p[j*nlandp+k]  = neght;
						gmeltr_p[j*nlandp+k] = gmeltr;
						compct_p[j*nlandp+k] = compct;
						mostht_p[j*nlandp+k] = mostht;
						vap_p[j*nlandp+k]    = vap;
						albedo_p[j*nlandp+k] = albedo;					 
						dewtmp_p[j*nlandp+k] = dewtmp;					
						
						/////////////////////////////////////////////////
						// END SNOW Module
						////////////////////////////////////////////////
						// snow is being considered - allow for it  
						// find the moisture supplied to interception storage  
						// rainf is rainfall in inches/ivl. adjust for fraction of land  
						// segment covered by snow. WYIELDL is the water yielded by the  
						// snowpack in inches/ivl. it has already been adjusted to an  
						// effective yield over the entire land segment  
						
						supy = rainf * (1.0 - snocov) + wyield;
						
						if(hrfg == 1) 
						{
							// it is time to recalculate intermittently computed numbers  
							// adjustment factor for input pet to account for forest and  
							// snowcover  
							// Jian Ouyang: how to calculate forestation ratio

							double forest = pSnowCtl2[nOrder].lfForest;					 
							petadj = (1.0 - forest) * (1.0 - snocov) + forest;
							petmax = ppw_param3[nOrder].petmax_p;
							petmin = ppw_param3[nOrder].petmin_p;
							
							if(airtmp < petmax)
							{
								//adjustment factor may be reduced 
								if(airtmp < petmin) 
								{
									//pet is completely shut off 
									petadj = 0.0;
								} 
								else 
								{
									if (petadj > 0.5) 
										petadj = 0.5;
								}
							}

							if(icefg == 1)
							{
								double fzg = pSnowCtl2[nOrder].fzg;				
								double fzgl = pSnowCtl2[nOrder].fzgl;				

								inffac = 1.0 - fzg * packi;		
								if(inffac < fzgl)				
									inffac = fzgl;				

/*
								// calculate factor to reduce infiltration and percolation 
								// to account for frozen ground 
								if(iffcfg == 1)
								{
									// enhanced version of the original method - 
									// this algorithm defaults to the original result if 
									// the parameters (fzg and fzgl) have the default values 

									inffac = 1.0 - fzg * packi;
									if(inffac < fzgl)
										inffac = fzgl;
								}
								else 
								{
 									inffac = 1.0;				         
								}
*/							}
							else 
							{
								// petadj and inffac remain unchanged
							}
							
							// adjust input pet  
							//pet = petinp * petadj;
							pet = pet * petadj;
						}
						prec_p[j] = prec;
						supy_p[j] = supy;
						pet_p[j]  = pet;
					}
					else // snow module is off
					{
						/* snow is not being considered */
						/* all precipitation is assumed to be rain */
						//prec = pad[scrtch_1.precfp + scrtch_1.ivl1 - 1];

						supy = w_prec * ppluinfo[k].luPREmult;
						pet  = w_pet * ppluinfo[k].luPETmult;
						atem = w_temp;
						wind = w_wind;
						solr = w_srad;
						dewp = w_dewp;
						clou = w_clou;

						// get weather data
//						int wdata = GetWeatherData(j,tempfg,tCurrent,&supy,&pet,&atem,&wind,&solr,&dewp,&clou);
//						if (wdata == -1)
//							goto L001;
//
/*						for(int n=0; n<pswsinfo[j].nwst; n++)
						{
							if(tmList != NULL && tmList[pswsinfo[j].wsti[n]-1].pRecord != NULL)
							{
								supy += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[0]*pswsinfo[j].wti[n];
								pet  += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[1]*pswsinfo[j].wti[n]; 
								if(tempfg == 1)
								{
									atem += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[2]*pswsinfo[j].wti[n];
									wind += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[3]*pswsinfo[j].wti[n]; 
									solr += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[4]*pswsinfo[j].wti[n]; 
									dewp += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[5]*pswsinfo[j].wti[n];
									clou += tmList[pswsinfo[j].wsti[n]-1].pRecord[nCount+tmList[pswsinfo[j].wsti[n]-1].nShift].fNum[6]*pswsinfo[j].wti[n]; 
								}
							}
						}
*/
						dewtmp = dewp;						
						prec   = supy;						
						pet_irr[j] = pet;

						double perc = supy;
						double eldat = 0.0;	//ft
						double airtmp = 20; //C
						
						if(tempfg == 1)
						{
							atem_p[j] =	(atem-32)/1.8;		// C		
							eldat = ptmp_param1[j].eldat;	// ft
							
							adjtemp(&eldat, &atem_p[j], &airtmp, hrfg, &perc, &deltm, nSHour);   
							
							atem_p[j] = airtmp;	//degree C
							wind_p[j] =	wind;	// miles/ivl
							solr_p[j] =	solr;	//ly/ivl
							dewp_p[j] =	(dewp-32)/1.8;	//degree C
							clou_p[j] =	clou;
						}
						prec_p[j] = prec;
						supy_p[j] = supy;
						pet_p[j]  = pet;
						inffac    = 1.0;                              
					}

					f_prec[j*nlandp+k] = prec;									 
					
					// simulate interception  
					int mon    = tCurrent.GetMonth() - 1;
					int nxtmon = mon + 1;
					if(nxtmon >= 12)
						nxtmon = 0;
					int ndays;

					if(mon == 0 || mon == 2 || mon == 4 || mon == 6 || mon == 7 || mon == 9 || mon == 11)
						ndays = 31;
					if(mon == 3 || mon == 5 || mon == 8 || mon == 10)
						ndays = 30;
					int nYear = tCurrent.GetYear();
					if(mon == 1)
					{
						if(nYear%400 == 0)
							ndays = 29;
						else if(nYear%100 == 0)
							ndays = 28;
						else if(nYear%4 == 0)
							ndays = 29;
						else
							ndays = 28;
					}
					int day = tCurrent.GetDay();
					
					nOrder = lgroup*nlandp+k;
					nOrder2 = j*nlandp+k;
					double cepo = 0.0;
					
					// monthly data mapping
					if(vcsfg == 1)
						cepscm = cepscm_p[nOrder].fnum;
					if(vuzfg == 1)
						uzsnm = uzsnm_p[nOrder].fnum;
					if(vnnfg == 1)
						nsurm = nsurm_p[nOrder].fnum;
					if(vifwfg == 1)
						intfwm = intfwm_p[nOrder].fnum;
					if(vircfg == 1)
						ircm = ircm_p[nOrder].fnum;
					if(vlefg == 1)
						lzetpm = lzetpm_p[nOrder].fnum;
					
					lzsn   = ppw_param2[nOrder].lzsn_p;
					infilt = ppw_param2[nOrder].infilt_p;
					kvary  = ppw_param2[nOrder].kvary_p;
					agwrc  = ppw_param2[nOrder].agwr_p;
					petmax = ppw_param3[nOrder].petmax_p;
					petmin = ppw_param3[nOrder].petmin_p;
					infexp = ppw_param3[nOrder].infexp_p;
					infild = ppw_param3[nOrder].infild_p;
					deepfr = ppw_param3[nOrder].deepfr_p;
					basetp = ppw_param3[nOrder].basetp_p;
					agwetp = ppw_param3[nOrder].agwetp_p;
					cepsc  = ppw_param4[nOrder].cepsc_p;
					uzsn   = ppw_param4[nOrder].uzsn_p;
					nsur   = ppw_param4[nOrder].nsur_p;
					intfw  = ppw_param4[nOrder].intfw_p;
					irc    = ppw_param4[nOrder].irc_p;
					lzetp  = ppw_param4[nOrder].lzetp_p;

					// initial conditions
					ceps  = ceps_p[nOrder2];
					surs  = surs_p[nOrder2];
					uzs   = uzs_p[nOrder2];
					ifws  = ifws_p[nOrder2];
					lzs   = lzs_p[nOrder2];
					agws  = agws_p[nOrder2];
					gwvs  = gwvs_p[nOrder2];
					lsur  = pluinfop[nOrder2].lsur;
					slsur = pluinfop[nOrder2].slsur;

					//check for landuse change (02-2008)
					if (cLU.nLUchangeFlag == 1 && pluinfop[nOrder2].bLUchange == true)
					{
						cLU.GetLanduseInfo(tCurrent,&pluinfop[nOrder2],slsur,lsur);
					}

					if(pluinfop[nOrder2].piid == 1)	// impervious land
						infilt =  0.0;
					
					int smsfg  = smsfg_p[nOrder2];
					int fsmsfg = fsmsfg_p[nOrder2];
					int nblks  = 1;
					double suri = 0.0;
					double infil = 0.0; // global
					double uzi = 0.0; // return value
					double ifwi = 0.0;// return value
					double ifwli = 0.0; // global initialized to 0
					double perc = 0.0; // local
					double ifwk1 = ifwk1_p[nOrder2];
					double ifwk2 = ifwk2_p[nOrder2];
					double lzfrac = lzfrac_p[nOrder2];
					double rlzrat = rlzrat_p[nOrder2];
					double dec = dec_p[nOrder2];
					double src = src_p[nOrder2];
					double lzi = 0.0; // local variable
					double kgw = 0.0;
					double agwli = 0.0;
					double igwi = 0.0;
					double agwi = 0.0; // lateral inflow
					double rparm = rparm_p[nOrder2];
					double taet = 0.0;	//total ET
					double baset = 0.0;	//baseflow ET
					double cepe = 0.0;	//interception ET
					double uzet = 0.0;	//upperzone ET
					double agwet = 0.0;	//groundwater ET
					double lzet = 0.0;	//lowerzone ET
					double alifp = 0.0;

					
					//Add fraction 1 of the irrigation application to precipitation (supy) if irrigfg is 1
					if (irrigfg == 1) 
					{
						int cGroupId = lgroup*nlandp+k;
						supy += irrigDemand[j*nlandp+k] * pirriginfop[cGroupId].fraction1;
					} 

					icept(&vcsfg, &dayfg, cepscm, &mon, &nxtmon,
						&day, &ndays, &supy, &cepsc, &ceps, &cepo);
					
					if(slifp > 0)
					{
						// surface lateral inflow timseries  
						//*surli = pad[scrtch_1.slifp + scrtch_1.ivl1 - 1];
					}
					else
					{
						// surface lateral inflow not considered  
						surli = 0.0;
					}
					
					// surface inflow is the sum of interception outflow and surface  
					// lateral inflow (if any)  
					suri = cepo + surli;
					// Msupy is used below and again in subroutine group surfac  
					// Surss is the value of surs at the start of the ivl -  
					// it is used by module section MSTLAY  
					msupy = suri + surs;
					double surss = surs;
					//Add fraction 2 of the irrigation to soil moisture (msupy) if irrigfg is 1
					if (irrigfg == 1) 
					{
						int cGroupId = lgroup*nlandp+k;
						msupy += irrigDemand[j*nlandp+k] * pirriginfop[cGroupId].fraction2 ;
						
					} 					
					// set flags which indicate whether or not there is anything to  
					// infiltrate and whether or not this is the first in a series of  
					// wet intervals  
					if(msupy > 0.0)
					{
						// there is surface moisture supply  
						if(smsfg == 0)
						{
							// this is the first interval with surface moisture supply  
							// after one or more intervals with none  
							fsmsfg = 1;
						}
						else
						{
							// this is not the first wet interval  
							fsmsfg = 0;
						}
						// there is surface moisture supply  
						smsfg = 1;
					}
					else
					{
						// there is no surface moisture supply  
						smsfg  = 0;
						fsmsfg = 0;
					}
					
					// Uzsn may be a varying parameter - the code to interpolate its  
					// current value is placed here because UZSN is used in several  
					// places in the code below this point  
					if(dayfg == 1)                     
					{
						// it is the first interval of the day  
						if(vuzfg == 1)
						{
							// uzsn is allowed to vary throughout the year  
							// interpolate for the daily value  
							// linearly interpolate uzsn between two values from the  
							// monthly array uzsnm(12)  
							uzsn = dayval(&uzsnm[mon], &uzsnm[nxtmon], &day, &ndays);
						}
						else
						{
							// uzsn does not vary throughout the year and  
							// has been supplied by the run interpreter  
						}
					}
					
					// determine the current value of the lower zone storage ratio  
					lzrat = 0.0; 
					if (lzsn > 0)
						lzrat = lzs / lzsn;  //move to mappingpar
					// convert to internal units
					infilt = infilt*delt60;    // in/interval   
					
					if(smsfg == 1)
					{
						// simulate behavior of water on the land surface - surface  
						// detention, infiltration, interflow input, surface outflow  
						//ecnt1 = scrtch_1.pwecnt[0];
						surfac(&lzrat, &infilt, &infexp, &inffac, &infild,
							&fsmsfg, &dayfg, &vnnfg, nsurm, &lsur,
							&slsur, &vifwfg, intfwm, &nblks, &msupy,
							&uzsn, &uzs, &delt60, &rtopfg, &uzfg,
							&mon, &nxtmon, &day, &ndays, &dec,
							&src, &nsur, &intfw, &surs, &infil,
							&uzi, &ifwi, &suro);
					}
					else
					{
						// storage on the surface and outputs from it will be zero 
						surs  = 0.0;
						suro  = 0.0;
						ifwi  = 0.0;
						infil = 0.0;
						uzi   = 0.0;
					}
					//Add fraction 3 of the irrigation to uzs if irrigfg is 1
					//Add fraction 4 of the irrigation to lzs if irrigfg is 1
					//Add fraction 5 of the irrigation to agws if irrigfg is 1
					if (irrigfg == 1) 
					{
						int cGroupId = lgroup*nlandp+k;
						uzs += irrigDemand[j*nlandp+k] * pirriginfop[cGroupId].fraction3;
						lzs += irrigDemand[j*nlandp+k] * pirriginfop[cGroupId].fraction4;
						agws += irrigDemand[j*nlandp+k] * pirriginfop[cGroupId].fraction5;
						
					} 					
					if(infilt > LIMITNUM)      // pervious land
					{
						// simulate interflow  
						if(ilifp > 0)
						{
							// interflow lateral inflow timseries  
						}
						else
						{
							// interflow lateral not being considered  
							ifwli = 0.0;
						}
						intflw(&dayfg, &vircfg, ircm, &mon, &nxtmon,
							&day, &ndays, &delt60, &nblks, &ifwi,
							&ifwli, &irc, &ifwk1, &ifwk2, &ifws,
							&uzs, &ifwo);
						// simulate upper zone behavior  
						uzone(&nblks, &uzsn, &uzi, &infilt,	&inffac, &lzrat, &uzs, &perc);
						// collect inflows to lower zone and groundwater  
						
						iperc = perc + infil;
						// simulate lower zone behavior  
						lzone(&iperc, &lzrat, &lzfrac, &lzs, &rlzrat,&lzi);
						
						// simulate groundwater behavior  
						// groundwater recession parameters
						kgw = (1.0 - pow(agwrc, (delt60/24.0)));
						gwi = iperc - lzi;
						if(alifp > 0)
						{
							// groundwater laterial inflow timseries  
							//*agwli = pad[scrtch_1.alifp + scrtch_1.ivl1 - 1];
						}
						else
						{
							// groundwater laterial not considered  
							agwli = 0.0;
						}

						gwater(&deepfr, &gwi, &kvary, &dayfg, &kgw,
							&agwli, &agws, &gwvs, &igwi, &agwi,	&agwo);
						// simulate ET  
						evapt(&pet, &basetp, &nblks, &uzsn, &agwetp,
							&kvary, &dayfg,	&vlefg, lzetpm, &mon,
							&nxtmon, &day, &ndays, &lzsn, &delt60,
							&agwo, &ceps, &uzs, &agws, &gwvs,
							&lzetp, &rparm, &lzs, &rempet, &taet,
							&baset, &cepe, &uzet, &agwet, &lzet);
					}
					else
					{
						taet = 0.0;
						ifwo = 0.0;
						perc = 0.0;									
						gwi  = 0.0;									
						igwi = 0.0;									
						agwi = 0.0;									
						agwo = 0.0;
						double rempet = pet;
						evicep(&ceps, &rempet, &taet, &cepe);
					}
					// find total outflow  
					pero = suro + ifwo + agwo;
					// total input of water to the pervious land segment  
					watin = supy + surli + ifwli + agwli;
					// net input of water to the pervious land segment  
					watdif = watin - (pero + igwi + taet);
					// total moisture storage 
					pers = ceps + surs + ifws + uzs + lzs + agws;
					
					// update
					ifwk1_p[nOrder2] = ifwk1;
					ifwk2_p[nOrder2] = ifwk2;
					lzfrac_p[nOrder2] = lzfrac;
					rlzrat_p[nOrder2] = rlzrat;
					rparm_p[nOrder2]  = rparm;
					dec_p[nOrder2]    = dec ;
					src_p[nOrder2]    = src ;
					smsfg_p[nOrder2]  = smsfg ;
					fsmsfg_p[nOrder2] = fsmsfg;
 					ppw_param4[nOrder].cepsc_p = cepsc;
					ppw_param4[nOrder].uzsn_p  = uzsn;
					ppw_param4[nOrder].nsur_p  = nsur;
					ppw_param4[nOrder].intfw_p = intfw;
					ppw_param4[nOrder].irc_p   = irc;
					ppw_param4[nOrder].lzetp_p = lzetp;

					// Irrigation demand calculations
					if (irrigfg == 1 && k == nlandp-1)
					{
						//Find out the cumulative precipitation and potential evapotranspiration
						//for each day
						if(curDay == prevDay )
						{
							curPeriodPrec[j]	+= prec_p[j];
							if (petfg == 1)
								curPeriodET[j]	+= pirrigpet[lgroup].petval * delt60;
							else
								curPeriodET[j]	+= pet_irr[j];
						}
						else
						{
							//Shift the cumulative precipitations and ETs a day forward
							// Precip[day1] = Precip[days] ...to maxEtDays
							for(int d=0; d<maxEtDays-1; d++)
							{
								cumulativePrec[j*maxEtDays + d] = cumulativePrec[j*maxEtDays + d + 1] ;
								cumulativeET[j*maxEtDays + d] = cumulativeET[j*maxEtDays + d + 1] ;
							}
							cumulativePrec[j*maxEtDays + (maxEtDays - 1)] = curPeriodPrec[j] ;
							cumulativeET[j*maxEtDays + (maxEtDays - 1)] = curPeriodET[j] ;

//							wsIrrigDemand[j] = 0.0 ;

							for(int luInd=0; luInd<nlandp; luInd++)
							{							
								double etdemand  = 0.0;  
								double totPrecip = 0.0;

								int cGroupId = lgroup*nlandp+luInd;
								int cGroupId2 = j*nlandp+luInd;								
								int isIrrigPeriod = 0; 
								if (pirriginfop[cGroupId].startmonth < pirriginfop[cGroupId].endmonth)
								{
								   if(tCurrent.GetMonth() >= pirriginfop[cGroupId].startmonth && tCurrent.GetMonth() <= pirriginfop[cGroupId].endmonth)
									   isIrrigPeriod = 1 ;
								}
								else
								{
								   isIrrigPeriod = 1 ; 
								   if(tCurrent.GetMonth() < pirriginfop[cGroupId].startmonth && tCurrent.GetMonth() > pirriginfop[cGroupId].endmonth)
									   isIrrigPeriod = 0 ;

								}
								if (isIrrigPeriod == 1) 
								{	

									//ET demand = PET*Kc; Kc is the crop coefficient
									
									for(int d=0; d<pirriginfop[cGroupId].etdays; d++)
										totPrecip += cumulativePrec[j*maxEtDays + (maxEtDays-1-d)];

									int luetdays = __max(1,pirriginfop[cGroupId].etdays);
									if(monVaryIrrig == 1)
									{
										for(int d=0; d<luetdays; d++)
											etdemand += cumulativeET[j*maxEtDays + (maxEtDays-1-d)] * pmonetcinfop[cGroupId].monETCs[tCurrent.GetMonth()-1];
										//etdemand = curPeriodET[j] * pmonetcinfop[cGroupId].monETCs[tCurrent.GetMonth()-1] ;
									}
									else
									{
										//etdemand = curPeriodET[j] * pirriginfop[cGroupId].etcoeff ;
										for(int d=0; d<luetdays; d++)
											etdemand += cumulativeET[j*maxEtDays + (maxEtDays-1-d)] * pirriginfop[cGroupId].etcoeff;
									}
									//Irrigation demand is calculated only for pervious land segments
//									if(pluinfop[cGroupId2].piid != 1)          // pervious land 
//									{
										//if PET*Kc > Precipitation then irrigation demand = PET*Kc - Precipitation
										//irrigation demand and watershed level irrigation demand per timestep
										//irrigDemand[cGroupId2] = (etdemand > curPeriodPrec[j])?((etdemand - curPeriodPrec[j])/(24/delt60)):0.0 ;
										
										double etdeficit = etdemand - totPrecip;
										double numTS = luetdays * 24 / delt60;
										
										//irrigDemand[cGroupId2] = (etdemand > totPrecip)?((etdemand - totPrecip)/((pirriginfop[cGroupId].etdays)*24/delt60)):0.0 ;
										irrigDemand[cGroupId2] = (etdemand > totPrecip)?(etdeficit / numTS):0.0;
										
										//watershed level irrigation demand (volume) is 
										//sum of irrigation demand for all the landuses, which is the
										//product of area of the landuse and irrigation demand in depth units
//										double lfAREA = pluinfop[cGroupId2].area;

//										if (cLU.nLUchangeFlag == 1 && pluinfop[cGroupId2].bLUchange == true)
//											lfAREA = cLU.GetLanduseArea(tCurrent, &pluinfop[cGroupId2]);
//										wsIrrigDemand[j] += irrigDemand[cGroupId2] * lfAREA;
//									}
								}
								else
								{
									irrigDemand[cGroupId2] = 0.0;	// inch/ivl									
									//wsIrrigDemand[j] = 0.0;			// in-acre/ivl		
								}
							}
							curPeriodPrec[j] = prec_p[j];

							if (petfg == 1)
								curPeriodET[j] = pirrigpet[lgroup].petval * delt60;
							else
								curPeriodET[j] = pet_irr[j];
						}
					}
					
					/**********************************/
					// J.S. start sediment loop here
					double dets =0, det, smpf, wssd, scrsd, sosed;
					if(sedfg == 1)
					{
						smpf  = psd_param1[nOrder].smpf_p;
						krer  = psd_param1[nOrder].krer_p;
						jrer  = psd_param1[nOrder].jrer_p;
						affix = psd_param1[nOrder].affix_p;
						cover = psd_param1[nOrder].cover_p;
						nvsi  = psd_param1[nOrder].nvsi_p;
						kser  = psd_param1[nOrder].kser_p;
						jser  = psd_param1[nOrder].jser_p;
						kger  = psd_param1[nOrder].kger_p;
						jger  = psd_param1[nOrder].jger_p;
						dets  = dets_s[nOrder2];
						
						if(pluinfop[nOrder2].piid == 2)	//pervious land segment
						{
							double *coverm = NULL;
							if(pCRVm != NULL)
								coverm = pCRVm[nOrder].fnum;

							double *nvsim = NULL;
							if(pVSIVm != NULL)
								nvsim = pVSIVm[nOrder].fnum;

							detach(&dayfg, &crvfg, coverm, &mon, &nxtmon, &day, &ndays,
								&supy, &snowfg, &snocov, &delt60, &smpf, &krer,&jrer, 
								&cover, &dets, &det);

//							if (dayfg == 1) 
//							{
								//it is the first interval of the day
								if (vsivfg != 0)
								{
									//net vert. input values are allowed to vary throughout the
									//year
									//interpolate for the daily value
									//units are tons/acre-ivl
									//linearly interpolate nvsi between two values from the
									//monthly array nvsim(12)
									nvsi = dayval(&nvsim[mon],&nvsim[nxtmon],&day,&ndays);
								}
								else
								{
									//net vert. input values do not vary throughout the year.
									//nvsi value has been supplied by the run interpreter
								}

//								if (vsivfg == 2 && drydfg == 1) 
//								{
									//last day was dry, add a whole days load in first interval
									//detailed output will show load added over the whole day.
//									double dummy = nvsi* deltd;
//									dets = dets + dummy;
//								}
//								else 
//								{
									//dont accumulate until tomorrow, maybe
//									nvsi = 0.0;
//								}
								if (vsivfg == 2) 
								{
									if (drydfg == 1)
									{
										//last day was dry, add a whole days load in first interval
										//detailed output will show load added over the whole day.
										double dummy = nvsi* deltd;
										dets = dets + dummy;
									}
									else 
									{
										//dont accumulate until tomorrow, maybe
										nvsi = 0.0;
									}
								}
//							}

							//augment the detached sediment storage by external(vertical)
							//inputs of sediment - dets and detsb units are tons/acre
							double slsed = 0.0;	// ??
							double dummy = slsed;
							if (vsivfg < 2) 
							  dummy = dummy + nvsi;

							dets = dets + dummy;

							sosed1(&suro, &surs, &delt60, &kser, &jser,
								&kger, &jger, &dets, &wssd, &scrsd, &sosed);

							wssd_p[nOrder2] = wssd;
							scrs_p[nOrder2] = scrsd;
							
							if(supy <0.00001)
								atach(&affix, &dets);
							dets_s[nOrder2] = dets;
						}
						else  // impervious land segmnet
						{
							double slds = slds_s[nOrder2];
							accsdp = psd_param1[nOrder].accsdp_p;
							remsdp = psd_param1[nOrder].remsdp_p;
							
							//solids washoff
							sosld1(&suro, &surs, &delt60, &kser, &jser, &slds, &sosed);

							scrsd = 0.0;
							wssd  = sosed;

							//ccumulate and remove solids independent of runoff
							//accum(&dayfg, &supy, &drydfg, &accsdp, &remsdp, &slds);
							double frac_sand = fr_sand[nOrder2];
							double frac_silt = fr_silt[nOrder2];
							double frac_clay = fr_clay[nOrder2];

							accum2(dayfg, supy, drydfg, accsdp, remsdp, slds, 
							fr_sand_bs[nOrder2], fr_silt_bs[nOrder2], fr_clay_bs[nOrder2],
							frac_sand, frac_silt, frac_clay);

							//update sediment fractions
							fr_sand[nOrder2] = frac_sand;
							fr_silt[nOrder2] = frac_silt;
							fr_clay[nOrder2] = frac_clay;
							
							slds_s[nOrder2] = slds;
							wssd_p[nOrder2] = wssd;
							scrs_p[nOrder2] = 0.0;

							//apply street sweeping if applicable
							if (sweepfg != 0)
							{
								int nOrderImp = lgroup*nlandimp+impindex;
								int startmonth = psd_sweep[nOrderImp].start_month;//month
								int endmonth = psd_sweep[nOrderImp].end_month;//month
								double percent_area = psd_sweep[nOrderImp].percent_area;//fraction
								double frequency = psd_sweep[nOrderImp].frequency;//days
								double remeff_sand = psd_sweep[nOrderImp].effic_sand;
								double remeff_silt = psd_sweep[nOrderImp].effic_silt;
								double remeff_clay = psd_sweep[nOrderImp].effic_clay;
								double runoff = suro / 12.0;//ft/ivl

								if ( cLU.CanSweep(mon+1, startmonth, endmonth) ) //mon starts with zero
								{
									double buildup = slds_s[nOrder2];//tons/ac
									double frac_sand = fr_sand[nOrder2];
									double frac_silt = fr_silt[nOrder2];
									double frac_clay = fr_clay[nOrder2];
									double area = pluinfop[nOrder2].area;//acre
									COleDateTime tLast = tLastSwept[nOrder2];//datetime
								
									cLU.BuildupSweep(buildup,frac_sand,frac_silt, 
										frac_clay,remeff_sand,remeff_silt,remeff_clay, 
										area,percent_area,runoff,frequency,tCurrent,tLast);
									
									//update the buildup and sediment fractions
									slds_s[nOrder2] = buildup;//tons/ac
									fr_sand[nOrder2] = frac_sand;
									fr_silt[nOrder2] = frac_silt;
									fr_clay[nOrder2] = frac_clay;
									tLastSwept[nOrder2] = tLast;
								}
								//increment index
								impindex++;
							}
						}
					} 
					
					// J.S. start soil tempersature loop here
					if(tempfg == 1)		
					{
						tsopfg = pstmp_parm1[nOrder].tsopfg;
						aslt  = pstmp_parm1[nOrder].aslt;//degree C
						bslt  = pstmp_parm1[nOrder].bslt;	
						aift  =	pstmp_parm1[nOrder].aift;
						bift  =	pstmp_parm1[nOrder].bift;	
						agwt  =	pstmp_parm1[nOrder].agwt;
						bgwt  =	pstmp_parm1[nOrder].bgwt;	

						if (msltfg == 1)
						{
							asltm_p = asltm[nOrder].fnum;//degree C
							bsltm_p = bsltm[nOrder].fnum;
						}
						if (miftfg == 1)
						{
							aiftm_p = aiftm[nOrder].fnum;
							biftm_p = biftm[nOrder].fnum;
						}
						if (mgwtfg == 1)
						{
							agwtm_p = agwtm[nOrder].fnum;
							bgwtm_p = bgwtm[nOrder].fnum;
						}

						airtmp = atem_p[j];			//degree C
						sltmp = soilts[nOrder2];	//degree C
						iftmp = soiltu[nOrder2];	//degree C
						gwtmp = soiltl[nOrder2];	//degree C

						pstemp(hrfg,dayfg,tsopfg,msltfg,miftfg,mgwtfg,&mon,&nxtmon,
							&day,&ndays,aslt,asltm_p,bslt,bsltm_p,aift,aiftm_p,bift,biftm_p,
							agwt,agwtm_p,bgwt,bgwtm_p,airtmp,sltmp,iftmp,gwtmp);

						soilts[nOrder2] = sltmp;//degree C

						if (soilts[nOrder2] < 0.5)
							// don't let water temp drop below 0.5 degree C (09-07-05)
							soilts[nOrder2] = 0.5;
											
						if(snowfg == 1)
						{
							// adjust surface outflow temperature if snowmelt is occuring (09-07-05)
							if (f_wyield[nOrder2] > 0)
								// snow melt is occuring
								soilts[nOrder2] = 0.5;
						}

						soiltu[nOrder2] = iftmp;
						soiltl[nOrder2] = gwtmp;
						pstmp_parm1[nOrder].aslt = aslt;
						pstmp_parm1[nOrder].bslt = bslt;	
						pstmp_parm1[nOrder].aift = aift;
						pstmp_parm1[nOrder].bift = bift;	
						pstmp_parm1[nOrder].agwt = agwt;
						pstmp_parm1[nOrder].bgwt = bgwt;	
					}  

					// J.S. start calculate sediment DO and CO2

					if(oxfg == 1)	// land calculation
					{
						double wt, elev, elevgc;
						wt = soilts[nOrder2];
						//compute factor for correcting dissolved gas
						//saturated concentrations for altitude
						elev   = ptmp_param1[j].elev;						
						elevgc = pow(((288.0- 0.00198*elev)/288.0),5.256);

						// Dissolved Oxygen
						double idoxp, adoxp;
						double pdoxout = 0.;
						double pdoxout_route = 0.;
						double pdoxout_bypass = 0.;
						idoxp = doco_parm1[nOrder].idoxp;
						adoxp = doco_parm1[nOrder].adoxp;
						if(midofg == 1)
							idoconcm = idoconc[nOrder].fnum;
						if(madofg == 1)
							adoconcm = adoconc[nOrder].fnum;
						// CO2
						double pco2out = 0.;
						double pco2out_route = 0.;
						double pco2out_bypass = 0.;
						double ico2p, aco2p;
						ico2p = doco_parm1[nOrder].ico2p;
						aco2p = doco_parm1[nOrder].aco2p;
						if(mico2fg == 1)
							ico2concm = ico2conc[nOrder].fnum;
						if(maco2fg == 1)
							aco2concm = aco2conc[nOrder].fnum;

						double route_suro = pLURoute[lgroup*nlandp+k].route_suro;
						double route_ifwo = pLURoute[lgroup*nlandp+k].route_ifwo;
						double route_agwo = pLURoute[lgroup*nlandp+k].route_agwo;
						double bypass_suro = pLURoute[lgroup*nlandp+k].bypass_suro;
						double bypass_ifwo = pLURoute[lgroup*nlandp+k].bypass_ifwo;
						double bypass_agwo = pLURoute[lgroup*nlandp+k].bypass_agwo;

						soilgas(elevgc, midofg, madofg, mico2fg, maco2fg, dayfg, 
							&idoxp, &adoxp, &ico2p, &aco2p, idoconcm, adoconcm, 
							ico2concm, aco2concm, mon, nxtmon, day, ndays, wt, 
							suro, ifwo, agwo, route_suro, route_ifwo, route_agwo, 
							bypass_suro, bypass_ifwo, bypass_agwo, &pdoxout, &pco2out, 
							&pdoxout_route, &pco2out_route,&pdoxout_bypass, &pco2out_bypass);

						// Dissolved Oxygen
						pdop[j*nlandp+k] = pdoxout;
						pdop_route[j*nlandp+k]  = pdoxout_route;
						pdop_bypass[j*nlandp+k]  = pdoxout_bypass;
						doco_parm1[nOrder].idoxp = idoxp ;
						doco_parm1[nOrder].adoxp = adoxp;
						// CO2
						pco2p[j*nlandp+k] = pco2out;
						pco2p_route[j*nlandp+k] = pco2out_route;
						pco2p_bypass[j*nlandp+k] = pco2out_bypass;
						doco_parm1[nOrder].ico2p = ico2p ;
						doco_parm1[nOrder].aco2p = aco2p;
					}
					// end calculate sediment DO and CO2

					/**********************************/
					// after do loop j,k for both Pwater and I water
					// start new do loop for sws and land use j,k
					// get parameter
					//
					// Calculate Pollutants
					double soqo  = 0.0;
					double soqoc = 0.0;
					int    qafp  = 0;
					int    qifp  = 0;
					int    qsdfg = 0;
					int    qsofg = 0;
					int    n     = 0;
					double suroqo = 0.0;
					
					if(pqalfg == 1)
					{
						//nQuals is the number of constituents being simulated
						for(n=0; n<nQuals; n++)	
						{
							int nOrder3   = lgroup*nQuals*nlandp + n*nlandp + k;	 
							int nOrder4   = j*nlandp*nQuals + k*nQuals + n;
							double acqop  = pQualInput[nOrder3].acqop;
							double remqop = pQualInput[nOrder3].sqolim;
							
							// REMQOP IS ACTUALLY SQOLIM
							double *acqopm = NULL;
							if(pIMonAccum != NULL)
								acqopm = pIMonAccum[nOrder3].fnum;

							double *remqom_i = NULL;
							if(pIMonSQOLIM != NULL)
								remqom_i = pIMonSQOLIM[nOrder3].fnum;
							
							remqop = acqop/remqop;
							for(int m=0; m<12; m++)
							{
								if(acqopm != NULL && remqom_i != NULL)
									remqom[m] = acqopm[m]/remqom_i[m];
								else
									remqom[m] = 1;
							}

							double sqo   = sqo_s[nOrder4];
							double wsqop = pQualInput[nOrder3].wsqop;
							//sediment associated J.S
							double potfw = pQualInput[nOrder3].potfw;
							double potfs = pQualInput[nOrder3].potfs;
							double washqs = washqs_s[nOrder4];
							double scrqs  = scrqs_s[nOrder4];
							double soqs   = 0;
							soqo  = soqo_s[nOrder4];
							soqoc = 0;

							// simulate constituent n  
							// simulate by association with sediment  
							qsdfg = pQual[lgroup*nQuals+n].qsdfg;
							qsofg = pQual[lgroup*nQuals+n].qsofg;

							// sediment associtated  
							if(qsdfg > 0 && sedfg == 1)
							{
								// constituent n is simulated by association with sediment  
								// the value of qsfp refers to the set of sediment  
								// associated parameters to use  
								qualsd(&wssd, &scrsd, &potfw, &potfs, &washqs, &scrqs, &soqs);
								washqs_p[nOrder4] = washqs;
								scrqs_p[nOrder4] = scrqs;
								soqs_p[nOrder4] = soqs;
							}
							else
							{
								washqs_p[nOrder4] = 0.0;
								scrqs_p[nOrder4] = 0.0;
								soqs_p[nOrder4] = 0.0;
							}
							
							int adfxfg = 0;
							int adcnfg = 0;
							double adflx = 0.0;
							double adcnc = 0.0;
							double *adfxmn = NULL;
							double *adcnmn = NULL;
							double adfxfx = 0.0; 
							double adcnfx = 0.0;
							double adtot = 0.0;
							double sliqo = 0.0;		// lateral input (not supported)

							// check if admospheric deposition option is on
							if (adfglnd > 0)
							{
								adfxfg = maddfglnd;
								adcnfg = mawdfglnd;
								adflx = pQualInput[nOrder3].addc;
								adcnc = pQualInput[nOrder3].awdc;
								if(pIMonDRYDEP != NULL)
									adfxmn = pIMonDRYDEP[nOrder3].fnum;
								if(pIMonWETDEP != NULL)
									adcnmn = pIMonWETDEP[nOrder3].fnum;
							}
			
							//double wsfac = 2.30 / (wsqop * delt60); (10-16-09) John Riverson								 
							double wsfac = 2.30 / wsqop;
							
							BUILDUP(dayfg,vqofg,adcnfg,adfxfg,qsofg,day,ndays,
								mon,nxtmon,delt60,prec,sliqo,adflx,adcnc,adfxmn,
								adcnmn,&adfxfx,&adcnfx,&acqop,&remqop,acqopm,
								remqom,&adtot,&sqo);

							//apply street sweeping if applicable
							if (sedfg == 1 && sweepfg == 2 && pluinfop[nOrder2].piid == 1) //impervious land only
							{
								int nOrderImp = lgroup*nlandimp+impindex_GQ;
								int startmonth = psd_sweep[nOrderImp].start_month;//month
								int endmonth = psd_sweep[nOrderImp].end_month;//month
								double percent_area = psd_sweep[nOrderImp].percent_area;//fraction
								double frequency = psd_sweep[nOrderImp].frequency;//days
								double remeff_GQ = pGQ_sweep[nOrderImp].effic_GQual[n];
								double runoff = suro / 12.0;//ft/ivl

								if ( cLU.CanSweep(mon+1, startmonth, endmonth) ) 
								{
									double buildup = sqo;//tons/ac
									double area = pluinfop[nOrder2].area;//acre
									COleDateTime tLastSwept = tLastSwept_GQ[nOrder4];//datetime
								
									cLU.BuildupSweep_GQ(buildup, remeff_GQ, area, 
										percent_area, runoff, frequency,
										tCurrent, tLastSwept);
									
									//update the buildup
									sqo = buildup;//tons/ac
									tLastSwept_GQ[nOrder4] = tLastSwept;
								}
							}

							WASHOFF(suro,wsfac,&sqo,&soqo,&soqoc);
							
//							WASHOF(dayfg,vqofg,acqopm,remqom,suro,wsfac,mon,nxtmon,
//								day,ndays,prec,adfxfg,adcnfg,adfxmn,adcnmn,adflx,
//								adcnc,sliqo,delt60,qsofg,&acqop,&remqop,&sqo,&soqo,
//								&soqoc,&adfxfx,&adcnfx,&adtot);

							suroqo = (suro>0)?soqo:0.0;
							
							// sum outflows of constituent n from the land surface  
							f_suroqo[nOrder4] = suroqo;
							sqo_s[nOrder4]    = sqo;
							washqs_s[nOrder4] = washqs;
							scrqs_s[nOrder4]  = scrqs;
							soqo_s[nOrder4]   = soqo;

							// simulate quality constituent in surface flow 
							if(qsowfg > 0)
							{
								// constiuent n is present in surface flow 
								double *soqcm = NULL;
								if (pIMonSUROCONC != NULL)
									soqcm = pIMonSUROCONC[nOrder3].fnum;
								double sowqc   = pQualInput[nOrder3].soqc;
								double sowqual = 0;
								
								qualsuro(&dayfg, &vsqcfg, &suro, soqcm, &mon,
									&nxtmon, &day, &ndays, &sowqc, &sowqual);
								
								// cumulate outflow 
								f_suroqo[nOrder4] += sowqual;
							}

							// simulate quality constituent in interflow  
							qifp = qifwfg;
							if(qifp > 0)
							{
								double *ioqcm = NULL;
								if (pIMonINTERCONC != NULL)
									ioqcm = pIMonINTERCONC[nOrder3].fnum;
								double ioqc   = pQualInput[nOrder3].ioqc;
								double ioqual = 0;
								
								qualif(&dayfg, &viqcfg, &ifwo, ioqcm, &mon,
									&nxtmon, &day, &ndays, &ioqc, &ioqual);
								
								// cumulate outflow  
								f_ifoqual[nOrder4] = ioqual;               
							}
							
							// simulate quality constituent in active groundwater outflow  
							qafp = qagwfg;
							if(qafp > 0)
							{
								double *aoqcm = NULL;
								if (pIMonGRNDCONC != NULL)
									aoqcm = pIMonGRNDCONC[nOrder3].fnum;
								double aoqc   = pQualInput[nOrder3].aoqc;
								double aoqual = 0.0;
								
								qualgw(&dayfg, &vaqcfg, &agwo, aoqcm, &mon,
									&nxtmon, &day, &ndays, &aoqc, &aoqual);
								
								// cumulate outflow  
								f_aoqual[nOrder4] = aoqual;
							}
						}
						//increment index
						if (pluinfop[nOrder2].piid == 1)
							impindex_GQ++;
					}

					f_suro[nOrder2]		= suro;
					f_ifwo[nOrder2]		= ifwo;
					f_agwo[nOrder2]		= agwo;
					f_cepe[nOrder2]	    = cepe;          
					f_uzet[nOrder2]	    = uzet;          
					f_baset[nOrder2]	= baset;          
					f_lzet[nOrder2]	    = lzet;          
					f_agwet[nOrder2]	= agwet;          
					f_perc[nOrder2]	    = perc;          
					f_infil[nOrder2]	= infil;         
					f_gwi[nOrder2]		= gwi;           
					f_igwi[nOrder2]		= igwi;          
					f_agwi[nOrder2]		= agwi;          
					ceps_p[nOrder2]		= ceps;
					surs_p[nOrder2]		= surs;
					uzs_p[nOrder2]		= uzs;
					ifws_p[nOrder2]		= ifws;
					lzs_p[nOrder2]		= lzs;
					agws_p[nOrder2]		= agws;
					gwvs_p[nOrder2]		= gwvs;
					ftaet_p[nOrder2]	= taet;
					
					// apply reduction
					if (pFlowControls != NULL && ncland > 0)
					{
						f_suro[nOrder2]	*= pFlowControls[nOrder2];

						if(ncland == 2)
						{
							f_ifwo[nOrder2]	*= pFlowControls[nOrder2];
							f_agwo[nOrder2]	*= pFlowControls[nOrder2];
						}
					}
				}
			}
		}
		
		nCount++;

		if (tCurrent >= toStart && tCurrent <= toEnd && nLUsummary > 0)
			counter++;

		// J.S. Mapping value for all watershed
		for(j=0; j<nsws; j++)
		{
			if(pswsinfo[j].lksws != 0)
			{
				int jj = pswsinfo[j].lksws - 1;
				if(tempfg == 1)
				{
					atem_p[j] = atem_p[jj];
					airtmp_p[j] = airtmp_p[jj];			
					snotmp_p[j] = snotmp_p[jj];			
					wind_p[j] = wind_p[jj];
					solr_p[j] = solr_p[jj];
					dewp_p[j] = dewp_p[jj];
					clou_p[j] = clou_p[jj];

					tmud_p[j] = tmud_p[jj];
					tmuddt_p[j] = tmuddt_p[jj];
				}

				prec_p[j] = prec_p[jj];
				supy_p[j] = supy_p[jj];
				pet_p[j]  = pet_p[jj];
				pet_irr[j]= pet_irr[jj];

				for(k=0; k<nlandp; k++)
				{
					//added (04-14-2010)
					ceps_p[j*nlandp+k]	= ceps_p[jj*nlandp+k];
					surs_p[j*nlandp+k]	= surs_p[jj*nlandp+k];
					uzs_p[j*nlandp+k]	= uzs_p[jj*nlandp+k];
					ifws_p[j*nlandp+k]	= ifws_p[jj*nlandp+k];
					lzs_p[j*nlandp+k]	= lzs_p[jj*nlandp+k];
					agws_p[j*nlandp+k]	= agws_p[jj*nlandp+k];
					gwvs_p[j*nlandp+k]	= gwvs_p[jj*nlandp+k];
					ftaet_p[j*nlandp+k]	= ftaet_p[jj*nlandp+k];
					snowep_p[j*nlandp+k]= snowep_p[jj*nlandp+k];
					mneghs_p[j*nlandp+k]= mneghs_p[jj*nlandp+k];
					packwc_p[j*nlandp+k]= packwc_p[jj*nlandp+k];
					neght_p[j*nlandp+k]	= neght_p[jj*nlandp+k];
					gmeltr_p[j*nlandp+k]= gmeltr_p[jj*nlandp+k];
					compct_p[j*nlandp+k]= compct_p[jj*nlandp+k];
					mostht_p[j*nlandp+k]= mostht_p[jj*nlandp+k];
					vap_p[j*nlandp+k]	= vap_p[jj*nlandp+k];
					smsfg_p[j*nlandp+k]	= smsfg_p[jj*nlandp+k];
					fsmsfg_p[j*nlandp+k]= fsmsfg_p[jj*nlandp+k];
					ifwk1_p[j*nlandp+k]	= ifwk1_p[jj*nlandp+k];
					ifwk2_p[j*nlandp+k]	= ifwk2_p[jj*nlandp+k];
					lzfrac_p[j*nlandp+k]= lzfrac_p[jj*nlandp+k];
					rlzrat_p[j*nlandp+k]= rlzrat_p[jj*nlandp+k];
					dec_p[j*nlandp+k]	= dec_p[jj*nlandp+k];
					src_p[j*nlandp+k]	= src_p[jj*nlandp+k];
					rparm_p[j*nlandp+k]	= rparm_p[jj*nlandp+k];
					//added					
					f_suro[j*nlandp+k]	= f_suro[jj*nlandp+k];
					f_ifwo[j*nlandp+k]	= f_ifwo[jj*nlandp+k];
					f_agwo[j*nlandp+k]	= f_agwo[jj*nlandp+k];
					f_prec[j*nlandp+k]	= f_prec[jj*nlandp+k];				
					f_snowf[j*nlandp+k]	= f_snowf[jj*nlandp+k];				
					f_rainf[j*nlandp+k]	= f_rainf[jj*nlandp+k];				
					f_prain[j*nlandp+k]	= f_prain[jj*nlandp+k];				
					f_melt[j*nlandp+k]	= f_melt[jj*nlandp+k];				
					f_snowe[j*nlandp+k]	= f_snowe[jj*nlandp+k];				
					f_wyield[j*nlandp+k] = f_wyield[jj*nlandp+k];			
					pack_p[j*nlandp+k]  = pack_p[jj*nlandp+k];				
//					pack_sws[j*nlandp+k] = pack_sws[jj*nlandp+k];				
					packf_p[j*nlandp+k] = packf_p[jj*nlandp+k];				
					packw_p[j*nlandp+k] = packw_p[jj*nlandp+k];				
					packi_p[j*nlandp+k] = packi_p[jj*nlandp+k];				
					pdepth_p[j*nlandp+k] = pdepth_p[jj*nlandp+k];			
					covinx_p[j*nlandp+k] = covinx_p[jj*nlandp+k];			
					neghts_p[j*nlandp+k] = neghts_p[jj*nlandp+k];			
					xlnmlt_p[j*nlandp+k] = xlnmlt_p[jj*nlandp+k];			
					rdenpf_p[j*nlandp+k] = rdenpf_p[jj*nlandp+k];			
					skyclr_p[j*nlandp+k] = skyclr_p[jj*nlandp+k];			
					snocov_p[j*nlandp+k] = snocov_p[jj*nlandp+k];			
					dull_p[j*nlandp+k] = dull_p[jj*nlandp+k];				
					albedo_p[j*nlandp+k] = albedo_p[jj*nlandp+k];			
					paktmp_p[j*nlandp+k] = paktmp_p[jj*nlandp+k];			
					dewtmp_p[j*nlandp+k] = dewtmp_p[jj*nlandp+k];			
					f_cepe[j*nlandp+k]	= f_cepe[jj*nlandp+k];				
					f_uzet[j*nlandp+k]	= f_uzet[jj*nlandp+k];				
					f_baset[j*nlandp+k]	= f_baset[jj*nlandp+k];				
					f_lzet[j*nlandp+k]	= f_lzet[jj*nlandp+k];				
					f_agwet[j*nlandp+k]	= f_agwet[jj*nlandp+k];				
					f_perc[j*nlandp+k]	= f_perc[jj*nlandp+k];				
					f_infil[j*nlandp+k] = f_infil[jj*nlandp+k];				
					f_gwi[j*nlandp+k]	= f_gwi[jj*nlandp+k];				
					f_igwi[j*nlandp+k]	= f_igwi[jj*nlandp+k];				
					f_agwi[j*nlandp+k]	= f_agwi[jj*nlandp+k];				
					
					if(irrigfg == 1 )
						//Find out the similar group and assign irrigation demands
						irrigDemand[j*nlandp+k] = irrigDemand[jj*nlandp+k];

					if(sedfg == 1)
					{
						//added (04-14-2010)
						dets_s[j*nlandp+k] = dets_s[jj*nlandp+k];
						slds_s[j*nlandp+k] = slds_s[jj*nlandp+k];
						fr_sand[j*nlandp+k] = fr_sand[jj*nlandp+k];
						fr_silt[j*nlandp+k] = fr_silt[jj*nlandp+k];
						fr_clay[j*nlandp+k] = fr_clay[jj*nlandp+k];
						fr_sand_bs[j*nlandp+k] = fr_sand_bs[jj*nlandp+k];
						fr_silt_bs[j*nlandp+k] = fr_silt_bs[jj*nlandp+k];
						fr_clay_bs[j*nlandp+k] = fr_clay_bs[jj*nlandp+k];
						tLastSwept[j*nlandp+k] = tLastSwept[jj*nlandp+k];
						tLastSwept_GQ[j*nlandp+k] = tLastSwept_GQ[jj*nlandp+k];
						//added
						wssd_p[j*nlandp+k] = wssd_p[jj*nlandp+k];
						scrs_p[j*nlandp+k] = scrs_p[jj*nlandp+k];
					}

					if(pqalfg == 1)
					{
						int nOrder5 = j*nlandp*nQuals + k*nQuals;
						int nOrder6 = jj*nlandp*nQuals + k*nQuals;
						for(int m=0; m<nQuals; m++)
						{
							//added (04-14-2010)
							sqo_s[nOrder5+m] = sqo_s[nOrder6+m];
							washqs_s[nOrder5+m] = washqs_s[nOrder6+m];
							scrqs_s[nOrder5+m] = scrqs_s[nOrder6+m];
							soqo_s[nOrder5+m] = soqo_s[nOrder6+m];
							//added
							f_suroqo[nOrder5+m] = f_suroqo[nOrder6+m];
							f_ifoqual[nOrder5+m] = f_ifoqual[nOrder6+m];             
							f_aoqual[nOrder5+m] = f_aoqual[nOrder6+m];
							if(sedfg == 1)
							{
								washqs_p[nOrder5+m] = washqs_p[nOrder6+m];
								scrqs_p[nOrder5+m] = scrqs_p[nOrder6+m];
								soqs_p[nOrder5+m] = soqs_p[nOrder6+m];
							}
						}
					}

					if(tempfg == 1)
					{
						soilts[j*nlandp+k] = soilts[jj*nlandp+k];
						soiltu[j*nlandp+k] = soiltu[jj*nlandp+k];
						soiltl[j*nlandp+k] = soiltl[jj*nlandp+k];
					}

					// mapping for similar watersheds
					if(oxfg == 1)	
					{
						pdop[j*nlandp+k] = pdop[jj*nlandp+k];
						pdop_route[j*nlandp+k] = pdop_route[jj*nlandp+k];
						pdop_bypass[j*nlandp+k] = pdop_bypass[jj*nlandp+k];
						pco2p[j*nlandp+k] = pco2p[jj*nlandp+k];
						pco2p_route[j*nlandp+k] = pco2p_route[jj*nlandp+k];
						pco2p_bypass[j*nlandp+k] = pco2p_bypass[jj*nlandp+k];
					}
				}
			}
		}

		for(j=0; j<nQuals*nsws; j++)
		{
			f_poqual[j] = 0.0;
			f_poqual_route[j] = 0.0;
			f_poqual_bypass[j] = 0.0;
			f_posqual[j]= 0.0;
			f_posqual_route[j]= 0.0;
			f_posqual_bypass[j]= 0.0;
			f_soqual[j] = 0.0;				
			f_ioqual[j] = 0.0;				
			f_goqual[j] = 0.0;				
		}

		for(j=0; j<nsws; j++)
		{
			int rgroup = pReachInfo[j].rgid - 1;
			int lgroup = pswsinfo[j].gindex;
			
			double fsuro  = 0.0;
			double fifwo  = 0.0;
			double fagwo  = 0.0;
			double fprec  = 0.0;					
			double fsnowf = 0.0;					
			double frainf = 0.0;					
			double fprain = 0.0;					
			double fmelt  = 0.0;					
			double fsnowe = 0.0;					
			double fwyield = 0.0;					
			double fpack = 0.0;					
//			double fpack_sws = 0.0;					
			double fpackf = 0.0;					
			double fpackw = 0.0;					
			double fpacki = 0.0;					
			double fpdepth = 0.0;					
			double fcovindx = 0.0;				
			double fneghts = 0.0;					
			double fxlnmelt = 0.0;				
			double frdenpkf = 0.0;				
			double fskyclear = 0.0;				
			double fsnocov = 0.0;					
			double fdullness = 0.0;				
			double falbedo = 0.0;					
			double fpaktemp = 0.0;				
			double fdewtmp = 0.0;					
//			double fuzi   = 0.0;					
			double fcepe  = 0.0;					
			double fuzet  = 0.0;					
			double fbaset  = 0.0;					
			double flzet  = 0.0;					
			double fagwet  = 0.0;					
			double fperc  = 0.0;					
			double finfil = 0.0;					
			double fgwi   = 0.0;					
			double figwi  = 0.0;					
			double fagwi  = 0.0;					
			double fsurs  = 0.0;
			double fuzs   = 0.0;
			double flzs   = 0.0;
			double fagws  = 0.0;
			double ftaet  = 0.0;
			double fwssd  = 0.0;
			double fscrsd = 0.0;
//			pdox[j] = 0.0;
			pdox_route[j] = 0.0;
			pdox_bypass[j] = 0.0;
//			pco2[j] = 0.0;
			pco2_route[j] = 0.0;
			pco2_bypass[j] = 0.0;
			fSum[j] = 0.0;
			froute[j] = 0.0;
			fbypass[j] = 0.0;
			fgwo[j] = 0.0;
			froute_gwo[j] = 0.0;
			fbypass_gwo[j] = 0.0;
//			soiltm[j] = 0.0;
			soiltm_route[j] = 0.0;
			soiltm_bypass[j] = 0.0;

			for(k=0; k<nlandp; k++)
			{
				double lfAREA = pluinfop[j*nlandp+k].area;// acre;
				if (cLU.nLUchangeFlag == 1 && pluinfop[j*nlandp+k].bLUchange == true)
					lfAREA = cLU.GetLanduseArea(tCurrent, &pluinfop[j*nlandp+k]);

				froute[j]+= (f_suro[j*nlandp+k]*pLURoute[lgroup*nlandp+k].route_suro
							 +f_ifwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].route_ifwo
							 +f_agwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].route_agwo
							 )*lfAREA;
				fbypass[j]+= (f_suro[j*nlandp+k]*pLURoute[lgroup*nlandp+k].bypass_suro
							 +f_ifwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].bypass_ifwo
							 +f_agwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].bypass_agwo
							 )*lfAREA;
				froute_gwo[j]+= f_agwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].route_agwo*lfAREA;
				fbypass_gwo[j]+= f_agwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].bypass_agwo*lfAREA;

				fsuro	  += f_suro[j*nlandp+k] * lfAREA; 
				fifwo	  += f_ifwo[j*nlandp+k] * lfAREA;
				fagwo	  += f_agwo[j*nlandp+k] * lfAREA;
				fprec	  += f_prec[j*nlandp+k] * lfAREA;	
				fsnowf	  += f_snowf[j*nlandp+k] * lfAREA;	
				frainf	  += f_rainf[j*nlandp+k] * lfAREA;	
				fprain	  += f_prain[j*nlandp+k] * lfAREA;	
				fmelt	  += f_melt[j*nlandp+k]  * lfAREA;	
				fsnowe	  += f_snowe[j*nlandp+k] * lfAREA;	
				fwyield	  += f_wyield[j*nlandp+k] * lfAREA;	
				fpack	  += pack_p[j*nlandp+k] * lfAREA;	
//				fpack_sws += pack_sws[j*nlandp+k] * lfAREA;	
				fpackf	  += packf_p[j*nlandp+k] * lfAREA;	
				fpackw	  += packw_p[j*nlandp+k] * lfAREA;	
				fpacki	  += packi_p[j*nlandp+k] * lfAREA;	
				fpdepth	  += pdepth_p[j*nlandp+k] * lfAREA;	
				fcovindx  += covinx_p[j*nlandp+k] * lfAREA;	
				fneghts	  += neghts_p[j*nlandp+k] * lfAREA;	
				fxlnmelt  += xlnmlt_p[j*nlandp+k] * lfAREA;	
				frdenpkf  += rdenpf_p[j*nlandp+k];								
				fskyclear += skyclr_p[j*nlandp+k];								
				fsnocov	  += snocov_p[j*nlandp+k];								
				fdullness += dull_p[j*nlandp+k];								
				falbedo	  += albedo_p[j*nlandp+k];								
				fpaktemp  += paktmp_p[j*nlandp+k];								
				fdewtmp	  += dewtmp_p[j*nlandp+k];								
				fcepe	  += f_cepe[j*nlandp+k]*lfAREA;		
				fuzet	  += f_uzet[j*nlandp+k]*lfAREA;		
				fbaset	  += f_baset[j*nlandp+k]*lfAREA;		
				flzet	  += f_lzet[j*nlandp+k]*lfAREA;		
				fagwet	  += f_agwet[j*nlandp+k]*lfAREA;		
				fperc	  += f_perc[j*nlandp+k]*lfAREA;		
				finfil	  += f_infil[j*nlandp+k]*lfAREA;		
				fgwi	  += f_gwi[j*nlandp+k]*lfAREA;		
				figwi	  += f_igwi[j*nlandp+k]*lfAREA;		
				fagwi	  += f_agwi[j*nlandp+k]*lfAREA;		
				fsurs	  += surs_p[j*nlandp+k]*lfAREA;
				fuzs	  += uzs_p[j*nlandp+k]*lfAREA;
				flzs	  += lzs_p[j*nlandp+k]*lfAREA;
				fagws	  += agws_p[j*nlandp+k]*lfAREA;		
				ftaet	  += ftaet_p[j*nlandp+k]*lfAREA;		
				
				// landuse summary
				if (tCurrent >= toStart && tCurrent <= toEnd)
				{
					// land unit-area output for SUSTAIN model
					if(nSUSTAIN == 1) // && lfAREA > 0)
					{
						suro_sustain[j*nlandp+k] += f_suro[j*nlandp+k];		
						agwi_sustain[j*nlandp+k] += f_agwi[j*nlandp+k];		
					}

					if (nLUsummary > 0)
					{
						area_s[j*nlandp+k]  += lfAREA;//acre		
						precip_s[j*nlandp+k] += f_prec[j*nlandp+k] * lfAREA;//in-acre		
						suro_s[j*nlandp+k]  += f_suro[j*nlandp+k] * lfAREA;		
						ifwo_s[j*nlandp+k]  += f_ifwo[j*nlandp+k] * lfAREA;	
						agwo_s[j*nlandp+k]  += f_agwo[j*nlandp+k] * lfAREA;	
						pero_s[j*nlandp+k]  += (f_suro[j*nlandp+k]+f_ifwo[j*nlandp+k]+f_agwo[j*nlandp+k]) * lfAREA;	
						taet_s[j*nlandp+k]  += ftaet_p[j*nlandp+k] * lfAREA;	
					}
				}

				double s_suro = 0.0;
				double s_suro3 = 0.0;	// for SUSTAIN timeseries
				double s_ifwo = 0.0;
				double s_agwo = 0.0;

				if(sedfg == 1)
				{
					double s1 = wssd_p[j*nlandp+k] * lfAREA;	// english tons
					double s2 = scrs_p[j*nlandp+k] * lfAREA;
					double unit = IN_ACRE_TO_FT3*FT3_TO_M3;		// convert in-acre to ft^3 then to m^3 
					
					s_suro = f_suro[j*nlandp+k] * lfAREA * psd_param2[lgroup*nlandp+k].sed_suro * unit * GRAM_TO_TONS;	// (m^3 * mg/l -> g -> english tons) load from the surface runoff 
					s_ifwo = f_ifwo[j*nlandp+k] * lfAREA * psd_param2[lgroup*nlandp+k].sed_ifwo * unit * GRAM_TO_TONS;	// load from the interflow 
					s_agwo = f_agwo[j*nlandp+k] * lfAREA * psd_param2[lgroup*nlandp+k].sed_agwo * unit * GRAM_TO_TONS;	// load from the groundwater 
					
					double s_suro2 = 0.0;
					double s_ifwo2 = 0.0;
					double s_agwo2 = 0.0;

					double totalload = 0.0;	
					double sedwssd = 0.0;
					double sedscrs = 0.0;
					double sedsuro = 0.0;
					double sedifwo = 0.0;
					double sedagwo = 0.0;
					double totalsurfaceload = 0.0;
					double fracsum = 0.0;
					double multiplier = 1.0;

					//calculate fraction sum for silt and clay
					for (int ii=0; ii<NumSed; ii++)
						if (rsd_param[rgroup*NumSed+ii].sedflg != 0)
							fracsum += psd_param2[lgroup*nlandp+k].sed[ii];

					// calculate the total load (sand, silt, and clay)
					for (ii=0; ii<NumSed; ii++)
					{
						if (sandfg == 0 && rsd_param[rgroup*NumSed+ii].sedflg == 0)
							continue;

						double fract = psd_param2[lgroup*nlandp+k].sed[ii];
//						double surfaceload = fract*(s1+s2+s_suro);
						double surfaceload = fract*(s2+s_suro);
						double sedwssd2 = fract*s1;
						double sedscrs2 = fract*s2;
						double sedsuro2 = fract*s_suro;
						// (09/21/2011)
						if (rsd_param[rgroup*NumSed+ii].sedflg == 0 && fr_sand_bs[j*nlandp+k] > 0) //sand
							surfaceload += fract/fr_sand_bs[j*nlandp+k]*fr_sand[j*nlandp+k]*s1;
						//
						else if (rsd_param[rgroup*NumSed+ii].sedflg == 1 && fr_silt_bs[j*nlandp+k] > 0) //silt
							surfaceload += fract/fr_silt_bs[j*nlandp+k]*fr_silt[j*nlandp+k]*s1;
						else if (rsd_param[rgroup*NumSed+ii].sedflg == 2 && fr_clay_bs[j*nlandp+k] > 0) //clay
							surfaceload += fract/fr_clay_bs[j*nlandp+k]*fr_clay[j*nlandp+k]*s1;
						
						//normalized fraction is used only for interflow and groundflow 
						//to maintain the input concentration constant for silt and clay
						double interload = 0.0;
						if (fracsum > 0 && rsd_param[rgroup*NumSed+ii].sedflg != 0)
							interload = (fract/fracsum)*s_ifwo;
						
						double groundload = 0.0;
						if (fracsum > 0 && rsd_param[rgroup*NumSed+ii].sedflg != 0)
							groundload = (fract/fracsum)*s_agwo;

						//apply reduction
						multiplier = 1.0;

						if (pSedControls != NULL && ncland > 0)
						{
							if (rsd_param[rgroup*NumSed+ii].sedflg == 0)		// sand 
								multiplier = pSedControls[j*nlandp*3+k*3+0];
							else if (rsd_param[rgroup*NumSed+ii].sedflg == 1)	// silt 
								multiplier = pSedControls[j*nlandp*3+k*3+1];
							else if (rsd_param[rgroup*NumSed+ii].sedflg == 2)	// clay 
								multiplier = pSedControls[j*nlandp*3+k*3+2];
						}

						surfaceload *= multiplier;
						sedwssd2 *= multiplier;
						sedscrs2 *= multiplier;
						sedsuro2 *= multiplier;

						if(ncland == 2)
						{
							interload *= multiplier;
							groundload *= multiplier;
						}

						s_suro2 += fract*s_suro*multiplier;
						s_ifwo2 += interload;
						s_agwo2 += groundload;

						totsed[j*NumSed+ii] += surfaceload + interload + groundload;
						totsed_route[j*NumSed+ii] += (surfaceload*pLURoute[lgroup*nlandp+k].route_suro 
							+ interload*pLURoute[lgroup*nlandp+k].route_ifwo 
							+ groundload*pLURoute[lgroup*nlandp+k].route_agwo);
						totsed_bypass[j*NumSed+ii] += (surfaceload*pLURoute[lgroup*nlandp+k].bypass_suro 
							+ interload*pLURoute[lgroup*nlandp+k].bypass_ifwo 
							+ groundload*pLURoute[lgroup*nlandp+k].bypass_agwo);

//						fwssd += (fract * wssd_p[j*nlandp+k]*lfAREA * multiplier);	
						
						// (09/21/2011)
						if (rsd_param[rgroup*NumSed+ii].sedflg == 0 && fr_sand_bs[j*nlandp+k] > 0) // sand
							fwssd += fract/fr_sand_bs[j*nlandp+k]*fr_sand[j*nlandp+k]*fract * wssd_p[j*nlandp+k]*lfAREA * multiplier;
						else if (rsd_param[rgroup*NumSed+ii].sedflg == 1 && fr_silt_bs[j*nlandp+k] > 0) //silt
							fwssd += fract/fr_silt_bs[j*nlandp+k]*fr_silt[j*nlandp+k]*fract * wssd_p[j*nlandp+k]*lfAREA * multiplier;
						else if (rsd_param[rgroup*NumSed+ii].sedflg == 2 && fr_clay_bs[j*nlandp+k] > 0) //clay
							fwssd += fract/fr_clay_bs[j*nlandp+k]*fr_clay[j*nlandp+k]*fract * wssd_p[j*nlandp+k]*lfAREA * multiplier;
						
						fscrsd += (fract * scrs_p[j*nlandp+k]*lfAREA * multiplier);	
						
						totalload += surfaceload + interload + groundload;
						sedwssd += sedwssd2;
						sedscrs += sedscrs2;
						sedsuro += sedsuro2;
						sedifwo += interload;
						sedagwo += groundload;

//						totalsurfaceload += surfaceload;
						totalsurfaceload += fract * (wssd_p[j*nlandp+k] + scrs_p[j*nlandp+k] + f_suro[j*nlandp+k] * psd_param2[lgroup*nlandp+k].sed_suro * unit * GRAM_TO_TONS) * multiplier;
						s_suro3 += fract * multiplier * f_suro[j*nlandp+k] * psd_param2[lgroup*nlandp+k].sed_suro * unit * GRAM_TO_TONS;
					}
		
					// update after TMDL reduction
					s_suro = s_suro2;
					s_ifwo = s_ifwo2;
					s_agwo = s_agwo2;

					if (tCurrent >= toStart && tCurrent <= toEnd)
					{
						if (nLUsummary > 0)
						{
							sedload_s[j*nlandp+k] += totalload;
							sedwssd_s[j*nlandp+k] += sedwssd;
							sedscrs_s[j*nlandp+k] += sedscrs;
							sedsuro_s[j*nlandp+k] += sedsuro;
							sedifwo_s[j*nlandp+k] += sedifwo;
							sedagwo_s[j*nlandp+k] += sedagwo;
						}
						if (nSUSTAIN == 1)
						{
							sosed_sustain[j*nlandp+k] += totalsurfaceload;
							iosed_sustain[j] += sedifwo;
							aosed_sustain[j] += sedagwo;
						}
					}
				}

				if(pqalfg == 1)
				{
					int nOrder5 = j*nlandp*nQuals + k*nQuals;
	
					for(int m=0; m<nQuals; m++)	
					{
						//nQuals is the number of constituents being simulated
						int nOrder3 = lgroup*nQuals*nlandp + m*nlandp + k;
						double potfc = pQualInput[nOrder3].potfc;
						int potfcfg = pQual[lgroup*nQuals+m].potfcfg;
						
						double surfaceload = s_suro*potfc + f_suroqo[nOrder5+m]*lfAREA;
						double surfaceload2 = s_suro3*potfc + f_suroqo[nOrder5+m]; // for SUSTAIN timeseries
						double interload = f_ifoqual[nOrder5+m]*lfAREA;
						double groundload = f_aoqual[nOrder5+m]*lfAREA;

						if (potfcfg == 2) //apply to the total
						{
							interload += s_ifwo*potfc ;
							groundload += s_agwo*potfc;
						}

						//apply TMDL reduction
						if (pQualControls != NULL && ncland > 0)
						{
							surfaceload *= pQualControls[nOrder5+m];
							surfaceload2 *= pQualControls[nOrder5+m];

							if(ncland == 2)
							{
								interload   *= pQualControls[nOrder5+m];
								groundload  *= pQualControls[nOrder5+m];
							}
						}

						double load = surfaceload + interload + groundload;
						f_poqual[j*nQuals+m] += load;
						f_poqual_route[j*nQuals+m] += (surfaceload*pLURoute[lgroup*nlandp+k].route_suro 
							+ interload*pLURoute[lgroup*nlandp+k].route_ifwo 
							+ groundload*pLURoute[lgroup*nlandp+k].route_agwo);
						f_poqual_bypass[j*nQuals+m] += (surfaceload*pLURoute[lgroup*nlandp+k].bypass_suro 
							+ interload*pLURoute[lgroup*nlandp+k].bypass_ifwo 
							+ groundload*pLURoute[lgroup*nlandp+k].bypass_agwo);
						// sediment as gqual
						if (gqsdfg == 1 && sedfg == 1)
						{
							if (sed_mapp[lgroup*4].qualid == pQual[lgroup*nQuals+m].qualid)
							{
								for (int ii=0; ii<NumSed; ii++)
								{
									if (sandfg == 0 && rsd_param[rgroup*NumSed+ii].sedflg == 0)
										continue;

									if (pluinfop[j*nlandp+k].piid == 1)
									{
										qualsed[j*NumSed+ii] += surfaceload*sed_mapp[lgroup*4+0].sed[ii];
										qualsed_route[j*NumSed+ii] += surfaceload*sed_mapp[lgroup*4+0].sed[ii]*pLURoute[lgroup*nlandp+k].route_suro;
										qualsed_bypass[j*NumSed+ii] += surfaceload*sed_mapp[lgroup*4+0].sed[ii]*pLURoute[lgroup*nlandp+k].bypass_suro;
									}
									else if (pluinfop[j*nlandp+k].piid == 2)
									{
										qualsed[j*NumSed+ii] += surfaceload*sed_mapp[lgroup*4+1].sed[ii] + interload*sed_mapp[lgroup*4+2].sed[ii] + groundload*sed_mapp[lgroup*4+3].sed[ii];
										qualsed_route[j*NumSed+ii] += (surfaceload*sed_mapp[lgroup*4+1].sed[ii]*pLURoute[lgroup*nlandp+k].route_suro + interload*sed_mapp[lgroup*4+2].sed[ii]*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*sed_mapp[lgroup*4+3].sed[ii]*pLURoute[lgroup*nlandp+k].route_agwo);
										qualsed_bypass[j*NumSed+ii] += (surfaceload*sed_mapp[lgroup*4+1].sed[ii]*pLURoute[lgroup*nlandp+k].bypass_suro + interload*sed_mapp[lgroup*4+2].sed[ii]*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*sed_mapp[lgroup*4+3].sed[ii]*pLURoute[lgroup*nlandp+k].bypass_agwo);
									}
								}
							}
						}
						if (oxfg == 1)
						{
							if (pluinfop[j*nlandp+k].piid == 1)
							{
//								f_roqual[j*13+0] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].bod;
//								f_roqual[j*13+1] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].nox;
//								f_roqual[j*13+2] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].tam;
								for (int ii=0; ii<NumSed; ii++)
								{
									if (rsd_param[rgroup*NumSed+ii].sedflg == 0) //sand
									{
//										f_roqual[j*13+3] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].snh4*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+3] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+3] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
									}
									else if (rsd_param[rgroup*NumSed+ii].sedflg == 1) //silt
									{
//										f_roqual[j*13+4] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].snh4*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+4] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+4] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
									}
									else if (rsd_param[rgroup*NumSed+ii].sedflg == 2) //clay
									{
//										f_roqual[j*13+5] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].snh4*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+5] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+5] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
									}
								}
//								f_roqual[j*13+6] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].po4;
								for (ii=0; ii<NumSed; ii++)
								{
									if (rsd_param[rgroup*NumSed+ii].sedflg == 0) //sand
									{
//										f_roqual[j*13+7] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].spo4*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+7] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+7] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
									}
									else if (rsd_param[rgroup*NumSed+ii].sedflg == 1) //silt
									{
//										f_roqual[j*13+8] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].spo4*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+8] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+8] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
									}
									else if (rsd_param[rgroup*NumSed+ii].sedflg == 2) //clay
									{
//										f_roqual[j*13+9] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].spo4*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+9] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+9] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
									}
								}
//								f_roqual[j*13+10] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].orn;
//								f_roqual[j*13+11] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].orp;
//								f_roqual[j*13+12] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].orc;

								f_roqual_route[j*13+0] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].bod*pLURoute[lgroup*nlandp+k].route_suro;
								f_roqual_route[j*13+1] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].nox*pLURoute[lgroup*nlandp+k].route_suro;
								f_roqual_route[j*13+2] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].tam*pLURoute[lgroup*nlandp+k].route_suro;
								f_roqual_route[j*13+6] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].po4*pLURoute[lgroup*nlandp+k].route_suro;
								f_roqual_route[j*13+10] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].orn*pLURoute[lgroup*nlandp+k].route_suro;
								f_roqual_route[j*13+11] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].orp*pLURoute[lgroup*nlandp+k].route_suro;
								f_roqual_route[j*13+12] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].orc*pLURoute[lgroup*nlandp+k].route_suro;
								
								f_roqual_bypass[j*13+0] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].bod*pLURoute[lgroup*nlandp+k].bypass_suro;
								f_roqual_bypass[j*13+1] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].nox*pLURoute[lgroup*nlandp+k].bypass_suro;
								f_roqual_bypass[j*13+2] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].tam*pLURoute[lgroup*nlandp+k].bypass_suro;
								f_roqual_bypass[j*13+6] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].po4*pLURoute[lgroup*nlandp+k].bypass_suro;
								f_roqual_bypass[j*13+10] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].orn*pLURoute[lgroup*nlandp+k].bypass_suro;
								f_roqual_bypass[j*13+11] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].orp*pLURoute[lgroup*nlandp+k].bypass_suro;
								f_roqual_bypass[j*13+12] += surfaceload*land_mapp[rgroup*nQuals*4+m*4].orc*pLURoute[lgroup*nlandp+k].bypass_suro;
								
								// landuse summary
								if (tCurrent >= toStart && tCurrent <= toEnd && nLUsummary > 0)
								{
									rqload_s[j*nlandp*11+k*11+0] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+0].bod;
									rqload_s[j*nlandp*11+k*11+1] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+0].nox;
									rqload_s[j*nlandp*11+k*11+2] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+0].tam;
	 								rqload_s[j*nlandp*11+k*11+3] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+0].snh4;
									rqload_s[j*nlandp*11+k*11+4] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+0].po4;
	 								rqload_s[j*nlandp*11+k*11+5] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+0].spo4;
									rqload_s[j*nlandp*11+k*11+6] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+0].orn;
									rqload_s[j*nlandp*11+k*11+7] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+0].orp;
									rqload_s[j*nlandp*11+k*11+8] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+0].orc;
									if (m == 0)	// do not loop with quals
									{
										rqload_s[j*nlandp*11+k*11+9] += pdop[j*nlandp+k]*lfAREA/LBS_TO_GRAM;	// gm to lb
										rqload_s[j*nlandp*11+k*11+10] += pco2p[j*nlandp+k]*lfAREA/LBS_TO_GRAM;
									}
								}
							}
							else if (pluinfop[j*nlandp+k].piid == 2)
							{
//								f_roqual[j*13+0] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].bod + interload*land_mapp[rgroup*nQuals*4+m*4+2].bod + groundload*land_mapp[rgroup*nQuals*4+m*4+3].bod;
//								f_roqual[j*13+1] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].nox + interload*land_mapp[rgroup*nQuals*4+m*4+2].nox + groundload*land_mapp[rgroup*nQuals*4+m*4+3].nox;
//								f_roqual[j*13+2] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].tam + interload*land_mapp[rgroup*nQuals*4+m*4+2].tam + groundload*land_mapp[rgroup*nQuals*4+m*4+3].tam;
								for (int ii=0; ii<NumSed; ii++)
								{
									if (rsd_param[rgroup*NumSed+ii].sedflg == 0) //sand
									{
//										f_roqual[j*13+3] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+3] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4*pLURoute[lgroup*nlandp+k].route_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+3] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4*pLURoute[lgroup*nlandp+k].bypass_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
									}
									else if (rsd_param[rgroup*NumSed+ii].sedflg == 1) //silt
									{
//										f_roqual[j*13+4] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+4] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4*pLURoute[lgroup*nlandp+k].route_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+4] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4*pLURoute[lgroup*nlandp+k].bypass_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
									}
									else if (rsd_param[rgroup*NumSed+ii].sedflg == 2) //clay
									{
//										f_roqual[j*13+5] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+5] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4*pLURoute[lgroup*nlandp+k].route_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+5] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4*pLURoute[lgroup*nlandp+k].bypass_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
									}
								}
//								f_roqual[j*13+6] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].po4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].po4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].po4;
								for (ii=0; ii<NumSed; ii++)
								{
									if (rsd_param[rgroup*NumSed+ii].sedflg == 0) //sand
									{
//										f_roqual[j*13+7] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+7] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4*pLURoute[lgroup*nlandp+k].route_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+7] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4*pLURoute[lgroup*nlandp+k].bypass_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
									}
									else if (rsd_param[rgroup*NumSed+ii].sedflg == 1) //silt
									{
//										f_roqual[j*13+8] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+8] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4*pLURoute[lgroup*nlandp+k].route_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+8] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4*pLURoute[lgroup*nlandp+k].bypass_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
									}
									else if (rsd_param[rgroup*NumSed+ii].sedflg == 2) //clay
									{
//										f_roqual[j*13+9] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_route[j*13+9] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4*pLURoute[lgroup*nlandp+k].route_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
										f_roqual_bypass[j*13+9] += (surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4*pLURoute[lgroup*nlandp+k].bypass_agwo)*psd_param2[lgroup*nlandp+k].sed[ii];
									}
								}
//								f_roqual[j*13+10] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orn + interload*land_mapp[rgroup*nQuals*4+m*4+2].orn + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orn;
//								f_roqual[j*13+11] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orp + interload*land_mapp[rgroup*nQuals*4+m*4+2].orp + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orp;
//								f_roqual[j*13+12] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orc + interload*land_mapp[rgroup*nQuals*4+m*4+2].orc + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orc;
								
								f_roqual_route[j*13+0] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].bod*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].bod*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].bod*pLURoute[lgroup*nlandp+k].route_agwo;
								f_roqual_route[j*13+1] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].nox*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].nox*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].nox*pLURoute[lgroup*nlandp+k].route_agwo;
								f_roqual_route[j*13+2] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].tam*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].tam*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].tam*pLURoute[lgroup*nlandp+k].route_agwo;
								f_roqual_route[j*13+6] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].po4*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].po4*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].po4*pLURoute[lgroup*nlandp+k].route_agwo;
								f_roqual_route[j*13+10] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orn*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].orn*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orn*pLURoute[lgroup*nlandp+k].route_agwo;
								f_roqual_route[j*13+11] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orp*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].orp*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orp*pLURoute[lgroup*nlandp+k].route_agwo;
								f_roqual_route[j*13+12] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orc*pLURoute[lgroup*nlandp+k].route_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].orc*pLURoute[lgroup*nlandp+k].route_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orc*pLURoute[lgroup*nlandp+k].route_agwo;
								
								f_roqual_bypass[j*13+0] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].bod*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].bod*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].bod*pLURoute[lgroup*nlandp+k].bypass_agwo;
								f_roqual_bypass[j*13+1] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].nox*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].nox*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].nox*pLURoute[lgroup*nlandp+k].bypass_agwo;
								f_roqual_bypass[j*13+2] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].tam*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].tam*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].tam*pLURoute[lgroup*nlandp+k].bypass_agwo;
								f_roqual_bypass[j*13+6] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].po4*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].po4*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].po4*pLURoute[lgroup*nlandp+k].bypass_agwo;
								f_roqual_bypass[j*13+10] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orn*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].orn*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orn*pLURoute[lgroup*nlandp+k].bypass_agwo;
								f_roqual_bypass[j*13+11] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orp*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].orp*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orp*pLURoute[lgroup*nlandp+k].bypass_agwo;
								f_roqual_bypass[j*13+12] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orc*pLURoute[lgroup*nlandp+k].bypass_suro + interload*land_mapp[rgroup*nQuals*4+m*4+2].orc*pLURoute[lgroup*nlandp+k].bypass_ifwo + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orc*pLURoute[lgroup*nlandp+k].bypass_agwo;
								
								if (tCurrent >= toStart && tCurrent <= toEnd && nLUsummary > 0)		
								{
									rqload_s[j*nlandp*11+k*11+0] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].bod + interload*land_mapp[rgroup*nQuals*4+m*4+2].bod + groundload*land_mapp[rgroup*nQuals*4+m*4+3].bod;
									rqload_s[j*nlandp*11+k*11+1] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].nox + interload*land_mapp[rgroup*nQuals*4+m*4+2].nox + groundload*land_mapp[rgroup*nQuals*4+m*4+3].nox;
									rqload_s[j*nlandp*11+k*11+2] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].tam + interload*land_mapp[rgroup*nQuals*4+m*4+2].tam + groundload*land_mapp[rgroup*nQuals*4+m*4+3].tam;
									rqload_s[j*nlandp*11+k*11+3] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].snh4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].snh4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].snh4;
									rqload_s[j*nlandp*11+k*11+4] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].po4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].po4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].po4;
									rqload_s[j*nlandp*11+k*11+5] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].spo4 + interload*land_mapp[rgroup*nQuals*4+m*4+2].spo4 + groundload*land_mapp[rgroup*nQuals*4+m*4+3].spo4;
									rqload_s[j*nlandp*11+k*11+6] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orn + interload*land_mapp[rgroup*nQuals*4+m*4+2].orn + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orn;
									rqload_s[j*nlandp*11+k*11+7] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orp + interload*land_mapp[rgroup*nQuals*4+m*4+2].orp + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orp;
									rqload_s[j*nlandp*11+k*11+8] += surfaceload*land_mapp[rgroup*nQuals*4+m*4+1].orc + interload*land_mapp[rgroup*nQuals*4+m*4+2].orc + groundload*land_mapp[rgroup*nQuals*4+m*4+3].orc;
									if (m == 0)	// do not loop with quals
									{
										rqload_s[j*nlandp*11+k*11+9] += pdop[j*nlandp+k]*lfAREA/LBS_TO_GRAM;	// gm to lb
										rqload_s[j*nlandp*11+k*11+10] += pco2p[j*nlandp+k]*lfAREA/LBS_TO_GRAM;
									}
								}
							}
						}
						f_soqual[nQuals*j+m] += f_suroqo[nOrder5+m]*lfAREA;     
						f_ioqual[nQuals*j+m] += f_ifoqual[nOrder5+m]*lfAREA;    
						f_goqual[nQuals*j+m] += f_aoqual[nOrder5+m]*lfAREA;     
						if (tCurrent >= toStart && tCurrent <= toEnd)
						{
							if (nLUsummary > 0)
							{
								suroload_s[nOrder5+m] += surfaceload;
								ifwoload_s[nOrder5+m] += interload;
								agwoload_s[nOrder5+m] += groundload;
								uniload_s[nOrder5+m] += load;
							}
							if (nSUSTAIN == 1)
							{
								soqual_sustain[nOrder5+m] += surfaceload2;
								ioqual_sustain[j*nQuals+m] += interload;
								aoqual_sustain[j*nQuals+m] += groundload;
							}
						}

						int qsdfg = pQual[lgroup*nQuals+m].qsdfg;
						if (qsdfg > 0 && sedfg == 1)
						{
							// get load from sediment 
							load = soqs_p[nOrder5+m]*lfAREA; 
							double washqsload = washqs_p[nOrder5+m]*lfAREA;
							double scrqsload = scrqs_p[nOrder5+m]*lfAREA;
							double load2 = soqs_p[nOrder5+m]; // for SUSTAIN timeseries
							// sediment as gqual
							if (gqsdfg == 1 && sedfg == 1)
 							{
 								if (sed_mapp[lgroup*4].qualid == pQual[lgroup*nQuals+m].qualid)
 								{
 									for (int ii=0; ii<NumSed; ii++)
 									{
										if (sandfg == 0 && rsd_param[rgroup*NumSed+ii].sedflg == 0)
											continue;

 										if (pluinfop[j*nlandp+k].piid == 1)
										{
 											qualsed[j*NumSed+ii] += load*sed_mapp[lgroup*4+0].sed[ii];
 											qualsed_route[j*NumSed+ii] += load*sed_mapp[lgroup*4+0].sed[ii]*pLURoute[lgroup*nlandp+k].route_suro;
 											qualsed_bypass[j*NumSed+ii] += load*sed_mapp[lgroup*4+0].sed[ii]*pLURoute[lgroup*nlandp+k].bypass_suro;
										}
 										else if (pluinfop[j*nlandp+k].piid == 2)
										{
 											qualsed[j*NumSed+ii] += load*sed_mapp[lgroup*4+1].sed[ii];
 											qualsed_route[j*NumSed+ii] += load*sed_mapp[lgroup*4+1].sed[ii]*pLURoute[lgroup*nlandp+k].route_suro;
 											qualsed_bypass[j*NumSed+ii] += load*sed_mapp[lgroup*4+1].sed[ii]*pLURoute[lgroup*nlandp+k].bypass_suro;
										}
 									}
 								}
 							}

							if (pQualControls != NULL && ncland > 0)
							{
								load *= pQualControls[nOrder5+m];
								load2 *= pQualControls[nOrder5+m];
								washqsload *= pQualControls[nOrder5+m];
								scrqsload *= pQualControls[nOrder5+m];
							}

							if (tCurrent >= toStart && tCurrent <= toEnd)
							{
								if (nLUsummary > 0)
								{
									suroload_s[nOrder5+m] += load;
									uniload_s[nOrder5+m] += load;
									suniload_s[nOrder5+m] += load;
									washqsload_s[nOrder5+m] += washqsload;
									scrqsload_s[nOrder5+m] += scrqsload;
								}
								if (nSUSTAIN == 1)
								{
									soqual_sustain[nOrder5+m] += load2;
								}
							}
							f_poqual[nQuals*j+m] += load;
							f_poqual_route[nQuals*j+m] += load*pLURoute[lgroup*nlandp+k].route_suro;
							f_poqual_bypass[nQuals*j+m] += load*pLURoute[lgroup*nlandp+k].bypass_suro;
							f_posqual[nQuals*j+m]+= load;
							f_posqual_route[nQuals*j+m]+= load*pLURoute[lgroup*nlandp+k].route_suro;
							f_posqual_bypass[nQuals*j+m]+= load*pLURoute[lgroup*nlandp+k].bypass_suro;
							
							if (oxfg == 1)
							{
								if (pluinfop[j*nlandp+k].piid == 1)
								{
//									f_roqual[j*13+0] += load*land_mapp[rgroup*nQuals*4+m*4].bod;
//									f_roqual[j*13+1] += load*land_mapp[rgroup*nQuals*4+m*4].nox;
//									f_roqual[j*13+2] += load*land_mapp[rgroup*nQuals*4+m*4].tam;
									for (int ii=0; ii<NumSed; ii++)
									{
										if (rsd_param[rgroup*NumSed+ii].sedflg == 0) //sand
										{
//											f_roqual[j*13+3] += load*land_mapp[rgroup*nQuals*4+m*4].snh4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+3] += load*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+3] += load*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
										else if (rsd_param[rgroup*NumSed+ii].sedflg == 1) //silt
										{
//											f_roqual[j*13+4] += load*land_mapp[rgroup*nQuals*4+m*4].snh4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+4] += load*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+4] += load*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
										else if (rsd_param[rgroup*NumSed+ii].sedflg == 2) //clay
										{
//											f_roqual[j*13+5] += load*land_mapp[rgroup*nQuals*4+m*4].snh4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+5] += load*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+5] += load*land_mapp[rgroup*nQuals*4+m*4].snh4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
									}
//									f_roqual[j*13+6] += load*land_mapp[rgroup*nQuals*4+m*4].po4;
									for (ii=0; ii<NumSed; ii++)
									{
										if (rsd_param[rgroup*NumSed+ii].sedflg == 0) //sand
										{
//											f_roqual[j*13+7] += load*land_mapp[rgroup*nQuals*4+m*4].spo4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+7] += load*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+7] += load*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
										else if (rsd_param[rgroup*NumSed+ii].sedflg == 1) //silt
										{
//											f_roqual[j*13+8] += load*land_mapp[rgroup*nQuals*4+m*4].spo4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+8] += load*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+8] += load*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
										else if (rsd_param[rgroup*NumSed+ii].sedflg == 2) //clay
										{
//											f_roqual[j*13+9] += load*land_mapp[rgroup*nQuals*4+m*4].spo4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+9] += load*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+9] += load*land_mapp[rgroup*nQuals*4+m*4].spo4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
									}
//									f_roqual[j*13+10] += load*land_mapp[rgroup*nQuals*4+m*4].orn;
//									f_roqual[j*13+11] += load*land_mapp[rgroup*nQuals*4+m*4].orp;
//									f_roqual[j*13+12] += load*land_mapp[rgroup*nQuals*4+m*4].orc;
									
									f_roqual_route[j*13+0] += load*land_mapp[rgroup*nQuals*4+m*4].bod*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+1] += load*land_mapp[rgroup*nQuals*4+m*4].nox*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+2] += load*land_mapp[rgroup*nQuals*4+m*4].tam*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+6] += load*land_mapp[rgroup*nQuals*4+m*4].po4*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+10] += load*land_mapp[rgroup*nQuals*4+m*4].orn*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+11] += load*land_mapp[rgroup*nQuals*4+m*4].orp*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+12] += load*land_mapp[rgroup*nQuals*4+m*4].orc*pLURoute[lgroup*nlandp+k].route_suro;
									
									f_roqual_bypass[j*13+0] += load*land_mapp[rgroup*nQuals*4+m*4].bod*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+1] += load*land_mapp[rgroup*nQuals*4+m*4].nox*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+2] += load*land_mapp[rgroup*nQuals*4+m*4].tam*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+6] += load*land_mapp[rgroup*nQuals*4+m*4].po4*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+10] += load*land_mapp[rgroup*nQuals*4+m*4].orn*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+11] += load*land_mapp[rgroup*nQuals*4+m*4].orp*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+12] += load*land_mapp[rgroup*nQuals*4+m*4].orc*pLURoute[lgroup*nlandp+k].bypass_suro;
									
									if (tCurrent >= toStart && tCurrent <= toEnd && nLUsummary > 0)
									{
										rqload_s[j*nlandp*11+k*11+0] += load*land_mapp[rgroup*nQuals*4+m*4].bod;
										rqload_s[j*nlandp*11+k*11+1] += load*land_mapp[rgroup*nQuals*4+m*4].nox;
										rqload_s[j*nlandp*11+k*11+2] += load*land_mapp[rgroup*nQuals*4+m*4].tam;
										rqload_s[j*nlandp*11+k*11+3] += load*land_mapp[rgroup*nQuals*4+m*4].snh4;
										rqload_s[j*nlandp*11+k*11+4] += load*land_mapp[rgroup*nQuals*4+m*4].po4;
										rqload_s[j*nlandp*11+k*11+5] += load*land_mapp[rgroup*nQuals*4+m*4].spo4;
										rqload_s[j*nlandp*11+k*11+6] += load*land_mapp[rgroup*nQuals*4+m*4].orn;
										rqload_s[j*nlandp*11+k*11+7] += load*land_mapp[rgroup*nQuals*4+m*4].orp;
										rqload_s[j*nlandp*11+k*11+8] += load*land_mapp[rgroup*nQuals*4+m*4].orc;
									}
								}
								else if (pluinfop[j*nlandp+k].piid == 2)
								{
//									f_roqual[j*13+0] += load*land_mapp[rgroup*nQuals*4+m*4+1].bod;
//									f_roqual[j*13+1] += load*land_mapp[rgroup*nQuals*4+m*4+1].nox;
//									f_roqual[j*13+2] += load*land_mapp[rgroup*nQuals*4+m*4+1].tam;
									for (int ii=0; ii<NumSed; ii++)
									{
										if (rsd_param[rgroup*NumSed+ii].sedflg == 0) //sand
										{
//											f_roqual[j*13+3] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+3] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+3] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
										else if (rsd_param[rgroup*NumSed+ii].sedflg == 1) //silt
										{
//											f_roqual[j*13+4] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+4] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+4] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
										else if (rsd_param[rgroup*NumSed+ii].sedflg == 2) //clay
										{
//											f_roqual[j*13+5] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+5] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+5] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
									}
//									f_roqual[j*13+6] += load*land_mapp[rgroup*nQuals*4+m*4+1].po4;
									for (ii=0; ii<NumSed; ii++)
									{
										if (rsd_param[rgroup*NumSed+ii].sedflg == 0) //sand
										{
//											f_roqual[j*13+7] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+7] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+7] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
										else if (rsd_param[rgroup*NumSed+ii].sedflg == 1) //silt
										{
//											f_roqual[j*13+8] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+8] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+8] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
										else if (rsd_param[rgroup*NumSed+ii].sedflg == 2) //clay
										{
//											f_roqual[j*13+9] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_route[j*13+9] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].route_suro*psd_param2[lgroup*nlandp+k].sed[ii];
											f_roqual_bypass[j*13+9] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4*pLURoute[lgroup*nlandp+k].bypass_suro*psd_param2[lgroup*nlandp+k].sed[ii];
										}
									}
//									f_roqual[j*13+10] += load*land_mapp[rgroup*nQuals*4+m*4+1].orn;
//									f_roqual[j*13+11] += load*land_mapp[rgroup*nQuals*4+m*4+1].orp;
//									f_roqual[j*13+12] += load*land_mapp[rgroup*nQuals*4+m*4+1].orc;
									
									f_roqual_route[j*13+0] += load*land_mapp[rgroup*nQuals*4+m*4+1].bod*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+1] += load*land_mapp[rgroup*nQuals*4+m*4+1].nox*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+2] += load*land_mapp[rgroup*nQuals*4+m*4+1].tam*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+6] += load*land_mapp[rgroup*nQuals*4+m*4+1].po4*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+10] += load*land_mapp[rgroup*nQuals*4+m*4+1].orn*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+11] += load*land_mapp[rgroup*nQuals*4+m*4+1].orp*pLURoute[lgroup*nlandp+k].route_suro;
									f_roqual_route[j*13+12] += load*land_mapp[rgroup*nQuals*4+m*4+1].orc*pLURoute[lgroup*nlandp+k].route_suro;
									
									f_roqual_bypass[j*13+0] += load*land_mapp[rgroup*nQuals*4+m*4+1].bod*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+1] += load*land_mapp[rgroup*nQuals*4+m*4+1].nox*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+2] += load*land_mapp[rgroup*nQuals*4+m*4+1].tam*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+6] += load*land_mapp[rgroup*nQuals*4+m*4+1].po4*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+10] += load*land_mapp[rgroup*nQuals*4+m*4+1].orn*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+11] += load*land_mapp[rgroup*nQuals*4+m*4+1].orp*pLURoute[lgroup*nlandp+k].bypass_suro;
									f_roqual_bypass[j*13+12] += load*land_mapp[rgroup*nQuals*4+m*4+1].orc*pLURoute[lgroup*nlandp+k].bypass_suro;
									
									if (tCurrent >= toStart && tCurrent <= toEnd && nLUsummary > 0)
									{
										rqload_s[j*nlandp*11+k*11+0] += load*land_mapp[rgroup*nQuals*4+m*4+1].bod;
										rqload_s[j*nlandp*11+k*11+1] += load*land_mapp[rgroup*nQuals*4+m*4+1].nox;
										rqload_s[j*nlandp*11+k*11+2] += load*land_mapp[rgroup*nQuals*4+m*4+1].tam;
										rqload_s[j*nlandp*11+k*11+3] += load*land_mapp[rgroup*nQuals*4+m*4+1].snh4;
										rqload_s[j*nlandp*11+k*11+4] += load*land_mapp[rgroup*nQuals*4+m*4+1].po4;
										rqload_s[j*nlandp*11+k*11+5] += load*land_mapp[rgroup*nQuals*4+m*4+1].spo4;
										rqload_s[j*nlandp*11+k*11+6] += load*land_mapp[rgroup*nQuals*4+m*4+1].orn;
										rqload_s[j*nlandp*11+k*11+7] += load*land_mapp[rgroup*nQuals*4+m*4+1].orp;
										rqload_s[j*nlandp*11+k*11+8] += load*land_mapp[rgroup*nQuals*4+m*4+1].orc;
									}
								}
							}
						}

						fsqo_s[nQuals*j+m]    += sqo_s[nOrder5+m]*lfAREA;
						fwashqs_s[nQuals*j+m] += washqs_s[nOrder5+m]*lfAREA;
						fscrqs_s[nQuals*j+m]  += scrqs_s[nOrder5+m]*lfAREA;
						fsoqo_s[nQuals*j+m]   += soqo_s[nOrder5+m]*lfAREA;
					}
				}
				
				if(tempfg == 1)
				{
//					soiltm[j] += soilts[j*nlandp+k]*f_suro[j*nlandp+k]*lfAREA;	//degree C * inch * acre
//					soiltm[j] += soiltu[j*nlandp+k]*f_ifwo[j*nlandp+k]*lfAREA;	//degree C * inch * acre
//					soiltm[j] += soiltl[j*nlandp+k]*f_agwo[j*nlandp+k]*lfAREA;	//degree C * inch * acre
					soiltm_route[j] += (soilts[j*nlandp+k]*f_suro[j*nlandp+k]*pLURoute[lgroup*nlandp+k].route_suro+
										 soiltu[j*nlandp+k]*f_ifwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].route_ifwo+
										 soiltl[j*nlandp+k]*f_agwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].route_agwo)
										 *lfAREA;
					soiltm_bypass[j] += (soilts[j*nlandp+k]*f_suro[j*nlandp+k]*pLURoute[lgroup*nlandp+k].bypass_suro+
										 soiltu[j*nlandp+k]*f_ifwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].bypass_ifwo+
										 soiltl[j*nlandp+k]*f_agwo[j*nlandp+k]*pLURoute[lgroup*nlandp+k].bypass_agwo)
										 *lfAREA;
				}

				if(oxfg == 1)	// adding for each landuse (g)
				{
//					pdox[j] += pdop[j*nlandp+k]*lfAREA;	  
					pdox_route[j] += pdop_route[j*nlandp+k]*lfAREA;	  
					pdox_bypass[j] += pdop_bypass[j*nlandp+k]*lfAREA;	  
//					pco2[j] += pco2p[j*nlandp+k]*lfAREA;	  
					pco2_route[j] += pco2p_route[j*nlandp+k]*lfAREA;	  
					pco2_bypass[j] += pco2p_bypass[j*nlandp+k]*lfAREA;	  
				}
			}

			fSum[j]		+= fsuro + fifwo + fagwo;
			fgwo[j]		+= fagwo;
			cepe_s[j]   += fcepe;				
			uzet_s[j]   += fuzet;				
			baset_s[j]  += fbaset;				
			lzet_s[j]   += flzet;				
			agwet_s[j]  += fagwet;				
			perc_s[j]   += fperc;				
			infil_s[j]  += finfil;				
			gwi_s[j]    += fgwi;				
			igwi_s[j]   += figwi;				
			agwi_s[j]   += fagwi;				
			prec_s[j]	+= fprec;					

			// baseflow timeseries for SUSTAIN
			if (tCurrent >= toStart && tCurrent <= toEnd)
			{
				// land unit-area output for SUSTAIN model
				if(nSUSTAIN == 1) // && lfAREA > 0)
				{
					ifwo_sustain[j] += fifwo;		
					agwo_sustain[j] += fagwo;		
				}
			}

			if (snowfg == 1)
			{
				if (airtmp_min[j] == -999)	//first entry
					airtmp_min[j] = airtmp_p[j];
				else if (airtmp_min[j] > airtmp_p[j])
					airtmp_min[j] = airtmp_p[j];

				if (airtmp_max[j] == -999)	//first entry
					airtmp_max[j] = airtmp_p[j];
				else if (airtmp_max[j] < airtmp_p[j])
					airtmp_max[j] = airtmp_p[j];
				airtmp_s[j]   += airtmp_p[j];			
				snotmp_s[j]   += snotmp_p[j];			
				snowf_s[j]    += fsnowf;				
				rainf_s[j]    += frainf;				
				prain_s[j]    += fprain;				
				melt_s[j]     += fmelt;					
				snowe_s[j]    += fsnowe;				
				wyield_s[j]   += fwyield;				
//				wyield_sws[j] = fwyield;				
				pack_s[j]	  += fpack;					
				packf_s[j]	  += fpackf;				
				packw_s[j]	  += fpackw;				
				packi_s[j]	  += fpacki;				
				pdepth_s[j]   += fpdepth;				
//				pdepth_sws[j] = fpack_sws;				
				covindx_s[j]  += fcovindx;				
				neghts_s[j]	  += fneghts;				
				xlnmelt_s[j]  += fxlnmelt;				
				rdenpkf_s[j]  += frdenpkf/nlandp;		
				skyclear_s[j] += fskyclear/nlandp;		
				snocov_s[j]   += fsnocov/nlandp;		
				dullness_s[j] += fdullness/nlandp;		
				albedo_s[j]	  += falbedo/nlandp;		
				paktemp_s[j]  += fpaktemp/nlandp;		
				dewtmp_s[j]   += fdewtmp/nlandp;		
			}
													
			fsuro_s[j]  += fsuro;
			fifwo_s[j]  += fifwo;
			fagwo_s[j]  += fagwo;
			fsurs_s[j]  += fsurs;
			fuzs_s[j]   += fuzs;
			flzs_s[j]   += flzs;
			fagws_s[j]  += fagws;
			ftaet_s[j]  += ftaet;
			fwssd_s[j]  += fwssd;
			fscrsd_s[j] += fscrsd;
			fSum_s[j]   += fSum[j];
			for (k=0; k<NumSed; k++)
			{
				sosed_s[j] += totsed[j*NumSed+k];
			}
			for(int m=0; m<nQuals; m++)		
			{
				poqual_s[nQuals*j+m] += f_poqual[nQuals*j+m];
				soqual_s[nQuals*j+m] += f_soqual[nQuals*j+m];          
				ioqual_s[nQuals*j+m] += f_ioqual[nQuals*j+m];          
				goqual_s[nQuals*j+m] += f_goqual[nQuals*j+m];          
			}

			// save results to the corresponding files
			// Calculate CO2 from land. The following portion can be writen a subroutin.
		}
		// initialize
		for(j=0; j<nsws*nlandp; j++)
		{
			f_suro[j]	= 0.0;
			f_ifwo[j]	= 0.0;
			f_agwo[j]	= 0.0;
			f_prec[j]	= 0.0;		
			f_snowf[j]	= 0.0;		
			f_rainf[j]	= 0.0;		
			f_prain[j]	= 0.0;		
			f_melt[j]	= 0.0;		
			f_snowe[j]	= 0.0;		
			f_wyield[j]	= 0.0;		
			f_cepe[j]	= 0.0;      
			f_uzet[j]	= 0.0;      
			f_baset[j]	= 0.0;      
			f_lzet[j]	= 0.0;      
			f_agwet[j]	= 0.0;      
			f_perc[j]	= 0.0;      
			f_infil[j]	= 0.0;      
			f_gwi[j]	= 0.0;      
			f_igwi[j]	= 0.0;      
			f_agwi[j]	= 0.0;      
		}
	
		//**********************BEGIN TRANSPORTATION********************

		int mon    = tCurrent.GetMonth() - 1;
		int nxtmon = mon + 1;
		if(nxtmon >= 12)
			nxtmon = 0;

		int ndays;
		if(mon == 0 || mon == 2 || mon == 4 || mon == 6 || mon == 7 || mon == 9 || mon == 11)
			ndays = 31;
		if(mon == 3 || mon == 5 || mon == 8 || mon == 10)
			ndays = 30;

		int nYear = tCurrent.GetYear();
		if(mon == 1)
		{
			if(nYear%400 == 0)
				ndays = 29;
			else if(nYear%100 == 0)
				ndays = 28;
			else if(nYear%4 == 0)
				ndays = 29;
			else
				ndays = 28;
		}
		int day = tCurrent.GetDay();
		int hour16 = tCurrent.GetHour();

		for(int m=0; m<nch; m++)
		{
			double qlink = 0.0;
			double qup = 0.0;
			double qup_bypass = 0.0;
			double qland = 0.0;
			double qland_bypass = 0.0;
			double pt = 0.0;
			double ptwd_target = 0.0;
			double irrwithdrawal = 0.0;
			double ptwithdrawal = 0.0;
			double qin = 0.0;

			// find the stream index
			int nIndex = stream[m].index;

			// stream-based group
			int rgroup = pReachInfo[nIndex].rgid - 1;  
			int lgroup = pswsinfo[nIndex].gindex;
			int trgp = pReachInfo[nIndex].trgid - 1;  

			// stream parameters
			double slope = pReachInfo[nIndex].slope;

			//calculate the pressure correction factor for conductive-
			//convective heat transport
			double cfpres = 1;
			if (tempfg > 0)
			{
				double elev = ptmp_param1[nIndex].relev;	//ft
				cfpres = pow(((288.0- 0.001981*elev)/288.0), 5.256);
			}

			// update the previous value
			v1[nIndex] = v2[nIndex];
			q1[nIndex] = q2[nIndex];
			double dep1 = qh[nIndex];

			// withdraw water from the reach for the irrigation purpose (cfs)
			if (irrigfg == 1)
			{
				double vbip = __max(v1[nIndex]-v_bip[nIndex],0.0);
				irrwithdrawal = GetIrrWD(nIndex, delts, vbip, tCurrent);
			}

			// check withdrawal with available water in reach
			if (irrwithdrawal*delts > v1[nIndex])
				irrwithdrawal = v1[nIndex]/delts;

			// remove negative point source - cfs (08-30-05)
			ptwithdrawal = - GetWithdrawal(nIndex, tCurrent);	// withdrawal is -ve value	
			
			// check withdrawal with available water in reach
			if (ptwithdrawal*delts > (v1[nIndex]-irrwithdrawal*delts))
				ptwithdrawal = (v1[nIndex]-irrwithdrawal*delts)/delts;

			// get point source inflow
			pt = GetFlow(nIndex, tCurrent);	// cfs

			// get the point source withdrawal if targeted to this stream
			if(pPSReduction != NULL && pPtWithDrawal != NULL)
			{
				for (int mm=0; mm<nPtWithDrawal; ++mm)
				{
					int nPSIndex = -1;
					if (pChannelInfo[nIndex].rchid == pPtWithDrawal[mm].targetrchid)
						nPSIndex = GetPSIndex(pPtWithDrawal[mm].wdrawlrchid,pPtWithDrawal[mm].strPermit,pPtWithDrawal[mm].strPipe);

					if (nPSIndex <0)
						continue;

					double wd_vol = - GetTargetWithDrawal(nPSIndex, tCurrent) * delts;	// ft3
					int nRIndex = FindReachIndex(pPtWithDrawal[mm].wdrawlrchid);

					if (wd_vol > v2[nRIndex])
						wd_vol = v2[nRIndex];

					ptwd_target += wd_vol / delts;	// cfs
				}
			}
		
			// upstream routed and bypassed water 
			int nNum = pChannelInfo[nIndex].cListUppersOrder.GetSize();
			for(j=0; j<nNum; j++)
			{
				int nUpperReach = pChannelInfo[nIndex].cListUppersOrder.GetAt(j);
				if(nUpperReach < 0 || nUpperReach >= nsws)
				{
					AfxMessageBox("Wrong NETWORK");
					goto L001;
				}
				else																	 
				{
					for (k=0; k<pChannelInfo[nUpperReach].nDSchan; k++)
					{
						if (pChannelInfo[nIndex].rchid == pChannelInfo[nUpperReach].down_ch[k])
						{
							qup += pChannelInfo[nUpperReach].down_flow[k];
							qup_bypass += pChannelInfo[nUpperReach].bypass_flow[k];
						}
					}
				}
			}

			// get total flow from land (cfs)
			//qland = fSum[pChannelInfo[nIndex].nIndexSWS]*3630/delts; 
//			qland = fSum[nIndex]*IN_ACRE_TO_FT3/delts; 
			qland = froute[nIndex]*IN_ACRE_TO_FT3/delts;		// cfs

			// bypass flow to downstream channel(s)
			qland_bypass = fbypass[nIndex]*IN_ACRE_TO_FT3/delts;		// cfs
			for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
				pChannelInfo[nIndex].bypass_flow[j] = qland_bypass * pReachFtable[nIndex].bypass_fr[j];

//			qland -= qland_bypass;

			// linkage files
			if (nLinkFiles > 0)
			{
				if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
				{
					POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
					while (pos != NULL)
					{
						Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
						qlink += plink435.pLinkData[i].flow; //cfs
					}
				}
			}

			// total inflow (cfs)
			qin = qup + qup_bypass + qland + pt + ptwd_target + qlink;	

			// for stream summary
			if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
			{
				usif_s[nIndex] += qup * delts;					// ft3
				luif_s[nIndex] += qland * delts;				// ft3
				usifbp_s[nIndex] += qup_bypass * delts;			// ft3
				luifbp_s[nIndex] += qland_bypass * delts;		// ft3
				if (nPtSource > 0)
				{
					psif_s[nIndex] += pt * delts;				// ft3
					pswd_s[nIndex] += ptwithdrawal * delts;		// ft3
					pswddi_s[nIndex] += ptwd_target * delts;	// ft3
				}
				if (irrigfg == 1)
					irwd_s[nIndex] += irrwithdrawal * delts;	// ft3

				ivol_s[nIndex] += qin * delts;					// ft3
			}

			int nf = fnt;
			int st = 0;
			double evapvol = 0.0;
			double convf = 1.0;
			double *convfm = NULL;
			if(pMONTH_COV != NULL)
				convfm = pMONTH_COV[rgroup].fnum;

			//calculate volume of water in system (ft3)
			double volt = v1[nIndex] + (qin - irrwithdrawal - ptwithdrawal) * delts;
			
			volt = max(volt, 0); //avoid negative volume

			// account for precipitation and evaporation
			if (kc > 0)
				evapvol = SA[nIndex] * (pet_p[nIndex]/kc - prec_p[nIndex])/12;	// ft3
			
			if (evapvol > volt)
				evapvol = volt;

			volt -= evapvol;	// ft3

			double VOLT = volt*FT3_TO_M3;	// m3
			double KS = pReachInfo[nIndex].ks;

			if (KS > 0)	//hspf
			{
				int nFTindex = 0;
 				double COKS = 1.0 - KS;
 				double FACTA1 = 0.0;
				if ((COKS*delts) > 0)
					FACTA1 = 1.0 / (COKS*delts);

				double LEN = pReachInfo[nIndex].length * MILE_TO_FEET;	// ft

				if (pReachFtable[nIndex].nFTrecord > 0)	// user defined FTABLE
				{
					if (pReachFtable[nIndex].nFTrecord == 1)
					{
						// no routing 
						q2[nIndex] = volt/delts;	//(outflow = inflow)

						// special case (01-21-2013)
//						if (!ApplyStreamIceMelt(nIndex,temp2[nIndex],wyield_sws[nIndex],pdepth_sws[nIndex],q2,q2_frozen))
//							goto L001;

						v2[nIndex] = 0.0;
						qh[nIndex] = 0.0;
						SA[nIndex] = 0.0;
						XA[nIndex] = 0.0;
						HR[nIndex] = 0.0;

						for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
							pChannelInfo[nIndex].down_flow[j] = q2[nIndex] * pReachFtable[nIndex].bypass_fr[j];
					}
					else
					{
						int nRet = ROUTE(nIndex,dayfg,vconfg,convfm,delts,KS,COKS,q1[nIndex], 
							volt,FACTA1,mon,nxtmon,day,ndays,convf,&nFTindex,&v2[nIndex],&q2[nIndex]);
						
						// special case (01-21-2013)
//						if (!ApplyStreamIceMelt(nIndex,temp2[nIndex],wyield_sws[nIndex],pdepth_sws[nIndex],q2,q2_frozen))
//							goto L001;

						if(nRet == 2)	
							goto L001;

						//compute depth, surface area, cross-sectional area and hydraulic radius
 						nRet = AUXIL(nFTindex, v2[nIndex], LEN, &qh[nIndex], &SA[nIndex], &XA[nIndex], 
							  &HR[nIndex]);
						
						if(nRet == 2)	
							goto L001;
					}
				}
				else if (pReachInfo[nIndex].lkfg != 0)	// lake
				{
					if (pReachInfo[nIndex].routefg == 0)
					{
						// no routing 
						q2[nIndex] = volt/delts;	//(outflow = inflow)

						// special case (01-21-2013)
//						if (!ApplyStreamIceMelt(nIndex,temp2[nIndex],wyield_sws[nIndex],pdepth_sws[nIndex],q2,q2_frozen))
//							goto L001;

						v2[nIndex] = 0.0;
						qh[nIndex] = 0.0;
						SA[nIndex] = 0.0;
						XA[nIndex] = 0.0;
						HR[nIndex] = 0.0;

						pChannelInfo[nIndex].down_flow[0] = q2[nIndex];
					}
					else
					{
						routinelake(nIndex,qin,ptwithdrawal,irrwithdrawal,delt60,
								prec_p[nIndex],pet_p[nIndex],v1[nIndex],v2[nIndex],
								q2[nIndex],qh[nIndex]);

						// special case (01-21-2013)
//						if (!ApplyStreamIceMelt(nIndex,temp2[nIndex],wyield_sws[nIndex],pdepth_sws[nIndex],q2,q2_frozen))
//							goto L001;

						SA[nIndex] = pReachInfo[nIndex].length * MILE_TO_FEET * pReachInfo[nIndex].width;		// ft2
						if (pReachInfo[nIndex].length > 0)
							XA[nIndex] = v2[nIndex] / (pReachInfo[nIndex].length*MILE_TO_FEET);	// ft2	
						double avdepth = 0.0;
						if (SA[nIndex] > 0)
							avdepth = v2[nIndex] / SA[nIndex];											// ft
						double topwidth = 0.0;
						if (pReachInfo[nIndex].length > 0)
							topwidth = SA[nIndex] / (pReachInfo[nIndex].length * MILE_TO_FEET);				// ft
						if (avdepth > 0 || topwidth > 0)
							HR[nIndex] = (topwidth * avdepth) / (2.0 * avdepth + topwidth);				// ft
					}
				}
				else	// internal FTABLE
				{
					if (pReachInfo[nIndex].routefg == 0)
					{
						// no routing 
						q2[nIndex] = volt/delts;	//(outflow = inflow)

						// special case (01-21-2013)
//						if (!ApplyStreamIceMelt(nIndex,temp2[nIndex],wyield_sws[nIndex],pdepth_sws[nIndex],q2,q2_frozen))
//							goto L001;

						v2[nIndex] = 0.0;
						qh[nIndex] = 0.0;
						SA[nIndex] = 0.0;
						XA[nIndex] = 0.0;
						HR[nIndex] = 0.0;

						pChannelInfo[nIndex].down_flow[0] = q2[nIndex];
					}
					else
					{
						route(nf, nIndex, volt, dayfg, vconfg, convfm, mon, nxtmon, day, ndays, 
							convf, delts, &st, &fq[nIndex*fnt], &fh[nIndex*fnt], &fv[nIndex*fnt], 
							&fa[nIndex*fnt], &fr[nIndex*fnt], &fsa[nIndex*fnt], &qh[nIndex], 
							&XA[nIndex], &HR[nIndex], &SA[nIndex], &v2[nIndex], &q2[nIndex]);
						
						// special case (01-21-2013)
//						if (!ApplyStreamIceMelt(nIndex,temp2[nIndex],wyield_sws[nIndex],pdepth_sws[nIndex],q2,q2_frozen))
//							goto L001;

						if (st < 0)
						{
							CString strError;
							strError.Format("Check channel %d", pChannelInfo[nIndex].rchid);
							AfxMessageBox(strError);
							Log(strError);
							goto L001;
						}
					}
				}
			}
			else
			{
				int routemethod = 1;
L111:
				int route = routine(volt, dayfg, vconfg, convfm, mon, nxtmon, day, ndays,
					convf,delts, &fq[nIndex*fnt], &fh[nIndex*fnt],&fv[nIndex*fnt], 
					&fa[nIndex*fnt], &fr[nIndex*fnt], &fsa[nIndex*fnt],&XA[nIndex], 
					&HR[nIndex], &SA[nIndex], &q1[nIndex], &q2[nIndex],&v1[nIndex], 
					&v2[nIndex], &qh[nIndex], &qk[nIndex*fnt], &st, &nf,&nIndex, 
					routemethod);

				if (route == 1)	// lake
				{
					if (pReachInfo[nIndex].routefg == 0)
					{
						// no routing 
						q2[nIndex] = volt/delts;	//(outflow = inflow)

						// special case (01-21-2013)
//						if (!ApplyStreamIceMelt(nIndex,temp2[nIndex],wyield_sws[nIndex],pdepth_sws[nIndex],q2,q2_frozen))
//							goto L001;

						v2[nIndex] = 0.0;
						qh[nIndex] = 0.0;
						SA[nIndex] = 0.0;
						XA[nIndex] = 0.0;
						HR[nIndex] = 0.0;

						pChannelInfo[nIndex].down_flow[0] = q2[nIndex];
					}
					else
					{
						routinelake(nIndex,qin,ptwithdrawal,irrwithdrawal,delt60,
								prec_p[nIndex],pet_p[nIndex],v1[nIndex],v2[nIndex],
								q2[nIndex],qh[nIndex]);
						
						// special case (01-21-2013)
//						if (!ApplyStreamIceMelt(nIndex,temp2[nIndex],wyield_sws[nIndex],pdepth_sws[nIndex],q2,q2_frozen))
//							goto L001;

						SA[nIndex] = pReachInfo[nIndex].length * MILE_TO_FEET * pReachInfo[nIndex].width;		// ft2
						if (pReachInfo[nIndex].length > 0)
							XA[nIndex] = v2[nIndex] / (pReachInfo[nIndex].length*MILE_TO_FEET);	// ft2	
						double avdepth = 0.0;
						if (SA[nIndex] > 0)
							avdepth = v2[nIndex] / SA[nIndex];											// ft
						double topwidth = 0.0;
						if (pReachInfo[nIndex].length > 0)
							topwidth = SA[nIndex] / (pReachInfo[nIndex].length * MILE_TO_FEET);				// ft
						if (avdepth > 0 || topwidth > 0)
							HR[nIndex] = (topwidth * avdepth) / (2.0 * avdepth + topwidth);				// ft
					}
				}
				else if(route == 2)	
					goto L001;
				else if(st < 0)
				{
					if (routemethod == 1)
					{
						routemethod = 2;
						CString strError;
						strError.Format("Check channel %d", pChannelInfo[nIndex].rchid);
						Log(strError);
						goto L111;
					}
					else
					{
						CString strError;
						strError.Format("Check channel %d", pChannelInfo[nIndex].rchid);
						AfxMessageBox(strError);
						Log(strError);
						goto L001;
					}
				}
				else
				{
					// special case (01-21-2013)
//					if (!ApplyStreamIceMelt(nIndex,temp2[nIndex],wyield_sws[nIndex],pdepth_sws[nIndex],q2,q2_frozen))
//						goto L001;
				}
			}
			
			// apply reduction (01-05-06)
			if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
			{
				double qsum = 0.0;
				for (j=0; j<ncrchOutlets; j++)
				{
					if (pChannelInfo[nIndex].rchid == pBMPReduction[j].rchid)
					{
						for (k=0; k<pChannelInfo[nIndex].nDSchan; k++)
						{
							if (pMON_SWITCH[j+k].nSwitch[mon] == 0)
								continue;
							double limit = pBMPLimit[j+k].fLimit_flow;	// cfs
							if (limit >= 0 && pChannelInfo[nIndex].down_flow[k] > limit)	
								pChannelInfo[nIndex].down_flow[k] = limit;

							pChannelInfo[nIndex].down_flow[k] *= (1 - pBMPReduction[j+k].fReduction_flow); 	
							qsum += pChannelInfo[nIndex].down_flow[k];
						}
						break;
					}
				}
				q2[nIndex] = qsum;
			}

			// for stream summary
			if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
			{
				for (j=0; j<pChannelInfo[nIndex].nDSchan; j++)
				{
					pChannelInfo[nIndex].down_flow_s[j] += pChannelInfo[nIndex].down_flow[j] * delts;	// ft3
					pChannelInfo[nIndex].bypass_flow_s[j] += pChannelInfo[nIndex].bypass_flow[j] * delts;	// ft3
				}
			}

			if (v2[nIndex] > 0)
				avcount[nIndex] += 1;
			
			v2_s[nIndex] += v2[nIndex];	 
			q2_s[nIndex] += q2[nIndex];

			double avdep  = 0.5*(qh[nIndex] + dep1);	// ft 

			DEP_s[nIndex] += avdep;						// ft	  

			double surfacearea = SA[nIndex];			// ft^2 
			
			SA_s[nIndex] += surfacearea / ACRE_TO_FT2;	//  ft^2 -> acres	   

			double avdepm = 0.0;
			double avdepe = 0.0;
			
			if (surfacearea > 0)
				avdepe = v2[nIndex] / surfacearea;	// ft
			
			avdepm = avdepe * FT_TO_M;				// m

			AVDEP_s[nIndex] += avdepe;				// ft	   

			double hradm = HR[nIndex]*FT_TO_M;		// ft -> m	   

			HRAD_s[nIndex] += HR[nIndex];			// ft	 

			double avvelm = 0.0;
			double avvele = 0.0;

			if (XA[nIndex] > 0)
				avvele = q2[nIndex] / XA[nIndex];	// ft/s   

			avvelm = avvele * FT_TO_M;				// m/s

			AVVEL_s[nIndex] += avvele;				// ft/s		   

			double db50 = pReachInfo[nIndex].w1*FT_TO_M;		// median diameter of bed material (m)
			double akappa = 0.4;	// Karman constant 
			double grav = 9.81;		// m/sec^2
			double gamma = 1000;	// kg/m^3	 
			double tau = 0;			// (kg/m^2)		  
			
			if (avdepm > 0.0)
			{
				//water in reach
				if (pReachInfo[nIndex].lkfg != 0) 
				{
					//use formula appropriate to a lake- from "hydraulics
					//of sediment transport", by w.h. graf- eq.8.49
					double ustar = avvelm/(17.66+(log10(avdepm/(96.5*db50)))*2.3/akappa);
					
					tau = gamma*pow(ustar,2)/grav;
				}
				else
				{
					//use formula appropriate to a river or stream, manual eq (44)
					tau = gamma * hradm * slope;	// (kg/m^2)
				}
			}
			else
			{
				//water body is dry - values undefined
				tau= 0.0;
			}

			// update
			vols[nIndex]	= v1[nIndex];		//ft3
			vol[nIndex]		= v2[nIndex];		//ft3
			double ros		= q1[nIndex];		//cfs
			double ro		= q2[nIndex];		//cfs
			double srovol = 0;					//ft3
			double erovol = 0;					//ft3
			double crrat = pReachInfo[nIndex].crrat;

			// call adcal to get the average flow volume
			ADCALC(vols[nIndex], ros, ro, crrat, delts, srovol, erovol);	
	
			double rom      = ro * FT3_TO_M3;			// cfs to cms
			double VOLS		= vols[nIndex]*FT3_TO_M3;	// ft^3 to m^3
			double VOL		= vol[nIndex]*FT3_TO_M3;	// ft^3 to m^3
			double SROVOL	= srovol*FT3_TO_M3;		// ft^3 to m^3
			double EROVOL	= erovol*FT3_TO_M3;		// ft^3 to m^3

			// ++++++++ TEMP temperature ++++++++

			if(tempfg == 1)
			{
				int	   nPolType = 0;
				double mlink = 0.0;
				double mup = 0.0;
				double mup_bypass = 0.0;
				double mland = 0.0;
				double mland_bypass = 0.0;
				double mpt = 0.0;
				double mptwd_target = 0.0;
				double mirwd = 0.0;
				double mpswd = 0.0;
				double imat = 0.0;
				double conc = temp2[nIndex];

				// get the point source withdrawal if targeted to this stream
				mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,temp2,tCurrent);	//degree C * m3

				// modified (11-01-2010)
				mptwd_target /= FT3_TO_M3;	//degree C * ft3

				// upstream routed and bypassed load
				nPolType = POLUT_TEMP;
				if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
					goto L001;

				// from land
//				mland = soiltm[nIndex]*IN_ACRE_TO_FT3;	// degree C * ft3 (acre-in = 3630 ft3)
				mland = soiltm_route[nIndex]*IN_ACRE_TO_FT3;// degree C * ft3
				
				// bypass load to downstream channel(s)
				mland_bypass = soiltm_bypass[nIndex]*IN_ACRE_TO_FT3;// degree C * ft3
				for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
					pChannelInfo[nIndex].bypass_temp[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

//				mland -= mland_bypass;

				// from point sources
				int pqualid = PS_TEMP;
				int sqalfg = 0;		// get total load
				double pload  = GetLoad2(sqalfg, nIndex, pqualid, tCurrent);
				
				if (pload == UNKNOWN)
					//use the stream temperature 
					pload = conc * delts * pt;// degreeC*ft3/timestep
				else
					pload *= delt60;     // degreeC*ft3/hr to degreeC*ft3/timestep					    
				
				mpt = pload; // input load 
				
				// irrigation withdrawal
				mirwd = conc * delts * irrwithdrawal;	// degreeC*ft3

				// pointsource withdrawal
				mpswd = conc * delts * ptwithdrawal;	// degreeC*ft3
				
				// linkage files
				if (nLinkFiles > 0)
				{
					if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
					{
						POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
						while (pos != NULL)
						{
							Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
							mlink += plink435.pLinkData[i].temp; //degree C * ft3
						}
					}
				}

				imat = mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	//degree C * ft3 = kcal.vol/l.C

				//assume precipitation has instream conc.
//				imat += conc * SA[nIndex] * prec_p[nIndex]/12;	// degreeC*ft3

				//imat = max(0, imat);	//avoid negative value

				// for stream summary (degreeC*ft3)
				if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
				{
					ustemp_s[nIndex] += (mup+mlink);			
					lutemp_s[nIndex] += mland;			
					ustempbp_s[nIndex] += mup_bypass;			
					lutempbp_s[nIndex] += mland_bypass;			
					if (nPtSource > 0)
					{
						pstemp_s[nIndex] += mpt;		
						pswdtemp_s[nIndex] += mpswd;	
						pswdtempdi_s[nIndex] += mptwd_target;	
					}
					if (irrigfg == 1)
						irwdtemp_s[nIndex] += mirwd;	
					
					itemp_s[nIndex] += imat;			
				}

				double romat = 0.0;								//degree C * ft3
				double airtmp = atem_p[nIndex];					//degree C
				atem = atem_p[nIndex];							//degree C
				wind = wind_p[nIndex]*MILE_TO_METER;			//mile/ivld to m/ivld
				solr = solr_p[nIndex];							//ly/ivl
				dewp = dewp_p[nIndex];							//degree C
				clou = clou_p[nIndex];							//tenth
				supy = supy_p[nIndex];							//in/ivl
				double elev   = ptmp_param1[nIndex].relev;		//ft
				double eldat  = ptmp_param1[nIndex].reldat;		//ft
				double cfsaex = ptmps_param1[rgroup].cfsaex_p;	//none
				double katrad = ptmps_param1[rgroup].katrad_p;	//none
				double kcond  = ptmps_param1[rgroup].kcond_p;	//none
				double kevap  = ptmps_param1[rgroup].kevap_p;	//none

				//adjtemp(&eldat, &atem, &airtmp, &hrfg, &supy, &delts);
				adjtemp(&eldat, &atem, &airtmp, hrfg, &supy, &deltm, nSHour);   

				temp1[nIndex] = temp2[nIndex];	//degree C

				advect(admod, volt, &imat, &vols[nIndex], &ros, &vol[nIndex], &ro, &conc,
						   &romat, delts, &js, crrat);

				temp2[nIndex] = conc;		//degree C
				matoutp[nIndex] = romat;	//degreeC*ft3

				for (int jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
				{
					if (q2[nIndex] > 0.0) 
					  pChannelInfo[nIndex].down_temp[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matoutp[nIndex];
					else
					  pChannelInfo[nIndex].down_temp[jk]= 0.0;
				}

				// apply reduction (01-05-06)
				if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
					matoutp[nIndex] = GetBMPReductionLoad(nPolType,nQuals+3,nIndex,mon,delts);

				// for stream summary (degreeC*ft3)
				if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
				{
					for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
					{
						pChannelInfo[nIndex].down_temp_s[j2] += pChannelInfo[nIndex].down_temp[j2];
						pChannelInfo[nIndex].bypass_temp_s[j2] += pChannelInfo[nIndex].bypass_temp[j2];
					}
				}

				//added (02-22-2011)
				int preflg = ptmps_param2[rgroup].preflg;		//flag
				int bedflg = ptmps_param2[rgroup].bedflg;		//flag
				int tgflg = ptmps_param2[rgroup].tgflg;			//flag
				double kmud = ptmps_param2[rgroup].kmud;		//kcal/m2/degC/hr
				double kgrnd = ptmps_param2[rgroup].kgrnd;		//kcal/m2/degC/hr
				
				//convert rate coefficients from kcal/m2/C/hr to kcal/m2/C/ivl
				kmud *= delt60;
				kgrnd *= delt60;

				double muddep = ptmps_param2[rgroup].muddep;	//m
				double tgrnd = ptmps_param2[rgroup].tgrnd;		//degree C
				double *tgrndm = NULL;
				if (ptmps_mon != NULL)
					tgrndm = ptmps_mon[rgroup].fnum;			//degree C
				
				double tmud = tmud_p[nIndex];					//degree C
				double tmuddt = tmuddt_p[nIndex];				//degree C / ivl

//				if (avdepe > 0.17 && pReachInfo[nIndex].lkfg <= 10)
				if (pReachInfo[nIndex].lkfg <= 10)
					caltemp(dayfg, day, ndays, mon, nxtmon, preflg, bedflg, tgflg, solr, dewp, airtmp, wind, cfsaex, katrad, kcond, 
							delt60, kevap, avdepe, prec_p[nIndex], kmud, muddep, kgrnd, temp1[nIndex], cfpres, tgrndm, clou, 
							temp2[nIndex], tgrnd, tmud, tmuddt);

				//update the mud temperature 
				tmud_p[nIndex] = tmud;					//degree C
				tmuddt_p[nIndex] = tmuddt;				//degree C / ivl

				if (temp2_min[nIndex] == -999)	//first entry
					temp2_min[nIndex] = temp2[nIndex];
				else if (temp2_min[nIndex] > temp2[nIndex])
					temp2_min[nIndex] = temp2[nIndex];

				if (temp2_max[nIndex] == -999)	//first entry
					temp2_max[nIndex] = temp2[nIndex];
				else if (temp2_max[nIndex] < temp2[nIndex])
					temp2_max[nIndex] = temp2[nIndex];

				temp2_s[nIndex] += temp2[nIndex];
			}
			
			// ++++++++ SED sediment ++++++++

			// 0 is dummy 1-3 suspended, 4-6 bed, 7-9 tot, 10 grand total
			double RSED1[11],RSED[11];	
			for (int j2= 0; j2<11; j2++)
			{
				RSED1[j2] = 0.0;	//at the beginning of interval
				RSED[j2] = 0.0;		//at the end of interval
			}
			// 0 is dummy 1-3 sand,silt,clay, and 4 is total
			double DEPSCR[5],SSED[5],ROSED[5],PSLOADSED[5],IRRWDSED[5],PSWDSED[5],PSDTSED[5];  
			for (j2= 0; j2<5; ++j2)
			{
				DEPSCR[j2] = 0.0;
				SSED[j2] = 0.0;
				ROSED[j2] = 0.0;
				PSLOADSED[j2] = 0.0;
				IRRWDSED[j2] = 0.0;
				PSWDSED[j2] = 0.0;
				PSDTSED[j2] = 0.0;
			}

			if(sedfg == 1)	
			{
				int nSed_sand = 0;// number of sediment classes (sand)
				int nSed_silt = 0;// number of sediment classes (silt)
				int nSed_clay = 0;// number of sediment classes (clay)
				double rsed1 = 0.0;//sediment mass in bed for the given class (mg/l*m3=gm)
				double frcsed_mass = 0.0;// the fraction of sediment class in terms of mass
				double frcsed_vol = 0.0;// the fraction of sediment class in terms of volume
				double rbsedTOT = rbsedtot[nIndex];// total sediemnt mass in bed (mg/l*m3)
				double vbsedTOT = vbsedtot[nIndex];// total sediemnt volume in bed (m3)
				double volumesed = 0.0;// total sediemnt volume in bed at the end of ivl (m3)
				double rhomn = 0.0;// average density (g/cc)
				for (int ii=0; ii<NumSed; ii++)
				{
					//check if sand is simulated or not
					if(sandfg == 0 && rsd_param[rgroup*NumSed+ii].sedflg == 0)
						continue;
					rsed1 = rbsed[nIndex*NumSed+ii];
					if (rbsedTOT > 0)
						frcsed_mass = rsed1/rbsedTOT;
					rhomn += frcsed_mass*rsd_param[rgroup*NumSed+ii].rho;
				}

				for (ii=0; ii<NumSed; ii++)
				{
					if (sandfg == 0 && rsd_param[rgroup*NumSed+ii].sedflg == 0)
						continue;

					if (rsd_param[rgroup*NumSed+ii].sedflg == 0)		  
					{
						// sediment class is sand
						RSED1[1] += rssed[nIndex*NumSed+ii];	// g
						RSED1[4] += rbsed[nIndex*NumSed+ii];	// g
						++nSed_sand;
					}
					else if (rsd_param[rgroup*NumSed+ii].sedflg == 1)		  
					{
						// sediment class is silt
						RSED1[2] += rssed[nIndex*NumSed+ii];	// g
						RSED1[5] += rbsed[nIndex*NumSed+ii];	// g
						++nSed_silt;
					}
					else if (rsd_param[rgroup*NumSed+ii].sedflg == 2)	
					{
						// sediment class is clay
						RSED1[3] += rssed[nIndex*NumSed+ii];	
						RSED1[6] += rbsed[nIndex*NumSed+ii];	
						++nSed_clay;
					}
				}

				RSED1[7] = RSED1[1] + RSED1[4];
				RSED1[8] = RSED1[2] + RSED1[5];
				RSED1[9] = RSED1[3] + RSED1[6];
				RSED1[10] = RSED1[7] + RSED1[8] + RSED1[9];

				// get load from the point sources (lb/hr)
				int sqalfg = 0;		// get total load 
				for (ii=1; ii<4; ii++)
				{
					int pqualid = 100 + ii;	// 101=sand, 102=silt, 103=clay
					PSLOADSED[ii] = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
					PSLOADSED[4] += PSLOADSED[ii];
				}

				// stream bank erosion (gram)
				if (sedber == 1 && pReachInfo[nIndex].lkfg == 0)
				{
					double qber = rsd_berparam[nIndex].qber;	// cfs
					double jber = rsd_berparam[nIndex].jber;
					double kber = rsd_berparam[nIndex].kber;
					double rchlen = pReachInfo[nIndex].length * MILE_TO_FEET;	// ft

					if (qber < 0)
						qber = q_bfd[nIndex];	// cfs

					// call bersed 
					bersed(jber, kber, rchlen, delt60, q2[nIndex], qber, XA[nIndex],
						xa_thr[nIndex], HR[nIndex], hr_thr[nIndex], &ber_sd[nIndex]);

					sober_s[nIndex] += ber_sd[nIndex] * GRAM_TO_TONS;	// english tons
				}

				rbsedtot[nIndex] = 0.0; 
				vbsedtot[nIndex] = 0.0; 

				//simulate cohesive sediment classes
				for(ii=0; ii<NumSed; ii++)
				{
					if (rsd_param[rgroup*NumSed+ii].sedflg == 0)
						// it is sand, skip to the next iteration ii
						continue;

					double mber = 0.0;
					if (sedber == 1 && pReachInfo[nIndex].lkfg == 0)
						mber = ber_sd[nIndex]*rsd_berparam[nIndex].sed[ii];	// gram
					double mlink = 0.0;
					double mup = 0.0;
					double mup_bypass = 0.0;
					double mland = 0.0;
					double mland_bypass = 0.0;
					double mpt = 0.0;
					double mptwd_target = 0.0;
					double mirwd = 0.0;
					double mpswd = 0.0;
					double imat = 0.0;

					// get the point source withdrawal if targeted to this stream
					if(pPSReduction != NULL && pPtWithDrawal != NULL)
					{
						for (int mm=0; mm<nPtWithDrawal; ++mm)
						{
							int nPSIndex = -1;
							if (pChannelInfo[nIndex].rchid == pPtWithDrawal[mm].targetrchid)
								nPSIndex = GetPSIndex(pPtWithDrawal[mm].wdrawlrchid,pPtWithDrawal[mm].strPermit,pPtWithDrawal[mm].strPipe);

							if (nPSIndex <0)
								continue;

							double wd_vol = - GetTargetWithDrawal(nPSIndex, tCurrent) * delts;	// ft3
							int nRIndex = FindReachIndex(pPtWithDrawal[mm].wdrawlrchid);

							if (wd_vol > v2[nRIndex])
								wd_vol = v2[nRIndex];

							mptwd_target += sed2[nRIndex*NumSed+ii] * wd_vol * FT3_TO_M3;	// g/ivl
						}
					}

					// upstream routed and bypassed load
					nNum = pChannelInfo[nIndex].cListUppersOrder.GetSize();
					if(nNum > 0)
					{
						for(int j2=0; j2<nNum; j2++)
						{
							int nUpperReach = pChannelInfo[nIndex].cListUppersOrder.GetAt(j2);
							if(nUpperReach < 0 || nUpperReach >= nsws)
							{
								AfxMessageBox("Wrong NETWORK");
								goto L001;
							}
							else																	
							{
								for (int j3 = 0; j3< pChannelInfo[nUpperReach].nDSchan; j3++)
								{
									if (pChannelInfo[nIndex].rchid == pChannelInfo[nUpperReach].down_ch[j3])
									{
										mup += pChannelInfo[nUpperReach].down_matsed[j3*NumSed+ii];
										mup_bypass += pChannelInfo[nUpperReach].bypass_matsed[j3*NumSed+ii];
									}
								}
							}
						}
					}

					// from land
//					mland = totsed[nIndex*NumSed+ii]*0.907185e6;   // from land in g
//					totsed[nIndex*NumSed+ii] = 0.0;
					mland = totsed_route[nIndex*NumSed+ii]*0.907185e6;	// g
					totsed_route[nIndex*NumSed+ii] = 0.0;

					// bypass load to downstream channel(s)
					mland_bypass = totsed_bypass[nIndex*NumSed+ii]*0.907185e6;	// g
					totsed_bypass[nIndex*NumSed+ii] = 0.0;

					// check if any sediment in GQUAL section
					if (gqsdfg == 1 && pqalfg == 1)
					{
//						mland += qualsed[nIndex*NumSed+ii] * LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						mland += qualsed_route[nIndex*NumSed+ii] * LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						mland_bypass += qualsed_bypass[nIndex*NumSed+ii] * LBS_TO_GRAM;	// from lb/ivld to gram/ivld
//						qualsed[nIndex*NumSed+ii] = 0.0;
						qualsed_route[nIndex*NumSed+ii] = 0.0;
						qualsed_bypass[nIndex*NumSed+ii] = 0.0;
					}

//					mland -= mland_bypass;
	
					for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
						pChannelInfo[nIndex].bypass_matsed[j*NumSed+ii] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

					double conc = sed2[nIndex*NumSed+ii];	// mg/l
					double pload = 0.0;

					if (rsd_param[rgroup*NumSed+ii].sedflg == 1)		 
					{
						// silt 
						//from point source
						pload = PSLOADSED[2];
						if (nSed_silt > 0)
							pload /= nSed_silt;
						pload *= delt60;     // lbs/hr to lbs/timestep					    
						mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld;	

						// remove negative point source load
						mpswd = conc * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	
						PSWDSED[2] += mpswd;

						// diverted point source load
//						mpswd = conc * delts * ptwd_target * FT3_TO_M3;	// g/ivl	
//						PSDTSED[2] += mpswd;

						// irrigation withdrawal mass
						mirwd = conc * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	
						IRRWDSED[2] += mirwd;
					}
					else if (rsd_param[rgroup*NumSed+ii].sedflg == 2)	
					{
						// clay
						//from point source
						pload = PSLOADSED[3];
						if (nSed_clay > 0)
							pload /= nSed_clay;
						pload *= delt60;     // lbs/hr to lbs/timestep					    
						mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld;	

						// remove negative point source load
						mpswd = conc * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	
						PSWDSED[3] += mpswd;

						// diverted point source load
//						mpswd = conc * delts * ptwd_target * FT3_TO_M3;	// g/ivl	
//						PSDTSED[3] += mpswd;

						// irrigation withdrawal mass
						mirwd = conc * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	
						IRRWDSED[3] += mirwd;
					}

					// linkage files
					if (nLinkFiles > 0)
					{
						if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
						{
							POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
							while (pos != NULL)
							{
								Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
								mlink += plink435.pLinkData[i].pSed[ii]; //grams
							}
						}
					}

					double romat = 0.0;
					imat = mber + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// grams

					//imat = max(0, imat);	//avoid negative value

					// for stream summary (english tons)
					if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
					{
						if (sedber == 1 && pReachInfo[nIndex].lkfg == 0)
							bersed_s[nIndex*NumSed+ii] += mber * GRAM_TO_TONS;			
						ussed_s[nIndex*NumSed+ii] += (mup+mlink) * GRAM_TO_TONS;			
						lused_s[nIndex*NumSed+ii] += mland * GRAM_TO_TONS;			
						ussedbp_s[nIndex*NumSed+ii] += mup_bypass * GRAM_TO_TONS;			
						lusedbp_s[nIndex*NumSed+ii] += mland_bypass * GRAM_TO_TONS;			
						if (nPtSource > 0)
						{
							pssed_s[nIndex*NumSed+ii] += mpt * GRAM_TO_TONS;		
							pswdsed_s[nIndex*NumSed+ii] += mpswd * GRAM_TO_TONS;	
							pswdseddi_s[nIndex*NumSed+ii] += mptwd_target * GRAM_TO_TONS;	
						}
						if (irrigfg == 1)
							irwdsed_s[nIndex*NumSed+ii] += mirwd * GRAM_TO_TONS;	
						ised_s[nIndex*NumSed+ii] += imat * GRAM_TO_TONS;
						bedsed_s[nIndex*NumSed+ii] += rbsed[nIndex*NumSed+ii] * GRAM_TO_TONS;			
					}

					double qq2   = q2[nIndex]*FT3_TO_M3;	// ft^3/s to m^3/s
					double qq1   = q1[nIndex]*FT3_TO_M3;
					double vols0 = vols[nIndex]*FT3_TO_M3;
					double vol0  = vol[nIndex]*FT3_TO_M3;
					
					advect(admod, VOLT, &imat, &vols0, &qq1, &vol0, &qq2, &conc, &romat,
						   delts, &js, crrat);
					
					sed2[nIndex*NumSed+ii]   = conc;	// mg/l
					matsed[nIndex*NumSed+ii] = romat;	// g

					double volume = vol[nIndex]*FT3_TO_M3;	// m3
					double depscr = 0;					// mg/l*m3

					//total weight relative to water - units are (mg/l)*m3
					rsed1 = rbsed[nIndex*NumSed+ii];		// mg/l*m3
					double vsed1 = vbsed[nIndex*NumSed+ii];		// m3

					if (rbsedTOT > 0.0)
					{
						frcsed_mass = rsed1 / rbsedTOT;
					}
					else
					{
						//no bed at start of interval, assume equal fractions 
						if (NumSed > 0)
							frcsed_mass = 1.0/NumSed;
					}

					if (vbsedTOT > 0.0)
					{
						frcsed_vol = vsed1 / vbsedTOT;
					}
					else
					{
						//no bed at start of interval, assume equal fractions 
						if (NumSed > 0)
							frcsed_vol = 1.0/NumSed;
					}

					//calculate exchange between bed and suspended sediment
					double rsed  = conc*volume;		// storage in suspension (mg/l)*m3
					//convert settling velocity from in/sec to m/ivl
					double w = rsd_param[rgroup*NumSed+ii].w*0.0254*delts;	// fall velocity (m/timestep)
					double taucd = rsd_param[rgroup*NumSed+ii].taucd*0.4535924/0.09290304;	//critical bed shear stress for deposition (kg/m^2)
					double taucs = rsd_param[rgroup*NumSed+ii].taucs*0.4535924/0.09290304;	//critical bed shear stress for scour (kg/m^2)
					//convert erodibility coeff from lb/ft^2/day to kg/m^2/ivl
					double m = rsd_param[rgroup*NumSed+ii].m*deltd*0.4535924/0.09290304;	// erodibility coefficient of the sediment (kg/m^2/timestep)

					//find the burial rate (in/day)
					double bur_rate = rsd_param[rgroup*NumSed+ii].burial*deltd*0.0254; // burial rate of the sediment class (m/timestep)
					double bur_vol = bur_rate * pReachInfo[nIndex].length*MILE_TO_METER * rsd_genparam[rgroup].bedwid*FT_TO_M*(1.0 - rsd_genparam[rgroup].por);	// m3
					double bur_mass = bur_vol * rsd_param[rgroup*NumSed+ii].rho/CM3_TO_M3;	//(mg/l)*m3
					if (rsd_genparam[rgroup].burial > 0)
					{
						bur_rate = rsd_genparam[rgroup].burial*deltd*0.0254; // burial rate of the total sediment (m/timestep)
						bur_vol = bur_rate * pReachInfo[nIndex].length*MILE_TO_METER * rsd_genparam[rgroup].bedwid*FT_TO_M*(1.0 - rsd_genparam[rgroup].por);	// m3
						bur_mass = bur_vol*rhomn/CM3_TO_M3*frcsed_vol;//(mg/l)*m3
					}
					
					double depmass = 0.;
					double scrmass = 0.;

					if(avdepe > 0.17 && pReachInfo[nIndex].lkfg <= 10)
						BDEXCH(avdepm,w,tau,taucd,taucs,m,volume,frcsed_mass,&rsed,&rsed1,&depscr);	

					//added (03-24-2014)
					if (depscr < 0)
						scrmass = -depscr;
					else
						depmass = depscr;
	
					if (volume > 0)
						conc = rsed/volume;				// mg/l
					else
						conc = 0.0;
					
					//set small concentrations to zero
					if (fabs(conc) < 1.0E-15) 
					{
						//small conc., set to zero
						if (depscr > 0.0) 
						{
							//deposition has occurred, add small storage to deposition
							depscr += rsed;	// mg/l*m3	
							rsed1  += rsed;	// mg/l*m3
						}
						else
						{
							//add small storage to outflow
							matsed[nIndex*NumSed+ii] += rsed;
							depscr = 0.0;
						}
						rsed = 0.0;
						conc = 0.0;
					}

					//remove the burial mass
					rsed1 -= bur_mass;
					if (rsed1 < 0)
						rsed1 = 0.0;

					sed2[nIndex*NumSed+ii]   = conc;				// mg/l
					rssed[nIndex*NumSed+ii]  = rsed;				// mg/l*m3
					rbsed[nIndex*NumSed+ii]  = rsed1;				// mg/l*m3
					vbsed[nIndex*NumSed+ii]  = rsed1/
						(rsd_param[rgroup*NumSed+ii].rho/CM3_TO_M3);// m3
					sedbed[nIndex*NumSed+ii] = rsed1;
					rbsedtot[nIndex] += rsed1;
					vbsedtot[nIndex] += vbsed[nIndex*NumSed+ii];

					if (rsd_param[rgroup*NumSed+ii].sedflg == 1)	// silt 
					{
						DEPSCR[2] += depscr;						// g
						RSED[2]   += rsed;							// mg/l*m3
						RSED[5]   += rsed1;							// mg/l*m3
						RSED[8]   += rsed+rsed1;					// mg/l*m3
						ROSED[2]  += matsed[nIndex*NumSed+ii];		// g
						SSED[2]   += conc;							// mg/l
					}
					else if (rsd_param[rgroup*NumSed+ii].sedflg == 2)	// clay
					{
						DEPSCR[3] += depscr;						// g
						RSED[3]   += rsed;							// mg/l*m3
						RSED[6]   += rsed1;							// mg/l*m3
						RSED[9]   += rsed+rsed1;					// mg/l*m3
						ROSED[3]  += matsed[nIndex*NumSed+ii];		// g
						SSED[3]	  += conc;							// mg/l
					}

					DEPSCR[4]	+= depscr;							// g
					ROSED[4]	+= matsed[nIndex*NumSed+ii];		// g
					SSED[4]		+= conc;							// mg/l
					RSED[10]	+= rsed+rsed1;						// mg/l*m3

					for (int jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)			 
					{
						if (q2[nIndex] > 0.0) 
						  pChannelInfo[nIndex].down_matsed[jk*NumSed+ii] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matsed[nIndex*NumSed+ii];		// g
						else
						  pChannelInfo[nIndex].down_matsed[jk*NumSed+ii]= 0.0;
					}

					// apply reduction (01-05-06)
					if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
					{
						double romatsum = 0.0;
						for (int j1=0; j1<ncrchOutlets; j1++)
						{
							if (pChannelInfo[nIndex].rchid == pBMPReduction[j1].rchid)
							{
								for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									if (pMON_SWITCH[j1+j2].nSwitch[mon] == 0)
										continue;

									if (rsd_param[rgroup*NumSed+ii].sedflg == 1) // silt
									{
										double limit = pBMPLimit[j1+j2].fLimit_qual[nQuals+1];	// mg/l
										double fConc = 0.0;
										if (pChannelInfo[nIndex].down_flow[j2] > 0)
											fConc = pChannelInfo[nIndex].down_matsed[j2*NumSed+ii]/(pChannelInfo[nIndex].down_flow[j2]*FT3_TO_M3*delts);
										if (limit >= 0 &&  fConc > limit)	
											pChannelInfo[nIndex].down_matsed[j2*NumSed+ii] = limit*pChannelInfo[nIndex].down_flow[j2]*FT3_TO_M3*delts;

										pChannelInfo[nIndex].down_matsed[j2*NumSed+ii] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQuals+1]); 
									}
									else if (rsd_param[rgroup*NumSed+ii].sedflg == 2) // clay
									{
										double limit = pBMPLimit[j1+j2].fLimit_qual[nQuals+2];	// mg/l
										double fConc = 0.0;
										if (pChannelInfo[nIndex].down_flow[j2] > 0)
											fConc = pChannelInfo[nIndex].down_matsed[j2*NumSed+ii]/(pChannelInfo[nIndex].down_flow[j2]*FT3_TO_M3*delts);
										if (limit >= 0 &&  fConc > limit)	
											pChannelInfo[nIndex].down_matsed[j2*NumSed+ii] = limit*pChannelInfo[nIndex].down_flow[j2]*FT3_TO_M3*delts;

										pChannelInfo[nIndex].down_matsed[j2*NumSed+ii] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQuals+2]); 
									}
									romatsum += pChannelInfo[nIndex].down_matsed[j2*NumSed+ii];
								}
								break;
							}
						}
						matsed[nIndex*NumSed+ii] = romatsum;
					}

					// for stream summary (english ton)
					if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
					{
						depscr_ss[nIndex*NumSed+ii] += depscr * GRAM_TO_TONS;			
						depmass_ss[nIndex*NumSed+ii] += depmass * GRAM_TO_TONS;			
						scrmass_ss[nIndex*NumSed+ii] += scrmass * GRAM_TO_TONS;			
						for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
						{
							pChannelInfo[nIndex].down_matsed_s[j2*NumSed+ii] += pChannelInfo[nIndex].down_matsed[j2*NumSed+ii] * GRAM_TO_TONS;	 
							pChannelInfo[nIndex].bypass_matsed_s[j2*NumSed+ii] += pChannelInfo[nIndex].bypass_matsed[j2*NumSed+ii] * GRAM_TO_TONS;	 
						}
					}

					//find total volume of sediment
					if (rsd_param[rgroup*NumSed+ii].rho > 0)
						//volumesed += rsed1/(rsd_param[rgroup*NumSed+ii].rho/CM3_TO_M3);	// m3
						volumesed += (rsed1/rsd_param[rgroup*NumSed+ii].rho)*CM3_TO_M3;	// m3
					
					// +++++++ output parameters +++++++

					ssedc_s[nIndex*NumSed+ii] += sed2[nIndex*NumSed+ii];	
					ssed_s[nIndex] += sed2[nIndex*NumSed+ii];	

//					if (q2[nIndex] > 0 && delts > 0 )
//					{
//						rossedc_s[nIndex*NumSed+ii] += (matsed[nIndex*NumSed+ii]) / (q2[nIndex]*FT3_TO_M3*delts);	// conc (mg/l)
//						rossed_s[nIndex] += (matsed[nIndex*NumSed+ii]) / (q2[nIndex]*FT3_TO_M3*delts);	// conc (mg/l)
//					}

					rsed_s[nIndex] += sedbed[nIndex*NumSed+ii]*GRAM_TO_TONS;	// english tons
					rbedsed_s[nIndex*NumSed+ii] += sedbed[nIndex*NumSed+ii]*GRAM_TO_TONS;	// english tons
					rdepscr_s[nIndex*NumSed+ii] += depscr*GRAM_TO_TONS;						// english tons
					depscr_s[nIndex] += depscr*GRAM_TO_TONS;					// english tons
					rosed1_s[nIndex*NumSed+ii] += matsed[nIndex*NumSed+ii]*GRAM_TO_TONS;	// english tons	
					rosed_s[nIndex] += matsed[nIndex*NumSed+ii]*GRAM_TO_TONS;	// english tons	
				}

				//simulate non cohesive sediment (sand)
				if (sandfg != 0)
				{
					double fsl = SSED[2] + SSED[3];	// mg/l

					for(ii=0; ii<NumSed; ii++)
					{
						if (rsd_param[rgroup*NumSed+ii].sedflg != 0)
							// It is not a sand, go to the next iteration ii
							continue;

						double mber = 0.0;
						if (sedber == 1 && pReachInfo[nIndex].lkfg == 0)
							mber = ber_sd[nIndex]*rsd_berparam[nIndex].sed[ii];	// gram
						double mlink = 0.0;
						double mup = 0.0;
						double mup_bypass = 0.0;
						double mland = 0.0;
						double mland_bypass = 0.0;
						double mpt = 0.0;
						double mptwd_target = 0.0;
						double mirwd = 0.0;
						double mpswd = 0.0;
						double imat = 0.0;

						// get the point source withdrawal if targeted to this stream
						if(pPSReduction != NULL && pPtWithDrawal != NULL)
						{
							for (int mm=0; mm<nPtWithDrawal; ++mm)
							{
								int nPSIndex = -1;
								if (pChannelInfo[nIndex].rchid == pPtWithDrawal[mm].targetrchid)
									nPSIndex = GetPSIndex(pPtWithDrawal[mm].wdrawlrchid,pPtWithDrawal[mm].strPermit,pPtWithDrawal[mm].strPipe);

								if (nPSIndex <0)
									continue;

								double wd_vol = - GetTargetWithDrawal(nPSIndex, tCurrent) * delts;	// ft3
								int nRIndex = FindReachIndex(pPtWithDrawal[mm].wdrawlrchid);

								if (wd_vol > v2[nRIndex])
									wd_vol = v2[nRIndex];

								mptwd_target += sed2[nRIndex*NumSed+ii] * wd_vol * FT3_TO_M3;	// g/ivl
							}
						}

						// upstream routed and bypassed load
						nNum = pChannelInfo[nIndex].cListUppersOrder.GetSize();
						if(nNum > 0)
						{
							for(int j2=0; j2<nNum; j2++)
							{
								int nUpperReach = pChannelInfo[nIndex].cListUppersOrder.GetAt(j2);
								if(nUpperReach < 0 || nUpperReach >= nsws)
								{
									AfxMessageBox("Wrong NETWORK");
									goto L001;
								}
								else																	
								{
									for (int j3 = 0; j3< pChannelInfo[nUpperReach].nDSchan; j3++)
									{
										if (pChannelInfo[nIndex].rchid == pChannelInfo[nUpperReach].down_ch[j3])
										{
											mup += pChannelInfo[nUpperReach].down_matsed[j3*NumSed+ii];
											mup_bypass += pChannelInfo[nUpperReach].bypass_matsed[j3*NumSed+ii];
										}
									}
								}
							}
						}

						// from land
//						mland = totsed[nIndex*NumSed+ii]*0.907185e6;   // from land in g
//						totsed[nIndex*NumSed+ii] = 0.0;
						mland = totsed_route[nIndex*NumSed+ii]*0.907185e6;	// g
						totsed_route[nIndex*NumSed+ii] = 0.0;

						// bypass load to downstream channel(s)
						mland_bypass = totsed_bypass[nIndex*NumSed+ii]*0.907185e6;	// g
						totsed_bypass[nIndex*NumSed+ii] = 0.0;

						// check if any sediment in GQUAL section
						if (gqsdfg == 1 && pqalfg == 1)
						{
//							mland += qualsed[nIndex*NumSed+ii] * LBS_TO_GRAM;	// from lb/ivld to gram/ivld
							mland += qualsed_route[nIndex*NumSed+ii] * LBS_TO_GRAM;	// from lb/ivld to gram/ivld
							mland_bypass += qualsed_bypass[nIndex*NumSed+ii] * LBS_TO_GRAM;	// from lb/ivld to gram/ivld
//							qualsed[nIndex*NumSed+ii] = 0.0;
							qualsed_route[nIndex*NumSed+ii] = 0.0;
							qualsed_bypass[nIndex*NumSed+ii] = 0.0;
						}

//						mland -= mland_bypass;
		
						for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
							pChannelInfo[nIndex].bypass_matsed[j*NumSed+ii] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

						double conc = sed2[nIndex*NumSed+ii];	// mg/l
						double pload = 0.0;

						//from point source
						pload = PSLOADSED[1];
						if (nSed_sand > 0)
							pload /= nSed_sand;
						pload *= delt60;     // lbs/hr to lbs/timestep					    
						mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld;	

						// remove negative point source load
						mpswd = conc * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	
						PSWDSED[1] += mpswd;

						// diverted point source load
//						mpswd = conc * delts * ptwd_target * FT3_TO_M3;	// g/ivl	
//						PSDTSED[1] += mpswd;

						// irrigation withdrawal mass
						mirwd = conc * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	
						IRRWDSED[1] += mirwd;

						// linkage files
						if (nLinkFiles > 0)
						{
							if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
							{
								POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
								while (pos != NULL)
								{
									Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
									mlink += plink435.pLinkData[i].pSed[ii]; //grams
								}
							}
						}

						double romat = 0.0;
						imat = mber + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// grams

						//imat = max(0, imat);	//avoid negative value
		
						// for stream summary (english tons)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							if (sedber == 1 && pReachInfo[nIndex].lkfg == 0)
								bersed_s[nIndex*NumSed+ii] += mber * GRAM_TO_TONS;			
							ussed_s[nIndex*NumSed+ii] += (mup+mlink) * GRAM_TO_TONS;			
							lused_s[nIndex*NumSed+ii] += mland * GRAM_TO_TONS;			
							ussedbp_s[nIndex*NumSed+ii] += mup_bypass * GRAM_TO_TONS;			
							lusedbp_s[nIndex*NumSed+ii] += mland_bypass * GRAM_TO_TONS;			
							if (nPtSource > 0)
							{
								pssed_s[nIndex*NumSed+ii] += mpt * GRAM_TO_TONS;		
								pswdsed_s[nIndex*NumSed+ii] += mpswd * GRAM_TO_TONS;	
								pswdseddi_s[nIndex*NumSed+ii] += mptwd_target * GRAM_TO_TONS;	
							}
							if (irrigfg == 1)
								irwdsed_s[nIndex*NumSed+ii] += mirwd * GRAM_TO_TONS;	
							ised_s[nIndex*NumSed+ii] += imat * GRAM_TO_TONS;
							bedsed_s[nIndex*NumSed+ii] += rbsed[nIndex*NumSed+ii] * GRAM_TO_TONS;			
						}

						double vols0 = vols[nIndex]*FT3_TO_M3;
						double vol0  = vol[nIndex]*FT3_TO_M3;
						double volume = vol[nIndex]*FT3_TO_M3;	// m3
						double depscr = 0;					// mg/l*m3

						//total weight relative to water - units are (mg/l)*m3
						rsed1 = rbsed[nIndex*NumSed+ii];		// mg/l*m3
						//calculate exchange between bed and suspended sediment
						double rsed  = conc*volume;		// storage in suspension (mg/l)*m3
						//convert settling velocity from in/sec to m/ivl
						double w = rsd_param[rgroup*NumSed+ii].w*0.0254*delts;	// fall velocity (m/timestep)
						double ksand = rsd_param[rgroup*NumSed+ii].taucd;	
						double expsnd = rsd_param[rgroup*NumSed+ii].taucs;

						double db50e = rsd_param[rgroup*NumSed+ii].d / 12.0; // ft
						double db50m = db50e * 304.8; // mm
						double wsande = w * 3.28 / delts; // from m/ivl to ft/sec
						double tw = temp2[nIndex]; // degree C

						double vsed1 = vbsed[nIndex*NumSed+ii];		// m3

						if (vbsedTOT > 0.0)
						{
							frcsed_vol = vsed1 / vbsedTOT;
						}
						else
						{
							//no bed at start of interval, assume equal fractions 
							if (NumSed > 0)
								frcsed_vol = 1.0/NumSed;
						}

						//find the burial rate (in/day)
						double bur_rate = rsd_param[rgroup*NumSed+ii].burial*deltd*0.0254; // burial rate of the sediment class (m/timestep)
						double bur_vol = bur_rate * pReachInfo[nIndex].length*MILE_TO_METER * rsd_genparam[rgroup].bedwid*FT_TO_M*(1.0 - rsd_genparam[rgroup].por);	// m3
						double bur_mass = bur_vol * rsd_param[rgroup*NumSed+ii].rho/CM3_TO_M3;	//(mg/l)*m3
						if (rsd_genparam[rgroup].burial > 0)
						{
							bur_rate = rsd_genparam[rgroup].burial*deltd*0.0254; // burial rate of the total sediment (m/timestep)
							bur_vol = bur_rate * pReachInfo[nIndex].length*MILE_TO_METER * rsd_genparam[rgroup].bedwid*FT_TO_M*(1.0 - rsd_genparam[rgroup].por);	// m3
							bur_mass = bur_vol*rhomn/CM3_TO_M3*frcsed_vol;//(mg/l)*m3
						}

						//set undefined temp value to 20 degc
						if (tw < -100.) tw = 20.0;

						double twide = 0.0;
						if (pReachInfo[nIndex].length > 0)
							twide = SA[nIndex] / (pReachInfo[nIndex].length * MILE_TO_FEET);	// ft
						
						double depmass = 0.;
						double scrmass = 0.;
//						if (pReachInfo[nIndex].lkfg <= 10)
							sandld(imat, vols0, SROVOL, vol0, EROVOL, ksand, avvele, expsnd,
								   rom, sandfg, db50e, HR[nIndex], slope, tw, wsande, twide, db50m,
								   fsl, avdepe, conc, rsed, rsed1, depscr, romat);

						//added (03-24-2014)
						if (depscr < 0)
							scrmass = -depscr;
						else
							depmass = depscr;
	
						//set small concentrations to zero
						if (fabs(conc) < 1.0E-15) 
						{
							//small conc., set to zero
							if (depscr > 0.0) 
							{
								//deposition has occurred, add small storage to deposition
								depscr += rsed;	// mg/l*m3	
								rsed1  += rsed;	// mg/l*m3
							}
							else
							{
								//add small storage to outflow
								romat += rsed;
								depscr = 0.0;
							}
							rsed = 0.0;
							conc = 0.0;
						}

						//remove the burial mass
						rsed1 -= bur_mass;
						if (rsed1 < 0)
							rsed1 = 0.0;

						sed2[nIndex*NumSed+ii]   = conc;			// mg/l
						matsed[nIndex*NumSed+ii] = romat;			// g
						rssed[nIndex*NumSed+ii]  = rsed;			// mg/l*m3
						rbsed[nIndex*NumSed+ii]  = rsed1;			// mg/l*m3
						vbsed[nIndex*NumSed+ii]  = rsed1/
							(rsd_param[rgroup*NumSed+ii].rho/CM3_TO_M3);// m3	
						sedbed[nIndex*NumSed+ii] = rsed1;
						rbsedtot[nIndex] += rsed1;
						vbsedtot[nIndex] += vbsed[nIndex*NumSed+ii];

						DEPSCR[1] += depscr;						// g
						RSED[1]   += rsed;							// mg/l*m3
						RSED[4]   += rsed1;							// mg/l*m3
						RSED[7]   += rsed+rsed1;					// mg/l*m3
						ROSED[1]  += matsed[nIndex*NumSed+ii];		// g
						SSED[1]   += conc;							// mg/l

						DEPSCR[4] += depscr;						// g
						ROSED[4]  += matsed[nIndex*NumSed+ii];		// g
						SSED[4]	  += conc;							// mg/l
						RSED[10]  += rsed+rsed1;					// mg/l*m3

						for (int jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)			 
						{
							if (q2[nIndex] > 0.0) 
							  pChannelInfo[nIndex].down_matsed[jk*NumSed+ii] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matsed[nIndex*NumSed+ii];		// g
							else
							  pChannelInfo[nIndex].down_matsed[jk*NumSed+ii]= 0.0;
						}

						// apply reduction (01-05-06)
						if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
						{
							double romatsum = 0.0;
							for (int j1=0; j1<ncrchOutlets; j1++)
							{
								if (pChannelInfo[nIndex].rchid == pBMPReduction[j1].rchid)
								{
									for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
									{
										if (pMON_SWITCH[j1+j2].nSwitch[mon] == 0)
											continue;

										double limit = pBMPLimit[j1+j2].fLimit_qual[nQuals+0];	// mg/l
										double fConc = 0.0;
										if (pChannelInfo[nIndex].down_flow[j2] > 0)
											fConc = pChannelInfo[nIndex].down_matsed[j2*NumSed+ii]/(pChannelInfo[nIndex].down_flow[j2]*FT3_TO_M3*delts);
										if (limit >= 0 &&  fConc > limit)	
											pChannelInfo[nIndex].down_matsed[j2*NumSed+ii] = limit*pChannelInfo[nIndex].down_flow[j2]*FT3_TO_M3*delts;

										pChannelInfo[nIndex].down_matsed[j2*NumSed+ii] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQuals+0]); 

										romatsum += pChannelInfo[nIndex].down_matsed[j2*NumSed+ii];
									}
									break;
								}
							}
							matsed[nIndex*NumSed+ii] = romatsum;
						}

						// for stream summary (english ton)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							depscr_ss[nIndex*NumSed+ii] += depscr * GRAM_TO_TONS;			
							depmass_ss[nIndex*NumSed+ii] += depmass * GRAM_TO_TONS;			
							scrmass_ss[nIndex*NumSed+ii] += scrmass * GRAM_TO_TONS;			
							for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								pChannelInfo[nIndex].down_matsed_s[j2*NumSed+ii] += pChannelInfo[nIndex].down_matsed[j2*NumSed+ii] * GRAM_TO_TONS;	 
								pChannelInfo[nIndex].bypass_matsed_s[j2*NumSed+ii] += pChannelInfo[nIndex].bypass_matsed[j2*NumSed+ii] * GRAM_TO_TONS;	 
							}
						}

						//find total volume of sediment
						if (rsd_param[rgroup*NumSed+ii].rho > 0)
							//volumesed += rsed1/(rsd_param[rgroup*NumSed+ii].rho/CM3_TO_M3);	// m3
							volumesed += (rsed1/rsd_param[rgroup*NumSed+ii].rho)*CM3_TO_M3;	// m3
						
						// +++++++ output parameters +++++++

						ssedc_s[nIndex*NumSed+ii] += sed2[nIndex*NumSed+ii];	
						ssed_s[nIndex] += sed2[nIndex*NumSed+ii];	

//						if (q2[nIndex] > 0 && delts > 0 )
//						{
//							rossedc_s[nIndex*NumSed+ii] += (matsed[nIndex*NumSed+ii]) / (q2[nIndex]*FT3_TO_M3*delts);	// conc (mg/l)
//							rossed_s[nIndex] += (matsed[nIndex*NumSed+ii]) / (q2[nIndex]*FT3_TO_M3*delts);	// conc (mg/l)
//						}

						rsed_s[nIndex] += sedbed[nIndex*NumSed+ii]*GRAM_TO_TONS;	// english tons
						rbedsed_s[nIndex*NumSed+ii] += sedbed[nIndex*NumSed+ii]*GRAM_TO_TONS;	// english tons
						rdepscr_s[nIndex*NumSed+ii] += depscr*GRAM_TO_TONS;						// english tons
						depscr_s[nIndex] += depscr*GRAM_TO_TONS;					// english tons
						rosed1_s[nIndex*NumSed+ii] += matsed[nIndex*NumSed+ii]*GRAM_TO_TONS;	// english tons	
						rosed_s[nIndex] += matsed[nIndex*NumSed+ii]*GRAM_TO_TONS;	// english tons	
					}
				}

				//find total depth of sediment

				//allow for porosity
				volumesed/=(1.0 - rsd_genparam[rgroup].por);		// m3
				//calculate thickness of bed-  m
				double sedbeddep = 0.0;	// m
				if (pReachInfo[nIndex].length > 0 && rsd_genparam[rgroup].bedwid > 0)
					sedbeddep = volumesed/(pReachInfo[nIndex].length*MILE_TO_METER*rsd_genparam[rgroup].bedwid*FT_TO_M);	// m

				// +++++++ output parameters +++++++

				beddep_s[nIndex] += sedbeddep/FT_TO_M; // ft
				tau_s[nIndex]   += tau;
			}				
			
			// ++++++++ GQUAL general water quality constituents ++++++++

			if(pqalfg == 1)
			{
				for(int ii=0; ii<nQuals; ii++)
				{
					double mber = 0.0;
					double mup = 0.0;
					double mup_bypass = 0.0;
					double mland = 0.0;
					double mland_bypass = 0.0;
					double mpt = 0.0;
					double mptwd_target = 0.0;
					double mirwd = 0.0;
					double mpswd = 0.0;
					double imat = 0.0;
					double TOT1 = 0.0;
					double TOT2 = 0.0;
					double TOT3 = 0.0;
					double sedq_pswd_target[] = {0.,0.,0.,0.};	// 0 is dummy, 1 sand, 2 silt and 3 clay
					double mlink = 0.0;
					double depmass = 0.0;
					double scrmass = 0.0;

					double ADDCPM[5];		// 1-4  DecaySS, TempSS, DecayBS, TempBS
					for (j=0; j<5; j++)
						ADDCPM[j] = 0.0;
											
					double ADPM1[7],ADPM2[7],ADPM3[7],SQAL[7];	// 1-6	SandSS, SiltSS, ClaySS, SandBS, SiltBS, ClayBS
					for (j=0; j<7; j++)
					{
						ADPM1[j] = 0.0;
						ADPM2[j] = 0.0;
						ADPM3[j] = 0.0;
						SQAL[j]  = 0.0;
					}

					// 0 is dummy 1-12	SandSS, SiltSS, ClaySS, TotalSS, 
					// SandBS, SiltBS, ClayBS, TotalBS, 
					// TotSand, TotSilt, TotClay, Total
					double RSQAL[13];	
					for (j=0; j<13; j++)
						RSQAL[j] = 0.0;
					
					// 0 is dummy, 1-4 sand, silt, clay, and total
					double DSQAL[5],ROSQAL[5];	
					for (j=0; j<5; j++)
					{
						DSQAL[j] = 0.0;
						ROSQAL[j] = 0.0;
					}

					int qsdfg = pQual[lgroup*nQuals+ii].qsdfg;
					int rqsdfg = pQualwq[rgroup*nQuals+ii].qsdfg;
					if (rqsdfg > 0 && sedfg == 1) 
					{
						//constituent is sediment-associated-

						//table-type gq-seddecay
						//convert rates from /day to /ivl
						ADDCPM[1] = pGQ_SEDDECAY[rgroup*nQuals+ii].addcpm[0]*delt60/24.0;
						ADDCPM[2] = pGQ_SEDDECAY[rgroup*nQuals+ii].addcpm[1];
						ADDCPM[3] = pGQ_SEDDECAY[rgroup*nQuals+ii].addcpm[2]*delt60/24.0;
						ADDCPM[4] = pGQ_SEDDECAY[rgroup*nQuals+ii].addcpm[3];

						//adsorption/desorption parameters

						//table-type gq-kd (l/mg)
						for (int jj=1; jj<7; jj++)
							ADPM1[jj] = pGQ_KD[rgroup*nQuals+ii].adpm[jj-1];

						//table-type gq-adrate
						//convert rates from /day to /ivl
						for (jj=1; jj<7; jj++)
							ADPM2[jj] = pGQ_ADRATE[rgroup*nQuals+ii].adpm[jj-1]*delt60/24.0;

						//table-type gq-adtheta (unit none)
						for (jj=1; jj<7; jj++)
							ADPM3[jj] = pGQ_ADTHETA[rgroup*nQuals+ii].adpm[jj-1];

						//table-type gq-sedconc (mg/mg)
						if (sedfg == 1)
						{
							for (jj=1; jj<7; jj++)
								SQAL[jj] = CSQAL[nIndex*nQuals*6+ii*6+(jj-1)];
						}

						//find the total quantity of material on various forms of sediment (g)
						for (jj=1; jj<4; jj++)
						{
							RSQAL[jj]   = SQAL[jj]*RSED1[jj];		// g 
							RSQAL[jj+4] = SQAL[jj+3]*RSED1[jj+3];	// g 
							RSQAL[jj+8] = RSQAL[jj]+RSQAL[jj+4];
							TOT1 += RSQAL[jj];
							TOT2 += RSQAL[jj+4];
							TOT3 += RSQAL[jj+8];
						}

						RSQAL[4] = TOT1;
						RSQAL[8] = TOT2;
						RSQAL[12]= TOT3;
					}
					else
					{
						//qual not sediment-associated (g)
						RSQAL[12]= 0.0;
					}

					//find total quantity of qual in the rchres (lb)
					if (sedfg == 1)
					{
						RDQAL[nIndex*nQuals+ii] = conc_dis[nIndex*nQuals+ii]*vol[nIndex];		
						RRQAL[nIndex*nQuals+ii] = RDQAL[nIndex*nQuals+ii] + RSQAL[12]/LBS_TO_GRAM;	
					}

					int adfxfg = 0;
					int adcnfg = 0;
					double adflx = 0.0;
					double adcnc = 0.0;
					double *adfxmn = NULL;
					double *adcnmn = NULL;
					double unit = 1/LB_FT3_TO_MG_L;  // mg/l -> lb/ft^3   
					double adfxfx = 0.0; 
					double adcnfx = 0.0;
					double adtot = 0.0;

					// check if admospheric deposition option is on
					if (adfgrch > 0)
					{
						adfxfg = maddfgrch;
						adcnfg = mawdfgrch;
						adflx = pQualwq[rgroup*nQuals+ii].addc;
						adcnc = pQualwq[rgroup*nQuals+ii].awdc;
						if(pMDDrch != NULL)
							adfxmn = pMDDrch[rgroup*nQuals+ii].fnum;
						if(pMWDrch != NULL)
							adcnmn = pMWDrch[rgroup*nQuals+ii].fnum;
						//dry deposition	(lb/acre/ivl)
						if (adfxfg > 0) 
							//dry flux is taken from monthly values
							adfxfx = dayval(&adfxmn[mon],&adfxmn[nxtmon],&day,&ndays) * (delt60 / 24.0);
						else
							adfxfx = adflx * (delt60 / 24.0);
       
						//wet deposition	(lb/acre/ivl)
						if (adcnfg > 0) 
							//wet deposition concentration is taken from monthly values
							adcnfx = prec_p[nIndex] * dayval(&adcnmn[mon],&adcnmn[nxtmon],&day,&ndays) * unit * IN_ACRE_TO_FT3;
						else
							adcnfx = prec_p[nIndex] * adcnc * unit * IN_ACRE_TO_FT3;	// in/ivl * mg/l * (mg/l -> lb/ft3) * (lb/ft3 -> lb/acre-in) --> lb/acre/ivl
       
						adtot = (adfxfx + adcnfx) * SA[nIndex] / ACRE_TO_FT2;	// - units are lb/ivl
					}

					// stream bank erosion
					if (sedfg == 1 && sedber == 1 && rqsdfg > 0 && pReachInfo[nIndex].lkfg == 0 )
					{
						double potfs = pQualwq[rgroup*nQuals+ii].potber;	// lb/ton-sediment

						// associate with scouring of soil matrix - units are qty/acre-ivl  
						if (ber_sd[nIndex] > 0.0)
							mber = ber_sd[nIndex] * GRAM_TO_TONS * potfs;	// from g/ivl to tons/ivl * lb/tons -> lb/ivl
					}

					// get the point source withdrawal if targeted to this stream
					if(pPSReduction != NULL && pPtWithDrawal != NULL)
					{
						for (int mm=0; mm<nPtWithDrawal; ++mm)
						{
							int nPSIndex = -1;
							if (pChannelInfo[nIndex].rchid == pPtWithDrawal[mm].targetrchid)
								nPSIndex = GetPSIndex(pPtWithDrawal[mm].wdrawlrchid,pPtWithDrawal[mm].strPermit,pPtWithDrawal[mm].strPipe);

							if (nPSIndex <0)
								continue;

							double wd_vol = - GetTargetWithDrawal(nPSIndex, tCurrent) * delts;	// ft3
							int nRIndex = FindReachIndex(pPtWithDrawal[mm].wdrawlrchid);

							if (wd_vol > v2[nRIndex])
								wd_vol = v2[nRIndex];

							mptwd_target += conc_dis[nRIndex*nQuals+ii] * wd_vol;	// lb/ivl
							
							if (sedfg == 1 && rqsdfg > 0)
							{
								for (int j3=0; j3<NumSed; ++j3)
								{
									if (sandfg == 0 && rsd_param[rgroup*NumSed+j3].sedflg == 0)
										continue;

									double sedmass = sed2[nRIndex*NumSed+j3] * wd_vol * FT3_TO_M3;	// g/ivl
									if (rsd_param[rgroup*NumSed+j3].sedflg == 0)	// sand
										sedq_pswd_target[1] += sedmass * CSQAL[nRIndex*nQuals*6+ii*6+0];// g/ivl	
									else if (rsd_param[rgroup*NumSed+j3].sedflg == 1)	// silt
										sedq_pswd_target[2] += sedmass * CSQAL[nRIndex*nQuals*6+ii*6+1];// g/ivl	
									else if (rsd_param[rgroup*NumSed+j3].sedflg == 2) // clay
										sedq_pswd_target[3] += sedmass * CSQAL[nRIndex*nQuals*6+ii*6+2];// g/ivl	
								}
							}
						}
					}

					// upstream routed and bypassed load
					nNum = pChannelInfo[nIndex].cListUppersOrder.GetSize();
					if(nNum > 0)
					{
						for(int j2=0; j2<nNum; j2++)
						{
							int nUpperReach = pChannelInfo[nIndex].cListUppersOrder.GetAt(j2);
							if(nUpperReach < 0 || nUpperReach >= nsws)
							{
								AfxMessageBox("Wrong NETWORK");
								goto L001;
							}
							else																	 
							{
								for (int j3=0; j3<pChannelInfo[nUpperReach].nDSchan; j3++)
								{
									if (pChannelInfo[nIndex].rchid == pChannelInfo[nUpperReach].down_ch[j3])
									{
										mup += pChannelInfo[nUpperReach].down_matqal[j3*nQuals+ii];
										mup_bypass += pChannelInfo[nUpperReach].bypass_matqal[j3*nQuals+ii];
									}
								}
							}
						}
					}

					// Get load from land (lb/ivl)
//					mland = f_poqual[nIndex*nQuals+ii];
					mland = f_poqual_route[nIndex*nQuals+ii];

					if (qsdfg == 1 && sedfg == 1 && rqsdfg > 0)	// if adsdes in stream then seperate sediment associated qual
						mland -= f_posqual_route[nIndex*nQuals+ii];
//						mland -= f_posqual[nIndex*nQuals+ii];

					// bypass load to downstream channel(s)
					mland_bypass = f_poqual_bypass[nIndex*nQuals+ii];

					if (qsdfg == 1 && sedfg == 1 && rqsdfg > 0)	// if adsdes in stream then seperate sediment associated qual
						mland_bypass -= f_posqual_bypass[nIndex*nQuals+ii];

					for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
						pChannelInfo[nIndex].bypass_matqal[j*nQuals+ii] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

//					mland -= mland_bypass;	// mland includes the bypass portion

					int pqualid = pQual[lgroup*nQuals+ii].qualid;
					int sqalfg = 0;	// get total load
					if (rqsdfg > 0 && sedfg == 1 && PSLOADSED[4] > 0)
						sqalfg = 1;	// get dissolved load 
					double pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
					pload *= delt60;	// lb/hr to lb/timestep					      
					mpt = pload;		// input load in lb  

					double conc = conc_dis[nIndex*nQuals+ii];			
					double romat = 0.0;

					// irrigation withdrawal (lb/ivl)
					mirwd = conc * delts * irrwithdrawal;	 

					// pointsource withdrawal (lb/ivl)
					mpswd = conc * delts * ptwithdrawal;	 

					// linkage files
					if (nLinkFiles > 0)
					{
						if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
						{
							POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
							while (pos != NULL)
							{
								Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
								mlink += plink435.pLinkData[i].pQual[ii]; //lb
							}
						}
					}

					imat = adtot + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink; // lb/ivl	
					
					//imat = max(0, imat);	//avoid negative value

					// for stream summary (lb)
					if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
					{
						if (sedfg == 1 && sedber == 1 && rqsdfg > 0 && pReachInfo[nIndex].lkfg == 0)
							berqual_s[nIndex*nQuals+ii] += mber;			
						usqual_s[nIndex*nQuals+ii] += (mup+mlink);			
						luqual_s[nIndex*nQuals+ii] += mland;			
						usqualbp_s[nIndex*nQuals+ii] += mup_bypass;			
						luqualbp_s[nIndex*nQuals+ii] += mland_bypass;			
						if (nPtSource > 0)
						{
							psqual_s[nIndex*nQuals+ii] += mpt;		
							pswdqual_s[nIndex*nQuals+ii] += mpswd;	
							pswdqualdi_s[nIndex*nQuals+ii] += mptwd_target;	
						}
						if (irrigfg == 1)
							irwdqual_s[nIndex*nQuals+ii] += mirwd;	

						adtot_s[nIndex*nQuals+ii] += adtot;			
						iqual_s[nIndex*nQuals+ii] += imat;			
					}

					advect(admod, volt, &imat, &vols[nIndex], &ros, &vol[nIndex], &ro,
						   &conc, &romat, delts, &js, crrat);

					matout[nIndex*nQuals+ii] = romat; // lb/interval

					for (int jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)			 
					{
						if (q2[nIndex] > 0.0) 
						  pChannelInfo[nIndex].down_matqal[jk*nQuals+ii] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matout[nIndex*nQuals+ii];	// lb
						else
						  pChannelInfo[nIndex].down_matqal[jk*nQuals+ii] = 0.0;
					}

					double twat = 15.5;	// default (degree C)
					if (tempfg == 1)
					{
						// adjust decay rate based on temperature of water (tw)
						twat = temp2[nIndex];	// degree C

						if (twat <= -10)	
							twat = 20.0;
						//correct unrealistically high values
						if (twat > 50)	
							twat = 50.0;
					}

					//this number is used to adjust reaction rates for temperature
					double tw20= twat - 20.0;

					if (avdepe > 0.17 && pReachInfo[nIndex].lkfg <= 10) 
					{
						//simulate decay of dissolved material
						if (conc > 1.0E-25) 
						{
							//simulate decay at 20 degree C per interval
							double da1 = pQualwq[rgroup*nQuals+ii].fstdec*deltd;	  
							double tcdecay = pQualwq[rgroup*nQuals+ii].thfst;
							//if (tempfg == 1)
								da1 *= pow(tcdecay,tw20);

							//calculate the total change in material due to decay-units are
							//conc*vol/l.ivl
							//conc *= (1.0 - exp(-da1));
							conc *= exp(-da1);	// lb/ft3

							//conc = conc*(1.0 - 0.5*da1)/(1 + 0.5*da1);  //lb/ft3  
							if(conc < 0) conc = 0;
						}
						else
						{
							//too little dissolved material to simulate decay
						}
					}
					else
					{
						 //rchres depth is less than two inches - dissolved decay
						 //is not considered
					}

					if (rqsdfg > 0 && sedfg == 1 && pReachInfo[nIndex].lkfg <= 10) 
					{
						//this constituent is associated with sediment

						// get load from the point sources
						double sedq_point[] = {0.,0.,0.,0.};	// 0 is dummy, 1 sand, 2 silt and 3 clay
						int pqualid = pQual[lgroup*nQuals+ii].qualid;
						int sqalfg = 2;		// get sediment associated load
						double pload = 0.0;
						if (PSLOADSED[4] > 0)
							pload = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
						pload *= delt60;	// lb/hr to lb/timestep					      

						for (j=1; j<4; j++)
						{
							if (PSLOADSED[4] > 0)
								sedq_point[j] = PSLOADSED[j]/PSLOADSED[4]*pload;
						}

						// Get load from land (lb/ivl)
						double sedq_land_route[4] = {0.,0.,0.,0.};	// 0 is dummy, 1 sand, 2 silt and 3 clay
						double sedq_land_bypass[4] = {0.,0.,0.,0.};	// 0 is dummy, 1 sand, 2 silt and 3 clay

						if (qsdfg == 1)
						{
							// if adsdes in stream then seperate sediment associated qual
							for (int j2=0; j2<nlandp; ++j2)
							{
								int nOrder1 = nIndex*nlandp*3+j2*3;
								int nOrder5 = nIndex*nlandp*nQuals+j2*nQuals;
								double lfAREA = pluinfop[nIndex*nlandp+j2].area;
								if (cLU.nLUchangeFlag == 1 && pluinfop[nIndex*nlandp+j2].bLUchange == true)
									lfAREA = cLU.GetLanduseArea(tCurrent,&pluinfop[nIndex*nlandp+j2]);
								double sedqload = soqs_p[nOrder5+ii]*lfAREA;
								
								for (int j3=0; j3<NumSed; ++j3)
								{
									if (sandfg == 0 && rsd_param[rgroup*NumSed+j3].sedflg == 0)
										continue;

									if (rsd_param[rgroup*NumSed+j3].sedflg == 0)
									{
										// apply TMDL reduction to sand associated qual load 
										double multiplier = 1.0;
										if (pSedControls != NULL && pQualControls != NULL && ncland > 0)
											multiplier = pSedControls[nOrder1+0]*pQualControls[nOrder5+ii];
										sedq_land_route[1] += sedqload*psd_param2[lgroup*nlandp+j2].sed[j3]*multiplier*pLURoute[lgroup*nlandp+j2].route_suro; 
										sedq_land_bypass[1] += sedqload*psd_param2[lgroup*nlandp+j2].sed[j3]*multiplier*pLURoute[lgroup*nlandp+j2].bypass_suro; 
									}
									else if (rsd_param[rgroup*NumSed+j3].sedflg == 1)
									{
										// apply TMDL reduction to silt 
										double multiplier = 1.0;
										if (pSedControls != NULL && pQualControls != NULL && ncland > 0)
											multiplier = pSedControls[nOrder1+1]*pQualControls[nOrder5+ii];
										sedq_land_route[2] += sedqload*psd_param2[lgroup*nlandp+j2].sed[j3]*multiplier*pLURoute[lgroup*nlandp+j2].route_suro; 
										sedq_land_bypass[2] += sedqload*psd_param2[lgroup*nlandp+j2].sed[j3]*multiplier*pLURoute[lgroup*nlandp+j2].bypass_suro; 
									}
									else if (rsd_param[rgroup*NumSed+j3].sedflg == 2) 
									{
										// apply TMDL reduction to clay
										double multiplier = 1.0;
										if (pSedControls != NULL && pQualControls != NULL && ncland > 0)
											multiplier = pSedControls[nOrder1+2]*pQualControls[nOrder5+ii];
										sedq_land_route[3] += sedqload*psd_param2[lgroup*nlandp+j2].sed[j3]*multiplier*pLURoute[lgroup*nlandp+j2].route_suro; 
										sedq_land_bypass[3] += sedqload*psd_param2[lgroup*nlandp+j2].sed[j3]*multiplier*pLURoute[lgroup*nlandp+j2].bypass_suro; 
									}
								}
							}
						}

						// load from bank erosion (lb/ivl)
						double sedq_ber[] = {0.,0.,0.,0.};	// 0 is dummy, 1 sand, 2 silt and 3 clay
						
						if (sedber == 1)
						{
							for (int j3=0; j3<NumSed; ++j3)
							{
								if (sandfg == 0 && rsd_param[rgroup*NumSed+j3].sedflg == 0)
									continue;

								if (rsd_param[rgroup*NumSed+j3].sedflg == 0)
								{
									// sand 
									sedq_ber[1] = mber * rsd_berparam[nIndex].sed[j3];	
								}
								else if (rsd_param[rgroup*NumSed+j3].sedflg == 1)
								{
									// silt 
									sedq_ber[2] = mber * rsd_berparam[nIndex].sed[j3]; 
								}
								else if (rsd_param[rgroup*NumSed+j3].sedflg == 2) 
								{
									// clay
									sedq_ber[3] = mber * rsd_berparam[nIndex].sed[j3];
								}
							}
						}

						//zero the accumulators
						TOT1 = 0.0;
						TOT2 = 0.0;

						//repeat for each sediment size fraction
						for (j=1; j<4; j++)
						{
							if (j == 1 && sandfg == 0)
								continue;

							//get data on inflow of sediment-associated material
							double ISQAL = 0.0;
							mup   = 0.0;
							mup_bypass = 0.0;
							mland = 0.0;
							mland_bypass = 0.0;
							mpt   = 0.0;
							mirwd = 0.0;
							mpswd = 0.0;
					        mptwd_target = 0.0;
							mber  = 0.0;
							mlink = 0.0;

							// upstream
							nNum = pChannelInfo[nIndex].cListUppersOrder.GetSize();
							if(nNum > 0)
							{
								for(int j2=0; j2<nNum; j2++)
								{
									int nUpperReach = pChannelInfo[nIndex].cListUppersOrder.GetAt(j2);
									if(nUpperReach < 0 || nUpperReach >= nsws)
									{
										AfxMessageBox("Wrong NETWORK");
										goto L001;
									}
									else																	 
									{
										for (int j3=0; j3<pChannelInfo[nUpperReach].nDSchan; j3++)
										{
											if (pChannelInfo[nIndex].rchid == pChannelInfo[nUpperReach].down_ch[j3])
											{
												mup += pChannelInfo[nUpperReach].down_sedqal[j3*nQuals*3+ii*3+(j-1)];
												mup_bypass += pChannelInfo[nUpperReach].bypass_sedqal[j3*nQuals*3+ii*3+(j-1)];
											}
										}
									}
								}
							}

							// Get load from land (lb/ivl)
							mland = sedq_land_route[j];

							// Get load from land bypass (lb/ivl)
							mland_bypass = sedq_land_bypass[j];

							for (int jk=0; jk<pChannelInfo[nIndex].nDSchan; ++jk)
								pChannelInfo[nIndex].bypass_sedqal[jk*nQuals*3+ii*3+(j-1)] = mland_bypass * pReachFtable[nIndex].bypass_fr[jk];

//							mland -= mland_bypass;	// mland includes the bypass portion

							// get load from the point sources (lb/ivl)
							mpt = sedq_point[j];

							// get load from the bank erosion (lb/ivl)
							mber = sedq_ber[j];

							// irrigation withdrawal (g/ivl)
							mirwd = SQAL[j] * IRRWDSED[j];	 

							// pointsource withdrawal (g/ivl)
							mpswd = SQAL[j] * PSWDSED[j];	 
						
							// get load from the point withdrawal target (g/ivl)
							mptwd_target = sedq_pswd_target[j];

							// linkage files
							if (nLinkFiles > 0)
							{
								if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
								{
									POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
									while (pos != NULL)
									{
										Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
										mlink += plink435.pLinkData[i].pSedQual[ii*3+(j-1)]; //lb
									}
								}
							}

							ISQAL = (mup + mup_bypass + mland + mpt + mber) * LBS_TO_GRAM + mptwd_target - mirwd - mpswd + mlink;	// g/ivl

							//ISQAL = max(0, ISQAL);	//avoid negative value

							// update the total mass input to the reach
							imat += ISQAL/LBS_TO_GRAM;

							//advect this material, including calculation of deposition
							//and scour (all units are in g)
							ADVQAL(ISQAL,RSED[j],RSED[j+3],DEPSCR[j],ROSED[j],RSQAL[j],
								   RSQAL[j+4],SQAL[j],SQAL[j+3],DSQAL[j],ROSQAL[j]);

							if (ROSQAL[j] < 0)
								ROSQAL[j] = 0.0;

							matsedout[nIndex*nQuals*3+ii*3+(j-1)] = ROSQAL[j]/LBS_TO_GRAM;// lb/interval

							// update total mass leaving the reach
							matout[nIndex*nQuals+ii] += ROSQAL[j]/LBS_TO_GRAM; // lb/interval

							//we need to compute outflow through each individual exit
							for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)			 
							{
								if (fabs(ROSED[j]) > 0.0 && q2[nIndex] > 0.0) 
								  pChannelInfo[nIndex].down_sedqal[jk*nQuals*3+ii*3+(j-1)] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matsedout[nIndex*nQuals*3+ii*3+(j-1)];	// lb
								else
								  pChannelInfo[nIndex].down_sedqal[jk*nQuals*3+ii*3+(j-1)] = 0.0;
							}

							TOT1 += DSQAL[j];
							TOT2 += ROSQAL[j];
							
							//added (03-24-2014)
							if (DSQAL[j] < 0)
								scrmass += (-DSQAL[j]);
							else
								depmass += DSQAL[j];

							// for stream summary (lb)
							if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
							{
								if (sedfg == 1 && sedber == 1 && rqsdfg > 0 && pReachInfo[nIndex].lkfg == 0)
									berqual_s[nIndex*nQuals+ii] += mber;			
								usqual_s[nIndex*nQuals+ii] += (mup+mlink);			
								luqual_s[nIndex*nQuals+ii] += mland;			
								usqualbp_s[nIndex*nQuals+ii] += mup_bypass;			
								luqualbp_s[nIndex*nQuals+ii] += mland_bypass;			
								if (nPtSource > 0)
								{
									psqual_s[nIndex*nQuals+ii] += mpt;		
									pswdqual_s[nIndex*nQuals+ii] += mpswd/LBS_TO_GRAM;	
									pswdqualdi_s[nIndex*nQuals+ii] += mptwd_target/LBS_TO_GRAM;	
								}
								if (irrigfg == 1)
									irwdqual_s[nIndex*nQuals+ii] += mirwd/LBS_TO_GRAM;	

								iqual_s[nIndex*nQuals+ii] += ISQAL/LBS_TO_GRAM;			
							}
						}

						DSQAL[4] = TOT1;	//Deposition/scour of qual
						ROSQAL[4]= TOT2;

						double SQDEC[8];	// 1-7	gm
						for (j=0; j<8; j++)
							SQDEC[j] = 0.0;

						if (avdepe > 0.17) 
						{
							//simulate decay on suspended sediment (1-3)
							ADECAYSS(ADDCPM,tw20,RSED,SQAL,SQDEC);
						}
						else
						{
							//rchres depth is less than two inches - decay of qual
							//associated with suspended sediment is not considered
							for (j=1; j<4; j++)
								SQDEC[j] = 0.0;
						}

						//simulate decay on bed sediment (4-6)
						ADECAYBS(ADDCPM,tw20,RSED,SQAL,SQDEC);

						//get total decay
						double TOT= 0.0;

						for (j=1; j<7; j++)
							TOT= TOT + SQDEC[j];

						SQDEC[7] = TOT;		// gm

						double ADQAL[7];	// gm
						for (j=0; j<7; j++)
							ADQAL[j] = 0.0;

						if (avdepe > 0.17) 
						{
							//simulate exchange due to adsorption and desorption
							// convert conc from lb/ft3 to mg/l
							conc *= LB_FT3_TO_MG_L;

							ADSDES(VOL,RSED,ADPM1,ADPM2,ADPM3,tw20,conc,SQAL,ADQAL);
							
							// convert conc from mg/l to lb/ft3
							conc /= LB_FT3_TO_MG_L;
						}
						else
						{
							//rchres depth is less than two inches - adsorption and
							//desorption of qual is not considered
							for (j=1; j<8; j++)
								ADQAL[j] = 0.0;
						}

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							adqal_s[nIndex*nQuals+ii] += (ADQAL[4]+ADQAL[5]+ADQAL[6])/LBS_TO_GRAM;//total bed sediment qual (ads/des)			
							dsqal_s[nIndex*nQuals+ii] += DSQAL[4]/LBS_TO_GRAM;	//total sediment qual (dep/scr)			
							depqal_s[nIndex*nQuals+ii] += depmass/LBS_TO_GRAM;	//total sediment qual (dep/scr)			
							scrqal_s[nIndex*nQuals+ii] += scrmass/LBS_TO_GRAM;	//total sediment qual (dep/scr)			
						}
						//find total quantity of material on various forms of sediment
						TOT1= 0.0;
						TOT2= 0.0;
						TOT3= 0.0;

						for (j=1; j<4; j++)
						{
							if (j == 1 && sandfg == 0)
								continue;

							RSQAL[j]   = SQAL[j] * RSED[j];
							RSQAL[j+4] = SQAL[j+3] * RSED[j+3];
							RSQAL[j+8] = RSQAL[j] + RSQAL[j+4];
							TOT1 += RSQAL[j];
							TOT2 += RSQAL[j+4];
							TOT3 += RSQAL[j+8];
						}

						RSQAL[4] = TOT1;	// total suspended
						RSQAL[8] = TOT2;	// total in bed
						RSQAL[12]= TOT3;	// grand total
					}
					else
					{
						//qual constituent not associated with sediment-total just
						//above should have been set to zero by run interpreter
						RSQAL[12]= 0.0;
					}

					// update concentration
					conc_dis[nIndex*nQuals+ii] = conc;	// lb/ft^3
					conc_tot[nIndex*nQuals+ii] = conc;	// lb/ft^3

					if (sedfg == 1)
					{
						//find total quantity of qual in rchres (lb)
						RDQAL[nIndex*nQuals+ii] = conc*vol[nIndex];	
						RRQAL[nIndex*nQuals+ii] = RDQAL[nIndex*nQuals+ii] + RSQAL[12]/LBS_TO_GRAM;
						
						// update CSQAL (mg/mg)
						for (int jj=1; jj<7; jj++)
							CSQAL[nIndex*nQuals*6+ii*6+(jj-1)] = SQAL[jj];

						// total qual with suspended sediment and in dissolved phase (lb/ft3)
						if (vol[nIndex] > 0)
							conc_tot[nIndex*nQuals+ii] = (RDQAL[nIndex*nQuals+ii] + 
														  RSQAL[4]/LBS_TO_GRAM) / vol[nIndex];
					}

					// apply reduction (01-05-06)
					if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
					{
						double romatsum = 0.0;
						for (int j1=0; j1<ncrchOutlets; j1++)
						{
							if (pChannelInfo[nIndex].rchid == pBMPReduction[j1].rchid)
							{
								for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									if (pMON_SWITCH[j1+j2].nSwitch[mon] == 0)
										continue;

									double limit = pBMPLimit[j1+j2].fLimit_qual[ii] * 6.24279605761446E-05;	// mg/l to lb/ft3
									double fConc = 0.0;
									if (pChannelInfo[nIndex].down_flow[j2] > 0)
										fConc = pChannelInfo[nIndex].down_matqal[j2*nQuals+ii]/(pChannelInfo[nIndex].down_flow[j2]*delts);
									if (limit >= 0 &&  fConc > limit)	
										pChannelInfo[nIndex].down_matqal[j2*nQuals+ii] = limit*pChannelInfo[nIndex].down_flow[j2]*delts;

									pChannelInfo[nIndex].down_matqal[j2*nQuals+ii] *= (1 - pBMPReduction[j1+j2].fReduction_qual[ii]); 	
									romatsum += pChannelInfo[nIndex].down_matqal[j2*nQuals+ii];
									
									// apply reduction to sediment associated qual
									if (rqsdfg > 0 && sedfg == 1)
									{
										double downsedqual = 0.0;
										double reductionfr = 1.0;
										for (j=1; j<4; j++)
										{
											if (j == 1 && sandfg == 0)
												continue;

											downsedqual += pChannelInfo[nIndex].down_sedqal[j2*nQuals*3+ii*3+(j-1)];
										}
										fConc = downsedqual/(pChannelInfo[nIndex].down_flow[j2]*delts);
										if (limit >= 0 &&  fConc > limit)	
											reductionfr = limit/fConc;

										//repeat for each sediment size fraction
										for (j=1; j<4; j++)
										{
											if (j == 1 && sandfg == 0)
												continue;
											pChannelInfo[nIndex].down_sedqal[j2*nQuals*3+ii*3+(j-1)] *= reductionfr;
											pChannelInfo[nIndex].down_sedqal[j2*nQuals*3+ii*3+(j-1)] *= (1 - pBMPReduction[j1+j2].fReduction_qual[ii]); 	
											romatsum += pChannelInfo[nIndex].down_sedqal[j2*nQuals*3+ii*3+(j-1)];
										}
									}
								}
								break;
							}
						}
						matout[nIndex*nQuals+ii] = romatsum;
					}

					// for stream summary (lb)
					if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
					{
						for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
						{
							pChannelInfo[nIndex].down_matqal_s[j2*nQuals+ii] += pChannelInfo[nIndex].down_matqal[j2*nQuals+ii];	 	
							pChannelInfo[nIndex].bypass_matqal_s[j2*nQuals+ii] += pChannelInfo[nIndex].bypass_matqal[j2*nQuals+ii];	 
						}
					}

					// output variables
					conc_s[nIndex*nQuals+ii]   += conc_dis[nIndex*nQuals+ii];//lb/ft3	 
					matout_s[nIndex*nQuals+ii] += matout[nIndex*nQuals+ii];//lb
					matin_s[nIndex*nQuals+ii]  += imat;//lb

					for (j2=0; j2<4; j2++)
					{
						if (j2 == 0 && sandfg == 0)	// no sand simulation
							continue;

						// convert conc from g to lb
						matosqal_s[nIndex*nQuals*4+ii*4+j2] += ROSQAL[j2+1]/LBS_TO_GRAM;
					}

					for (j2=0; j2<8; j2++)
					{
						if ((j2 == 0 || j2 == 4) && sandfg == 0)	// no sand simulation
							continue;

						// convert conc from g to lb
						matsqal_s[nIndex*nQuals*8+ii*8+j2]  += RSQAL[j2+1]/LBS_TO_GRAM;
					}
				}
			}
			
			// ++++++++ RQUAL water quality constituents ++++++++
			if (oxfg == 1)
			{
				//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
				//		SUBROUTINE   RQUAL
				//
				//		+ + + PURPOSE + + +
				//		Simulate constituents involved in biochemical 
				//		transformations
				//
				//		+ + + EXTERNALS + + +
				//		OXRX,NUTRX,PLANK,PHCARB
				//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
				
				double SROVOL	= ros*FT3_TO_M3;					// ft^3/s to m^3/s
				double EROVOL	= ro*FT3_TO_M3;						// ft^3/s to m^3/s
				double VOLSP	= VOL;								// m^3
				double LEN = pReachInfo[nIndex].length*MILE_TO_FEET*FT_TO_M;	// m 
				double DELTH = LEN * pReachInfo[nIndex].slope;		// m
				int	   LKFG = pReachInfo[nIndex].lkfg;				// lkfg = 0 for reach 
				double WIND = wind_p[nIndex]*MILE_TO_METER;			// from mile/ivld to m/ivld;
				double CFPRES = cfpres;
				int    nPolType = 0;								// pollutant type identifier

				//convert average depth and average velocity to english units,
				double AVDEPE = avdepe;		// ft
				double AVVELE = avvele;		// ft/s

				double DEPCOR = 0;
				if (AVDEPE > 0.0) 
					//define conversion factor from mg/m2 to mg/l
					DEPCOR = 3.28084e-3/AVDEPE;
       
				double TW  = temp2[nIndex];	// degc	
				//set undefined temp value to 20 degc
				if (TW < -100.0)
				  TW= 20.0;

				//simulate primary do and bod balances
				// CALL OXRX
				//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
				//		SUBROUTINE   OXRX
				//
				//		+ + + PURPOSE + + +
				//		Simulate primary do, bod balances
				//
				//		+ + + EXTERNALS + + +
				//		ADVECT,SINK,OXBEN,OXREA,BODDEC
				//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
				
				// initialize 
				double DOBEN = 0;
				double BODBNR = 0;
				double BODOX = 0;
				double SNKBOD = 0;
				double KOREA = 0;
				double RODOX = 0;
				double ROBOD = 0;	
									
				// defined local variable 
				double READOX=0.,BODDOX=0.,BENDOX=0.,DECBOD=0.,BNRBOD=0.,BENOD=0.,
					   SCRVEL=0.,SCRFAC=0.;

				//0=dummy, 1=base release rate of BOD materials,
				//2=increment to bottom release rate due to decreasing
                //dissolved oxygen concentration
				double BRBOD[3];
				for (int j2=0; j2<3; j2++)
					BRBOD[j2] = 0.0;

				//Particulate NH4-N storages; 0=dummy, 1-3=suspended sand, silt, clay, 
				//4=total suspended, 5-7=bed sand, silt, clay,
				//8=total bed, 9-11=total sand, total silt, total clay, 12=grand total
				double RSNH4[13],RSPO4[13];
				for (int j3=0; j3<13; j3++)
				{
					RSNH4[j3] = 0.0;
					RSPO4[j3] = 0.0;
				}

				double NO3 = 0.0;
				double TAM = 0.0;
				double NO2 = 0.0;
				double PO4 = 0.0;
				double PHVAL = 7.0;
				double NH4 = 0.0;
				double NH3 = 0.0;
				double PHYTO = 0;	// mg/l
				double PHYCLA = 0;	// ug/l
				double BENAL = 0;	// mg/m2
				double ZOO = 0;		// mg/l
				double ORN = 0;		// mg/l
				double ORP = 0;		// mg/l
				double ORC = 0;		// mg/l
				double TORN = 0;	// mg/l
				double TORP = 0;	// mg/l
				double TORC = 0;	// mg/l
				double POTBOD = 0;

				//define constant param1
				//convert units from 1/hr to 1/ivl
				double KBOD20= ox_parm1[rgroup].kbod20*delt60;		// 1/ivld
				double KODSET= ox_parm1[rgroup].kodset*delt60;		// m/ivld
				double REAK = ox_parm1[rgroup].reak*delt60;			// 1/ivld
				double TCBOD = ox_parm1[rgroup].tcbod;				// none
				double TCGINV = ox_parm1[rgroup].tcginv;			// none
				double EXPRED = ox_parm1[rgroup].expred;			// none
				double EXPREV = ox_parm1[rgroup].exprev;			// none
				double SUPSAT = ox_parm1[rgroup].supsat;			// none

				//define constant param2
				double TCBEN = ox_parm2[rgroup].tcben;				// none
				double EXPOD = ox_parm2[rgroup].expod;				// none
				double EXPREL = ox_parm2[rgroup].exprel;			// none

				if (benrfg == 1) 
				{
					//get benthic release parms - table-type ox-benparm
					//convert units from 1/hr to 1/ivl
					BENOD = ox_parm2[rgroup].benod*delt60;			// mg/m2/ivld
					BRBOD[1] = ox_parm2[rgroup].brbod*delt60;		// mg/m2/ivld
					BRBOD[2] = ox_parm2[rgroup].brbod_inc*delt60;	// mg/m2/ivld
					//calculate scouring factor
					SCRVEL = scour_parms[rgroup].scrvel/FT_TO_M;		// ft/s
					if (AVVELE > SCRVEL) 
						SCRFAC= scour_parms[rgroup].scrmul;			// none
					else
						//adjustment for scouring is not necessary
						SCRFAC= 1.0;
				}
				else
				{
					BENOD = 0.0;				// mg/m2/ivld
					BRBOD[1] = 72.0*delt60;		// mg/m2/ivld
					BRBOD[2] = 100.0*delt60;	// mg/m2/ivld
				}

				//get general parameters - these always required
				//table-type ox-genparm

				double DOX  = dox[nIndex];		// mg/l
				double RDOX = DOX* VOLSP;		// mg/l*m3
				double BOD  = bod[nIndex];		// mg/l
				double RBOD = BOD* VOLSP;		// mg/l*m3
				double SATDO = satdo[nIndex];	// mg/l
				
				// stream summary
				int nNumRqual = 11;

				// atmospheric deposition (8-19-2013)
				int adfxfg = 0;
				int adcnfg = 0;
				double adflx = 0.0;
				double adcnc = 0.0;
				double *adfxmn = NULL;
				double *adcnmn = NULL;
				double unit = 1/16018.4633739601;  // mg/l -> lb/ft3   
				double adfxfx = 0.0; 
				double adcnfx = 0.0;
				double adtot = 0.0;
				double ADTOT[7];
				for (j3=0; j3<7; j3++)
				{
					ADTOT[j3] = 0.0;
				}

				// check if atmospheric deposition option is on
				if (adfgrch > 0)
				{
					adfxfg = maddfgrch;
					adcnfg = mawdfgrch;

					for(int ii=0; ii<nQuals; ii++)
					{
						adflx = pQualwq[rgroup*nQuals+ii].addc;
						adcnc = pQualwq[rgroup*nQuals+ii].awdc;
						if(pMDDrch != NULL)
							adfxmn = pMDDrch[rgroup*nQuals+ii].fnum;
						if(pMWDrch != NULL)
							adcnmn = pMWDrch[rgroup*nQuals+ii].fnum;
						//dry deposition	(lb/acre/ivl)
						if (adfxfg > 0) 
							//dry flux is taken from monthly values
							adfxfx = dayval(&adfxmn[mon],&adfxmn[nxtmon],&day,&ndays) * (delt60 / 24.0);
						else
							adfxfx = adflx * (delt60 / 24.0);
   
						//wet deposition	(lb/acre/ivl)
						if (adcnfg > 0) 
							//wet deposition concentration is taken from monthly values
							adcnfx = prec_p[nIndex] * dayval(&adcnmn[mon],&adcnmn[nxtmon],&day,&ndays) * unit * 3630;
						else
							adcnfx = prec_p[nIndex] * adcnc * unit * 3630;	// in/ivl * mg/l * (mg/l -> lb/ft3) * (lb/ft3 -> lb/acre-in) --> lb/acre/ivl
						
						adtot = (adfxfx + adcnfx) * SA[nIndex] / 43560.0;	// - units are lb/ivl

						ADTOT[0] += adtot * atms_mapp[rgroup*nQuals+ii].bod;
						ADTOT[1] += adtot * atms_mapp[rgroup*nQuals+ii].nox;
						ADTOT[2] += adtot * atms_mapp[rgroup*nQuals+ii].tam;
						ADTOT[3] += adtot * atms_mapp[rgroup*nQuals+ii].po4;
						ADTOT[4] += adtot * atms_mapp[rgroup*nQuals+ii].orn;
						ADTOT[5] += adtot * atms_mapp[rgroup*nQuals+ii].orp;
						ADTOT[6] += adtot * atms_mapp[rgroup*nQuals+ii].orc;
					}
				}				

				// DOX
				double mup = 0.0;
				double mup_bypass = 0.0;
				double mland = 0.0;
				double mland_bypass = 0.0;
				double mpt = 0.0;
				double mptwd_target = 0.0;
				double mirwd = 0.0;
				double mpswd = 0.0;
				double imat = 0.0;
				double mlink = 0.0;

				// get the point source withdrawal if targeted to this stream
				mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,dox,tCurrent);

				// upstream routed and bypassed load
				nPolType = POLUT_DOX;
				if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
					goto L001;

				// from land
				mland = pdox_route[nIndex];	// gram

				// bypass load to downstream channel(s)
				mland_bypass = pdox_bypass[nIndex];
				for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
					pChannelInfo[nIndex].bypass_dox[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

//				mland -= mland_bypass;

				// from point sources
				int pqualid = PS_DOX;
				int sqalfg = 0;		// get total load
				double pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
				pload *= delt60;     // lb/hr to lb/timestep					    
				mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld 

				double DPDOX = DOX;			// mg/l

				// irrigation withdrawal 
				mirwd = DPDOX * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

				// pointsource withdrawal 
				mpswd = DPDOX * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

				// linkage files
				if (nLinkFiles > 0)
				{
					if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
					{
						POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
						while (pos != NULL)
						{
							Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
							mlink += plink435.pLinkData[i].dox; //g
						}
					}
				}

				imat = mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

				//imat = max(0, imat);	//avoid negative value

				// for stream summary (lb)
				if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
				{
					usrqual_s[nIndex*nNumRqual+0] += (mup+mlink) / LBS_TO_GRAM;			
					lurqual_s[nIndex*nNumRqual+0] += mland / LBS_TO_GRAM;			
					atmsrqual_s[nIndex*nNumRqual+0] = 0;			
					usrqualbp_s[nIndex*nNumRqual+0] += mup_bypass / LBS_TO_GRAM;			
					lurqualbp_s[nIndex*nNumRqual+0] += mland_bypass / LBS_TO_GRAM;			
					if (nPtSource > 0)
					{
						psrqual_s[nIndex*nNumRqual+0] += mpt / LBS_TO_GRAM;		
						pswdrqual_s[nIndex*nNumRqual+0] += mpswd / LBS_TO_GRAM;	
						pswdrqualdi_s[nIndex*nNumRqual+0] += mptwd_target / LBS_TO_GRAM;	
					}
					if (irrigfg == 1)
						irwdrqual_s[nIndex*nNumRqual+0] += mirwd / LBS_TO_GRAM;
					
					irqual_s[nIndex*nNumRqual+0] += imat / LBS_TO_GRAM;			
				}

				double IDOX = imat;		// gram

				//advect dissolved oxygen
				advect(admod, VOLT, &IDOX, &VOLS, &SROVOL, &VOL, &EROVOL, &DPDOX, &RODOX,
					   delts, &js, crrat);
			
				dox[nIndex] = DPDOX;		// mg/l
				matdox[nIndex] = RODOX;		//gram

				for (int jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
				{
					if (q2[nIndex] > 0.0) 
					  pChannelInfo[nIndex].down_dox[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matdox[nIndex];
					else
					  pChannelInfo[nIndex].down_dox[jk]= 0.0;
				}

				// apply reduction (01-05-06)
				if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
					matdox[nIndex] = GetBMPReductionLoad(nPolType,nQuals+4,nIndex,mon,delts);

				// for stream summary (lb)
				if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
				{
					for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
					{
						pChannelInfo[nIndex].down_dox_s[j2] += pChannelInfo[nIndex].down_dox[j2] / LBS_TO_GRAM;
						pChannelInfo[nIndex].bypass_dox_s[j2] += pChannelInfo[nIndex].bypass_dox[j2] / LBS_TO_GRAM;
					}
				}

				DOX = dox[nIndex];	// mg/l

				// BOD
				mup = 0.0;
				mup_bypass = 0.0;
				mland = 0.0;
				adtot = 0.0;
				mland_bypass = 0.0;
				mpt = 0.0;
				mptwd_target = 0.0;
				mirwd = 0.0;
				mpswd = 0.0;
				imat = 0.0;
				mlink = 0.0;

				// get the point source withdrawal if targeted to this stream
				mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,bod,tCurrent);

				// upstream routed and bypassed load
				nPolType = POLUT_BOD;
				if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
					goto L001;

				// from land BOD
//				mland = f_roqual[nIndex*13+0]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
//				f_roqual[nIndex*13+0] = 0.0;
				mland = f_roqual_route[nIndex*13+0]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
				f_roqual_route[nIndex*13+0] = 0.0;

				mland_bypass = f_roqual_bypass[nIndex*13+0]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
				for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
					pChannelInfo[nIndex].bypass_bod[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

				f_roqual_bypass[nIndex*13+0] = 0.0;

//				mland -= mland_bypass;

				// from atmosphere
				adtot = ADTOT[0]*453.5924;	// from lb/ivld to gram/ivld

				//from point sources
				pqualid = PS_BOD;
				sqalfg = 0;		// get total load
				pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
				pload *= delt60;     // lb/hr to lb/timestep					    
				mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld 

				double DPBOD = BOD;	// mg/l

				// irrigation withdrawal 
				mirwd = DPBOD * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

				// pointsource withdrawal 
				mpswd = DPBOD * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

				// linkage files
				if (nLinkFiles > 0)
				{
					if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
					{
						POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
						while (pos != NULL)
						{
							Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
							mlink += plink435.pLinkData[i].bod; //g
						}
					}
				}

				imat = adtot + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

				//imat = max(0, imat);	//avoid negative value

				// for stream summary (lb)
				if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
				{
					usrqual_s[nIndex*nNumRqual+1] += (mup+mlink) / LBS_TO_GRAM;			
					lurqual_s[nIndex*nNumRqual+1] += mland / LBS_TO_GRAM;			
					atmsrqual_s[nIndex*nNumRqual+1] += adtot / LBS_TO_GRAM;			
					usrqualbp_s[nIndex*nNumRqual+1] += mup_bypass / LBS_TO_GRAM;			
					lurqualbp_s[nIndex*nNumRqual+1] += mland_bypass / LBS_TO_GRAM;			
					if (nPtSource > 0)
					{
						psrqual_s[nIndex*nNumRqual+1] += mpt / LBS_TO_GRAM;		
						pswdrqual_s[nIndex*nNumRqual+1] += mpswd / LBS_TO_GRAM;	
						pswdrqualdi_s[nIndex*nNumRqual+1] += mptwd_target / LBS_TO_GRAM;	
					}
					if (irrigfg == 1)
						irwdrqual_s[nIndex*nNumRqual+1] += mirwd / LBS_TO_GRAM;	
					irqual_s[nIndex*nNumRqual+1] += imat / LBS_TO_GRAM;			
				}

				double IBOD = imat;		// grams

				//advect bod
				advect(admod, VOLT, &IBOD, &VOLS, &SROVOL, &VOL, &EROVOL, &DPBOD, &ROBOD,
					   delts, &js, crrat);

				bod[nIndex] = DPBOD;		// mg/l
				matbod[nIndex] = ROBOD;		// g/ivld

				for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
				{
					if (q2[nIndex] > 0.0) 
					  pChannelInfo[nIndex].down_bod[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matbod[nIndex];
					else
					  pChannelInfo[nIndex].down_bod[jk]= 0.0;
				}

				// apply reduction (01-05-06)
				if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
					matbod[nIndex] = GetBMPReductionLoad(nPolType,nQuals+5,nIndex,mon,delts);

				// for stream summary (lb)
				if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
				{
					for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
					{
						pChannelInfo[nIndex].down_bod_s[j2] += pChannelInfo[nIndex].down_bod[j2] / LBS_TO_GRAM;
						pChannelInfo[nIndex].bypass_bod_s[j2] += pChannelInfo[nIndex].bypass_bod[j2] / LBS_TO_GRAM;
					}
				}

				BOD = bod[nIndex];		// mg/l

				if (AVDEPE > 0.17 && pReachInfo[nIndex].lkfg <= 10)
				{
					//sink bod
					DPBOD = BOD;	// mg/l
					SINK(VOL,AVDEPE,KODSET,&DPBOD,&SNKBOD);
					BOD = DPBOD;
					SNKBOD = -SNKBOD;
					if (benrfg == 1)
					{
						//simulate benthal oxygen demand and benthal release of bod,
						//and compute associated fluxes
						OXBEN(BRBOD,BENOD,TW,DEPCOR,SCRFAC,TCBEN,EXPOD,EXPREL,&DOX,&BOD,&DOBEN,&BODBNR);
						BENDOX = -DOBEN*VOLSP;
						BNRBOD = BODBNR*VOLSP;
					}
					else
					{
						//benthal influences are not considered
					}

					//calculate oxygen reaeration
					double REAKT = ox_parm1[rgroup].reak;	// 1/ft 
					double CFOREA = ox_parm1[rgroup].cforea;// correction factor for lake reaeration
										 
					OXREA(LKFG,WIND,CFOREA,AVVELE,AVDEPE,TCGINV,reamfg,&REAK,REAKT,&EXPRED,
						  &EXPREV,LEN,DELTH,TW,delts,delt60,&KOREA);
					//calculate oxygen saturation level for current water
					//temperature; satdo is expressed as mg oxygen per liter
					SATDO= 14.652 + TW*(-0.41022 + TW*(0.007991 - 0.7777E-4*TW));
					//adjust satdo to conform to prevalent atmospheric pressure
					//conditions; cfpres is the ratio of site pressure to sea level
					//pressure
					SATDO= CFPRES*SATDO;
					satdo[nIndex]=SATDO;	// (05-05)
					//compute dissolved oxygen value after reaeration,and
					//the reaeration flux
					double DOREA = KOREA*(SATDO - DOX);
					DOX   = DOX + DOREA;
					READOX= DOREA*VOLSP;
					//calculate bod decay, and compute associated fluxes
					BODDEC(TW,KBOD20,TCBOD,&BOD,&DOX,&BODOX);

					BODDOX= -BODOX*VOLSP;
					DECBOD= -BODOX*VOLSP;
				}
				else
				{
					//there is too little water to warrant simulation of
					//quality processes
					BODOX = 0.0;
					READOX= 0.0;
					BODDOX= 0.0;
					BENDOX= 0.0;
					DECBOD= 0.0;
					BNRBOD= 0.0;
					SNKBOD= 0.0;
				}
				if (nutfg == 1) 
				{
					//simulate primary inorganic nitrogen and phosphorus balances
					// CALL NUTRX
					//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					//		SUBROUTINE   NUTRX

					//		+ + + PURPOSE + + +
					//		Determine primary inorganic nitrogen and phosphorus balances

					//		+ + + EXTERNALS + + +
					//		DAYVAL,ADVECT,ADVNUT,AMMION,BENTH
					//		NH3VOL,NITRIF,DENIT,DECBAL,ADDSNU
					//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

					//+ + + LOCAL VARIABLES + + +

					// initialize
					double NH3VLT = 0;
					double BENTAM = 0;
					double BENPO4 = 0;
					double DODEMD = 0;
					double TAMNIT = 0;
					double NO2NTC = 0;
					double DUMXXX = 0;
//					double DENBOD = 0;
					
					// define local variables
					double DECNIT = 0,DECPO4 = 0,TOTN1 = 0,TOTN2 = 0,TOTP1 = 0,TOTP2 = 0,
						TOTPM1 = 0,TOTPM2 = 0,TOTPM3 = 0,TOTNM1 = 0,TOTNM2 = 0,TOTNM3 = 0,
						TWKELV = 0,AVDEPM = 0,BNRTAM = 0,BNRPO4 = 0,VOLNH3 = 0,NITDOX = 0,
						NITTAM = 0,NITNO2 = 0,NITNO3 = 0,DENNO3 = 0,DECCO2 = 0,BODTAM = 0,
						BODNO3 = 0,BODPO4 = 0;

					double BRTAM[3],BRPO4[3];
					for (j2=0; j2<3; j2++)
					{
						BRTAM[j2] = 0.0;
						BRPO4[j2] = 0.0;
					}

					double ISPO4[4],ISNH4[4],BNH4[4],BPO4[4],ADNHPM[4],ADPOPM[4],SPO4[4],SNH4[4];
					for (j2=0; j2<4; j2++)
					{
						BNH4[j2] = 0.0;
						BPO4[j2] = 0.0;
						ADNHPM[j2] = 0.0;
						ADPOPM[j2] = 0.0;
						SPO4[j2] = 0.0;
						SNH4[j2] = 0.0;
						ISPO4[j2] = 0.0;
						ISNH4[j2] = 0.0;
					}
					
					double ADNH4[5],ADPO4[5],DSPO4[5],ROSPO4[5],DSNH4[5],ROSNH4[5];
					for (j2=0; j2<5; j2++)
					{
						ADNH4[j2] = 0.0;
						ADPO4[j2] = 0.0;
						DSPO4[j2] = 0.0;
						ROSPO4[j2] = 0.0;
						DSNH4[j2] = 0.0;
						ROSNH4[j2] = 0.0;
					}

					double PH = ph[nIndex];
					double EXPNVG = 0.5;	// exponent in the gas layer mass transfer coefficient equation for NH3 volatilization
					double EXPNVL = 0.6667;	// exponent in the liquid layer mass transfer coefficient equation for NH3 volatilization
					double ANAER = 0.005;	// default value (mg/l)

					// check flags 
					if (tamfg == 0 && (amvfg == 1 || adnhfg == 1))
					{
						AfxMessageBox("Error - tam is not being simulated, and nh3 volat or	nh4 adsorption is being simulated");
						goto L001;
					}
							
					if (po4fg == 0 && adpofg == 1)
					{
						AfxMessageBox("Error - po4 is not being simulated, and po4 adsorption is being simulated");
						goto L001;
					}

					if ((adnhfg == 1 || adpofg == 1) && sedfg == 0)
					{
						AfxMessageBox("Error - sediment associated nh4 and/or po4 is being simulated but sediment is not being simulated");
						goto L001;
					}
					
				    //conversion factors - table-type conv-val1
					double CVBO  = nut_parm1[rgroup].cvbo;			// mg/mg
					double CVBPC = nut_parm1[rgroup].cvbpc;			// mols/mole
					double CVBPN = nut_parm1[rgroup].cvbpn;			// mols/mole
					double BPCNTC= nut_parm1[rgroup].bpcntc;		// none

					//calculate derived values
					double CVBP = (31.*BPCNTC)/(1200.*CVBPC);
					double CVBN = 14.0*CVBPN*CVBP/31.0;
					double CVOC = BPCNTC/(100.0*CVBO);
					double CVON = CVBN/CVBO;
					double CVOP = CVBP/CVBO;

					if ( (benrfg == 1) || (plkfg == 1) )
					{
						//benthal release parms - table-type nut-benparm
						//convert units from 1/hr to 1/ivl
						BRTAM[1] = nut_parm2[rgroup].brtam_1 * delt60;		// mg/m2/ivld
						BRTAM[2] = nut_parm2[rgroup].brtam_2 * delt60;		// mg/m2/ivld
						BRPO4[1] = nut_parm2[rgroup].brpo4_1 * delt60;		// mg/m2/ivld
						BRPO4[2] = nut_parm2[rgroup].brpo4_2 * delt60;		// mg/m2/ivld
						ANAER = nut_parm3[rgroup].anaer;					// mg/l
					}

					//ammonia volatilization parameters table nut-nh3volat
					if (tamfg == 1 && amvfg == 1) 
					{
						EXPNVG = nut_parm3[rgroup].expnvg;
						EXPNVL = nut_parm3[rgroup].expnvl;
					}

					//nitrification parameters - table-type nut-nitdenit
					//convert units from 1/hr to 1/ivl
					double KTAM20 = nut_parm1[rgroup].ktam20 * delt60;		// 1/ivld
					double KNO220 = nut_parm1[rgroup].kno220 * delt60;		// 1/ivld
					double KNO320 = nut_parm1[rgroup].kno320 * delt60;		// 1/ivld
					double TCNIT = nut_parm1[rgroup].tcnit;					// none
					double TCDEN = nut_parm1[rgroup].tcden;					// none
					double DENOXT = nut_parm1[rgroup].denoxt;				// mg/l

					if ((tamfg == 1 && adnhfg == 1) || (po4fg == 1 && adpofg == 1))
					{
						//bed sediment concentrations of nh4 and po4 - table nut-bedconc
						//convert concentrations from mg/kg to internal units of mg/mg
						BNH4[1] = nut_parm2[rgroup].bnh4_1 / 1.0e6;		// mg/mg
						BNH4[2] = nut_parm2[rgroup].bnh4_2 / 1.0e6;		// mg/mg
						BNH4[3] = nut_parm2[rgroup].bnh4_3 / 1.0e6;		// mg/mg
						BPO4[1] = nut_parm2[rgroup].bpo4_1 / 1.0e6;		// mg/mg
						BPO4[2] = nut_parm2[rgroup].bpo4_2 / 1.0e6;		// mg/mg
						BPO4[3] = nut_parm2[rgroup].bpo4_3 / 1.0e6;		// mg/mg

						//initialize adsorbed nutrient mass storages in bed
						for (j2=5; j2<8; ++j2)
						{
							RSNH4[j2] = BNH4[j2-4] * RSED1[j2-1];	
							RSPO4[j2] = BPO4[j2-4] * RSED1[j2-1];
							RSNH4[8] += RSNH4[j2];
							RSPO4[8] += RSPO4[j2];
						}
						//convert adsorption parameters from ml/g to internal units of l/mg
						ADNHPM[1] = nut_parm3[rgroup].adnhpm_1 / 1.0e6;		// l/mg
						ADNHPM[2] = nut_parm3[rgroup].adnhpm_2 / 1.0e6;		// l/mg
						ADNHPM[3] = nut_parm3[rgroup].adnhpm_3 / 1.0e6;		// l/mg
						ADPOPM[1] = nut_parm3[rgroup].adpopm_1 / 1.0e6;		// l/mg
						ADPOPM[2] = nut_parm3[rgroup].adpopm_2 / 1.0e6;		// l/mg
						ADPOPM[3] = nut_parm3[rgroup].adpopm_3 / 1.0e6;		// l/mg
					}

					//initial conditions - table-type nut-dinit
					double	RONO3	= 0.0;
					double	ROTAM	= 0.0;
					double	INO2	= 0.0;
					double	RONO2	= 0.0;
					double	ROPO4	= 0.0;
					NO3 = concno3[nIndex];			// mg/l
					TAM = conctam[nIndex];			// mg/l
					NO2 = concno2[nIndex];			// mg/l
					PO4 = concpo4[nIndex];			// mg/l
					SNH4[1] = snh4[nIndex*4+1];		// mg/mg (sand)
					SNH4[2] = snh4[nIndex*4+2];		// mg/mg (silt)
					SNH4[3] = snh4[nIndex*4+3];		// mg/mg (clay)
					SPO4[1] = spo4[nIndex*4+1];		// mg/mg
					SPO4[2] = spo4[nIndex*4+2];		// mg/mg
					SPO4[3] = spo4[nIndex*4+3];		// mg/mg
					
					//assume nh4 and nh3 are 0.99 x tam and 0.01 x tam respectively
//					NH4 = 0.99*TAM;
//					NH3 = 0.01*TAM;

					//initialize adsorbed nutrient mass storages in suspension
					RSNH4[4] = 0.0;
					RSPO4[4] = 0.0;
					for (j2=1; j2<4; ++j2)
					{
						RSNH4[j2] = SNH4[j2] * RSED1[j2];
						RSPO4[j2] = SPO4[j2] * RSED1[j2];
						RSNH4[4] += RSNH4[j2];	// total in suspension (sand+silt+clay)
						RSPO4[4] += RSPO4[j2];
					}
					//initialize totals on sand, silt, clay, and grand total
					RSNH4[9]  = RSNH4[1] + RSNH4[5];
					RSNH4[10] = RSNH4[2] + RSNH4[6];
					RSNH4[11] = RSNH4[3] + RSNH4[7];
					RSNH4[12] = RSNH4[4] + RSNH4[8];
					RSPO4[9]  = RSPO4[1] + RSPO4[5];
					RSPO4[10] = RSPO4[2] + RSPO4[6];
					RSPO4[11] = RSPO4[3] + RSPO4[7];
					RSPO4[12] = RSPO4[4] + RSPO4[8];

					// NO3
					mup = 0.0;
					mland = 0.0;
					adtot = 0.0;
					mup_bypass = 0.0;
					mland_bypass = 0.0;
					mpt = 0.0;
					mptwd_target = 0.0;
					mirwd = 0.0;
					mpswd = 0.0;
					imat = 0.0;
					mlink = 0.0;

					// get the point source withdrawal if targeted to this stream
					mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,concno3,tCurrent);

					// upstream routed and bypassed load
					nPolType = POLUT_NO3;
					if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
						goto L001;

					// from atmosphere
					adtot = ADTOT[1]*453.5924;	// from lb/ivld to gram/ivld

					// from land NO3
//					mland = f_roqual[nIndex*13+1]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
//					f_roqual[nIndex*13+1] = 0;
					mland = f_roqual_route[nIndex*13+1]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
					f_roqual_route[nIndex*13+1] = 0;

					mland_bypass = f_roqual_bypass[nIndex*13+1]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
					for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
						pChannelInfo[nIndex].bypass_no3[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

					f_roqual_bypass[nIndex*13+1] = 0;

//					mland -= mland_bypass;

					//from point sources
					pqualid = PS_NOX;
				    sqalfg = 0;		// get total load
					pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
					pload *= delt60;     // lb/hr to lb/timestep					    
					mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld 

					double DNO3= NO3;	// mg/l

					// irrigation withdrawal 
					mirwd = DNO3 * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

					// pointsource withdrawal 
					mpswd = DNO3 * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

					// linkage files
					if (nLinkFiles > 0)
					{
						if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
						{
							POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
							while (pos != NULL)
							{
								Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
								mlink += plink435.pLinkData[i].no3; //g
							}
						}
					}

					imat = adtot + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

					//imat = max(0, imat);	//avoid negative value

					// for stream summary (lb)
					if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
					{
						usrqual_s[nIndex*nNumRqual+2] += (mup+mlink) / LBS_TO_GRAM;			
						lurqual_s[nIndex*nNumRqual+2] += mland / LBS_TO_GRAM;			
						atmsrqual_s[nIndex*nNumRqual+2] += adtot / LBS_TO_GRAM;			
						usrqualbp_s[nIndex*nNumRqual+2] += mup_bypass / LBS_TO_GRAM;			
						lurqualbp_s[nIndex*nNumRqual+2] += mland_bypass / LBS_TO_GRAM;			
						if (nPtSource > 0)
						{
							psrqual_s[nIndex*nNumRqual+2] += mpt / LBS_TO_GRAM;		
							pswdrqual_s[nIndex*nNumRqual+2] += mpswd / LBS_TO_GRAM;	
							pswdrqualdi_s[nIndex*nNumRqual+2] += mptwd_target / LBS_TO_GRAM;	
						}
						if (irrigfg == 1)
							irwdrqual_s[nIndex*nNumRqual+2] += mirwd / LBS_TO_GRAM;
						
						irqual_s[nIndex*nNumRqual+2] += imat / LBS_TO_GRAM;			
					}

					//advect nitrate
					double INNO3 = imat;

					advect(admod, VOLT, &INNO3, &VOLS, &SROVOL, &VOL, &EROVOL, &DNO3,
						   &RONO3, delts, &js, crrat);

					concno3[nIndex] = DNO3;
					matno3[nIndex] = RONO3;

					//downstream NO3
					for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
					{
						if (q2[nIndex] > 0.0) 
						  pChannelInfo[nIndex].down_no3[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matno3[nIndex];
						else
						  pChannelInfo[nIndex].down_no3[jk]= 0.0;
					}

					// apply reduction (01-05-06)
					if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
						matno3[nIndex] = GetBMPReductionLoad(nPolType,nQuals+6,nIndex,mon,delts);

					// for stream summary (lb)
					if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
					{
						for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
						{
							pChannelInfo[nIndex].down_no3_s[j2] += pChannelInfo[nIndex].down_no3[j2] / LBS_TO_GRAM;
							pChannelInfo[nIndex].bypass_no3_s[j2] += pChannelInfo[nIndex].bypass_no3[j2] / LBS_TO_GRAM;
						}
					}

					NO3 = concno3[nIndex];

					if (tamfg != 0)
					{
						// TAM
						mup = 0.0;
						mland = 0.0;
						adtot = 0.0;
						mup_bypass = 0.0;
						mland_bypass = 0.0;
						mpt = 0.0;
						mptwd_target = 0.0;
						mirwd = 0.0;
						mpswd = 0.0;
						imat = 0.0;
						mlink = 0.0;
	
						// get the point source withdrawal if targeted to this stream
						mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,conctam,tCurrent);

						// upstream routed and bypassed load
						nPolType = POLUT_TAM;
						if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
							goto L001;

						// from atmosphere
						adtot = ADTOT[2]*453.5924;	// from lb/ivld to gram/ivld

						// from land TAM
//						mland = f_roqual[nIndex*13+2]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
//						f_roqual[nIndex*13+2] = 0;
						mland = f_roqual_route[nIndex*13+2]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						f_roqual_route[nIndex*13+2] = 0;

						mland_bypass = f_roqual_bypass[nIndex*13+2]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
							pChannelInfo[nIndex].bypass_tam[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

						f_roqual_bypass[nIndex*13+2] = 0;

//						mland -= mland_bypass;
		
						//from point sources
						pqualid = PS_TAM;
					    sqalfg = 0;		// get total load
						pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
						pload *= delt60;     // lb/hr to lb/timestep					    
						mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld 

						double DTAM = TAM;

						// irrigation withdrawal 
						mirwd = DTAM * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

						// pointsource withdrawal 
						mpswd = DTAM * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

						// linkage files
						if (nLinkFiles > 0)
						{
							if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
							{
								POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
								while (pos != NULL)
								{
									Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
									mlink += plink435.pLinkData[i].tam; //g
								}
							}
						}

						imat = adtot + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

						//imat = max(0, imat);	//avoid negative value

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							usrqual_s[nIndex*nNumRqual+3] += (mup+mlink) / LBS_TO_GRAM;			
							lurqual_s[nIndex*nNumRqual+3] += mland / LBS_TO_GRAM;			
							atmsrqual_s[nIndex*nNumRqual+3] += adtot / LBS_TO_GRAM;			
							usrqualbp_s[nIndex*nNumRqual+3] += mup_bypass / LBS_TO_GRAM;			
							lurqualbp_s[nIndex*nNumRqual+3] += mland_bypass / LBS_TO_GRAM;			
							if (nPtSource > 0)
							{
								psrqual_s[nIndex*nNumRqual+3] += mpt / LBS_TO_GRAM;		
								pswdrqual_s[nIndex*nNumRqual+3] += mpswd / LBS_TO_GRAM;	
								pswdrqualdi_s[nIndex*nNumRqual+3] += mptwd_target / LBS_TO_GRAM;	
							}
							if (irrigfg == 1)
								irwdrqual_s[nIndex*nNumRqual+3] += mirwd / LBS_TO_GRAM;
							
							irqual_s[nIndex*nNumRqual+3] += imat / LBS_TO_GRAM;			
						}

						//advect total ammonia
						double INTAM = imat;

						advect(admod, VOLT, &INTAM, &VOLS, &SROVOL, &VOL, &EROVOL, &DTAM,
							   &ROTAM, delts, &js, crrat);
						
						conctam[nIndex] = DTAM;
						mattam[nIndex] = ROTAM;

						//downstream TAM
						for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
						{
							if (q2[nIndex] > 0.0) 
							  pChannelInfo[nIndex].down_tam[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*mattam[nIndex];
							else
							  pChannelInfo[nIndex].down_tam[jk]= 0.0;
						}

						// apply reduction (01-05-06)
						if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
							mattam[nIndex] = GetBMPReductionLoad(nPolType,nQuals+7,nIndex,mon,delts);

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								pChannelInfo[nIndex].down_tam_s[j2] += pChannelInfo[nIndex].down_tam[j2] / LBS_TO_GRAM;
								pChannelInfo[nIndex].bypass_tam_s[j2] += pChannelInfo[nIndex].bypass_tam[j2] / LBS_TO_GRAM;
							}
						}
					}

					TAM = conctam[nIndex];
					
					//assume nh4 and nh3 are 0.99 x tam and 0.01 x tam respectively
					NH4 = 0.99*TAM;
					NH3 = 0.01*TAM;

					if (no2fg != 0) 
					{
						// NO2
						mup = 0.0;
						mland = 0.0;
						mup_bypass = 0.0;
						mland_bypass = 0.0;
						mpt = 0.0;
						mptwd_target = 0.0;
						mirwd = 0.0;
						mpswd = 0.0;
						imat = 0.0;
						mlink = 0.0;
	
						// get the point source withdrawal if targeted to this stream
						mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,concno2,tCurrent);

						// upstream routed and bypassed load
						nPolType = POLUT_NO2;
						if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
							goto L001;

						// from land NO2
						mland = 0;
						mland_bypass = 0;
						for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
							pChannelInfo[nIndex].bypass_no2[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

//						mland -= mland_bypass;

						//from point sources
						mpt = 0.0;

						double DNO2 = NO2;

						// irrigation withdrawal 
						mirwd = DNO2 * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

						// pointsource withdrawal 
						mpswd = DNO2 * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

						// linkage files
						if (nLinkFiles > 0)
						{
							if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
							{
								POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
								while (pos != NULL)
								{
									Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
									mlink += plink435.pLinkData[i].no2; //g
								}
							}
						}

						imat = mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

						//imat = max(0, imat);	//avoid negative value

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							usrqual_s[nIndex*nNumRqual+4] += (mup+mlink) / LBS_TO_GRAM;			
							lurqual_s[nIndex*nNumRqual+4] += mland / LBS_TO_GRAM;			
							atmsrqual_s[nIndex*nNumRqual+4] = 0;			
							usrqualbp_s[nIndex*nNumRqual+4] += mup_bypass / LBS_TO_GRAM;			
							lurqualbp_s[nIndex*nNumRqual+4] += mland_bypass / LBS_TO_GRAM;			
							if (nPtSource > 0)
							{
								psrqual_s[nIndex*nNumRqual+4] += mpt / LBS_TO_GRAM;		
								pswdrqual_s[nIndex*nNumRqual+4] += mpswd / LBS_TO_GRAM;	
								pswdrqualdi_s[nIndex*nNumRqual+4] += mptwd_target / LBS_TO_GRAM;	
							}
							if (irrigfg == 1)
								irwdrqual_s[nIndex*nNumRqual+4] += mirwd / LBS_TO_GRAM;	
							irqual_s[nIndex*nNumRqual+4] += imat / LBS_TO_GRAM;			
						}

						//advect nitrite
						INO2 = imat;

						advect(admod, VOLT, &INO2, &VOLS, &SROVOL, &VOL, &EROVOL, &DNO2,
							   &RONO2, delts, &js, crrat);
						
						concno2[nIndex] = DNO2;
						matno2[nIndex] = RONO2;

						//downstream NO2
						for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
						{
							if (q2[nIndex] > 0.0) 
							  pChannelInfo[nIndex].down_no2[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matno2[nIndex];
							else
							  pChannelInfo[nIndex].down_no2[jk]= 0.0;
						}

						// apply reduction (01-05-06)
						if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
							matno2[nIndex] = GetBMPReductionLoad(nPolType,nQuals+6,nIndex,mon,delts);

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								pChannelInfo[nIndex].down_no2_s[j2] += pChannelInfo[nIndex].down_no2[j2] / LBS_TO_GRAM;
								pChannelInfo[nIndex].bypass_no2_s[j2] += pChannelInfo[nIndex].bypass_no2[j2] / LBS_TO_GRAM;
							}
						}

						NO2 = concno2[nIndex];
					}

					if (po4fg != 0) 
					{
						// PO4
						mup = 0.0;
						mland = 0.0;
						adtot = 0.0;
						mup_bypass = 0.0;
						mland_bypass = 0.0;
						mpt = 0.0;
						mptwd_target = 0.0;
						mirwd = 0.0;
						mpswd = 0.0;
						imat = 0.0;
						mlink = 0.0;
	
						// get the point source withdrawal if targeted to this stream
						mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,concpo4,tCurrent);

						// upstream routed and bypassed load
						nPolType = POLUT_PO4;
						if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
							goto L001;

						// from atmosphere
						adtot = ADTOT[3]*453.5924;	// from lb/ivld to gram/ivld

						// from land PO4
//						mland = f_roqual[nIndex*13+6]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
//						f_roqual[nIndex*13+6] = 0;
						mland = f_roqual_route[nIndex*13+6]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						f_roqual_route[nIndex*13+6] = 0;

						mland_bypass = f_roqual_bypass[nIndex*13+6]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
							pChannelInfo[nIndex].bypass_po4[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

						f_roqual_bypass[nIndex*13+6] = 0;

//						mland -= mland_bypass;

						// from point source
						pqualid = PS_PO4;
					    sqalfg = 0;		// get total load
						pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
						pload *= delt60;     // lb/hr to lb/timestep					    
						mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld 

						double DPO4 = PO4;

						// irrigation withdrawal 
						mirwd = DPO4 * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

						// pointsource withdrawal 
						mpswd = DPO4 * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

						// linkage files
						if (nLinkFiles > 0)
						{
							if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
							{
								POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
								while (pos != NULL)
								{
									Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
									mlink += plink435.pLinkData[i].po4; //g
								}
							}
						}

						imat = adtot + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

						//imat = max(0, imat);	//avoid negative value

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							usrqual_s[nIndex*nNumRqual+5] += (mup+mlink) / LBS_TO_GRAM;			
							lurqual_s[nIndex*nNumRqual+5] += mland / LBS_TO_GRAM;			
							atmsrqual_s[nIndex*nNumRqual+5] += adtot / LBS_TO_GRAM;			
							usrqualbp_s[nIndex*nNumRqual+5] += mup_bypass / LBS_TO_GRAM;			
							lurqualbp_s[nIndex*nNumRqual+5] += mland_bypass / LBS_TO_GRAM;			
							if (nPtSource > 0)
							{
								psrqual_s[nIndex*nNumRqual+5] += mpt / LBS_TO_GRAM;		
								pswdrqual_s[nIndex*nNumRqual+5] += mpswd / LBS_TO_GRAM;	
								pswdrqualdi_s[nIndex*nNumRqual+5] += mptwd_target / LBS_TO_GRAM;	
							}
							if (irrigfg == 1)
								irwdrqual_s[nIndex*nNumRqual+5] += mirwd / LBS_TO_GRAM;	
							irqual_s[nIndex*nNumRqual+5] += imat / LBS_TO_GRAM;			
						}

						//advect ortho-phosphorus
						double INPO4 = imat;

						advect(admod, VOLT, &INPO4, &VOLS, &SROVOL, &VOL, &EROVOL, &DPO4,
							   &ROPO4, delts, &js, crrat);
						
						concpo4[nIndex] = DPO4;
						matpo4[nIndex] = ROPO4;

						//downstream PO4
						for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
						{
							if (q2[nIndex] > 0.0) 
							  pChannelInfo[nIndex].down_po4[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matpo4[nIndex];
							else
							  pChannelInfo[nIndex].down_po4[jk]= 0.0;
						}

						// apply reduction (01-05-06)
						if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
							matpo4[nIndex] = GetBMPReductionLoad(nPolType,nQuals+8,nIndex,mon,delts);

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								pChannelInfo[nIndex].down_po4_s[j2] += pChannelInfo[nIndex].down_po4[j2] / LBS_TO_GRAM;
								pChannelInfo[nIndex].bypass_po4_s[j2] += pChannelInfo[nIndex].bypass_po4[j2] / LBS_TO_GRAM;
							}
						}
					}
						
					PO4 = concpo4[nIndex];

					if (adpofg != 0) 
					{
						//advect adsorbed phosphate SPO4
						mup = 0.0;
						mup_bypass = 0.0;
						mland = 0.0;
						mland_bypass = 0.0;
						mpt = 0.0;
						mirwd = 0.0;
						mpswd = 0.0;
						imat = 0.0;

						// from land sediments associated PO4 (lb/ivl)
						double sedPO4_land[4] = {0.0,0.0,0.0,0.0};	// 0 is dummy, 1 sand, 2 silt and 3 clay
						//sand
//						sedPO4_land[1] = f_roqual[nIndex*13+7];	
//						f_roqual[nIndex*13+7] = 0.0;
						sedPO4_land[1] = f_roqual_route[nIndex*13+7];	
						f_roqual_route[nIndex*13+7] = 0.0;
						//silt
//						sedPO4_land[2] = f_roqual[nIndex*13+8];	
//						f_roqual[nIndex*13+8] = 0.0;
						sedPO4_land[2] = f_roqual_route[nIndex*13+8];	
						f_roqual_route[nIndex*13+8] = 0.0;
						//clay
//						sedPO4_land[3] = f_roqual[nIndex*13+9];	
//						f_roqual[nIndex*13+9] = 0.0;
						sedPO4_land[3] = f_roqual_route[nIndex*13+9];	
						f_roqual_route[nIndex*13+9] = 0.0;

						// from land bypass sediments associated PO4 (lb/ivl)
						double sedPO4_landbypass[4] = {0.0,0.0,0.0,0.0};	// 0 is dummy, 1 sand, 2 silt and 3 clay
						//sand
						sedPO4_landbypass[1] = f_roqual_bypass[nIndex*13+7];	
						f_roqual_bypass[nIndex*13+7] = 0.0;
						//silt
						sedPO4_landbypass[2] = f_roqual_bypass[nIndex*13+8];	
						f_roqual_bypass[nIndex*13+8] = 0.0;
						//clay
						sedPO4_landbypass[3] = f_roqual_bypass[nIndex*13+9];	
						f_roqual_bypass[nIndex*13+9] = 0.0;

						//zero the accumulators
						TOTP1= 0.0;
						TOTP2= 0.0;

						//repeat for each sediment fraction
						for (int J=1; J<4; J++)
						{
							// land
							mland = sedPO4_land[J]*LBS_TO_GRAM;// from lb/ivld to gram/ivld
							mland_bypass = sedPO4_landbypass[J]*LBS_TO_GRAM;	
							
							//downstream bypass sedPO4
							for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
								pChannelInfo[nIndex].bypass_spo4[jk*3+(J-1)] = mland_bypass * pReachFtable[nIndex].bypass_fr[jk];

//							mland -= mland_bypass;
							
							// upstream
							mup = 0.0;
							mup_bypass = 0.0;
							nNum = pChannelInfo[nIndex].cListUppersOrder.GetSize();
							if(nNum > 0)
							{
								for(int j2=0; j2<nNum; j2++)
								{
									int nUpperReach = pChannelInfo[nIndex].cListUppersOrder.GetAt(j2);
									if(nUpperReach < 0 || nUpperReach >= nsws)
									{
										AfxMessageBox("Wrong NETWORK");
										goto L001;
									}
									else																	 
									{
										for (int j3=0; j3<pChannelInfo[nUpperReach].nDSchan; j3++)
										{
											if (pChannelInfo[nIndex].rchid == pChannelInfo[nUpperReach].down_ch[j3])
											{
												mup += pChannelInfo[nUpperReach].down_spo4[j3*3+(J-1)];
												mup_bypass += pChannelInfo[nUpperReach].bypass_spo4[j3*3+(J-1)];
											}
										}
									}
								}
							}

							// linkage files
							mlink = 0.0;
							if (nLinkFiles > 0)
							{
								if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
								{
									POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
									while (pos != NULL)
									{
										Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
										mlink += plink435.pLinkData[i].spo4[J-1]; //g
									}
								}
							}

							ISPO4[J] = mland + mup + mup_bypass + mlink;	// g/ivl	

							ADVNUT(ISPO4[J],RSED[J],RSED[J+3],DEPSCR[J],ROSED[J],RSPO4[J],
								RSPO4[J + 4],BPO4[J],SPO4[J],DSPO4[J],ROSPO4[J]);

							spo4[nIndex*4+J] = SPO4[J];
							matospo4[nIndex*4+J] = ROSPO4[J];

							//added (03-24-2014)
							double depmass = 0.0;
							double scrmass = 0.0;

							if (DSPO4[J] < 0)
								scrmass = -DSPO4[J];
							else
								depmass = DSPO4[J];

							//downstream SPO4
							for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
							{
								if (q2[nIndex] > 0.0) 
								  pChannelInfo[nIndex].down_spo4[jk*3+(J-1)] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matospo4[nIndex*4+J];
								else
								  pChannelInfo[nIndex].down_spo4[jk*3+(J-1)] = 0.0;
							}

							// for stream summary (lb)
							if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
							{
								usSPO4_s[nIndex*3+(J-1)] += (mup + mup_bypass + mlink) / LBS_TO_GRAM;			
								luSPO4_s[nIndex*3+(J-1)] += mland / LBS_TO_GRAM;			
								iSPO4_s[nIndex*3+(J-1)]  += ISPO4[J] / LBS_TO_GRAM;			
								DSPO4_s[nIndex*3+(J-1)]  += DSPO4[J] / LBS_TO_GRAM;			
								DEPPO4_s[nIndex*3+(J-1)]  += depmass / LBS_TO_GRAM;			
								SCRPO4_s[nIndex*3+(J-1)]  += scrmass / LBS_TO_GRAM;			

								for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									pChannelInfo[nIndex].down_SPO4_s[j2*3+(J-1)] += pChannelInfo[nIndex].down_spo4[j2*3+(J-1)] / LBS_TO_GRAM;
									pChannelInfo[nIndex].bypass_SPO4_s[j2*3+(J-1)] += pChannelInfo[nIndex].bypass_spo4[j2*3+(J-1)] / LBS_TO_GRAM;
								}
							}

							TOTP1 = TOTP1 + DSPO4[J];
							TOTP2 = TOTP2 + ROSPO4[J];
						}

						DSPO4[4] = TOTP1;
						ROSPO4[4]= TOTP2;
					}

					if (tamfg != 0 && adnhfg != 0) 
					{
						//advect adsorbed ammonium SNH4
						mup = 0.0;
						mup_bypass = 0.0;
						mland = 0.0;
						mland_bypass = 0.0;
						mpt = 0.0;
						mirwd = 0.0;
						mpswd = 0.0;
						imat = 0.0;
	
						//zero the accumulators
						TOTN1= 0.0;
						TOTN2= 0.0;

						// from land sediments associated NH4 (lb/ivl)
						double sedNH4_land[4] = {0.0,0.0,0.0,0.0};	// 0 is dummy, 1 sand, 2 silt and 3 clay
						//sand
//						sedNH4_land[1] = f_roqual[nIndex*13+3];	
//						f_roqual[nIndex*13+3] = 0.0;
						sedNH4_land[1] = f_roqual_route[nIndex*13+3];	
						f_roqual_route[nIndex*13+3] = 0.0;
						//silt
//						sedNH4_land[2] = f_roqual[nIndex*13+4];	
//						f_roqual[nIndex*13+4] = 0.0;
						sedNH4_land[2] = f_roqual_route[nIndex*13+4];	
						f_roqual_route[nIndex*13+4] = 0.0;
						//clay
//						sedNH4_land[3] = f_roqual[nIndex*13+5];	
//						f_roqual[nIndex*13+5] = 0.0;
						sedNH4_land[3] = f_roqual_route[nIndex*13+5];	
						f_roqual_route[nIndex*13+5] = 0.0;

						// from land bypass sediments associated NH4 (lb/ivl)
						double sedNH4_landbypass[4] = {0.0,0.0,0.0,0.0};	// 0 is dummy, 1 sand, 2 silt and 3 clay
						//sand
						sedNH4_landbypass[1] = f_roqual_bypass[nIndex*13+3];	
						f_roqual_bypass[nIndex*13+3] = 0.0;
						//silt
						sedNH4_landbypass[2] = f_roqual_bypass[nIndex*13+4];	
						f_roqual_bypass[nIndex*13+4] = 0.0;
						//clay
						sedNH4_landbypass[3] = f_roqual_bypass[nIndex*13+5];	
						f_roqual_bypass[nIndex*13+5] = 0.0;

						//repeat for each sediment fraction
						for (int J=1; J<4; J++)
						{
							// land
							mland = sedNH4_land[J]*LBS_TO_GRAM;// from lb/ivld to gram/ivld
							mland_bypass = sedNH4_landbypass[J]*LBS_TO_GRAM;	
							
							//downstream bypass sedNH4
							for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
								pChannelInfo[nIndex].bypass_snh4[jk*3+(J-1)] = mland_bypass * pReachFtable[nIndex].bypass_fr[jk];

//							mland -= mland_bypass;
							
							// upstream
							mup = 0.0;
							mup_bypass = 0.0;
							nNum = pChannelInfo[nIndex].cListUppersOrder.GetSize();
							if(nNum > 0)
							{
								for(int j2=0; j2<nNum; j2++)
								{
									int nUpperReach = pChannelInfo[nIndex].cListUppersOrder.GetAt(j2);
									if(nUpperReach < 0 || nUpperReach >= nsws)
									{
										AfxMessageBox("Wrong NETWORK");
										goto L001;
									}
									else																	 
									{
										for (int j3=0; j3<pChannelInfo[nUpperReach].nDSchan; j3++)
										{
											if (pChannelInfo[nIndex].rchid == pChannelInfo[nUpperReach].down_ch[j3])
											{
												mup += pChannelInfo[nUpperReach].down_snh4[j3*3+(J-1)];
												mup_bypass += pChannelInfo[nUpperReach].bypass_snh4[j3*3+(J-1)];
											}
										}
									}
								}
							}

							// linkage files
							mlink = 0.0;
							if (nLinkFiles > 0)
							{
								if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
								{
									POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
									while (pos != NULL)
									{
										Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
										mlink += plink435.pLinkData[i].snh4[J-1]; //g
									}
								}
							}

							ISNH4[J] = mland + mup + mup_bypass + mlink;	// g/ivl	

							ADVNUT(ISNH4[J],RSED[J],RSED[J+3],DEPSCR[J],ROSED[J],RSNH4[J],
								RSNH4[J+4],BNH4[J],SNH4[J],DSNH4[J],ROSNH4[J]);

							snh4[nIndex*4+J] = SNH4[J];
							matosnh4[nIndex*4+J] = ROSNH4[J];

							//added (03-24-2014)
							double depmass = 0.0;
							double scrmass = 0.0;

							if (DSNH4[J] < 0)
								scrmass = -DSNH4[J];
							else
								depmass = DSNH4[J];

							//downstream SNH4
							for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
							{
								if (q2[nIndex] > 0.0) 
								  pChannelInfo[nIndex].down_snh4[jk*3+(J-1)] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matosnh4[nIndex*4+J];
								else
								  pChannelInfo[nIndex].down_snh4[jk*3+(J-1)] = 0.0;
							}

							// for stream summary (lb)
							if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
							{
								usSNH4_s[nIndex*3+(J-1)] += (mup + mup_bypass + mlink) / LBS_TO_GRAM;			
								luSNH4_s[nIndex*3+(J-1)] += mland / LBS_TO_GRAM;			
								iSNH4_s[nIndex*3+(J-1)]  += ISNH4[J] / LBS_TO_GRAM;			
								DSNH4_s[nIndex*3+(J-1)]  += DSNH4[J] / LBS_TO_GRAM;			
								DEPNH4_s[nIndex*3+(J-1)]  += depmass / LBS_TO_GRAM;			
								SCRNH4_s[nIndex*3+(J-1)]  += scrmass / LBS_TO_GRAM;			

								for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									pChannelInfo[nIndex].down_SNH4_s[j2*3+(J-1)] += pChannelInfo[nIndex].down_snh4[j2*3+(J-1)] / LBS_TO_GRAM;
									pChannelInfo[nIndex].bypass_SNH4_s[j2*3+(J-1)] += pChannelInfo[nIndex].bypass_snh4[j2*3+(J-1)] / LBS_TO_GRAM;
								}
							}

							TOTN1= TOTN1 + DSNH4[J];
							TOTN2= TOTN2 + ROSNH4[J];
						} 

						DSNH4[4] = TOTN1;
						ROSNH4[4]= TOTN2;
					}

					if (tamfg != 0) 
					{
						//calculate ammonia ionization in water column

						//get ph values
						if (mphfg == 1)
						{
							//user-supplied monthly values
//							if (dayfg == 1) 
								//interpolate a new value
//								PHVAL= DAYVAL(PHVALM(MON),PHVALM(NXTMON),DAY,NDAYS);
						}
						else
						{
							//time series value
							if (phfg == 1) 
								//use value computed in last time step
								PHVAL= PH;
							else
								//constant value
								PHVAL= 7.0;
						}
						//compute ammonia ionization
						if (pReachInfo[nIndex].lkfg <= 10)
							AMMION(TW,PHVAL,TAM,&NH3,&NH4);
					}

					if (AVDEPE > 0.17 && pReachInfo[nIndex].lkfg <= 10) 
					{
						if (benrfg != 0) 
						{
							//simulate benthal release of inorganic nitrogen and
							//ortho-phosphorus; and compute associated fluxes
							if (tamfg != 0) 
							{
								BENTH(DOX,ANAER,BRTAM,SCRFAC,DEPCOR,&TAM,&BENTAM);
								BNRTAM= BENTAM*VOLSP;
							}
							else
							{
								//benthal release of inorganic n not simulated
							}

							if (po4fg != 0) 
							{
								BENTH(DOX,ANAER,BRPO4,SCRFAC,DEPCOR,&PO4,&BENPO4);
								BNRPO4= BENPO4*VOLSP;
							}
							
							// for stream summary (lb)
							if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
							{
								benNH4_s[nIndex] += BNRTAM / LBS_TO_GRAM; // lb	
								benPO4_s[nIndex] += BNRPO4 / LBS_TO_GRAM; // lb	
							}
						}
						else
						{
							//benthal releases are not considered
						}

						if (tamfg != 0) 
						{
							if (amvfg != 0) 
							{
								//compute ammonia volatilization
								//convert water temperature to degrees kelvin and depth to meters
								TWKELV = TW + 273.16;		// kelvin
								AVDEPM = AVDEPE * .3048;	// m

								NH3VOL(EXPNVG,EXPNVL,KOREA,WIND,delt60,delts,AVDEPM,TWKELV,TW,PHVAL,&TAM,&NH3VLT);

								VOLNH3 = -NH3VLT*VOLSP;
							}
							else
							{
								VOLNH3= 0.0;
							}

							//calculate amount of nitrification; nitrification does not
							//take place if the do concentration is less than 2.0 mg/l
							double NO3NIT = 0;
							NITRIF(KTAM20,TCNIT,TW,no2fg,KNO220,&TAM,&NO2,&NO3,&DOX,&DODEMD,&TAMNIT,&NO2NTC,&NO3NIT);

							//compute nitrification fluxes
							NITDOX= -DODEMD*VOLSP;
							NITTAM= -TAMNIT*VOLSP;
							NITNO2= NO2NTC*VOLSP;
							NITNO3= NO3NIT*VOLSP;
						}
						else
						{
							//ammonia is not simulated; volatilization and
							//nitrification of tam are not considered
						}

						if (denfg != 0) 
						{
							//consider denitrification processes, and compute associated fluxes
							double NO3DE = 0;
							DENIT(KNO320,TCDEN,TW,DOX,DENOXT,&NO3,&NO3DE);
							DENNO3= -NO3DE*VOLSP;
						}

						//calculate amount of inorganic constituents released by
						//bod decay in reach water
						DECNIT= BODOX*CVON;
						DECPO4= BODOX*CVOP;
						DECCO2= BODOX*CVOC;

						//update state variables of inorganic constituents which
						//are end products of bod decay; and compute associated fluxes
						DECBAL(tamfg,po4fg,DECNIT,DECPO4,&TAM,&NO3,&PO4);

						if (tamfg != 0) 
							BODTAM= DECNIT*VOLSP;
						else
							BODNO3= DECNIT*VOLSP;

						if (po4fg == 1) 
							BODPO4= DECPO4*VOLSP;

						if (po4fg != 0 && sedfg != 0 && adpofg != 0)
						{
							//compute adsorption/desorption of phosphate
							ADDSNU(VOLSP,RSED,ADPOPM,&PO4,SPO4,&DUMXXX,ADPO4);
						}
						else
						{
							//computation of phosphate adsorption/desorption is not necessary
						}

						if (tamfg != 0 && sedfg != 0 && adnhfg != 0) 
						{
							//compute adsorption/desorption of ammonium
							ADDSNU(VOLSP,RSED,ADNHPM,&NH4,SNH4,&TAM,ADNH4);
						}
						else
						{
							//computation of ammonium adsorption/desorption is not wanted
						}
					}
					else
					{
						//too little water is in reach to warrant simulation
						//of quality processes
						DECNIT= 0.0;
						DECPO4= 0.0;
						DECCO2= 0.0;
						NITDOX= 0.0;
//						DENBOD= 0.0;
						NITTAM= 0.0;
						BNRTAM= 0.0;
						VOLNH3= 0.0;
						BODTAM= 0.0;
						NITNO2= 0.0;
						NITNO3= 0.0;
						DENNO3= 0.0;
						BODNO3= 0.0;
						BNRPO4= 0.0;
						BODPO4= 0.0;

						//DO 80 K= 1,4
						for (int K=1; K<5; K++)
						{
							ADNH4[K]= 0.0;
							ADPO4[K]= 0.0;
						}
						//80     CONTINUE
					}

					if (po4fg != 0 && sedfg != 0 && adpofg != 0) 
					{
						//find total quantity of phosphate on various forms of sediment
						TOTPM1= 0.0;
						TOTPM2= 0.0;
						TOTPM3= 0.0;

						//DO 90 J= 1,3
						for (int J=1; J<4; J++)
						{
							//added (01-14-08)
							spo4[nIndex*4+J] = SPO4[J];
							//compute mass of phosphate adsorbed to each suspended fraction
							RSPO4[J] = SPO4[J]*RSED[J];
							//compute mass of phosphate adsorbed to each bed fraction
							RSPO4[J + 4]= BPO4[J]*RSED[J + 3];
							//compute total mass of phosphate on each sediment fraction
							RSPO4[J + 8]= RSPO4[J] + RSPO4[J + 4];

							TOTPM1= TOTPM1 + RSPO4[J];
							TOTPM2= TOTPM2 + RSPO4[J + 4];
							TOTPM3= TOTPM3 + RSPO4[J + 8];
						}
						//90 CONTINUE

						//compute total suspended phosphate
						RSPO4[4] = TOTPM1;
						//compute total bed phosphate
						RSPO4[8] = TOTPM2;
						//compute total sediment-associated phosphate
						RSPO4[12]= TOTPM3;
					}

					if (tamfg != 0 && sedfg != 0 && adnhfg != 0) 
					{
						//find total amount of ammonium on various forms of sediment
						TOTNM1= 0.0;
						TOTNM2= 0.0;
						TOTNM3= 0.0;

						//DO 100 J= 1,3
						for (int J=1; J<4; J++)
						{
							//added (01-14-08)
							snh4[nIndex*4+J] = SNH4[J];
							//compute mass of ammonium adsorbed to each suspended fraction
							RSNH4[J] = SNH4[J]*RSED[J];
							//compute mass of ammonium adsorbed to each bed fraction
							RSNH4[J + 4]= BNH4[J]*RSED[J + 3];
							//compute total mass of ammonium on each sediment fraction
							RSNH4[J + 8]= RSNH4[J] + RSNH4[J + 4];

							TOTNM1= TOTNM1 + RSNH4[J];
							TOTNM2= TOTNM2 + RSNH4[J + 4];
							TOTNM3= TOTNM3 + RSNH4[J + 8];
						}
						//100 CONTINUE

						//compute total suspended ammonium
						RSNH4[4] = TOTNM1;
						//compute total bed ammonium
						RSNH4[8] = TOTNM2;
						//compute total sediment-associated ammonium
						RSNH4[12]= TOTNM3;
					}
			
					if (plkfg == 1) 
					{
						//simulate plankton populations and associated reactions
						//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
						//	SUBROUTINE   PLANK

						//	+ + + PURPOSE + + +
						//	Simulate behavior of plankton populations and associated
						//	reactions

						//	+ + + EXTERNALS + + +
						//	ADVPLK,SINK,ADVECT,DAYVAL,LITRCH,PHYRX,ZORX,BALRX
						//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

						if (zoofg == 1 && phyfg == 0)
						{
							AfxMessageBox("Error - zooplankton cannot be simulated without phytoplankton");
							goto L001;
						}
						if (nsfg == 1 && tamfg == 0)
						{
							AfxMessageBox("Error - ammonia cannot be included in n supply if it is not being simulated");
							goto L001;
						}
						if (po4fg == 0)
						{
							AfxMessageBox("Error - phosphate must be simulated if plankton are being simulated");
							goto L001;
						}

						// initialize
						double BALLIT = 0;
						double CFLIT = 0;
						double PHYLIT = 0;
						double SNKORC = 0;
						double SNKORN = 0;
						double SNKORP = 0;
						double SNKPHY = 0;
						double DOPHY = 0;
						double BODPHY = 0;
						double TAMPHY = 0;
						double NO3PHY = 0;
						double PO4PHY = 0;
						double DOBALG = 0;
						double BODBAL = 0;
						double TAMBAL = 0;
						double NO3BAL = 0;
						double PO4BAL = 0;
						double ROPHYT = 0;
						double ROZOO = 0;
						double ROORN = 0;
						double ROORP = 0;
						double ROORC = 0;
						double PHYCO2 = 0;
						double BALCO2 = 0;
						double ZCO2 = 0;
						double CO2 = concco2[nIndex];	// mg/l

						//growth limiting factor for the interval
						CString LIMC,LIMPHY,LIMBAL,LIMIT[7];
						LIMIT[0].Format("lit");
						LIMIT[1].Format("non");
						LIMIT[2].Format("tem");
						LIMIT[3].Format("nit");
						LIMIT[4].Format("po4");
						LIMIT[5].Format("none");
						LIMIT[6].Format("wat");
 
//						double DOZOO,PO4ZOO,ZEAT,NITZOO,BODZOO; (not supported yet)

						//define local variables
						double EXTCLA,EXTSED,INLIT,PHYDOX,PHYBOD,PHYTAM,PHYNO3,PHYPO4;
						double BALDOX,BALBOD,BALTAM,BALNO3,BALPO4;
//						double ZOODOX,ZOOBOD,ZOOTAM,ZOONO3,ZOOPO4; (not supported yet)

						// initial concentration
						PHYTO = concphy[nIndex];	// mg/l
						BENAL = concbenal[nIndex];	// mg/m2
						ZOO = conczoo[nIndex];		// mg/l
						ORN = concorn[nIndex];		// mg/l
						ORP = concorp[nIndex];		// mg/l
						ORC = concorc[nIndex];		// mg/l

						// define input constants
						double LITSED = plank_parm1[rgroup].litsed/FT_TO_M;	// l/mg/m
						double EXTB = plank_parm1[rgroup].extb;				// 1/m
						double MALGR = plank_parm1[rgroup].malgr*delt60;	// 1/ivld
						double ALNPR = plank_parm1[rgroup].alnpr;			// none
						double NONREF = plank_parm1[rgroup].nonref;			// none
						double RATCLP = plank_parm1[rgroup].ratclp;			// none

						double TALGRL = plank_parm2[rgroup].talgrl;			// degree C
						double TALGRH = plank_parm2[rgroup].talgrh;			// degree C
						double TALGRM = plank_parm2[rgroup].talgrm;			// degree C
						double CMMP = plank_parm2[rgroup].cmmp;				// mg/l
						double CMMNP = plank_parm2[rgroup].cmmnp;			// mg/l
						double CMMN = plank_parm2[rgroup].cmmn;				// mg/l
//						double CMMLT = plank_parm2[rgroup].cmmlt*delt;		// langleys/ivld
						double CMMLT = plank_parm2[rgroup].cmmlt;			// langleys/min		(07-06-05)

						double ALR20 = plank_parm3[rgroup].alr20*delt60;	// 1/ivld
						double PALDH = plank_parm3[rgroup].paldh;			// mg/l
						double NALDH = plank_parm3[rgroup].naldh;			// mg/l
						double ALDL = plank_parm3[rgroup].aldl*delt60;		// 1/ivld
						double ALDH = plank_parm3[rgroup].aldh*delt60;		// 1/ivld
						double OXALD = plank_parm3[rgroup].oxald*delt60;	// 1/ivld

						double REFSET = plank_parm4[rgroup].refset*delt60;	// 1/ivld
						double CFSAEX = plank_parm4[rgroup].cfsaex;			// none
						double CLALDH = plank_parm4[rgroup].claldh;			// ug/l		 
						double CFBALG = plank_parm4[rgroup].cfbalg;			// none
						double CFBALR = plank_parm4[rgroup].cfbalr;			// none
						double MBAL = plank_parm4[rgroup].mbal;				// mg/m2
						double SEED = plank_parm4[rgroup].seed;				// mg/l
						double MXSTAY = plank_parm4[rgroup].mxstay;			// mg/l
						double OREF = plank_parm4[rgroup].oref;				// m/s (if orefg = 1) otherwise m3/s
						double PHYSET = plank_parm4[rgroup].physet*delt60;	// 1/ivld

						//compute derived conversion factors
						double CVBC  = BPCNTC/100.0;
						double CVNRBO= NONREF*CVBO;
						double CVPB  = 31.0/(1000.*CVBP);
						double CVBCL = 31.0*RATCLP/CVPB;

						if (balfg == 1)
						{
							//convert maximum benthic algae to micromoles of phosphorus
							MBAL= MBAL/CVPB;
						}

						//compute derived quantities
						PHYCLA = PHYTO*CVBCL;
						double BALCLA = BENAL*CVBCL;
						double TVAL   = BOD/CVBO;

						if (phyfg == 1) 
						{
							TVAL= TVAL+ PHYTO;
							if (zoofg == 1)
							{
								TVAL= TVAL+ ZOO;
							}
						}

						TORN  = ORN+ CVBN*TVAL;
						TORP  = ORP+ CVBP*TVAL;
						TORC  = ORC+ CVBC*TVAL;
						POTBOD= BOD;

						if (phyfg == 1) 
						{
							POTBOD= POTBOD+ (CVNRBO*PHYTO);
							if (zoofg == 1)
							{
								POTBOD= POTBOD+ (CVNRBO*ZOO);
							}
						}

						//define fraction of biomass which is refractory material
						double REFR = 1.0 - NONREF;

						if (phyfg == 1) 
						{
							//phytoplankton simulated
							mup = 0.0;
							mland = 0.0;
							mup_bypass = 0.0;
							mland_bypass = 0.0;
							mpt = 0.0;
							mptwd_target = 0.0;
							mirwd = 0.0;
							mpswd = 0.0;
							imat = 0.0;
							mlink = 0.0;
		
							// upstream routed and bypassed load
							nPolType = POLUT_PHY;
							if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
								goto L001;

							// from land PHYTO
//							double gwo = fgwo[nIndex]*IN_ACRE_TO_FT3/delts; // cfs       
							double gwo = froute_gwo[nIndex]*IN_ACRE_TO_FT3/delts; // cfs       
							double gwo_bypass = fbypass_gwo[nIndex]*IN_ACRE_TO_FT3/delts; // cfs       
							mland = plank_parm4->phycon*gwo*delts*FT3_TO_M3; // mg/l*cfs -> grams/ivld
							mland_bypass = plank_parm4->phycon*gwo_bypass*delts*FT3_TO_M3; // mg/l*cfs -> grams/ivld
							for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
								pChannelInfo[nIndex].bypass_phy[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

//							mland -= mland_bypass;

							// from point source (11/11/2010)
							pqualid = PS_CLA;	// fixed for phycla
							sqalfg = 0;		// get total load
							pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
							pload *= delt60;     // lb/hr to lb/timestep					    
							mpt = pload * LBS_TO_GRAM * 1E6;	// from lb/ivld to microgram/ivld

							mpt /= CVBCL;	//converting phycla (ug/ivl) to phyto (mg/ivl)
							mpt /= 1000.0;	//converting phyto (mg/ivl) to phyto (g/ivl)

							// irrigation withdrawal (11/11/2010)
							mirwd = PHYTO * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

							// pointsource withdrawal (11/11/2010)
							mpswd = PHYTO * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

							// linkage files
							if (nLinkFiles > 0)
							{
								if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
								{
									POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
									while (pos != NULL)
									{
										Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
										mlink += plink435.pLinkData[i].phy; //g
									}
								}
							}

							imat = mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

							//imat = max(0, imat);	//avoid negative value

							double IPHYTO = imat;

							//advect phytoplankton
							ADVPLK(IPHYTO,VOLS,SROVOL,VOL,EROVOL,admod,VOLT,avvelm,OREF,MXSTAY,SEED,delts,&PHYTO,&ROPHYT,&js,crrat);
 
							matphy[nIndex] = ROPHYT;

							//downstream PHYTO
							for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
							{
								if (q2[nIndex] > 0.0) 
								  pChannelInfo[nIndex].down_phy[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matphy[nIndex];
								else
								  pChannelInfo[nIndex].down_phy[jk]= 0.0;
							}

							double DPHYTO = PHYTO;

							if (pReachInfo[nIndex].lkfg <= 10)
								SINK(VOL,AVDEPE,PHYSET,&DPHYTO,&SNKPHY);

							PHYTO = DPHYTO;
 
							if (zoofg == 1) 
							{
								//zooplankton on
								mup = 0.0;
								mland = 0.0;
								mup_bypass = 0.0;
								mland_bypass = 0.0;
								mpt = 0.0;
								mptwd_target = 0.0;
								mirwd = 0.0;
								mpswd = 0.0;
								imat = 0.0;
								mlink = 0.0;

								// upstream routed and bypassed load
								nPolType = POLUT_ZOO;
								if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
									goto L001;

								// from land ZOO
								mland = 0;
								mland_bypass = 0;
								for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
									pChannelInfo[nIndex].bypass_zoo[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

//								mland -= mland_bypass;

								// from point source
								mpt = 0.0;

								// irrigation withdrawal 
								mirwd = 0.0;

								// pointsource withdrawal 
								mpswd = 0.0;

								// linkage files
								if (nLinkFiles > 0)
								{
									if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
									{
										POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
										while (pos != NULL)
										{
											Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
											mlink += plink435.pLinkData[i].zoo; //g
										}
									}
								}

								imat = mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

								//imat = max(0, imat);	//avoid negative value

								double IZOO = imat;

								//advect zooplankton
								ADVPLK(IZOO,VOLS,SROVOL,VOL,EROVOL,admod,VOLT,avvelm,OREF,MXSTAY,SEED,delts,&ZOO,&ROZOO,&js,crrat);

								matzoo[nIndex] = ROZOO;

								//downstream ZOO
								for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
								{
									if (q2[nIndex] > 0.0) 
									  pChannelInfo[nIndex].down_zoo[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matzoo[nIndex];
									else
									  pChannelInfo[nIndex].down_zoo[jk]= 0.0;
								}
							}
						}

//						if (IONFP > 0) 
							//input organic nitrogen
//							IORN= PAD(IONFP + IVL1);
//						else
							//no input organic nitrogen
//							IORN= 0.0;
      
//						INORN= IORN+ PLADDR(1)+ PLADWT(1)

						// ORN
						mup = 0.0;
						mland = 0.0;
						adtot = 0.0;
						mup_bypass = 0.0;
						mland_bypass = 0.0;
						mpt = 0.0;
						mptwd_target = 0.0;
						mirwd = 0.0;
						mpswd = 0.0;
						imat = 0.0;
						mlink = 0.0;
	
						// get the point source withdrawal if targeted to this stream
						mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,concorn,tCurrent);

						// upstream routed and bypassed load
						nPolType = POLUT_ORN;
						if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
							goto L001;

						// from atmosphere
						adtot = ADTOT[4]*453.5924;	// from lb/ivld to gram/ivld

						// from land ORN
//						mland = f_roqual[nIndex*13+10]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
//						f_roqual[nIndex*13+10] = 0;
						mland = f_roqual_route[nIndex*13+10]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						f_roqual_route[nIndex*13+10] = 0;

						mland_bypass = f_roqual_bypass[nIndex*13+10]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
							pChannelInfo[nIndex].bypass_orn[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

						f_roqual_bypass[nIndex*13+10] = 0;

//						mland -= mland_bypass;

						//from point sources
						pqualid = PS_ORN;
					    sqalfg = 0;		// get total load
						pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
						pload *= delt60;     // lb/hr to lb/timestep					    
						mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld 

						double DORN = ORN;

						// irrigation withdrawal 
						mirwd = DORN * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

						// pointsource withdrawal 
						mpswd = DORN * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

						// linkage files
						if (nLinkFiles > 0)
						{
							if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
							{
								POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
								while (pos != NULL)
								{
									Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
									mlink += plink435.pLinkData[i].orn; //g
								}
							}
						}

						imat = adtot + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

						//imat = max(0, imat);	//avoid negative value

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							usrqual_s[nIndex*nNumRqual+6] += (mup+mlink) / LBS_TO_GRAM;			
							lurqual_s[nIndex*nNumRqual+6] += mland / LBS_TO_GRAM;			
							atmsrqual_s[nIndex*nNumRqual+6] += adtot / LBS_TO_GRAM;			
							usrqualbp_s[nIndex*nNumRqual+6] += mup_bypass / LBS_TO_GRAM;			
							lurqualbp_s[nIndex*nNumRqual+6] += mland_bypass / LBS_TO_GRAM;			
							if (nPtSource > 0)
							{
								psrqual_s[nIndex*nNumRqual+6] += mpt / LBS_TO_GRAM;		
								pswdrqual_s[nIndex*nNumRqual+6] += mpswd / LBS_TO_GRAM;	
								pswdrqualdi_s[nIndex*nNumRqual+6] += mptwd_target / LBS_TO_GRAM;	
							}
							if (irrigfg == 1)
								irwdrqual_s[nIndex*nNumRqual+6] += mirwd / LBS_TO_GRAM;
							
							irqual_s[nIndex*nNumRqual+6] += imat / LBS_TO_GRAM;			
						}

						double INORN = imat;	// grams
 
						//advect organic nitrogen
						advect(admod, VOLT, &INORN, &VOLS, &SROVOL, &VOL, &EROVOL, &DORN,
							   &ROORN, delts, &js, crrat);
												
						concorn[nIndex] = DORN;
						matorn[nIndex] = ROORN;

						//downstream ORN
						for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
						{
							if (q2[nIndex] > 0.0) 
							  pChannelInfo[nIndex].down_orn[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matorn[nIndex];
							else
							  pChannelInfo[nIndex].down_orn[jk]= 0.0;
						}

						// apply reduction (01-05-06)
						if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
							matorn[nIndex] = GetBMPReductionLoad(nPolType,nQuals+9,nIndex,mon,delts);

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								pChannelInfo[nIndex].down_orn_s[j2] += pChannelInfo[nIndex].down_orn[j2] / LBS_TO_GRAM;
								pChannelInfo[nIndex].bypass_orn_s[j2] += pChannelInfo[nIndex].bypass_orn[j2] / LBS_TO_GRAM;
							}
						}

						DORN = concorn[nIndex];

						if (pReachInfo[nIndex].lkfg <= 10)
							SINK(VOL,AVDEPE,REFSET,&DORN,&SNKORN);

						ORN = DORN;
 
						// ORP
						mup = 0.0;
						mland = 0.0;
						adtot = 0.0;
						mup_bypass = 0.0;
						mland_bypass = 0.0;
						mpt = 0.0;
						mptwd_target = 0.0;
						mirwd = 0.0;
						mpswd = 0.0;
						imat = 0.0;
						mlink = 0.0;
	
						// get the point source withdrawal if targeted to this stream
						mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,concorp,tCurrent);

						// upstream routed and bypassed load
						nPolType = POLUT_ORP;
						if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
							goto L001;

						// from atmosphere
						adtot = ADTOT[5]*453.5924;	// from lb/ivld to gram/ivld

						// from land ORP
//						mland = f_roqual[nIndex*13+11]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
//						f_roqual[nIndex*13+11] = 0;
						mland = f_roqual_route[nIndex*13+11]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						f_roqual_route[nIndex*13+11] = 0;

						mland_bypass = f_roqual_bypass[nIndex*13+11]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
							pChannelInfo[nIndex].bypass_orp[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

						f_roqual_bypass[nIndex*13+11] = 0;

//						mland -= mland_bypass;

						//from point sources
						pqualid = PS_ORP;
					    sqalfg = 0;		// get total load
						pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
						pload *= delt60;     // lb/hr to lb/timestep					    
						mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld 

						double DORP= ORP;

						// irrigation withdrawal 
						mirwd = DORP * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

						// pointsource withdrawal 
						mpswd = DORP * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

						// linkage files
						if (nLinkFiles > 0)
						{
							if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
							{
								POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
								while (pos != NULL)
								{
									Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
									mlink += plink435.pLinkData[i].orp; //g
								}
							}
						}

						imat = adtot + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

						//imat = max(0, imat);	//avoid negative value

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							usrqual_s[nIndex*nNumRqual+7] += (mup+mlink) / LBS_TO_GRAM;			
							lurqual_s[nIndex*nNumRqual+7] += mland / LBS_TO_GRAM;			
							atmsrqual_s[nIndex*nNumRqual+7] += adtot / LBS_TO_GRAM;			
							usrqualbp_s[nIndex*nNumRqual+7] += mup_bypass / LBS_TO_GRAM;			
							lurqualbp_s[nIndex*nNumRqual+7] += mland_bypass / LBS_TO_GRAM;			
							if (nPtSource > 0)
							{
								psrqual_s[nIndex*nNumRqual+7] += mpt / LBS_TO_GRAM;		
								pswdrqual_s[nIndex*nNumRqual+7] += mpswd / LBS_TO_GRAM;	
								pswdrqualdi_s[nIndex*nNumRqual+7] += mptwd_target / LBS_TO_GRAM;	
							}
							if (irrigfg == 1)
								irwdrqual_s[nIndex*nNumRqual+7] += mirwd / LBS_TO_GRAM;	
							irqual_s[nIndex*nNumRqual+7] += imat / LBS_TO_GRAM;			
						}

						double INORP = imat;	// grams
 
						//advect organic phosphorus
						advect(admod, VOLT, &INORP, &VOLS, &SROVOL, &VOL, &EROVOL, &DORP,
							   &ROORP, delts, &js, crrat);

						concorp[nIndex] = DORP;
						matorp[nIndex] = ROORP;

						//downstream ORP
						for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
						{
							if (q2[nIndex] > 0.0) 
							  pChannelInfo[nIndex].down_orp[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matorp[nIndex];
							else
							  pChannelInfo[nIndex].down_orp[jk]= 0.0;
						}

						// apply reduction (01-05-06)
						if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
							matorp[nIndex] = GetBMPReductionLoad(nPolType,nQuals+10,nIndex,mon,delts);

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								pChannelInfo[nIndex].down_orp_s[j2] += pChannelInfo[nIndex].down_orp[j2] / LBS_TO_GRAM;
								pChannelInfo[nIndex].bypass_orp_s[j2] += pChannelInfo[nIndex].bypass_orp[j2] / LBS_TO_GRAM;
							}
						}

						DORP = concorp[nIndex];

						if (pReachInfo[nIndex].lkfg <= 10)
							SINK(VOL,AVDEPE,REFSET,&DORP,&SNKORP);

						ORP = DORP;
 
						// ORC
						mup = 0.0;
						mland = 0.0;
						adtot = 0.0;
						mup_bypass = 0.0;
						mland_bypass = 0.0;
						mpt = 0.0;
						mptwd_target = 0.0;
						mirwd = 0.0;
						mpswd = 0.0;
						imat = 0.0;
						mlink = 0.0;
	
						// get the point source withdrawal if targeted to this stream
						mptwd_target = GetPointSourceWithDrawal(nIndex,delts,v2,concorc,tCurrent);

						// upstream routed and bypassed load
						nPolType = POLUT_ORC;
						if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
							goto L001;

						// from atmosphere
						adtot = ADTOT[6]*453.5924;	// from lb/ivld to gram/ivld

						// from land ORC
//						mland = f_roqual[nIndex*13+12]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
//						f_roqual[nIndex*13+12] = 0;
						mland = f_roqual_route[nIndex*13+12]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						f_roqual_route[nIndex*13+12] = 0;

						mland_bypass = f_roqual_bypass[nIndex*13+12]*LBS_TO_GRAM;	// from lb/ivld to gram/ivld
						for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
							pChannelInfo[nIndex].bypass_orc[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

						f_roqual_bypass[nIndex*13+12] = 0;

//						mland -= mland_bypass;

						//from point sources
						pqualid = PS_ORC;
					    sqalfg = 0;		// get total load
						pload  = GetLoad(sqalfg, nIndex, pqualid, tCurrent);
						pload *= delt60;     // lb/hr to lb/timestep					    
						mpt = pload * LBS_TO_GRAM;	// from lb/ivld to gram/ivld

						double DORC = ORC;

						// irrigation withdrawal 
						mirwd = DORC * delts * irrwithdrawal * FT3_TO_M3;	// g/ivl	 

						// pointsource withdrawal 
						mpswd = DORC * delts * ptwithdrawal * FT3_TO_M3;	// g/ivl	 

						// linkage files
						if (nLinkFiles > 0)
						{
							if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
							{
								POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
								while (pos != NULL)
								{
									Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
									mlink += plink435.pLinkData[i].orc; //g
								}
							}
						}

						imat = adtot + mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

						//imat = max(0, imat);	//avoid negative value

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							usrqual_s[nIndex*nNumRqual+8] += (mup+mlink) / LBS_TO_GRAM;			
							lurqual_s[nIndex*nNumRqual+8] += mland / LBS_TO_GRAM;			
							atmsrqual_s[nIndex*nNumRqual+8] += adtot / LBS_TO_GRAM;			
							usrqualbp_s[nIndex*nNumRqual+8] += mup_bypass / LBS_TO_GRAM;			
							lurqualbp_s[nIndex*nNumRqual+8] += mland_bypass / LBS_TO_GRAM;			
							if (nPtSource > 0)
							{
								psrqual_s[nIndex*nNumRqual+8] += mpt / LBS_TO_GRAM;		
								pswdrqual_s[nIndex*nNumRqual+8] += mpswd / LBS_TO_GRAM;	
								pswdrqualdi_s[nIndex*nNumRqual+8] += mptwd_target / LBS_TO_GRAM;	
							}
							if (irrigfg == 1)
								irwdrqual_s[nIndex*nNumRqual+8] += mirwd / LBS_TO_GRAM;
							
							irqual_s[nIndex*nNumRqual+8] += imat / LBS_TO_GRAM;			
						}

						double INORC = imat;	// grams

						//advect total organic carbon
						//double DORC= ORC;
						advect(admod, VOLT, &INORC, &VOLS, &SROVOL, &VOL, &EROVOL, &DORC,
							   &ROORC, delts, &js, crrat);

						concorc[nIndex] = DORC;
						matorc[nIndex] = ROORC;

						//downstream ORC
						for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
						{
							if (q2[nIndex] > 0.0) 
							  pChannelInfo[nIndex].down_orc[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matorc[nIndex];
							else
							  pChannelInfo[nIndex].down_orc[jk]= 0.0;
						}

						// apply reduction (01-05-06)
						if (pReachInfo[nIndex].lkfg > 10 && ncrch > 0)
							matorc[nIndex] = GetBMPReductionLoad(nPolType,nQuals+11,nIndex,mon,delts);

						// for stream summary (lb)
						if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
						{
							for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								pChannelInfo[nIndex].down_orc_s[j2] += pChannelInfo[nIndex].down_orc[j2] / LBS_TO_GRAM;
								pChannelInfo[nIndex].bypass_orc_s[j2] += pChannelInfo[nIndex].bypass_orc[j2] / LBS_TO_GRAM;
							}
						}

						DORC = concorc[nIndex];

						if (pReachInfo[nIndex].lkfg <= 10)
							SINK(VOL,AVDEPE,REFSET,&DORC,&SNKORC);

						ORC = DORC;
 
						if (AVDEPE > 0.17 && pReachInfo[nIndex].lkfg <= 10) 
						{
							//calculate solar radiation absorbed; solrad is the solar
							//radiation at gage, corrected for location of reach; 0.97
							//accounts for surface reflection (assumed 3 per cent); cfsaex
							//is the ratio of radiation incident to water surface to gage
							//radiation values (accounts for regional differences, shading
							//of water surface, etc); inlit is a measure of light intensity
							//immediately below surface of reach/res and is expressed as
							//ly/min
//							SOLRAD= PAD(SOLFP + IVL1);
							double SOLRAD = solr_p[nIndex];
							INLIT = 0.97*CFSAEX*SOLRAD/deltm;
 
							if (sdltfg == 1) 
							{
								//influence of sediment on light extinction is considered
//								if (sedfg == 0) 
//								{
									//read total sediment conc. from pad; units are mg/l
//									SSED[4]= PAD(SSEDFP(4) + IVL1);
//								}
//								else
//								{
									//data are available from module section sedtrn
//								}
								//estimate contribution of sediment to light extinction
								EXTSED= LITSED*SSED[4];
							}
							else
							{
								EXTSED= 0.0;
							}
							//calculate contribution of phytoplankton to light extinction
							//(self-shading)
							EXTCLA= .00452*PHYTO*CVBCL;
							//calculate light available for algal growth
							LITRCH(INLIT,EXTB,EXTCLA,EXTSED,AVDEPE,phyfg,balfg,&PHYLIT,&BALLIT,&CFLIT);
 
							if (phyfg == 1) 
							{
								//simulate phytoplankton
								PHYRX(PHYLIT,TW,TALGRL,TALGRH,TALGRM,MALGR,CMMP,
									CMMNP,tamfg,amrfg,nsfg,CMMN,CMMLT,delt60,
									CFLIT,ALR20,CVBPN,phfg,decfg,CVBPC,PALDH,
									NALDH,CLALDH,ALDL,ALDH,ANAER,OXALD,ALNPR,
									CVBO,REFR,CVNRBO,CVPB,CVBCL,LIMIT,CO2,
									&PO4,&NO3,&TAM,&DOX,&ORN,&ORP,&ORC,&BOD,&PHYTO,
									&LIMPHY,&PHYCO2,&PHYCLA,&DOPHY,&BODPHY,&TAMPHY,
									&NO3PHY,&PO4PHY);

								//compute associated fluxes
								PHYDOX= DOPHY*VOLSP;
								PHYBOD= BODPHY*VOLSP;
								PHYTAM= TAMPHY*VOLSP;
								PHYNO3= NO3PHY*VOLSP;
								PHYPO4= PO4PHY*VOLSP;
 
								if (zoofg == 1) 
								{
									//simulate zooplankton
//									ZORX(ZFIL20,TCZFIL,TW,PHYTO,MZOEAT,ZEXDEL,CVPB,
//										ZRES20,TCZRES,ANAER,ZOMASS,tamfg,REFR,
//										zfood,ZD,OXZD,CVBN,CVBP,CVBC,CVNRBO,CVBO,
//										DOX,BOD,ZOO,ORN,ORP,ORC,TAM,NO3,PO4,
//										ZEAT,ZCO2,DOZOO,BODZOO,NITZOO,PO4ZOO);
 
									//compute associated fluxes
//									ZOODOX= -DOZOO*VOLSP;
//									ZOOBOD= BODZOO*VOLSP;
//									if (tamfg != 0) 
//										ZOOTAM= NITZOO*VOLSP;
//									else
//										ZOONO3= NITZOO*VOLSP;
            
//									ZOOPO4= PO4ZOO*VOLSP;
									//update phytoplankton state variable to account for
									//zooplankton predation
//									PHYTO = PHYTO - ZEAT;
									//convert phytoplankton expressed as mg biomass/l to
									//chlorophyll a expressed as ug/l
//									PHYCLA= PHYTO*CVBCL;
								}
								else
								{
									//zooplankton not simulated
									ZCO2= 0.0;
								}
							}
							else
							{
								//phytoplankton and zooplankton not simulated
								PHYCO2= 0.0;
								ZCO2  = 0.0;
							}
 
							if (balfg == 1) 
							{
								//simulate benthic algae
								BALRX(BALLIT,TW,TALGRL,TALGRH,TALGRM,MALGR,CMMP,CMMNP,tamfg,
									amrfg,nsfg,CMMN,CMMLT,delt60,CFLIT,ALR20,CVBPN,phfg,
									decfg,CVBPC,PALDH,NALDH,ALDL,ALDH,ANAER,OXALD,CFBALG,
									CFBALR,ALNPR,CVBO,REFR,CVNRBO,CVPB,MBAL,DEPCOR,LIMIT,
									CVBCL,CO2,&PO4,&NO3,&TAM,&DOX,&ORN,&ORP,&ORC,&BOD,
									&BENAL,&LIMBAL,&BALCO2,&BALCLA,&DOBALG,&BODBAL,
									&TAMBAL,&NO3BAL,&PO4BAL);
 
								//compute associated fluxes
								BALDOX= DOBALG*VOLSP;
								BALBOD= BODBAL*VOLSP;
								BALTAM= TAMBAL*VOLSP;
								BALNO3= NO3BAL*VOLSP;
								BALPO4= PO4BAL*VOLSP;
							}
							else
							{
								//benthic algae not simulated
								BALCO2= 0.0;
							}
						  }
						  else
						  {
							//not enough water in reach/res to warrant simulation of
							//quality processes
							PHYCO2= 0.0;
							BALCO2= 0.0;
							ZCO2  = 0.0;
							PHYDOX= 0.0;
//							ZOODOX= 0.0;
							BALDOX= 0.0;
							PHYBOD= 0.0;
//							ZOOBOD= 0.0;
							BALBOD= 0.0;
							PHYTAM= 0.0;
//							ZOOTAM= 0.0;
							BALTAM= 0.0;
							PHYNO3= 0.0;
//							ZOONO3= 0.0;
							BALNO3= 0.0;
							PHYPO4= 0.0;
//							ZOOPO4= 0.0;
							BALPO4= 0.0;
 
							if (phyfg == 1) 
							{
							  //water scarcity limits phytoplankton growth
							  LIMC  = LIMIT[6];
//							  READ(LIMC,1000) LIMPHY;
							  LIMPHY = LIMC;				
							  PHYCLA= PHYTO*CVBCL;
							}
 
							if (balfg == 1) 
							{
							  //water scarcity limits benthic algae growth
							  LIMC  = LIMIT[6];
//							  READ(LIMC,1000) LIMBAL;
							  LIMBAL = LIMC;				
							  BALCLA= BENAL*CVBCL;
							}
						}
 
						//calculate total organic nitrogen, total organic phosphorus,
						//total organic carbon, and potential biochemical oxygen demand
						if (phyfg == 1) 
						{
							if (zoofg == 1) 
							{
								//phyto and zoo on
								TORN  = ORN + CVBN*(ZOO + PHYTO + BOD/CVBO);
								TORP  = ORP + CVBP*(ZOO + PHYTO + BOD/CVBO);
								TORC  = ORC + CVBC*(ZOO + PHYTO + BOD/CVBO);
								POTBOD= BOD + CVNRBO*(ZOO + PHYTO);
							}
							else
							{
								//phyto on, zoo off
								TORN  = ORN + CVBN*(PHYTO + BOD/CVBO);
								TORP  = ORP + CVBP*(PHYTO + BOD/CVBO);
								TORC  = ORC + CVBC*(PHYTO + BOD/CVBO);
								POTBOD= BOD + CVNRBO*PHYTO;
							}
						}
						else
						{
							//phyto and zoo off
							TORN  = ORN + CVBN*(BOD/CVBO);
							TORP  = ORP + CVBP*(BOD/CVBO);
							TORC  = ORC + CVBC*(BOD/CVBO);
							POTBOD= BOD;
						}

						if (phfg == 1) 
						{
							//simulate ph and carbon species
							// CALL PHCARB

							//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
							//	SUBROUTINE   PHCARB

							//	+ + + PURPOSE + + +
							//	Simulate ph, carbon dioxide, total inorganic carbon,
							//	and alkalinity

							//	+ + + EXTERNALS + + +
							//	ADVECT,BENTH,PHCALC,OMSG,OMSTR,OMSTI,OMSTD
							//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

							// initialize
							int CONVFG = 0;
							double HPLUS = 0;
							double ROTIC = 0;
							double ROCO2 = 0;
							double BENCO2 = 0;
							
							//define local variables
							int	PHDBFG;
							double ALK,COEFF1,COEFF2,COEFF3,COEFF4,HEST,HEST1;
							double HLLIM,HLLIM1,HULIM,HULIM1;

							double *CON = NULL,BRCO2[3];

							for (j2=0; j2<3;++j2)
								BRCO2[j2] = 62.0*delt60;			// mg/m2/ivld 

							// benthal releases 
							BRCO2[1] = ph_para[rgroup].brco2_1*delt60;	// mg/m2/ivld
							BRCO2[2] = ph_para[rgroup].brco2_2*delt60;	// mg/m2/ivld

							//get constant parameters
							int PHCNT = ph_para[rgroup].phcnt;			// none
							int ALKCON = ph_para[rgroup].alkcon;		// none
							if(ALKCON > 0)
								CON = new double[ALKCON];
							double CFCINV = ph_para[rgroup].cfcinv;		// none

							//initial conditions.  table-type ph-init
							double TIC = conctic[nIndex];			// mg/l
							CO2 = concco2[nIndex];					// mg/l (as carbon)
							PH = ph[nIndex];

							// TIC
							mup = 0.0;
							mland = 0.0;
							mup_bypass = 0.0;
							mland_bypass = 0.0;
							mpt = 0.0;
							mirwd = 0.0;
							mpswd = 0.0;
							imat = 0.0;
							mlink = 0.0;

							// upstream routed and bypassed load
							nPolType = POLUT_TIC;
							if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
								goto L001;

							// from land 
							mland = 0;
							mland_bypass = 0;
							for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
								pChannelInfo[nIndex].bypass_tic[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];


//							mland -= mland_bypass;

							// from pointsource
							mpt = 0.0;

							// irrigation withdrawal 
							mirwd = 0.0;	// g/ivl	 

							// pointsource withdrawal 
							mpswd = 0.0;	// g/ivl
							
							mptwd_target = 0.0;

							// linkage files
							if (nLinkFiles > 0)
							{
								if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
								{
									POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
									while (pos != NULL)
									{
										Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
										mlink += plink435.pLinkData[i].tic; //g
									}
								}
							}

							imat = mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

							//imat = max(0, imat);	//avoid negative value

							// for stream summary (lb)
							if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
							{
								usrqual_s[nIndex*nNumRqual+9] += (mup+mlink) / LBS_TO_GRAM;			
								lurqual_s[nIndex*nNumRqual+9] += mland / LBS_TO_GRAM;			
								atmsrqual_s[nIndex*nNumRqual+9] = 0;			
								usrqualbp_s[nIndex*nNumRqual+9] += mup_bypass / LBS_TO_GRAM;			
								lurqualbp_s[nIndex*nNumRqual+9] += mland_bypass / LBS_TO_GRAM;			
								if (nPtSource > 0)
								{
									psrqual_s[nIndex*nNumRqual+9] += mpt / LBS_TO_GRAM;		
									pswdrqual_s[nIndex*nNumRqual+9] += mpswd / LBS_TO_GRAM;	
									pswdrqualdi_s[nIndex*nNumRqual+9] += mptwd_target / LBS_TO_GRAM;	
								}
								if (irrigfg == 1)
									irwdrqual_s[nIndex*nNumRqual+9] += mirwd / LBS_TO_GRAM;
								
								irqual_s[nIndex*nNumRqual+9] += imat / LBS_TO_GRAM;			
							}

							double ITIC = imat;

							//advect total inorganic carbon
							double DTIC= TIC;
							
							advect(admod, VOLT, &ITIC, &VOLS, &SROVOL, &VOL, &EROVOL,
								   &DTIC, &ROTIC, delts, &js, crrat);

							TIC= DTIC;
							conctic[nIndex] = TIC;
							mattic[nIndex] = ROTIC;

							//downstream TIC
							for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
							{
								if (q2[nIndex] > 0.0) 
								  pChannelInfo[nIndex].down_tic[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*mattic[nIndex];
								else
								  pChannelInfo[nIndex].down_tic[jk]= 0.0;
							}

							// for stream summary (lb)
							if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
							{
								for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									pChannelInfo[nIndex].down_tic_s[j2] += pChannelInfo[nIndex].down_tic[j2] / LBS_TO_GRAM;
									pChannelInfo[nIndex].bypass_tic_s[j2] += pChannelInfo[nIndex].bypass_tic[j2] / LBS_TO_GRAM;
								}
							}

							// CO2
							mup = 0.0;
							mup_bypass = 0.0;
							mland = 0.0;
							mland_bypass = 0.0;
							mpt = 0.0;
							mirwd = 0.0;
							mpswd = 0.0;
							imat = 0.0;
							mlink = 0.0;

							// upstream routed and bypassed load
							nPolType = POLUT_CO2;
							if (!GetUpStreamAndUpBypassLoad(nPolType,nIndex,mup,mup_bypass))
								goto L001;

							// from land 
							mland = pco2_route[nIndex];	// gram/ivld

							// bypass load to downstream channel(s)
							mland_bypass = pco2_bypass[nIndex];
							for (j=0; j<pChannelInfo[nIndex].nDSchan; ++j)
								pChannelInfo[nIndex].bypass_co2[j] = mland_bypass * pReachFtable[nIndex].bypass_fr[j];

//							mland -= mland_bypass;

							// from pointsource
							mpt = 0.0;

							// irrigation withdrawal 
							mirwd = 0.0;	// g/ivl	 

							// pointsource withdrawal 
							mpswd = 0.0;	// g/ivl
							
							mptwd_target = 0.0;

							// linkage files
							if (nLinkFiles > 0)
							{
								if(!pChannelInfo[nIndex].cListUpStream.IsEmpty())
								{
									POSITION pos = pChannelInfo[nIndex].cListUpStream.GetHeadPosition();
									while (pos != NULL)
									{
										Link435& plink435 = (Link435&) pChannelInfo[nIndex].cListUpStream.GetNext(pos);
										mlink += plink435.pLinkData[i].co2; //g
									}
								}
							}

							imat = mup + mup_bypass + mland + mpt + mptwd_target - mirwd - mpswd + mlink;	// g/ivl		

							//imat = max(0, imat);	//avoid negative value

							// for stream summary (lb)
							if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
							{
								usrqual_s[nIndex*nNumRqual+10] += (mup+mlink) / LBS_TO_GRAM;			
								lurqual_s[nIndex*nNumRqual+10] += mland / LBS_TO_GRAM;			
								atmsrqual_s[nIndex*nNumRqual+10] = 0;			
								usrqualbp_s[nIndex*nNumRqual+10] += mup_bypass / LBS_TO_GRAM;			
								lurqualbp_s[nIndex*nNumRqual+10] += mland_bypass / LBS_TO_GRAM;			
								if (nPtSource > 0)
								{
									psrqual_s[nIndex*nNumRqual+10] += mpt / LBS_TO_GRAM;		
									pswdrqual_s[nIndex*nNumRqual+10] += mpswd / LBS_TO_GRAM;	
									pswdrqualdi_s[nIndex*nNumRqual+10] += mptwd_target / LBS_TO_GRAM;	
								}
								if (irrigfg == 1)
									irwdrqual_s[nIndex*nNumRqual+10] += mirwd / LBS_TO_GRAM;
								
								irqual_s[nIndex*nNumRqual+10] += imat / LBS_TO_GRAM;			
							}

							double ICO2 = imat;

							//advect carbon dioxide
							double DCO2= CO2;

							advect(admod, VOLT, &ICO2, &VOLS, &SROVOL, &VOL, &EROVOL,
								   &DCO2, &ROCO2, delts, &js, crrat);

							CO2= DCO2;
							concco2[nIndex] = CO2;
							matco2[nIndex] = ROCO2;

							//downstream CO2
							for (jk =0; jk<pChannelInfo[nIndex].nDSchan; jk++)		
							{
								if (q2[nIndex] > 0.0) 
								  pChannelInfo[nIndex].down_co2[jk] = (pChannelInfo[nIndex].down_flow[jk]/q2[nIndex])*matco2[nIndex];
								else
								  pChannelInfo[nIndex].down_co2[jk]= 0.0;
							}

							// for stream summary (lb)
							if (tCurrent >= toStart && tCurrent <= toEnd && nCHsummary > 0)
							{
								for (int j2 =0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									pChannelInfo[nIndex].down_co2_s[j2] += pChannelInfo[nIndex].down_co2[j2] / LBS_TO_GRAM;
									pChannelInfo[nIndex].bypass_co2_s[j2] += pChannelInfo[nIndex].bypass_co2[j2] / LBS_TO_GRAM;
								}
							}

							if (VOL > 0.0) 
							{
								//								if (CONSFG == 0)
								//								{
											//CON(ALKCON)= PAD(CNFP(ALKCON) + IVL1);
								//								}
								//								else
								//								{
											//con(alkcon) is available from section cons
								//								}
								ALK    = CON[ALKCON];
								double TWKELV = TW + 273.16;

								//convert tic, co2, and alk to molar concentrations for
								//duration of phcarb section
								TIC= TIC/12000.;
								CO2= CO2/12000.;
								ALK= ALK/50000.;

								if (AVDEPE > 0.17 && pReachInfo[nIndex].lkfg <= 10) 
								{
									if (benrfg == 1) 
									{
										//simulate benthal release of co2
										//convert co2 to mg/l for use by benth
										CO2= CO2* 12000.;
										BENTH(DOX,ANAER,BRCO2,SCRFAC,DEPCOR,&CO2,&BENCO2);
										CO2= CO2/ 12000.;
									}
									else
									{
										//benthal release of co2 is not considered
										BENCO2= 0.0;
									}
									//calculate molar saturation concentration for co2 (satco2);
									//first, calculate henry's constant, s, for co2; s is defined
									//as the molar concentration of atmospheric co2/partial
									//pressure of co2; cfpres corrects the equation for effects
									//of elevation differences from sea level
									double S= pow(10.,((2385.73/TWKELV) - 14.0184 + .0152642*TWKELV));
									double SATCO2= 3.16E-04*CFPRES*S;

									//calculate increase in co2 due to atmospheric invasion;
									//the co2 invasion is based on oxygen reaeration rate for
									//the control volume
									double KCINV= CFCINV*KOREA;
									if (KCINV >= 1.0) 
										KCINV= .999;

									//calculate net molar co2 change due to co2 invasion,
									//zooplankton excretion and respiration, phytoplankton
									//and benthic algae respiration, bod decay, and benthal
									//release of co2

									//if decfg is on, phyco2 and balco2 have already been set
									//to zero

									double DELTCD= KCINV*(SATCO2 - CO2) + (ZCO2 - PHYCO2 - BALCO2
										  + DECCO2 + BENCO2)/12000.;

									//calculate change in total inorganic carbon balance due
									//to net co2 change
									TIC= TIC + DELTCD;
									if (TIC < 0.0) 
										TIC= 0.0;
								}
								else
								{
									//too little water to warrant simulation of quality
									//processes; calculate values of co2 and ph state variables
									//based on only longitudinal advection
								}

								//calculate ionization product of water
								double KWEQU= pow(10.,(-4470.99/TWKELV + 6.0875 - .01706*TWKELV));

								//calculate first dissociation constant of carbonic acid
								double K1EQU= pow(10.,(-3404.71/TWKELV + 14.8435 - .032786*TWKELV));

								//calculate second dissociation constant of carbonic acid
								double K2EQU= pow(10.,(-2902.39/TWKELV + 6.4980 - .02379*TWKELV));

								//assign values to variables and coefficients used in the
								//solution algorithm

								//set ph to 7.0 if it is undefined (due to no water in reach)
								if (PH < 0.0) 
									PH=7.0;

								HEST  = pow(10.0,(-PH));
								HLLIM = 0.0;
								HULIM = 1.0;
								COEFF1= ALK + K1EQU;
								COEFF2= -KWEQU + ALK*K1EQU + K1EQU*K2EQU - TIC*K1EQU;
								COEFF3= -2.*K1EQU*K2EQU*TIC - K1EQU*KWEQU + ALK*K1EQU*K2EQU;
								COEFF4= -K1EQU*K2EQU*KWEQU;

								//store initial values for hest, hllim, and hulim; these
								//values will be used again if the solution technique for ph
								//does not produce a satisfactory solution within the allowed
								//number of iterations (phcnt)
								HEST1 = HEST;
								HLLIM1= HLLIM;
								HULIM1= HULIM;

								//set printing option for internal variables in the
								//ph solution 0
								PHDBFG= 0;

								//calculate ph
								PHCALC(PHDBFG,PHCNT,COEFF1,COEFF2,COEFF3,COEFF4,
									   &HEST,&HLLIM,&HULIM,&PH,&CONVFG,&HPLUS);

								if (CONVFG == 0) 
								{
									//a satisfactory solution for ph has not been reached;
									//write error message; repeat solution technique to print
									//out values for internal variables
									//CALL OMSTD (DATIM)
									//CALL OMSTI (RCHNO)
									//CALL OMSTR (COEFF1)
									//CALL OMSTR (COEFF2)
									//CALL OMSTR (COEFF3)
									//CALL OMSTR (COEFF4)
									//CALL OMSTR (ALK)
									//CALL OMSTR (TIC)
									//SGRP= 2
									//CALL OMSG (MESSU,MSGFL,SCLU,SGRP,PHECNT(2))

									//set printing option for internal variables in the ph
									//solution 1
									PHDBFG= 1;

									PHCALC(PHDBFG,PHCNT,COEFF1,COEFF2,COEFF3,COEFF4,
										 &HEST1,&HLLIM1,&HULIM1,&PH,&CONVFG,&HPLUS);
								}

								//calculate co2 concentration (molar)
								CO2= TIC/(1. + K1EQU/HPLUS + K1EQU*K2EQU/pow(HPLUS,2));

								//convert tic, co2, and alk from moles/liter to mg/liter
								TIC= TIC*12000.;
								CO2= CO2*12000.;
								ALK= ALK*50000.;
							}
							else
							{
								//reach/res has gone dry during the interval; set ph
								//equal to an undefined value
								PH= -1.0E30;
							}

							concco2[nIndex]	= CO2;		
							conctic[nIndex]	= TIC;		
							ph[nIndex] = PH;
							alk[nIndex] = ALK;

							if (CON != NULL)
								delete []CON;
						}
					}
				}
				//check do level; if dox exceeds user specified level of
				//supersaturation, then release excess do to the atmosphere
				double DOXS= DOX;
				if (DOX > SUPSAT*SATDO)
					DOX= SUPSAT*SATDO;

				readox[nIndex] = READOX + (DOX - DOXS)*VOLSP;

				//update dissolved totals and totals of nutrients
				RDOX = DOX* VOL;
				RBOD = BOD* VOL;
				double RNO3 = NO3* VOL;
				double RTAM = TAM* VOL;
				double RNO2 = NO2* VOL;
				double RPO4 = PO4* VOL;
				double RNH4 = NH4* VOL;
				double RNH3 = NH3* VOL;
				double RRNO3= NO3* VOL;
				double RRTAM= TAM* VOL;
				if (adnhfg == 1) 
					//add adsorbed suspended nh4 to dissolved
					RRTAM = RRTAM + RSNH4[4];

				double RRNO2= NO2* VOL;
				double RRPO4= PO4* VOL;
				if (adpofg == 1) 
					//add adsorbed suspended po4 to dissolved
					RRPO4 = RRPO4 + RSPO4[4];

				// update rqual conc here
				dox[nIndex]			= DOX;		
				bod[nIndex]			= BOD;		
				concphycla[nIndex]	= PHYCLA;
				concbenal[nIndex]	= BENAL;	
	 			concno3[nIndex]		= NO3;		
	 			conctam[nIndex]		= TAM;		
	 			concno2[nIndex]		= NO2;		
	 			concpo4[nIndex]		= PO4;		
				concphy[nIndex]		= PHYTO;	
				conczoo[nIndex]		= ZOO;		
				concorn[nIndex]		= ORN;		
				concorp[nIndex]		= ORP;		
				concorc[nIndex]		= ORC;		
				concTORN[nIndex]	= TORN;		
				concTORP[nIndex]	= TORP;		
				concTORC[nIndex]	= TORC;		


				// output variables
				dox_s[nIndex] += dox[nIndex];					//  mg/l
				if (dox[nIndex] < doxmin_s[nIndex])
					doxmin_s[nIndex] = dox[nIndex];
				if (dox[nIndex] > doxmax_s[nIndex])
					doxmax_s[nIndex] = dox[nIndex];
				doxav_s[nIndex] += dox[nIndex];	
				bod_s[nIndex] += bod[nIndex];
				no3_s[nIndex] += concno3[nIndex];	
				tam_s[nIndex] += conctam[nIndex];
				no2_s[nIndex] += concno2[nIndex];	
				po4_s[nIndex] += concpo4[nIndex];
				for (j2=1; j2<4; ++j2)
				{
					if (sandfg == 0 && j2 == 1)
						continue;
					snh4_s[nIndex*4+j2] += snh4[nIndex*4+j2]*1e+6;	// mg/kg
					spo4_s[nIndex*4+j2] += spo4[nIndex*4+j2]*1e+6;	// mg/kg
				}

				phy_s[nIndex] += concphy[nIndex];				// mg/l
				zoo_s[nIndex] += conczoo[nIndex];				// mg/l	
				phycla_s[nIndex] += concphycla[nIndex];			// ug/l
				benal_s[nIndex] += concbenal[nIndex];			// mg/m2
				orn_s[nIndex] += concorn[nIndex];
				orp_s[nIndex] += concorp[nIndex];	
				orc_s[nIndex] += concorc[nIndex];
				TORN_s[nIndex] += concTORN[nIndex];
				TORP_s[nIndex] += concTORP[nIndex];	
				TORC_s[nIndex] += concTORC[nIndex];

				co2_s[nIndex]  += concco2[nIndex];
				tic_s[nIndex]  += conctic[nIndex];

				matdox_s[nIndex] += matdox[nIndex]/1e+3;	// kg/ivld
				matbod_s[nIndex] += matbod[nIndex]/1e+3;	// kg/ivld
				matno3_s[nIndex] += matno3[nIndex]/1e+3;	// kg/ivld
				mattam_s[nIndex] += mattam[nIndex]/1e+3;	// kg/ivld
				matno2_s[nIndex] += matno2[nIndex]/1e+3;	// kg/ivld
				matpo4_s[nIndex] += matpo4[nIndex]/1e+3;	// kg/ivld
				for (j2=1; j2<4; ++j2)
				{
					if (sandfg == 0 && j2 == 1)
						continue;
					
					matosnh4_s[nIndex*4+j2] += matosnh4[nIndex*4+j2]/1e+3;	// kg/ivld
					matospo4_s[nIndex*4+j2] += matospo4[nIndex*4+j2]/1e+3;	// kg/ivld
				}
				for (j2=1; j2<13; ++j2)
				{
					matsnh4_s[nIndex*13+j2]  += RSNH4[j2]/LBS_TO_GRAM;	// gm to lb
					matspo4_s[nIndex*13+j2]  += RSPO4[j2]/LBS_TO_GRAM;	// gm to lb
				}
				matphy_s[nIndex] += matphy[nIndex]/1e+3;	// kg/ivld
				matzoo_s[nIndex] += matzoo[nIndex]/1e+3;	// kg/ivld
				matorn_s[nIndex] += matorn[nIndex]/1e+3;	// kg/ivld
				matorp_s[nIndex] += matorp[nIndex]/1e+3;	// kg/ivld
				matorc_s[nIndex] += matorc[nIndex]/1e+3;	// kg/ivld

				matco2_s[nIndex] += matco2[nIndex]/1e+3;	// kg/ivld
				mattic_s[nIndex] += mattic[nIndex]/1e+3;	// kg/ivld

				ph_s[nIndex] += ph[nIndex];
				alk_s[nIndex] += alk[nIndex];
			}

			// Threshold Statistics
			if (nThreshold > 0)
			{
				int simfg = 0;
				if (tCurrent.GetYear()   == toStart.GetYear()  && 
					tCurrent.GetMonth()  == toStart.GetMonth() &&
					tCurrent.GetDay()    == toStart.GetDay()   &&
					tCurrent.GetHour()   == toStart.GetHour()  &&
					tCurrent.GetMinute() == toStart.GetMinute())
					simfg = 1;

				if (trgp < 0)
					// skip the reach
					continue;
				for (j=0; j<ntnum; j++)
				{
					int ttype = pMTDATA[trgp*ntnum+j].ttype;
					if (ttype == 0)
						// no standard applied
						continue;

					double value1 = 0.0;
					int tnum = pMTDATA[trgp*ntnum+j].tnum - 1;
					double threshold = pMTDATA[trgp*ntnum+j].fnum[mon]; 
					int tsize = pTHR_RESULTS[nIndex*ntnum+j].q.size();
					int tcount = pThreshold[tnum].tqnum;

					for (k=0; k<tcount; k++)
					{
						int tqid = pThreshold[tnum].tqid[k];
						int tqsd = pThreshold[tnum].tqsd;
						
						//get the pollutant value
						//for GQUALS
						if(pqalfg == 1)
						{
							for (int ii=0; ii<nQuals; ii++)
							{
								double unit = 0.0;
								if(pQual[lgroup*nQuals+ii].qunit == "(ug/l)")
									unit = 16018460;
								else if(pQual[lgroup*nQuals+ii].qunit == "(#/100ml)")
									unit = 1601.846;
								else
									unit = LB_FT3_TO_MG_L;	// lb/ft3 to mg/l

								int pqualid = pQual[lgroup*nQuals+ii].qualid;
								if (tqid == pqualid)
								{
									if (tqsd == 1)
										value1 += (conc_dis[nIndex*nQuals+ii]*unit);
									else
										value1 += (conc_tot[nIndex*nQuals+ii]*unit);
									break;
								}
							}
						}
				
						double unit = LB_FT3_TO_MG_L;	// lb/ft3 to mg/l

						switch(tqid)
						{
						case PS_SAND:
							{
								//sand
								if (sedfg == 1 && sandfg != 0)
									value1 += SSED[1];
							}
							break;
						case PS_SILT:
							{
								//silt
								if (sedfg == 1)
									value1 += SSED[2];
							}
							break;
						case PS_CLAY:
							{
								//clay
								if (sedfg == 1)
									value1 += SSED[3];
							}
							break;
						case PS_TEMP:
							{
								//temp
								if (tempfg == 1)
									value1 += temp2[nIndex];
							}
							break;
						case PS_DOX:
							{
								//do
								if (oxfg == 1)
									value1 += dox[nIndex];
							}
							break;
						case PS_BOD:
							{
								//bod
								if (oxfg == 1)
									value1 += bod[nIndex];
							}
							break;
						case PS_NOX:
							{
								//nox
								if (nutfg == 1)
									value1 += (concno3[nIndex] + concno2[nIndex]);
							}
							break;
						case PS_TAM:
							{
								//tam
								if (nutfg == 1)
									value1 += conctam[nIndex];
							}
							break;
						case PS_PO4:
							{
								//po4
								if (nutfg == 1)
									value1 += concpo4[nIndex];
							}
							break;
						case PS_ORN:
							{
								//orn
								if (plkfg == 1)
									value1 += concorn[nIndex];
							}
							break;
						case PS_ORP:
							{
								//orp
								if (plkfg == 1)
									value1 += concorp[nIndex];
							}
							break;
						case PS_ORC:
							{
								//orc
								if (plkfg == 1)
									value1 += concorc[nIndex];
							}
							break;
						default:
							break;
						}
					}

					if (ttype == 3 || ttype == -3)
					{
						if (value1 > 0)
							value1 = log(value1);
						else
							value1 = log(SMALLNUM);
					}

					if (i == 0)
					{
						// first timestep of simulation
						if (ttype == 1)
						{
							if (value1 > threshold)
								pTHR_RESULTS[nIndex*ntnum+j].trigcount = 1;
							else
								pTHR_RESULTS[nIndex*ntnum+j].trigcount = tsize + 1;
						}
						else if (ttype == -1)
						{
							if (value1 < threshold)
								pTHR_RESULTS[nIndex*ntnum+j].trigcount = 1;
							else
								pTHR_RESULTS[nIndex*ntnum+j].trigcount = tsize + 1;
						}

						if (tsize > 0)
						{
							// populate the queue
							for (k=0; k<tsize; k++)
							{
								pTHR_RESULTS[nIndex*ntnum+j].q.pop();
								pTHR_RESULTS[nIndex*ntnum+j].q.push(value1);
								if (ttype != 1 && ttype != -1)
									pTHR_RESULTS[nIndex*ntnum+j].sum += value1;
							}
						}
						else
						{
							if (ttype != 1 && ttype != -1)
								pTHR_RESULTS[nIndex*ntnum+j].sum = value1;
						}
						
						// initialize for first time step
						pTHR_RESULTS[nIndex*ntnum+j].min = value1;
						pTHR_RESULTS[nIndex*ntnum+j].max = value1;
						pTHR_RESULTS[nIndex*ntnum+j].sumofmean = value1;

						pTHR_RESULTS[nIndex*ntnum+j].simmin = value1;
						pTHR_RESULTS[nIndex*ntnum+j].simmax = value1;
						pTHR_RESULTS[nIndex*ntnum+j].simsumofmean = value1;

						if (ttype == 3 || ttype == -3)
						{
							double value0 = exp(value1); // it is a log value
							pTHR_RESULTS[nIndex*ntnum+j].min = value0;
							pTHR_RESULTS[nIndex*ntnum+j].max = value0;
							pTHR_RESULTS[nIndex*ntnum+j].sumofmean = value0;

							pTHR_RESULTS[nIndex*ntnum+j].simmin = value0;
							pTHR_RESULTS[nIndex*ntnum+j].simmax = value0;
							pTHR_RESULTS[nIndex*ntnum+j].simsumofmean = value0;
						}
					}
					else
					{
						if (tsize > 0)
						{
							double value0 = pTHR_RESULTS[nIndex*ntnum+j].q.front();
							pTHR_RESULTS[nIndex*ntnum+j].q.pop();
							pTHR_RESULTS[nIndex*ntnum+j].q.push(value1);

							if (ttype != 1 && ttype != -1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].sum += (value1 - value0);
								pTHR_RESULTS[nIndex*ntnum+j].simsum += (value1 - value0);
							}
						}
						else
						{
							if (ttype != 1 && ttype != -1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].sum = value1;
								pTHR_RESULTS[nIndex*ntnum+j].simsum = value1;
							}
						}
					}

					// check the standard type
					switch(ttype)
					{
					case 1:
						{
							//instantaneous values > threshold
							if (value1 > threshold)
							{
								pTHR_RESULTS[nIndex*ntnum+j].trigcount = 1;
								pTHR_RESULTS[nIndex*ntnum+j].count ++;
								pTHR_RESULTS[nIndex*ntnum+j].simcount ++;
							}
							else
							{
								pTHR_RESULTS[nIndex*ntnum+j].trigcount ++;
								if (pTHR_RESULTS[nIndex*ntnum+j].trigcount <= tsize)
								{
									pTHR_RESULTS[nIndex*ntnum+j].count ++;
									pTHR_RESULTS[nIndex*ntnum+j].simcount ++;
								}
							}

							if (tsize > 0 && mofg == 1)
							{
								// start of the month
								double value0 = pTHR_RESULTS[nIndex*ntnum+j].q.front();
								pTHR_RESULTS[nIndex*ntnum+j].min = value0;
								pTHR_RESULTS[nIndex*ntnum+j].max = value0;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.clear();
								pTHR_RESULTS[nIndex*ntnum+j].sum = 0.0;

								// get min and max from the queue
								for (k=0; k<tsize; k++)
								{
									value0 = pTHR_RESULTS[nIndex*ntnum+j].q.front();
									pTHR_RESULTS[nIndex*ntnum+j].q.pop();
									pTHR_RESULTS[nIndex*ntnum+j].q.push(value0);

									if (pTHR_RESULTS[nIndex*ntnum+j].min > value0)
										pTHR_RESULTS[nIndex*ntnum+j].min = value0;
									if (pTHR_RESULTS[nIndex*ntnum+j].max < value0)
										pTHR_RESULTS[nIndex*ntnum+j].max = value0;

									pTHR_RESULTS[nIndex*ntnum+j].sum += value0;
									pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(value0);
								}
							}
							else if (mofg == 1)
							{
									pTHR_RESULTS[nIndex*ntnum+j].min = value1;
									pTHR_RESULTS[nIndex*ntnum+j].max = value1;
									pTHR_RESULTS[nIndex*ntnum+j].sum = value1;
									pTHR_RESULTS[nIndex*ntnum+j].listmonth.clear();
									pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(value1);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].min > value1)
									pTHR_RESULTS[nIndex*ntnum+j].min = value1;
								if (pTHR_RESULTS[nIndex*ntnum+j].max < value1)
									pTHR_RESULTS[nIndex*ntnum+j].max = value1;

								pTHR_RESULTS[nIndex*ntnum+j].sum += value1;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(value1);
							}

							if (tsize > 0 && simfg == 1)
							{
								// start of the simulation output
								double value0 = pTHR_RESULTS[nIndex*ntnum+j].q.front();
								pTHR_RESULTS[nIndex*ntnum+j].simmin = value0;
								pTHR_RESULTS[nIndex*ntnum+j].simmax = value0;
								pTHR_RESULTS[nIndex*ntnum+j].simsum = 0.0;
								pTHR_RESULTS[nIndex*ntnum+j].listsim.clear();

								// get min and max from the queue
								for (k=0; k<tsize; k++)
								{
									value0 = pTHR_RESULTS[nIndex*ntnum+j].q.front();
									pTHR_RESULTS[nIndex*ntnum+j].q.pop();
									pTHR_RESULTS[nIndex*ntnum+j].q.push(value0);

									if (pTHR_RESULTS[nIndex*ntnum+j].simmin > value0)
										pTHR_RESULTS[nIndex*ntnum+j].simmin = value0;
									if (pTHR_RESULTS[nIndex*ntnum+j].simmax < value0)
										pTHR_RESULTS[nIndex*ntnum+j].simmax = value0;

									pTHR_RESULTS[nIndex*ntnum+j].simsum += value0;
									//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(value0);
								}
							}
							else if (simfg == 1)
							{
									pTHR_RESULTS[nIndex*ntnum+j].simmin = value1;
									pTHR_RESULTS[nIndex*ntnum+j].simmax = value1;
									pTHR_RESULTS[nIndex*ntnum+j].simsum = value1;
									pTHR_RESULTS[nIndex*ntnum+j].listsim.clear();
									//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(value1);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].simmin > value1)
									pTHR_RESULTS[nIndex*ntnum+j].simmin = value1;
								if (pTHR_RESULTS[nIndex*ntnum+j].simmax < value1)
									pTHR_RESULTS[nIndex*ntnum+j].simmax = value1;

								pTHR_RESULTS[nIndex*ntnum+j].simsum += value1;
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(value1);
							}
						}
						break;
					case -1:
						{
							//instantaneous values < threshold
							if (value1 < threshold)
							{
								pTHR_RESULTS[nIndex*ntnum+j].trigcount = 1;
								pTHR_RESULTS[nIndex*ntnum+j].count ++;
								pTHR_RESULTS[nIndex*ntnum+j].simcount ++;
							}
							else
							{
								pTHR_RESULTS[nIndex*ntnum+j].trigcount ++;
								if (pTHR_RESULTS[nIndex*ntnum+j].trigcount <= tsize)
								{
									pTHR_RESULTS[nIndex*ntnum+j].count ++;
									pTHR_RESULTS[nIndex*ntnum+j].simcount ++;
								}
							}

							if (tsize > 0 && mofg == 1)
							{
								// start of the month
								double value0 = pTHR_RESULTS[nIndex*ntnum+j].q.front();
								pTHR_RESULTS[nIndex*ntnum+j].min = value0;
								pTHR_RESULTS[nIndex*ntnum+j].max = value0;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.clear();
								pTHR_RESULTS[nIndex*ntnum+j].sum = 0.0;

								// get min and max from the queue
								for (k=0; k<tsize; k++)
								{
									value0 = pTHR_RESULTS[nIndex*ntnum+j].q.front();
									pTHR_RESULTS[nIndex*ntnum+j].q.pop();
									pTHR_RESULTS[nIndex*ntnum+j].q.push(value0);

									if (pTHR_RESULTS[nIndex*ntnum+j].min > value0)
										pTHR_RESULTS[nIndex*ntnum+j].min = value0;
									if (pTHR_RESULTS[nIndex*ntnum+j].max < value0)
										pTHR_RESULTS[nIndex*ntnum+j].max = value0;

									pTHR_RESULTS[nIndex*ntnum+j].sum += value0;
									pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(value0);
								}
							}
							else if (mofg == 1)
							{
									pTHR_RESULTS[nIndex*ntnum+j].min = value1;
									pTHR_RESULTS[nIndex*ntnum+j].max = value1;
									pTHR_RESULTS[nIndex*ntnum+j].sum = value1;
									pTHR_RESULTS[nIndex*ntnum+j].listmonth.clear();
									pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(value1);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].min > value1)
									pTHR_RESULTS[nIndex*ntnum+j].min = value1;
								if (pTHR_RESULTS[nIndex*ntnum+j].max < value1)
									pTHR_RESULTS[nIndex*ntnum+j].max = value1;

								pTHR_RESULTS[nIndex*ntnum+j].sum += value1;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(value1);
							}

							if (tsize > 0 && simfg == 1)
							{
								// start of the simulation output
								double value0 = pTHR_RESULTS[nIndex*ntnum+j].q.front();
								pTHR_RESULTS[nIndex*ntnum+j].simmin = value0;
								pTHR_RESULTS[nIndex*ntnum+j].simmax = value0;
								pTHR_RESULTS[nIndex*ntnum+j].listsim.clear();
								pTHR_RESULTS[nIndex*ntnum+j].simsum = 0.0;

								// get min and max from the queue
								for (k=0; k<tsize; k++)
								{
									value0 = pTHR_RESULTS[nIndex*ntnum+j].q.front();
									pTHR_RESULTS[nIndex*ntnum+j].q.pop();
									pTHR_RESULTS[nIndex*ntnum+j].q.push(value0);

									if (pTHR_RESULTS[nIndex*ntnum+j].simmin > value0)
										pTHR_RESULTS[nIndex*ntnum+j].simmin = value0;
									if (pTHR_RESULTS[nIndex*ntnum+j].simmax < value0)
										pTHR_RESULTS[nIndex*ntnum+j].simmax = value0;

									pTHR_RESULTS[nIndex*ntnum+j].simsum += value0;
									//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(value0);
								}
							}
							else if (simfg == 1)
							{
									pTHR_RESULTS[nIndex*ntnum+j].simmin = value1;
									pTHR_RESULTS[nIndex*ntnum+j].simmax = value1;
									pTHR_RESULTS[nIndex*ntnum+j].simsum = value1;
									pTHR_RESULTS[nIndex*ntnum+j].listsim.clear();
									//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(value1);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].simmin > value1)
									pTHR_RESULTS[nIndex*ntnum+j].simmin = value1;
								if (pTHR_RESULTS[nIndex*ntnum+j].simmax < value1)
									pTHR_RESULTS[nIndex*ntnum+j].simmax = value1;

								pTHR_RESULTS[nIndex*ntnum+j].simsum += value1;
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(value1);
							}
						}
						break;
					case 2:
						{
							//arithmetic mean > threshold
							double mean = pTHR_RESULTS[nIndex*ntnum+j].sum;
							if (tsize > 0)
								mean = pTHR_RESULTS[nIndex*ntnum+j].sum / tsize;

							if (mofg == 1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].min = mean;
								pTHR_RESULTS[nIndex*ntnum+j].max = mean;
								pTHR_RESULTS[nIndex*ntnum+j].count = 0;
								pTHR_RESULTS[nIndex*ntnum+j].sumofmean = 0.0;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.clear();
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(mean);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].min > mean)
									pTHR_RESULTS[nIndex*ntnum+j].min = mean;
								if (pTHR_RESULTS[nIndex*ntnum+j].max < mean)
									pTHR_RESULTS[nIndex*ntnum+j].max = mean;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(mean);
							}

							if (simfg == 1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].simmin = mean;
								pTHR_RESULTS[nIndex*ntnum+j].simmax = mean;
								pTHR_RESULTS[nIndex*ntnum+j].simcount = 0;
								pTHR_RESULTS[nIndex*ntnum+j].simsumofmean = 0.0;
								pTHR_RESULTS[nIndex*ntnum+j].listsim.clear();
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(mean);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].simmin > mean)
									pTHR_RESULTS[nIndex*ntnum+j].simmin = mean;
								if (pTHR_RESULTS[nIndex*ntnum+j].simmax < mean)
									pTHR_RESULTS[nIndex*ntnum+j].simmax = mean;
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(mean);
							}

							if (mean > threshold)
							{
								pTHR_RESULTS[nIndex*ntnum+j].count ++;
								pTHR_RESULTS[nIndex*ntnum+j].simcount ++;
							}
							pTHR_RESULTS[nIndex*ntnum+j].sumofmean += mean;
							pTHR_RESULTS[nIndex*ntnum+j].simsumofmean += mean;
						}
						break;
					case -2:
						{
							//arithmetic mean < threshold
							double mean = pTHR_RESULTS[nIndex*ntnum+j].sum;
							if (tsize > 0)
								mean = pTHR_RESULTS[nIndex*ntnum+j].sum / tsize;

							if (mofg == 1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].min = mean;
								pTHR_RESULTS[nIndex*ntnum+j].max = mean;
								pTHR_RESULTS[nIndex*ntnum+j].count = 0;
								pTHR_RESULTS[nIndex*ntnum+j].sumofmean = 0.0;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.clear();
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(mean);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].min > mean)
									pTHR_RESULTS[nIndex*ntnum+j].min = mean;
								if (pTHR_RESULTS[nIndex*ntnum+j].max < mean)
									pTHR_RESULTS[nIndex*ntnum+j].max = mean;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(mean);
							}

							if (simfg == 1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].simmin = mean;
								pTHR_RESULTS[nIndex*ntnum+j].simmax = mean;
								pTHR_RESULTS[nIndex*ntnum+j].simcount = 0;
								pTHR_RESULTS[nIndex*ntnum+j].simsumofmean = 0.0;
								pTHR_RESULTS[nIndex*ntnum+j].listsim.clear();
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(mean);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].simmin > mean)
									pTHR_RESULTS[nIndex*ntnum+j].simmin = mean;
								if (pTHR_RESULTS[nIndex*ntnum+j].simmax < mean)
									pTHR_RESULTS[nIndex*ntnum+j].simmax = mean;
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(mean);
							}

							if (mean < threshold)
							{
								pTHR_RESULTS[nIndex*ntnum+j].count ++;
								pTHR_RESULTS[nIndex*ntnum+j].simcount ++;
							}
							pTHR_RESULTS[nIndex*ntnum+j].sumofmean += mean;
							pTHR_RESULTS[nIndex*ntnum+j].simsumofmean += mean;
						}
						break;
					case 3:
						{
							//geometric mean > threshold
							double mean = pTHR_RESULTS[nIndex*ntnum+j].sum;
							if (tsize > 0)
								mean = pTHR_RESULTS[nIndex*ntnum+j].sum / tsize;

							mean = exp(mean);

							if (mofg == 1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].min = mean;
								pTHR_RESULTS[nIndex*ntnum+j].max = mean;
								pTHR_RESULTS[nIndex*ntnum+j].count = 0;
								pTHR_RESULTS[nIndex*ntnum+j].sumofmean = 0.0;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.clear();
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(mean);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].min > mean)
									pTHR_RESULTS[nIndex*ntnum+j].min = mean;
								if (pTHR_RESULTS[nIndex*ntnum+j].max < mean)
									pTHR_RESULTS[nIndex*ntnum+j].max = mean;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(mean);
							}

							if (simfg == 1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].simmin = mean;
								pTHR_RESULTS[nIndex*ntnum+j].simmax = mean;
								pTHR_RESULTS[nIndex*ntnum+j].simcount = 0;
								pTHR_RESULTS[nIndex*ntnum+j].simsumofmean = 0.0;
								pTHR_RESULTS[nIndex*ntnum+j].listsim.clear();
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(mean);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].simmin > mean)
									pTHR_RESULTS[nIndex*ntnum+j].simmin = mean;
								if (pTHR_RESULTS[nIndex*ntnum+j].simmax < mean)
									pTHR_RESULTS[nIndex*ntnum+j].simmax = mean;
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(mean);
							}

							if (mean > threshold)
							{
								pTHR_RESULTS[nIndex*ntnum+j].count ++;
								pTHR_RESULTS[nIndex*ntnum+j].simcount ++;
							}
							pTHR_RESULTS[nIndex*ntnum+j].sumofmean += mean;
							pTHR_RESULTS[nIndex*ntnum+j].simsumofmean += mean;
						}
						break;
					case -3:
						{
							//geometric mean < threshold
							double mean = pTHR_RESULTS[nIndex*ntnum+j].sum;
							if (tsize > 0)
								mean = pTHR_RESULTS[nIndex*ntnum+j].sum / tsize;

							mean = exp(mean);

							if (mofg == 1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].min = mean;
								pTHR_RESULTS[nIndex*ntnum+j].max = mean;
								pTHR_RESULTS[nIndex*ntnum+j].count = 0;
								pTHR_RESULTS[nIndex*ntnum+j].sumofmean = 0.0;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.clear();
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(mean);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].min > mean)
									pTHR_RESULTS[nIndex*ntnum+j].min = mean;
								if (pTHR_RESULTS[nIndex*ntnum+j].max < mean)
									pTHR_RESULTS[nIndex*ntnum+j].max = mean;
								pTHR_RESULTS[nIndex*ntnum+j].listmonth.push_back(mean);
							}

							if (simfg == 1)
							{
								pTHR_RESULTS[nIndex*ntnum+j].simmin = mean;
								pTHR_RESULTS[nIndex*ntnum+j].simmax = mean;
								pTHR_RESULTS[nIndex*ntnum+j].simcount = 0;
								pTHR_RESULTS[nIndex*ntnum+j].simsumofmean = 0.0;
								pTHR_RESULTS[nIndex*ntnum+j].listsim.clear();
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(mean);
							}
							else
							{
								if (pTHR_RESULTS[nIndex*ntnum+j].simmin > mean)
									pTHR_RESULTS[nIndex*ntnum+j].simmin = mean;
								if (pTHR_RESULTS[nIndex*ntnum+j].simmax < mean)
									pTHR_RESULTS[nIndex*ntnum+j].simmax = mean;
								//pTHR_RESULTS[nIndex*ntnum+j].listsim.push_back(mean);
							}

							if (mean < threshold)
							{
								pTHR_RESULTS[nIndex*ntnum+j].count ++;
								pTHR_RESULTS[nIndex*ntnum+j].simcount ++;
							}
							pTHR_RESULTS[nIndex*ntnum+j].sumofmean += mean;
							pTHR_RESULTS[nIndex*ntnum+j].simsumofmean += mean;
						}
						break;
					default:
						break;
					}
				}
			}

			// save the time series data ?? check
/*			if(pChannelInfo[nIndex].bSave)
			{
				CString strTemp;
				strTemp = m_strModelResultLocation + "load\\" + pChannelInfo[nIndex].strRName;
				strTemp += ".tmp";
				
				TempTimeSeries tempr;
				tempr.tm = tCurrent;
				
				tempr.fNum[0] = q2[nIndex];
				tempr.fNum[1] = (tempfg==1)?matoutp[nIndex]:0.0;
				tempr.fNum[2] = (phfg==1)?matco2[nIndex]:0.0;
				tempr.fNum[3] = (sedfg==1)?matsed1[nIndex]:0.0;
				tempr.fNum[4] = (sedfg==1)?matsed2[nIndex]:0.0;

				for(int i0=0; i0<nQuals; i0++)
				{
					if(i0 < 11)
						tempr.fNum[5+i0] = matout[nIndex*nQuals+i0];
					else
					{
						TRACE("Too many pollutants, should be less than 11.\n");
					}
				}
				AddTempRecord(strTemp, tempr);
			}
*/
		}
		//**********************END TRANSPORTATION********************

		MSG msg;
		if(PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE) != 0)
		{
			if(msg.message == WM_DESTROY)
			{
				goto L001;
			}
			else if(msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
			{
				if(wndProgress.GetSafeHwnd() != NULL)
				{
					wndProgress.DestroyWindow();
					pWnd->ShowWindow(SW_SHOW);
					goto L001;
				}
				else
				{
					pWnd->m_wndStatusBar.SetPaneText(0, "Modeling process stopped by user.");
					pWnd->m_wndStatusBar.SetPaneText(1, "");
					pWnd->m_wndStatusBar.SetPaneText(2, "");
					goto L001;
				}
			}
			else
				AfxGetThread()->PumpMessage();
		}

		if(dayfg == 1)
		{
			if(bCalcEnd)
				goto L001;

			CString strMsg;
			strMsg.Format("Calculating: %02d-%02d-%04d", nSMonth, nSDay, nSYear);
			pWnd->m_wndStatusBar.SetPaneText(0, strMsg);
			
			strMsg.Format("Calculating:\t\t%02d-%02d-%04d", nSMonth, nSDay, nSYear);
			span = tCurrent-tStart;
			ETA_update(eta, span.GetTotalSeconds());
			int hh_elap, mm_elap, ss_elap;
			int hh_eta, mm_eta, ss_eta;
			ETA_get_time_elapsed(eta, &hh_elap, &mm_elap, &ss_elap);
			ETA_get_time_remaining(eta, &hh_eta, &mm_eta, &ss_eta);

			CString strForDdg = strMsg;
			CString strE;
			strE.Format("Time elapsed: %02d:%02d:%02d", hh_elap, mm_elap, ss_elap);
			pWnd->m_wndStatusBar.SetPaneText(1, strE);
			strE.Format("\nTime elapsed:\t\t%02d:%02d:%02d\n", hh_elap, mm_elap, ss_elap);
			strForDdg += strE;

			strE.Format("Time left: %02d:%02d:%02d\n", hh_eta, mm_eta, ss_eta);
			pWnd->m_wndStatusBar.SetPaneText(2, strE);
			
			strE.Format("Time left:\t\t%02d:%02d:%02d\n", hh_eta, mm_eta, ss_eta);
			strForDdg += strE;
			
			COleDateTimeSpan span0 = tEnd-tStart;
			double lfPart = span.GetTotalMinutes();
			double lfAll  = span0.GetTotalMinutes();
			double lfPerc = lfPart/lfAll;
			//pWnd->SetPercentage(lfPerc);
            
			if(wndProgress.GetSafeHwnd() != NULL)
			{
				wndProgress.SetText(strForDdg);
				wndProgress.SetPos((int)(lfPerc*100));
				wndProgress.PeekAndPump();
			}

			if(wndProgress.Cancelled()) 
			{
				wndProgress.DestroyWindow();
				pWnd->ShowWindow(SW_SHOW);
				goto L001;
			}
		}

		if(bCalcEnd)
			goto L001;

		if(wndProgress.Cancelled()) 
		{
			wndProgress.DestroyWindow();
			pWnd->ShowWindow(SW_SHOW);
			goto L001;
		}
	}

L000:

	bCalcEnd = true;
	tspan = toEnd - toStart;
	Days = tspan.GetTotalDays() + 1;
	Years = Days/365.25;
	//dt = Days/deltd;	// total intervals per simulation

 	// landuse average annual summary 
	if(nLUsummary == 1)
	{
		CString str,strRecord;
		CString strFileName = m_strModelResultLocation + "landuse.csv";
		dt = max(0,counter);
		counter = 0;//reset the counter

		for(j=0; j<nsws; j++)
		{
			strRecord = "";
			int lgroup = pswsinfo[j].gindex;
			for(k=0; k<nlandp; k++)
			{
				str.Format("%d,%d,AREA,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,area_s[j*nlandp+k]/dt);
				strRecord += str;
				str.Format("%d,%d,PREC,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,precip_s[j*nlandp+k]/Years);
				strRecord += str;
				str.Format("%d,%d,SURO,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,suro_s[j*nlandp+k]/Years);
				strRecord += str;
				str.Format("%d,%d,IFWO,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,ifwo_s[j*nlandp+k]/Years);
				strRecord += str;
				str.Format("%d,%d,AGWO,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,agwo_s[j*nlandp+k]/Years);
				strRecord += str;
				str.Format("%d,%d,PERO,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pero_s[j*nlandp+k]/Years);
				strRecord += str;
				str.Format("%d,%d,TAET,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,taet_s[j*nlandp+k]/Years);
				strRecord += str;
				area_s[j*nlandp+k] = 0.0;
				precip_s[j*nlandp+k] = 0.0;
				suro_s[j*nlandp+k] = 0.0;
				ifwo_s[j*nlandp+k] = 0.0;
				agwo_s[j*nlandp+k] = 0.0;
				pero_s[j*nlandp+k] = 0.0;
				taet_s[j*nlandp+k] = 0.0;

				if (sedfg == 1)
				{
					str.Format("%d,%d,SEDLOAD,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,sedload_s[j*nlandp+k]/Years);  
					strRecord += str;
					str.Format("%d,%d,SEDWSSD,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,sedwssd_s[j*nlandp+k]/Years);  
					strRecord += str;
					str.Format("%d,%d,SEDSCRS,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,sedscrs_s[j*nlandp+k]/Years);  
					strRecord += str;
					str.Format("%d,%d,SEDSURO,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,sedsuro_s[j*nlandp+k]/Years);  
					strRecord += str;
					str.Format("%d,%d,SEDIFWO,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,sedifwo_s[j*nlandp+k]/Years);  
					strRecord += str;
					str.Format("%d,%d,SEDAGWO,%12.5e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,sedagwo_s[j*nlandp+k]/Years);  
					strRecord += str;
					sedload_s[j*nlandp+k] = 0.0;
					sedwssd_s[j*nlandp+k] = 0.0;
					sedscrs_s[j*nlandp+k] = 0.0;
					sedsuro_s[j*nlandp+k] = 0.0;
					sedifwo_s[j*nlandp+k] = 0.0;
					sedagwo_s[j*nlandp+k] = 0.0;
				}
				
				if (pqalfg == 1)
				{
					for(int m=0; m<nQuals; m++)
					{
						double unit = 1.0;
						if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
							unit = 453592.0; 

						str.Format("%d,%d,SO_%s,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,suroload_s[j*nlandp*nQuals+k*nQuals+m]*unit/Years);
						strRecord += str;
						str.Format("%d,%d,IO_%s,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,ifwoload_s[j*nlandp*nQuals+k*nQuals+m]*unit/Years);
						strRecord += str;
						str.Format("%d,%d,AO_%s,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,agwoload_s[j*nlandp*nQuals+k*nQuals+m]*unit/Years);
						strRecord += str;
						str.Format("%d,%d,PO_%s,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,uniload_s[j*nlandp*nQuals+k*nQuals+m]*unit/Years);
						strRecord += str;
						suroload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
						ifwoload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
						agwoload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
						uniload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
						if (pQual[m].qsdfg > 0 && sedfg == 1)
						{
							str.Format("%d,%d,SED_%s,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,suniload_s[j*nlandp*nQuals+k*nQuals+m]*unit/Years);  
							strRecord += str;
							suniload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
							str.Format("%d,%d,SEDWSSD_%s,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,washqsload_s[j*nlandp*nQuals+k*nQuals+m]*unit/Years);  
							strRecord += str;
							washqsload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
							str.Format("%d,%d,SEDSCRS_%s,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,pQual[lgroup*nQuals+m].qname,scrqsload_s[j*nlandp*nQuals+k*nQuals+m]*unit/Years);  
							strRecord += str;
							scrqsload_s[j*nlandp*nQuals+k*nQuals+m] = 0.0;
						}
					}
				}
				if (oxfg == 1)
				{
					for(int m=0; m<11; m++)
					{
						if (rqflag_s[m] > 0)
						{
							str.Format("%d,%d,RQ_%s,%12.12e\n",pswsinfo[j].subbasin,pluinfop[j*nlandp+k].luid,rqname_s[m],rqload_s[j*nlandp*11+k*11+m]/Years);
							strRecord += str;
						}
						rqload_s[j*nlandp*11+k*11+m] = 0.0;
					}
				}
			}
			// output to the average annual summary file
			if(!WriteOutputLine(strRecord, m_filelanduse))                      
			{
				AfxMessageBox("Cannot write to file" + strFileName);
				Log("Cannot write to file" + strFileName);
				goto L001;
			}
		}
	}
 	// stream average annual summary 
	if(nCHsummary == 1)
	{
		CString str,strRecord;
		CString strFileName = m_strModelResultLocation + "stream.csv";

		for(j=0; j<nch; j++)
		{
			// find the stream index
			int nIndex = stream[j].index;
			int lgroup = pswsinfo[nIndex].gindex;		// land group
			int rgroup = pReachInfo[nIndex].rgid - 1;	// reach group 

			strRecord = "";
			str.Format("%d,-1,USIF,%12.12e\n",pChannelInfo[nIndex].rchid,usif_s[nIndex]/Years);
			strRecord += str;
			usif_s[nIndex] = 0.0;

			str.Format("%d,-2,LUIF,%12.12e\n",pChannelInfo[nIndex].rchid,luif_s[nIndex]/Years);
			strRecord += str;
			luif_s[nIndex] = 0.0;

			str.Format("%d,-1,USBP,%12.12e\n",pChannelInfo[nIndex].rchid,usifbp_s[nIndex]/Years);
			strRecord += str;
			usifbp_s[nIndex] = 0.0;

			str.Format("%d,-2,LUBP,%12.12e\n",pChannelInfo[nIndex].rchid,luifbp_s[nIndex]/Years);
			strRecord += str;
			luifbp_s[nIndex] = 0.0;

			if (nPtSource > 0)
			{
				str.Format("%d,-3,PSIF,%12.12e\n",pChannelInfo[nIndex].rchid,psif_s[nIndex]/Years);
				strRecord += str;
				psif_s[nIndex] = 0.0;

				str.Format("%d,-4,PSWD,%12.12e\n",pChannelInfo[nIndex].rchid,pswd_s[nIndex]/Years);
				strRecord += str;
				pswd_s[nIndex] = 0.0;

				str.Format("%d,-4,PSDT,%12.12e\n",pChannelInfo[nIndex].rchid,pswddi_s[nIndex]/Years);
				strRecord += str;
				pswddi_s[nIndex] = 0.0;
			}

			if (irrigfg == 1)
			{
				str.Format("%d,-5,IRWD,%12.12e\n",pChannelInfo[nIndex].rchid,irwd_s[nIndex]/Years);
				strRecord += str;
				irwd_s[nIndex] = 0.0;
			}

			str.Format("%d,0,IVOL,%12.12e\n",pChannelInfo[nIndex].rchid,ivol_s[nIndex]/Years);
			strRecord += str;
			ivol_s[nIndex] = 0.0;

			for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
			{
				str.Format("%d,%d,RO,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,pChannelInfo[nIndex].down_flow_s[j2]/Years);
				strRecord += str;
				pChannelInfo[nIndex].down_flow_s[j2] = 0.0;
			}

			for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
			{
				str.Format("%d,%d,BP,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,pChannelInfo[nIndex].bypass_flow_s[j2]/Years);
				strRecord += str;
				pChannelInfo[nIndex].bypass_flow_s[j2] = 0.0;
			}

			if (tempfg == 1)
			{
				str.Format("%d,-1,USTEMP,%12.12e\n",pChannelInfo[nIndex].rchid,ustemp_s[nIndex]/Years);
				strRecord += str;
				ustemp_s[nIndex] = 0.0;

				str.Format("%d,-2,LUTEMP,%12.12e\n",pChannelInfo[nIndex].rchid,lutemp_s[nIndex]/Years);
				strRecord += str;
				lutemp_s[nIndex] = 0.0;

				str.Format("%d,-1,USTEBP,%12.12e\n",pChannelInfo[nIndex].rchid,ustempbp_s[nIndex]/Years);
				strRecord += str;
				ustempbp_s[nIndex] = 0.0;

				str.Format("%d,-2,LUTEBP,%12.12e\n",pChannelInfo[nIndex].rchid,lutempbp_s[nIndex]/Years);
				strRecord += str;
				lutempbp_s[nIndex] = 0.0;

				if (nPtSource > 0)
				{
					str.Format("%d,-3,PSTEMP,%12.12e\n",pChannelInfo[nIndex].rchid,pstemp_s[nIndex]/Years);
					strRecord += str;
					pstemp_s[nIndex] = 0.0;

					str.Format("%d,-4,PSWDTEMP,%12.12e\n",pChannelInfo[nIndex].rchid,pswdtemp_s[nIndex]/Years);
					strRecord += str;
					pswdtemp_s[nIndex] = 0.0;

					str.Format("%d,-4,PSDTTEMP,%12.12e\n",pChannelInfo[nIndex].rchid,pswdtempdi_s[nIndex]/Years);
					strRecord += str;
					pswdtempdi_s[nIndex] = 0.0;
				}

				if (irrigfg == 1)
				{
					str.Format("%d,-5,IRWDTEMP,%12.12e\n",pChannelInfo[nIndex].rchid,irwdtemp_s[nIndex]/Years);
					strRecord += str;
					irwdtemp_s[nIndex] = 0.0;
				}

				str.Format("%d,0,ITEMP,%12.12e\n",pChannelInfo[nIndex].rchid,itemp_s[nIndex]/Years);
				strRecord += str;
				itemp_s[nIndex] = 0.0;

				for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
				{
					str.Format("%d,%d,ROTEMP,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,pChannelInfo[nIndex].down_temp_s[j2]/Years);
					strRecord += str;
					pChannelInfo[nIndex].down_temp_s[j2] = 0.0;
				}

				for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
				{
					str.Format("%d,%d,BPTEMP,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,pChannelInfo[nIndex].bypass_temp_s[j2]/Years);
					strRecord += str;
					pChannelInfo[nIndex].bypass_temp_s[j2] = 0.0;
				}
			}

			if (sedfg == 1)
			{
				for(int m=0; m<NumSed; m++)
				{
					if (sandfg == 0 && rsd_param[rgroup*NumSed+m].sedflg == 0)
						continue;

					str.Format("%d,-1,USSED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,ussed_s[nIndex*NumSed+m]/Years);
					strRecord += str;
					ussed_s[nIndex*NumSed+m] = 0.0;

					str.Format("%d,-2,LUSED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,lused_s[nIndex*NumSed+m]/Years);
					strRecord += str;
					lused_s[nIndex*NumSed+m] = 0.0;

					str.Format("%d,-1,USSBP_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,ussedbp_s[nIndex*NumSed+m]/Years);
					strRecord += str;
					ussedbp_s[nIndex*NumSed+m] = 0.0;

					str.Format("%d,-2,LUSBP_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,lusedbp_s[nIndex*NumSed+m]/Years);
					strRecord += str;
					lusedbp_s[nIndex*NumSed+m] = 0.0;

					if (nPtSource > 0)
					{
						str.Format("%d,-3,PSSED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,pssed_s[nIndex*NumSed+m]/Years);
						strRecord += str;
						pssed_s[nIndex*NumSed+m] = 0.0;

						str.Format("%d,-4,PSWDSED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,pswdsed_s[nIndex*NumSed+m]/Years);
						strRecord += str;
						pswdsed_s[nIndex*NumSed+m] = 0.0;

						str.Format("%d,-4,PSDTSED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,pswdseddi_s[nIndex*NumSed+m]/Years);
						strRecord += str;
						pswdseddi_s[nIndex*NumSed+m] = 0.0;
					}

					if (irrigfg == 1)
					{
						str.Format("%d,-5,IRWDSED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,irwdsed_s[nIndex*NumSed+m]/Years);
						strRecord += str;
						irwdsed_s[nIndex*NumSed+m] = 0.0;
					}

					if (sedber == 1 && pReachInfo[nIndex].lkfg == 0)
					{
						str.Format("%d,-6,SEDBER_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,bersed_s[nIndex*NumSed+m]/Years);  
						strRecord += str;
						bersed_s[nIndex*NumSed+m] = 0.0;
					}

					str.Format("%d,0,ISED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,ised_s[nIndex*NumSed+m]/Years);
					strRecord += str;
					ised_s[nIndex*NumSed+m] = 0.0;

					str.Format("%d,0,DEPSCR_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,depscr_ss[nIndex*NumSed+m]/Years);
					strRecord += str;
					depscr_ss[nIndex*NumSed+m] = 0.0;

					str.Format("%d,0,DEPMASS_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,depmass_ss[nIndex*NumSed+m]/Years);
					strRecord += str;
					depmass_ss[nIndex*NumSed+m] = 0.0;

					str.Format("%d,0,SCRMASS_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,scrmass_ss[nIndex*NumSed+m]/Years);
					strRecord += str;
					scrmass_ss[nIndex*NumSed+m] = 0.0;

					str.Format("%d,0,BEDSED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,m+1,bedsed_s[nIndex*NumSed+m]/Years);
					strRecord += str;
					bedsed_s[nIndex*NumSed+m] = 0.0;

					for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
					{
						str.Format("%d,%d,ROSED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,m+1,pChannelInfo[nIndex].down_matsed_s[j2*NumSed+m]/Years);
						strRecord += str;
						pChannelInfo[nIndex].down_matsed_s[j2*NumSed+m] = 0.0;
					}

					for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
					{
						str.Format("%d,%d,BPSED_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,m+1,pChannelInfo[nIndex].bypass_matsed_s[j2*NumSed+m]/Years);
						strRecord += str;
						pChannelInfo[nIndex].bypass_matsed_s[j2*NumSed+m] = 0.0;
					}
				}
			}

			if (pqalfg == 1)
			{
				for(int m=0; m<nQuals; m++)
				{
					double unit = 1.0;
					if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
						unit = 453592.0; 

					str.Format("%d,-1,USQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,usqual_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					usqual_s[nIndex*nQuals+m] = 0.0;

					str.Format("%d,-2,LUQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,luqual_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					luqual_s[nIndex*nQuals+m] = 0.0;

					str.Format("%d,-1,USQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,usqualbp_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					usqualbp_s[nIndex*nQuals+m] = 0.0;

					str.Format("%d,-2,LUQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,luqualbp_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					luqualbp_s[nIndex*nQuals+m] = 0.0;

					if (nPtSource > 0)
					{
						str.Format("%d,-3,PSQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,psqual_s[nIndex*nQuals+m]*unit/Years);
						strRecord += str;
						psqual_s[nIndex*nQuals+m] = 0.0;

						str.Format("%d,-4,PSWDQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,pswdqual_s[nIndex*nQuals+m]*unit/Years);
						strRecord += str;
						pswdqual_s[nIndex*nQuals+m] = 0.0;

						str.Format("%d,-4,PSDTQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,pswdqualdi_s[nIndex*nQuals+m]*unit/Years);
						strRecord += str;
						pswdqualdi_s[nIndex*nQuals+m] = 0.0;
					}

					if (irrigfg == 1)
					{
						str.Format("%d,-5,IRWDQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,irwdqual_s[nIndex*nQuals+m]*unit/Years);
						strRecord += str;
						irwdqual_s[nIndex*nQuals+m] = 0.0;
					}

					if (sedfg == 1 && sedber == 1 && pReachInfo[nIndex].lkfg == 0 && pQualwq[rgroup*nQuals+m].qsdfg > 0)
					{
						str.Format("%d,-6,BERQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,berqual_s[nIndex*nQuals+m]*unit/Years);
						strRecord += str;
						berqual_s[nIndex*nQuals+m] = 0.0;
					}

					str.Format("%d,0,ADTOT_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,adtot_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					adtot_s[nIndex*nQuals+m] = 0.0;

					str.Format("%d,0,IQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,iqual_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					iqual_s[nIndex*nQuals+m] = 0.0;

					str.Format("%d,0,ADQAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,adqal_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					adqal_s[nIndex*nQuals+m] = 0.0;

					str.Format("%d,0,DSQAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,dsqal_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					dsqal_s[nIndex*nQuals+m] = 0.0;

					str.Format("%d,0,DEPQAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,depqal_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					depqal_s[nIndex*nQuals+m] = 0.0;

					str.Format("%d,0,SCRQAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pQual[m].qname,scrqal_s[nIndex*nQuals+m]*unit/Years);
					strRecord += str;
					scrqal_s[nIndex*nQuals+m] = 0.0;

					for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
					{
						str.Format("%d,%d,QUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,pQual[m].qname,pChannelInfo[nIndex].down_matqal_s[j2*nQuals+m]*unit/Years);
						strRecord += str;
						pChannelInfo[nIndex].down_matqal_s[j2*nQuals+m] = 0.0;
					}

					for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
					{
						str.Format("%d,%d,QUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,pQual[m].qname,pChannelInfo[nIndex].bypass_matqal_s[j2*nQuals+m]*unit/Years);
						strRecord += str;
						pChannelInfo[nIndex].bypass_matqal_s[j2*nQuals+m] = 0.0;
					}
				}
			}
			if (oxfg == 1)
			{
				int nNumRqual = 11;
				for(int m=0; m<2; m++)
				{
					str.Format("%d,-1,USRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],usrqual_s[nIndex*nNumRqual+m]/Years);
					strRecord += str;
					usrqual_s[nIndex*nNumRqual+m] = 0.0;

					str.Format("%d,-2,LURQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],lurqual_s[nIndex*nNumRqual+m]/Years);
					strRecord += str;
					lurqual_s[nIndex*nNumRqual+m] = 0.0;

					str.Format("%d,-2,ATMSRQUAL_%s,%12.5e\n",pChannelInfo[nIndex].rchid,rqual_s[m],atmsrqual_s[nIndex*nNumRqual+m]/Years);
					strRecord += str;
					atmsrqual_s[nIndex*nNumRqual+m] = 0.0;

					str.Format("%d,-1,USRQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],usrqualbp_s[nIndex*nNumRqual+m]/Years);
					strRecord += str;
					usrqualbp_s[nIndex*nNumRqual+m] = 0.0;

					str.Format("%d,-2,LURQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],lurqualbp_s[nIndex*nNumRqual+m]/Years);
					strRecord += str;
					lurqualbp_s[nIndex*nNumRqual+m] = 0.0;

					if (nPtSource > 0)
					{
						str.Format("%d,-3,PSRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],psrqual_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						psrqual_s[nIndex*nNumRqual+m] = 0.0;

						str.Format("%d,-4,PSWDRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],pswdrqual_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						pswdrqual_s[nIndex*nNumRqual+m] = 0.0;

						str.Format("%d,-4,PSDTRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],pswdrqualdi_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						pswdrqualdi_s[nIndex*nNumRqual+m] = 0.0;
					}

					if (irrigfg == 1)
					{
						str.Format("%d,-5,IRWDRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],irwdrqual_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						irwdrqual_s[nIndex*nNumRqual+m] = 0.0;
					}

					str.Format("%d,0,IRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],irqual_s[nIndex*nNumRqual+m]/Years);
					strRecord += str;
					irqual_s[nIndex*nNumRqual+m] = 0.0;

					if (m == 0)
					{
						for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
						{
							str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_dox_s[j2]/Years);
							strRecord += str;
							pChannelInfo[nIndex].down_dox_s[j2] = 0.0;
						}
						for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
						{
							str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_dox_s[j2]/Years);
							strRecord += str;
							pChannelInfo[nIndex].bypass_dox_s[j2] = 0.0;
						}
					}
					else if(m == 1)
					{
						for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
						{
							str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_bod_s[j2]/Years);
							strRecord += str;
							pChannelInfo[nIndex].down_bod_s[j2] = 0.0;
						}
						for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
						{
							str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_bod_s[j2]/Years);
							strRecord += str;
							pChannelInfo[nIndex].bypass_bod_s[j2] = 0.0;
						}
					}
				}
				if (nutfg == 1)
				{
					for(int m=2; m<6; m++)
					{
						str.Format("%d,-1,USRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],usrqual_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						usrqual_s[nIndex*nNumRqual+m] = 0.0;

						str.Format("%d,-2,LURQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],lurqual_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						lurqual_s[nIndex*nNumRqual+m] = 0.0;

						str.Format("%d,-2,ATMSRQUAL_%s,%12.5e\n",pChannelInfo[nIndex].rchid,rqual_s[m],atmsrqual_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						atmsrqual_s[nIndex*nNumRqual+m] = 0.0;

						str.Format("%d,-1,USRQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],usrqualbp_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						usrqualbp_s[nIndex*nNumRqual+m] = 0.0;

						str.Format("%d,-2,LURQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],lurqualbp_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						lurqualbp_s[nIndex*nNumRqual+m] = 0.0;

						if (nPtSource > 0)
						{
							str.Format("%d,-3,PSRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],psrqual_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							psrqual_s[nIndex*nNumRqual+m] = 0.0;

							str.Format("%d,-4,PSWDRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],pswdrqual_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							pswdrqual_s[nIndex*nNumRqual+m] = 0.0;

							str.Format("%d,-4,PSDTRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],pswdrqualdi_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							pswdrqualdi_s[nIndex*nNumRqual+m] = 0.0;
						}

						if (irrigfg == 1)
						{
							str.Format("%d,-5,IRWDRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],irwdrqual_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							irwdrqual_s[nIndex*nNumRqual+m] = 0.0;
						}

						str.Format("%d,0,IRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],irqual_s[nIndex*nNumRqual+m]/Years);
						strRecord += str;
						irqual_s[nIndex*nNumRqual+m] = 0.0;

						if (m == 2)
						{
							for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_no3_s[j2]/Years);
								strRecord += str;
								pChannelInfo[nIndex].down_no3_s[j2] = 0.0;
							}
							for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_no3_s[j2]/Years);
								strRecord += str;
								pChannelInfo[nIndex].bypass_no3_s[j2] = 0.0;
							}
						}
						else if(m == 3)
						{
							for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_tam_s[j2]/Years);
								strRecord += str;
								pChannelInfo[nIndex].down_tam_s[j2] = 0.0;
							}
							for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_tam_s[j2]/Years);
								strRecord += str;
								pChannelInfo[nIndex].bypass_tam_s[j2] = 0.0;
							}
							if(sedfg == 1)
							{
								for (int j3=0; j3<3; j3++)
								{
									str.Format("%d,-1,USRQUAL_SNH4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,usSNH4_s[nIndex*3+j3]/Years);
									strRecord += str;
									usSNH4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,-2,LURQUAL_SNH4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,luSNH4_s[nIndex*3+j3]/Years);
									strRecord += str;
									luSNH4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,0,IRQUAL_SNH4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,iSNH4_s[nIndex*3+j3]/Years);
									strRecord += str;
									iSNH4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,0,DSRQUAL_SNH4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,DSNH4_s[nIndex*3+j3]/Years);
									strRecord += str;
									DSNH4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,0,DEPRQUAL_SNH4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,DEPNH4_s[nIndex*3+j3]/Years);
									strRecord += str;
									DEPNH4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,0,SCRRQUAL_SNH4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,SCRNH4_s[nIndex*3+j3]/Years);
									strRecord += str;
									SCRNH4_s[nIndex*3+j3] = 0.0;
								}
								for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									for (j3=0; j3<3; j3++)
									{
										str.Format("%d,%d,RQUAL_SNH4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,j3+1,pChannelInfo[nIndex].down_SNH4_s[j2*3+j3]/Years);
										strRecord += str;
										pChannelInfo[nIndex].down_SNH4_s[j2*3+j3] = 0.0;
									}
								}
								for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									for (j3=0; j3<3; j3++)
									{
										str.Format("%d,%d,RQUAL_SNH4BP_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,j3+1,pChannelInfo[nIndex].bypass_SNH4_s[j2*3+j3]/Years);
										strRecord += str;
										pChannelInfo[nIndex].bypass_SNH4_s[j2*3+j3] = 0.0;
									}
								}
							}
							
							//add benthic
							if (benrfg != 0)
							{
								str.Format("%d,0,BENRQUAL_NH4,%12.12e\n",pChannelInfo[nIndex].rchid,benNH4_s[nIndex]/Years);
								strRecord += str;
								benNH4_s[nIndex] = 0.0;
							}
						}
						else if(m == 4)
						{
							for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_no2_s[j2]/Years);
								strRecord += str;
								pChannelInfo[nIndex].down_no2_s[j2] = 0.0;
							}
							for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_no2_s[j2]/Years);
								strRecord += str;
								pChannelInfo[nIndex].bypass_no2_s[j2] = 0.0;
							}
						}
						else if(m == 5)
						{
							for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_po4_s[j2]/Years);
								strRecord += str;
								pChannelInfo[nIndex].down_po4_s[j2] = 0.0;
							}
							for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
							{
								str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_po4_s[j2]/Years);
								strRecord += str;
								pChannelInfo[nIndex].bypass_po4_s[j2] = 0.0;
							}
							if(sedfg == 1)
							{
								for (int j3=0; j3<3; j3++)
								{
									str.Format("%d,-1,USRQUAL_SPO4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,usSPO4_s[nIndex*3+j3]/Years);
									strRecord += str;
									usSPO4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,-2,LURQUAL_SPO4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,luSPO4_s[nIndex*3+j3]/Years);
									strRecord += str;
									luSPO4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,0,IRQUAL_SPO4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,iSPO4_s[nIndex*3+j3]/Years);
									strRecord += str;
									iSPO4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,0,DSRQUAL_SPO4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,DSPO4_s[nIndex*3+j3]/Years);
									strRecord += str;
									DSPO4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,0,DEPRQUAL_SPO4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,DEPPO4_s[nIndex*3+j3]/Years);
									strRecord += str;
									DEPPO4_s[nIndex*3+j3] = 0.0;
									str.Format("%d,0,SCRRQUAL_SPO4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j3+1,SCRPO4_s[nIndex*3+j3]/Years);
									strRecord += str;
									SCRPO4_s[nIndex*3+j3] = 0.0;
								}
								for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									for (j3=0; j3<3; j3++)
									{
										str.Format("%d,%d,RQUAL_SPO4_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,j3+1,pChannelInfo[nIndex].down_SPO4_s[j2*3+j3]/Years);
										strRecord += str;
										pChannelInfo[nIndex].down_SPO4_s[j2*3+j3] = 0.0;
									}
								}
								for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									for (j3=0; j3<3; j3++)
									{
										str.Format("%d,%d,RQUAL_SPO4BP_%d,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,j3+1,pChannelInfo[nIndex].bypass_SPO4_s[j2*3+j3]/Years);
										strRecord += str;
										pChannelInfo[nIndex].bypass_SPO4_s[j2*3+j3] = 0.0;
									}
								}
							}
							//add benthic
							if (benrfg != 0)
							{
								str.Format("%d,0,BENRQUAL_PO4,%12.12e\n",pChannelInfo[nIndex].rchid,benPO4_s[nIndex]/Years);
								strRecord += str;
								benPO4_s[nIndex] = 0.0;
							}
						}
					}
					if (plkfg == 1)
					{
						for(int m=6; m<9; m++)
						{
							str.Format("%d,-1,USRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],usrqual_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							usrqual_s[nIndex*nNumRqual+m] = 0.0;

							str.Format("%d,-2,LURQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],lurqual_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							lurqual_s[nIndex*nNumRqual+m] = 0.0;

							str.Format("%d,-2,ATMSRQUAL_%s,%12.5e\n",pChannelInfo[nIndex].rchid,rqual_s[m],atmsrqual_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							atmsrqual_s[nIndex*nNumRqual+m] = 0.0;

							str.Format("%d,-1,USRQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],usrqualbp_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							usrqualbp_s[nIndex*nNumRqual+m] = 0.0;

							str.Format("%d,-2,LURQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],lurqualbp_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							lurqualbp_s[nIndex*nNumRqual+m] = 0.0;

							if (nPtSource > 0)
							{
								str.Format("%d,-3,PSRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],psrqual_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								psrqual_s[nIndex*nNumRqual+m] = 0.0;

								str.Format("%d,-4,PSWDRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],pswdrqual_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								pswdrqual_s[nIndex*nNumRqual+m] = 0.0;

								str.Format("%d,-4,PSDTRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],pswdrqualdi_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								pswdrqualdi_s[nIndex*nNumRqual+m] = 0.0;
							}

							if (irrigfg == 1)
							{
								str.Format("%d,-5,IRWDRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],irwdrqual_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								irwdrqual_s[nIndex*nNumRqual+m] = 0.0;
							}

							str.Format("%d,0,IRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],irqual_s[nIndex*nNumRqual+m]/Years);
							strRecord += str;
							irqual_s[nIndex*nNumRqual+m] = 0.0;

							if (m == 6)
							{
								for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_orn_s[j2]/Years);
									strRecord += str;
									pChannelInfo[nIndex].down_orn_s[j2] = 0.0;
								}
								for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_orn_s[j2]/Years);
									strRecord += str;
									pChannelInfo[nIndex].bypass_orn_s[j2] = 0.0;
								}
							}
							else if(m == 7)
							{
								for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_orp_s[j2]/Years);
									strRecord += str;
									pChannelInfo[nIndex].down_orp_s[j2] = 0.0;
								}
								for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_orp_s[j2]/Years);
									strRecord += str;
									pChannelInfo[nIndex].bypass_orp_s[j2] = 0.0;
								}
							}
							else if(m == 8)
							{
								for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_orc_s[j2]/Years);
									strRecord += str;
									pChannelInfo[nIndex].down_orc_s[j2] = 0.0;
								}
								for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
								{
									str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_orc_s[j2]/Years);
									strRecord += str;
									pChannelInfo[nIndex].bypass_orc_s[j2] = 0.0;
								}
							}
						}
						if (phfg == 1)
						{
							for(int m=9; m<11; m++)
							{
								str.Format("%d,-1,USRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],usrqual_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								usrqual_s[nIndex*nNumRqual+m] = 0.0;

								str.Format("%d,-2,LURQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],lurqual_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								lurqual_s[nIndex*nNumRqual+m] = 0.0;

								str.Format("%d,-2,ATMSRQUAL_%s,%12.5e\n",pChannelInfo[nIndex].rchid,rqual_s[m],atmsrqual_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								atmsrqual_s[nIndex*nNumRqual+m] = 0.0;

								str.Format("%d,-1,USRQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],usrqualbp_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								usrqualbp_s[nIndex*nNumRqual+m] = 0.0;

								str.Format("%d,-2,LURQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],lurqualbp_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								lurqualbp_s[nIndex*nNumRqual+m] = 0.0;

								if (nPtSource > 0)
								{
									str.Format("%d,-3,PSRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],psrqual_s[nIndex*nNumRqual+m]/Years);
									strRecord += str;
									psrqual_s[nIndex*nNumRqual+m] = 0.0;

									str.Format("%d,-4,PSWDRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],pswdrqual_s[nIndex*nNumRqual+m]/Years);
									strRecord += str;
									pswdrqual_s[nIndex*nNumRqual+m] = 0.0;

									str.Format("%d,-4,PSDTRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],pswdrqualdi_s[nIndex*nNumRqual+m]/Years);
									strRecord += str;
									pswdrqualdi_s[nIndex*nNumRqual+m] = 0.0;
								}

								if (irrigfg == 1)
								{
									str.Format("%d,-5,IRWDRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],irwdrqual_s[nIndex*nNumRqual+m]/Years);
									strRecord += str;
									irwdrqual_s[nIndex*nNumRqual+m] = 0.0;
								}

								str.Format("%d,0,IRQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,rqual_s[m],irqual_s[nIndex*nNumRqual+m]/Years);
								strRecord += str;
								irqual_s[nIndex*nNumRqual+m] = 0.0;

								if (m == 9)
								{
									for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
									{
										str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_tic_s[j2]/Years);
										strRecord += str;
										pChannelInfo[nIndex].down_tic_s[j2] = 0.0;
									}
									for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
									{
										str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_tic_s[j2]/Years);
										strRecord += str;
										pChannelInfo[nIndex].bypass_tic_s[j2] = 0.0;
									}
								}
								else if(m == 10)
								{
									for (int j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
									{
										str.Format("%d,%d,RQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].down_co2_s[j2]/Years);
										strRecord += str;
										pChannelInfo[nIndex].down_co2_s[j2] = 0.0;
									}
									for (j2=0; j2<pChannelInfo[nIndex].nDSchan; j2++)
									{
										str.Format("%d,%d,RQUBP_%s,%12.12e\n",pChannelInfo[nIndex].rchid,j2+1,rqual_s[m],pChannelInfo[nIndex].bypass_co2_s[j2]/Years);
										strRecord += str;
										pChannelInfo[nIndex].bypass_co2_s[j2] = 0.0;
									}
								}
							}
						}
					}
				}
			}

			// output to the avaerage annual summary file
			if(!WriteOutputLine(strRecord, m_filestream))                      
			{
				AfxMessageBox("Cannot write to file" + strFileName);
				Log("Cannot write to file" + strFileName);
				goto L001;
			}
		}
	}

 	// pointsource average annual summary 
	if(nPSsummary == 1 && nPtSource > 0)
	{
		CString str,strRecord;
		CString strFileName = m_strModelResultLocation + "pointsource.csv";

		for(j=0; j<nch; j++)
		{
			// find the stream index
			int nIndex = stream[j].index;
			int lgroup = pswsinfo[nIndex].gindex;		
			
			if(!pChannelInfo[nIndex].cListPointSources.IsEmpty())
			{
				POSITION pos = pChannelInfo[nIndex].cListPointSources.GetHeadPosition();
				while (pos != NULL)
				{
					PS_SUMMARY& pPS_SUMMARY = (PS_SUMMARY&) pChannelInfo[nIndex].cListPointSources.GetNext(pos);

					strRecord = "";
					str.Format("%d,%s,%s,PS_FLOW,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.lfFlow/Years);
					strRecord += str;
					pPS_SUMMARY.lfFlow = 0.0;

					if (tempfg == 1)
					{
						str.Format("%d,%s,%s,PS_TEMP,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_TEMP]/Years);
						strRecord += str;
						pPS_SUMMARY.psQual[Index_TEMP] = 0.0;
					}
					if (sedfg == 1)
					{
						str.Format("%d,%s,%s,PS_SAND,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_SAND]/Years);
						strRecord += str;
						pPS_SUMMARY.psQual[Index_SAND] = 0.0;
						str.Format("%d,%s,%s,PS_SILT,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_SILT]/Years);
						strRecord += str;
						pPS_SUMMARY.psQual[Index_SILT] = 0.0;
						str.Format("%d,%s,%s,PS_CLAY,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_CLAY]/Years);
						strRecord += str;
						pPS_SUMMARY.psQual[Index_CLAY] = 0.0;
					}
					if (pqalfg == 1)
					{
						for(int m=0; m<nQuals; m++)
						{
							double unit = 1.0;
							if(pQual[lgroup*nQuals+m].qunit == "(#/100ml)")
								unit = 453592.0; 

							str.Format("%d,%s,%s,PS_GQUAL_%s,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pQual[m].qname,pPS_SUMMARY.pGQual[m]*unit/Years);
							strRecord += str;
							pPS_SUMMARY.pGQual[m] = 0.0;
						}
					}
					if (oxfg == 1)
					{
						str.Format("%d,%s,%s,PS_DOX,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_DOX]/Years);
						strRecord += str;
						pPS_SUMMARY.psQual[Index_DOX] = 0.0;

						str.Format("%d,%s,%s,PS_BOD,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_BOD]/Years);
						strRecord += str;
						pPS_SUMMARY.psQual[Index_BOD] = 0.0;

						if (nutfg == 1)
						{
							str.Format("%d,%s,%s,PS_NOX,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_NOX]/Years);
							strRecord += str;
							pPS_SUMMARY.psQual[Index_NOX] = 0.0;

							str.Format("%d,%s,%s,PS_TAM,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_TAM]/Years);
							strRecord += str;
							pPS_SUMMARY.psQual[Index_TAM] = 0.0;

							str.Format("%d,%s,%s,PS_PO4,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_PO4]/Years);
							strRecord += str;
							pPS_SUMMARY.psQual[Index_PO4] = 0.0;

							if (plkfg == 1)
							{
								str.Format("%d,%s,%s,PS_ORN,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_ORN]/Years);
								strRecord += str;
								pPS_SUMMARY.psQual[Index_ORN] = 0.0;

								str.Format("%d,%s,%s,PS_ORP,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_ORP]/Years);
								strRecord += str;
								pPS_SUMMARY.psQual[Index_ORP] = 0.0;

								str.Format("%d,%s,%s,PS_ORC,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_ORC]/Years);
								strRecord += str;
								pPS_SUMMARY.psQual[Index_ORC] = 0.0;

								if (phyfg == 1)
								{
									str.Format("%d,%s,%s,PS_CLA,%12.12e\n",pChannelInfo[nIndex].rchid,pPS_SUMMARY.strPermit,pPS_SUMMARY.strPipe,pPS_SUMMARY.psQual[Index_CLA]/Years);
									strRecord += str;
									pPS_SUMMARY.psQual[Index_CLA] = 0.0;
								}
							}
						}
					}

					// output to the summary file
					if(!WriteOutputLine(strRecord, m_filepointsource))                      
					{
						AfxMessageBox("Cannot write to file" + strFileName);
						Log("Cannot write to file" + strFileName);
						goto L001;
					}
				}
			}
		}
	}

	// Threshold Statistics
	if (nThreshold > 0)
	{
		//simulation period statistics
		CString strFileName = m_strModelResultLocation + "thresholdstat.csv";
		CString str,strRecord;
		double Timesteps = Days/deltd-1;

		for(j=0; j<nch; j++)
		{
			// find the stream index
			int nIndex = stream[j].index;
			int trgp = pReachInfo[nIndex].trgid - 1; 
			if (trgp < 0)
				// skip the reach
				continue;
			strRecord = "";

			for (k=0; k<ntnum; k++)
			{
				int ttype = pMTDATA[trgp*ntnum+k].ttype;
				if (ttype == 0)
					// no standard applied (skip)
					continue;

				int listsize = pTHR_RESULTS[nIndex*ntnum+k].listsim.size();
				if (listsize <= 0)
					continue;

				double *stat = NULL;
				stat = new double[listsize];

				double mean = 0.0;
				if (ttype == 1 || ttype == -1)
					mean = pTHR_RESULTS[nIndex*ntnum+k].simsum/Timesteps;
				else
					mean = pTHR_RESULTS[nIndex*ntnum+k].simsumofmean/Timesteps;

				pTHR_RESULTS[nIndex*ntnum+k].listsim.sort();

				int Index = 0;
				double sdsum = 0.0;
				while (!pTHR_RESULTS[nIndex*ntnum+k].listsim.empty())
				{
					double front = pTHR_RESULTS[nIndex*ntnum+k].listsim.front();
					sdsum += pow((front - mean),2);
					stat[Index] = front;
					
					pTHR_RESULTS[nIndex*ntnum+k].listsim.pop_front();
					Index ++;
				}

				double sd = sqrt(sdsum/(listsize-1));

				str.Format("%d,%d,exceed,%lf\n",pChannelInfo[nIndex].rchid,
					pMTDATA[trgp*ntnum+k].tnum,pTHR_RESULTS[nIndex*ntnum+k].simcount/Timesteps);
				strRecord += str;
				str.Format("%d,%d,min,%lf\n",pChannelInfo[nIndex].rchid,
					pMTDATA[trgp*ntnum+k].tnum,pTHR_RESULTS[nIndex*ntnum+k].simmin);
				strRecord += str;
				str.Format("%d,%d,max,%lf\n",pChannelInfo[nIndex].rchid,
					pMTDATA[trgp*ntnum+k].tnum,pTHR_RESULTS[nIndex*ntnum+k].simmax);
				strRecord += str;
				str.Format("%d,%d,mean,%lf\n",pChannelInfo[nIndex].rchid,
					pMTDATA[trgp*ntnum+k].tnum,mean);
				strRecord += str;
				str.Format("%d,%d,sd,%lf\n",pChannelInfo[nIndex].rchid,
					pMTDATA[trgp*ntnum+k].tnum,sd);
				strRecord += str;

				for (int n=0; n<101; n++)
				{
					// calculate the percentile rank
					// R = 1 + p * (N -1)
					// R = rank
					// p = percentile (in fraction)
					// N = number of values

					double rank = 1 + (n/100.) * (listsize - 1);
					int pos = int(rank);
					double dec = rank - pos;
					double pct = stat[pos-1];
					if(dec > 0)
						pct += (dec*(stat[pos]-stat[pos-1]));
					CString strTemp,strstat;
					strTemp.Format("%d",n+1000);
					strstat.Format("pct"+strTemp.Right(3));

					str.Format("%d,%d,%s,%lf\n",pChannelInfo[nIndex].rchid,
						pMTDATA[trgp*ntnum+k].tnum,strstat,pct);
					strRecord += str;
				}

				//release memory
				if (stat != NULL)
					delete[]stat;
			}

			// output to the summary file
			if(!WriteOutputLine(strRecord, m_filethresholdstat))                      
			{
				AfxMessageBox("Cannot write to file" + strFileName);
				Log("Cannot write to file" + strFileName);
				goto L001;
			}
		}
	}
}
CATCH_ALL(e)
{
}
END_CATCH_ALL

L001:

	for(j=0; j<nsws; j++)
	{
		FILE *fp = NULL;
		fp = pswsinfo[j].m_fileOut;
		if (fp != NULL) 
			fclose(fp);
		fp = pswsinfo[j].m_file_IFWO;
		if (fp != NULL) 
			fclose(fp);
		fp = pswsinfo[j].m_file_AGWO;
		if (fp != NULL) 
			fclose(fp);

		for(k=0; k<nlandp; k++)
		{
			FILE *fp = NULL;
			fp = pluinfop[j*nlandp+k].m_fileOut;
			if (fp != NULL) 
				fclose(fp);
		}

		if(!pChannelInfo[j].cListDownStream.IsEmpty())
		{
			FILE *fp = NULL;
			POSITION pos = pChannelInfo[j].cListDownStream.GetHeadPosition();
			while (pos != NULL)
			{
				Link435& plink435 = (Link435&) pChannelInfo[j].cListDownStream.GetNext(pos);
				fp = plink435.m_linkfile;
				if (fp != NULL) 
					fclose(fp);
			}
		}
	}
	if (nLUsummary > 0)
	{
		if (m_filelanduse != NULL) 
			fclose(m_filelanduse);
	}
	if (nCHsummary > 0)
	{
		if (m_filestream != NULL) 
			fclose(m_filestream);
	}
	if (nPSsummary > 0)
	{
		if (m_filepointsource != NULL) 
			fclose(m_filepointsource);
	}
	if (nThreshold > 0)
	{
		if (m_filethreshold != NULL) 
			fclose(m_filethreshold);
		if (m_filethresholdstat != NULL) 
			fclose(m_filethresholdstat);
	}

	if(wndProgress.GetSafeHwnd() != NULL)
		wndProgress.DestroyWindow();
	pWnd->ShowWindow(SW_SHOW);
	
	ETA_end(eta);
	ETA_destroy(eta);

	if (smsfg_p != NULL)		delete []smsfg_p;
	if (fsmsfg_p != NULL)		delete []fsmsfg_p;
	if (ifwk1_p != NULL)		delete []ifwk1_p;
	if (ifwk2_p != NULL)		delete []ifwk2_p;
	if (lzfrac_p != NULL)		delete []lzfrac_p;
	if (rlzrat_p != NULL)		delete []rlzrat_p;     
	if (rparm_p != NULL)		delete []rparm_p;
	if (dec_p != NULL)			delete []dec_p;
	if (src_p != NULL)			delete []src_p;
	if (ceps_p != NULL)			delete []ceps_p;
	if (surs_p != NULL)			delete []surs_p;
	if (uzs_p != NULL)			delete []uzs_p;
	if (ifws_p != NULL)			delete []ifws_p;
	if (lzs_p != NULL)			delete []lzs_p;
	if (agws_p != NULL)			delete []agws_p;
	if (gwvs_p != NULL)			delete []gwvs_p;
	if (precip_s != NULL)		delete []precip_s;

	//SUSTAIN external timeseries
	if (suro_sustain != NULL)	delete []suro_sustain;
	if (ifwo_sustain != NULL)	delete []ifwo_sustain;
	if (agwo_sustain != NULL)	delete []agwo_sustain;
	if (agwi_sustain != NULL)	delete []agwi_sustain;
	if (sosed_sustain != NULL)	delete []sosed_sustain;
	if (iosed_sustain != NULL)	delete []iosed_sustain;
	if (aosed_sustain != NULL)	delete []aosed_sustain;
	if (soqual_sustain != NULL)	delete []soqual_sustain;
	if (ioqual_sustain != NULL)	delete []ioqual_sustain;
	if (aoqual_sustain != NULL)	delete []aoqual_sustain;

	if (area_s != NULL)			delete []area_s;
	if (suro_s != NULL)			delete []suro_s;
	if (ifwo_s != NULL)			delete []ifwo_s;
	if (agwo_s != NULL)			delete []agwo_s;
	if (pero_s != NULL)			delete []pero_s;
	if (taet_s != NULL)			delete []taet_s;
	if (sedload_s != NULL)		delete []sedload_s;
	if (sedwssd_s != NULL)		delete []sedwssd_s;
	if (sedscrs_s != NULL)		delete []sedscrs_s;
	if (sedsuro_s != NULL)		delete []sedsuro_s;
	if (sedifwo_s != NULL)		delete []sedifwo_s;
	if (sedagwo_s != NULL)		delete []sedagwo_s;
	if (suroload_s != NULL)		delete []suroload_s;
	if (ifwoload_s != NULL)		delete []ifwoload_s;
	if (agwoload_s != NULL)		delete []agwoload_s;
	if (uniload_s != NULL)		delete []uniload_s;
	if (suniload_s != NULL)		delete []suniload_s;
	if (washqsload_s != NULL)	delete []washqsload_s;
	if (scrqsload_s != NULL)	delete []scrqsload_s;
	if (rqload_s != NULL)		delete []rqload_s;
	if (usif_s != NULL)			delete []usif_s;
	if (luif_s != NULL)			delete []luif_s;
	if (usifbp_s != NULL)		delete []usifbp_s;
	if (luifbp_s != NULL)		delete []luifbp_s;
	if (psif_s != NULL)			delete []psif_s;
	if (pswd_s != NULL)			delete []pswd_s;
	if (pswddi_s != NULL)		delete []pswddi_s;
	if (irwd_s != NULL)			delete []irwd_s;
	if (ivol_s != NULL)			delete []ivol_s;
	if (ustemp_s   != NULL)		delete []ustemp_s;
	if (lutemp_s   != NULL)		delete []lutemp_s;
	if (ustempbp_s   != NULL)	delete []ustempbp_s;
	if (lutempbp_s   != NULL)	delete []lutempbp_s;
	if (pstemp_s   != NULL)		delete []pstemp_s;
	if (pswdtemp_s != NULL)		delete []pswdtemp_s;
	if (pswdtempdi_s != NULL)	delete []pswdtempdi_s;
	if (irwdtemp_s != NULL)		delete []irwdtemp_s;
	if (itemp_s    != NULL)		delete []itemp_s;
	if (bersed_s   != NULL)		delete []bersed_s;
	if (ussed_s   != NULL)		delete []ussed_s;
	if (lused_s   != NULL)		delete []lused_s;
	if (ussedbp_s   != NULL)	delete []ussedbp_s;
	if (lusedbp_s   != NULL)	delete []lusedbp_s;
	if (pssed_s   != NULL)		delete []pssed_s;
	if (pswdsed_s != NULL)		delete []pswdsed_s;
	if (pswdseddi_s != NULL)	delete []pswdseddi_s;
	if (irwdsed_s != NULL)		delete []irwdsed_s;
	if (ised_s    != NULL)		delete []ised_s;
	if (depscr_ss != NULL)		delete []depscr_ss;
	if (depmass_ss != NULL)		delete []depmass_ss;
	if (scrmass_ss != NULL)		delete []scrmass_ss;
	if (bedsed_s  != NULL)		delete []bedsed_s;
	if (berqual_s != NULL)		delete []berqual_s;
	if (usqual_s   != NULL)		delete []usqual_s;
	if (luqual_s   != NULL)		delete []luqual_s;
	if (usqualbp_s   != NULL)	delete []usqualbp_s;
	if (luqualbp_s   != NULL)	delete []luqualbp_s;
	if (psqual_s   != NULL)		delete []psqual_s;
	if (pswdqual_s != NULL)		delete []pswdqual_s;
	if (pswdqualdi_s != NULL)	delete []pswdqualdi_s;
	if (irwdqual_s != NULL)		delete []irwdqual_s;
	if (adtot_s    != NULL)		delete []adtot_s;
	if (iqual_s    != NULL)		delete []iqual_s;
	if (adqal_s    != NULL)		delete []adqal_s;
	if (dsqal_s    != NULL)		delete []dsqal_s;
	if (depqal_s    != NULL)	delete []depqal_s;
	if (scrqal_s    != NULL)	delete []scrqal_s;
	if (usrqual_s   != NULL)	delete []usrqual_s;
	if (lurqual_s   != NULL)	delete []lurqual_s;
	if (atmsrqual_s   != NULL)	delete []atmsrqual_s;
	if (usrqualbp_s   != NULL)	delete []usrqualbp_s;
	if (lurqualbp_s   != NULL)	delete []lurqualbp_s;
	if (psrqual_s   != NULL)	delete []psrqual_s;
	if (pswdrqual_s != NULL)	delete []pswdrqual_s;
	if (pswdrqualdi_s != NULL)	delete []pswdrqualdi_s;
	if (irwdrqual_s != NULL)	delete []irwdrqual_s;
	if (irqual_s    != NULL)	delete []irqual_s;

	if (usSNH4_s != NULL)		delete []usSNH4_s;
	if (luSNH4_s != NULL)		delete []luSNH4_s;
	if (iSNH4_s  != NULL)		delete []iSNH4_s;
	if (DSNH4_s  != NULL)		delete []DSNH4_s;
	if (DEPNH4_s  != NULL)		delete []DEPNH4_s;
	if (SCRNH4_s  != NULL)		delete []SCRNH4_s;
	if (usSPO4_s != NULL)		delete []usSPO4_s;
	if (luSPO4_s != NULL)		delete []luSPO4_s;
	if (iSPO4_s  != NULL)		delete []iSPO4_s;
	if (DSPO4_s  != NULL)		delete []DSPO4_s;
	if (DEPPO4_s  != NULL)		delete []DEPPO4_s;
	if (SCRPO4_s  != NULL)		delete []SCRPO4_s;
	// benthic release
	if (benNH4_s  != NULL)		delete []benNH4_s;
	if (benPO4_s  != NULL)		delete []benPO4_s;

	if (fsuro_s != NULL)		delete []fsuro_s;
	if (fifwo_s != NULL)		delete []fifwo_s;
	if (fagwo_s != NULL)		delete []fagwo_s;
	if (fSum_s != NULL)			delete []fSum_s;
	if (cepe_s != NULL)			delete []cepe_s;
	if (uzet_s != NULL)			delete []uzet_s;
	if (baset_s != NULL)		delete []baset_s;
	if (lzet_s != NULL)			delete []lzet_s;
	if (agwet_s != NULL)		delete []agwet_s;
	if (perc_s != NULL)			delete []perc_s;
	if (infil_s != NULL)		delete []infil_s;		
	if (gwi_s != NULL)			delete []gwi_s;			
	if (igwi_s != NULL)			delete []igwi_s;		
	if (agwi_s != NULL)			delete []agwi_s;		
	if (prec_s != NULL)			delete []prec_s;		
	if (snowf_s != NULL)		delete []snowf_s;		
	if (rainf_s != NULL)		delete []rainf_s;		
	if (prain_s != NULL)		delete []prain_s;		
	if (melt_s != NULL)			delete []melt_s;		
	if (snowe_s != NULL)		delete []snowe_s;		
	if (wyield_s != NULL)		delete []wyield_s;		
	if (pack_s != NULL)			delete []pack_s;		
	if (packf_s != NULL)		delete []packf_s;		
	if (packw_s != NULL)		delete []packw_s;		
	if (packi_s != NULL)		delete []packi_s;		
	if (pdepth_s != NULL)		delete []pdepth_s;		
	if (covindx_s != NULL)		delete []covindx_s;		
	if (neghts_s != NULL)		delete []neghts_s;		
	if (xlnmelt_s != NULL)		delete []xlnmelt_s;		
	if (rdenpkf_s != NULL)		delete []rdenpkf_s;		
	if (skyclear_s != NULL)		delete []skyclear_s;	
	if (snocov_s != NULL)		delete []snocov_s;		
	if (dullness_s != NULL)		delete []dullness_s;	
	if (albedo_s != NULL)		delete []albedo_s;		
	if (paktemp_s != NULL)		delete []paktemp_s;		
	if (dewtmp_s != NULL)		delete []dewtmp_s;		
	if (DEP_s != NULL)		    delete []DEP_s;
	if (AVDEP_s != NULL)		delete []AVDEP_s;
	if (HRAD_s != NULL)			delete []HRAD_s;
	if (AVVEL_s != NULL)		delete []AVVEL_s;
	if (SA_s != NULL)			delete []SA_s;
	if (sqo_s != NULL)			delete []sqo_s;
	if (f_suro != NULL)			delete []f_suro;
	if (f_ifwo != NULL)			delete []f_ifwo;
	if (f_agwo != NULL)			delete []f_agwo;
	if (f_prec != NULL)			delete []f_prec;		
	if (f_snowf != NULL)		delete []f_snowf;		
	if (f_rainf != NULL)		delete []f_rainf;		
	if (f_prain != NULL)		delete []f_prain;		
	if (f_melt != NULL)			delete []f_melt;		
	if (f_snowe != NULL)		delete []f_snowe;		
	if (f_wyield != NULL)		delete []f_wyield;		
	if (f_cepe != NULL)			delete []f_cepe;
	if (f_uzet != NULL)			delete []f_uzet;
	if (f_baset != NULL)		delete []f_baset;
	if (f_lzet != NULL)			delete []f_lzet;
	if (f_agwet != NULL)		delete []f_agwet;
	if (f_perc != NULL)			delete []f_perc;
	if (f_infil != NULL)		delete []f_infil;		
	if (f_gwi != NULL)			delete []f_gwi;			
	if (f_igwi != NULL)			delete []f_igwi;		
	if (f_agwi != NULL)			delete []f_agwi;		
	if (fArea != NULL)			delete []fArea;
	if (f_poqual != NULL)		delete []f_poqual;
	if (f_poqual_route != NULL)	delete []f_poqual_route;
	if (f_poqual_bypass != NULL)delete []f_poqual_bypass;
//	if (f_roqual != NULL)		delete []f_roqual;
	if (f_roqual_route != NULL)	delete []f_roqual_route;
	if (f_roqual_bypass != NULL)delete []f_roqual_bypass;
	if (f_posqual != NULL)		delete []f_posqual;
	if (f_posqual_route != NULL)delete []f_posqual_route;
	if (f_posqual_bypass != NULL)delete []f_posqual_bypass;
	if (f_soqual != NULL)		delete []f_soqual;		
	if (f_ioqual != NULL)		delete []f_ioqual;		
	if (f_goqual != NULL)		delete []f_goqual;		
	if (f_suroqo != NULL)		delete []f_suroqo;
	if (f_ifoqual != NULL)		delete []f_ifoqual;     
	if (f_aoqual != NULL)		delete []f_aoqual;
	if (fSum != NULL)			delete []fSum;
	if (froute != NULL)			delete []froute;
	if (fbypass != NULL)		delete []fbypass;
	if (fgwo != NULL)			delete []fgwo;
	if (froute_gwo != NULL)		delete []froute_gwo;
	if (fbypass_gwo != NULL)	delete []fbypass_gwo;
	if (poqual_s != NULL)		delete []poqual_s;
	if (soqual_s != NULL)		delete []soqual_s;		
	if (ioqual_s != NULL)		delete []ioqual_s;      
	if (goqual_s != NULL)		delete []goqual_s;      
	if (fh != NULL)				delete []fh;
	if (fv != NULL)				delete []fv;
	if (fq != NULL)				delete []fq;
	if (fs != NULL)				delete []fs;
	if (fa != NULL)				delete []fa;
	if (fr != NULL)				delete []fr;
	if (fsa != NULL)			delete []fsa;				 
	if (fb != NULL)				delete []fb;
	if (fp != NULL)				delete []fp;
	if (qk != NULL)				delete []qk;
	if (v1 != NULL)				delete []v1;
	if (v2 != NULL)				delete []v2;
	if (avcount != NULL)		delete []avcount;
	if (v2_s != NULL)			delete []v2_s;
	if (q1 != NULL)				delete []q1;
	if (q2 != NULL)				delete []q2;
	if (q2_s != NULL)			delete []q2_s;
	if (vols != NULL)			delete []vols;
	if (vol != NULL)			delete []vol;
	if (qh != NULL)				delete []qh;
	if (XA != NULL)				delete []XA;
	if (HR != NULL)				delete []HR;
	if (v_bip != NULL)			delete []v_bip;
	if (xa_thr != NULL)			delete []xa_thr;
	if (hr_thr != NULL)			delete []hr_thr;
	if (ber_sd != NULL)			delete []ber_sd;
	if (v_bfd != NULL)			delete []v_bfd;
	if (SA != NULL)				delete []SA;
	if (conc_dis != NULL)		delete []conc_dis;
	if (conc_tot != NULL)		delete []conc_tot;
	if (matout != NULL)			delete []matout;
	if (matsedout != NULL)		delete []matsedout;
	if (conc_s != NULL)			delete []conc_s;
	if (concout_s != NULL)		delete []concout_s;
	if (matsqal_s != NULL)		delete []matsqal_s;
	if (matout_s != NULL)		delete []matout_s;
	if (matosqal_s != NULL)		delete []matosqal_s;
	if (matin_s != NULL)		delete []matin_s;
	if (sosed_s != NULL)		delete []sosed_s;
	if (sober_s != NULL)		delete []sober_s;
	if (dets_s != NULL)			delete []dets_s;
	if (fr_sand_bs != NULL)		delete []fr_sand_bs;
	if (fr_silt_bs != NULL)		delete []fr_silt_bs;
	if (fr_clay_bs != NULL)		delete []fr_clay_bs;
	if (fr_sand != NULL)		delete []fr_sand;
	if (fr_silt != NULL)		delete []fr_silt;
	if (fr_clay != NULL)		delete []fr_clay;
	if (slds_s != NULL)			delete []slds_s;
	if (wssd_p != NULL)			delete []wssd_p;
	if (scrs_p != NULL)			delete []scrs_p;
	if (tLastSwept != NULL)		delete []tLastSwept;
	if (tLastSwept_GQ != NULL)	delete []tLastSwept_GQ;
	if (uniflow != NULL)		delete []uniflow;
	if (sed2 != NULL)			delete []sed2;
	if (sedbed != NULL)			delete []sedbed;
	if (matsed != NULL)			delete []matsed;
	if (totsed != NULL)			delete []totsed;
	if (totsed_route != NULL)	delete []totsed_route;
	if (totsed_bypass != NULL)	delete []totsed_bypass;
	if (qualsed != NULL)		delete []qualsed;
	if (qualsed_route != NULL)	delete []qualsed_route;
	if (qualsed_bypass != NULL)	delete []qualsed_bypass;
	if (rssed != NULL)			delete []rssed;
	if (rbsed != NULL)			delete []rbsed;
	if (vbsed != NULL)			delete []vbsed;
	if (rbsedtot != NULL)		delete []rbsedtot;		
	if (vbsedtot != NULL)		delete []vbsedtot;		
	if (tau_s != NULL)			delete []tau_s;
	if (ssed_s != NULL)			delete []ssed_s;
	if (rossed_s != NULL)		delete []rossed_s;
	if (rsed_s != NULL)			delete []rsed_s;
	if (beddep_s != NULL)		delete []beddep_s;
	if (depscr_s != NULL)		delete []depscr_s;		
	if (rosed_s != NULL)		delete []rosed_s;		
	if (ssedc_s != NULL)		delete []ssedc_s;	
	if (rossedc_s != NULL)		delete []rossedc_s;	
	if (rosed1_s != NULL)		delete []rosed1_s;	
	if (rbedsed_s != NULL)		delete []rbedsed_s;	
	if (rdepscr_s != NULL)		delete []rdepscr_s;	
	if (temp1 != NULL)			delete []temp1;
	if (temp2 != NULL)			delete []temp2;
	if (temp2_min != NULL)		delete []temp2_min;
	if (temp2_max != NULL)		delete []temp2_max;
	if (temp2_s != NULL)		delete []temp2_s;
	if (matoutp != NULL)		delete []matoutp;
	if (prec_p != NULL)			delete []prec_p;
	if (supy_p != NULL)			delete []supy_p;
	if (atem_p != NULL)			delete []atem_p;
	if (tmud_p != NULL)			delete []tmud_p;
	if (tmuddt_p != NULL)		delete []tmuddt_p;
	if (wind_p != NULL)			delete []wind_p;
	if (solr_p != NULL)			delete []solr_p;
	if (dewp_p != NULL)			delete []dewp_p;
	if (clou_p != NULL)			delete []clou_p;
	if (pet_p != NULL)			delete []pet_p;
	if (pet_irr != NULL)		delete []pet_irr;
	if (soilts != NULL)			delete []soilts;
	if (soiltu != NULL)			delete []soiltu;
	if (soiltl != NULL)			delete []soiltl;
//	if (soiltm != NULL)			delete []soiltm;
	if (soiltm_route != NULL)	delete []soiltm_route;
	if (soiltm_bypass != NULL)	delete []soiltm_bypass;
	if (RDQAL != NULL)			delete []RDQAL;
	if (RRQAL != NULL)			delete []RRQAL;
	if (CSQAL != NULL)			delete []CSQAL;
	if (pdop != NULL)			delete []pdop;
	if (pdop_route != NULL)		delete []pdop_route;
	if (pdop_bypass != NULL)	delete []pdop_bypass;
	if (pco2p != NULL)			delete []pco2p;
	if (pco2p_route != NULL)	delete []pco2p_route;
	if (pco2p_bypass != NULL)	delete []pco2p_bypass;
//	if (pdox != NULL)			delete []pdox;
	if (pdox_route != NULL)		delete []pdox_route;
	if (pdox_bypass != NULL)	delete []pdox_bypass;
//	if (pco2 != NULL)			delete []pco2;
	if (pco2_route != NULL)		delete []pco2_route;
	if (pco2_bypass != NULL)	delete []pco2_bypass;
	if (soqs_p != NULL)			delete []soqs_p;
	if (washqs_p != NULL)		delete []washqs_p;
	if (scrqs_p != NULL)		delete []scrqs_p;
	if (moveavg != NULL)		delete []moveavg;
	if (airtmp_p != NULL)		delete []airtmp_p;		
	if (snotmp_p != NULL)		delete []snotmp_p;		
	if (airtmp_min != NULL)		delete []airtmp_min;		
	if (airtmp_max != NULL)		delete []airtmp_max;		
	if (airtmp_s != NULL)		delete []airtmp_s;		
	if (snotmp_s != NULL)		delete []snotmp_s;		
	if (packf_p != NULL)		delete []packf_p;
	if (pdepth_p != NULL)		delete []pdepth_p;
	if (rdenpf_p != NULL)		delete []rdenpf_p;
	if (snocov_p != NULL)		delete []snocov_p;
	if (packw_p != NULL)		delete []packw_p;
	if (packi_p != NULL)		delete []packi_p;
	if (paktmp_p != NULL)		delete []paktmp_p;
	if (pack_p != NULL)			delete []pack_p;
	if (dull_p != NULL)			delete []dull_p;
	if (covinx_p != NULL)		delete []covinx_p;
	if (xlnmlt_p != NULL)		delete []xlnmlt_p;
	if (skyclr_p != NULL)		delete []skyclr_p;
	if (snowep_p != NULL)		delete []snowep_p;
	if (covind_p != NULL)		delete []covind_p;
	if (neghts_p != NULL)		delete []neghts_p;
	if (mneghs_p != NULL)		delete []mneghs_p;
	if (packwc_p != NULL)		delete []packwc_p;
	if (neght_p != NULL)		delete []neght_p;
	if (gmeltr_p != NULL)		delete []gmeltr_p;
	if (compct_p != NULL)		delete []compct_p;
	if (mostht_p != NULL)		delete []mostht_p;
	if (vap_p != NULL)			delete []vap_p;
	if (albedo_p != NULL)		delete []albedo_p;		
	if (dewtmp_p != NULL)		delete []dewtmp_p;		
	if (fsurs_s != NULL)		delete []fsurs_s;
	if (fuzs_s != NULL)			delete []fuzs_s;
	if (flzs_s != NULL)			delete []flzs_s;
	if (fagws_s != NULL)		delete []fagws_s;
	if (ftaet_s != NULL)		delete []ftaet_s;
	if (fwssd_s != NULL)		delete []fwssd_s;
	if (fscrsd_s != NULL)		delete []fscrsd_s;
	if (fsqo_s != NULL)			delete []fsqo_s;
	if (fwashqs_s != NULL)		delete []fwashqs_s;
	if (fscrqs_s != NULL)		delete []fscrqs_s;
	if (fsoqo_s != NULL)		delete []fsoqo_s;
	if (fpoqc_s != NULL)		delete []fpoqc_s;
	if (washqs_s != NULL)		delete []washqs_s;
	if (scrqs_s != NULL)		delete []scrqs_s;
	if (soqo_s != NULL)			delete []soqo_s;
	if (ftaet_p != NULL)		delete []ftaet_p; 
	if (dox != NULL)			delete []dox; 
	if (bod != NULL)			delete []bod;
	if (satdo != NULL)			delete []satdo; 
	if (concno3 != NULL)		delete []concno3; 
	if (conctam != NULL)		delete []conctam; 
	if (concno2 != NULL)		delete []concno2; 
	if (concpo4 != NULL)		delete []concpo4; 
	if (snh4 != NULL)			delete []snh4; 
	if (spo4 != NULL)			delete []spo4; 
	if (matosnh4 != NULL)		delete []matosnh4; 
	if (matospo4 != NULL)		delete []matospo4; 
	if (concphy != NULL)		delete []concphy;
	if (concphycla != NULL)		delete []concphycla;
	if (concbenal != NULL)		delete []concbenal;
	if (conczoo != NULL)		delete []conczoo; 
	if (concorn != NULL)		delete []concorn; 
	if (concorp != NULL)		delete []concorp; 
	if (concorc != NULL)		delete []concorc; 
	if (concTORN != NULL)		delete []concTORN; 
	if (concTORP != NULL)		delete []concTORP; 
	if (concTORC != NULL)		delete []concTORC; 
	if (conctic != NULL)		delete []conctic; 
	if (concco2 != NULL)		delete []concco2; 
	if (ph != NULL)				delete []ph; 
	if (alk != NULL)			delete []alk; 
	if (dox_s != NULL)			delete []dox_s; 
	if (doxmin_s != NULL)		delete []doxmin_s; 
	if (doxmax_s != NULL)		delete []doxmax_s; 
	if (doxav_s != NULL)		delete []doxav_s; 
	if (bod_s != NULL)			delete []bod_s; 
	if (no3_s != NULL)			delete []no3_s; 
	if (tam_s != NULL)			delete []tam_s; 
	if (no2_s != NULL)			delete []no2_s; 
	if (po4_s != NULL)			delete []po4_s; 
	if (snh4_s != NULL)			delete []snh4_s; 
	if (spo4_s != NULL)			delete []spo4_s; 
	if (phy_s != NULL)			delete []phy_s; 
	if (zoo_s != NULL)			delete []zoo_s; 
	if (phycla_s != NULL)		delete []phycla_s; 
	if (benal_s != NULL)		delete []benal_s; 
	if (orn_s != NULL)			delete []orn_s; 
	if (orp_s != NULL)			delete []orp_s; 
	if (orc_s != NULL)			delete []orc_s; 
	if (TORN_s != NULL)			delete []TORN_s; 
	if (TORP_s != NULL)			delete []TORP_s; 
	if (TORC_s != NULL)			delete []TORC_s; 
	if (ph_s != NULL)			delete []ph_s; 
	if (alk_s != NULL)			delete []alk_s; 
	if (tic_s != NULL)			delete []tic_s; 
	if (co2_s != NULL)			delete []co2_s; 
	if (doxout_s != NULL)		delete []doxout_s; 
	if (bodout_s != NULL)		delete []bodout_s; 
	if (no3out_s != NULL)		delete []no3out_s; 
	if (tamout_s != NULL)		delete []tamout_s; 
	if (no2out_s != NULL)		delete []no2out_s; 
	if (po4out_s != NULL)		delete []po4out_s; 
	if (phyout_s != NULL)		delete []phyout_s; 
	if (zooout_s != NULL)		delete []zooout_s; 
	if (ornout_s != NULL)		delete []ornout_s; 
	if (orpout_s != NULL)		delete []orpout_s; 
	if (orcout_s != NULL)		delete []orcout_s; 
	if (ticout_s != NULL)		delete []ticout_s; 
	if (co2out_s != NULL)		delete []co2out_s; 
	if (matdox != NULL)			delete []matdox; 
	if (matbod != NULL)			delete []matbod; 
	if (matno3 != NULL)			delete []matno3; 
	if (mattam != NULL)			delete []mattam; 
	if (matno2 != NULL)			delete []matno2; 
	if (matpo4 != NULL)			delete []matpo4; 
	if (matphy != NULL)			delete []matphy; 
	if (matzoo != NULL)			delete []matzoo; 
	if (matorn != NULL)			delete []matorn; 
	if (matorp != NULL)			delete []matorp; 
	if (matorc != NULL)			delete []matorc; 
	if (mattic != NULL)			delete []mattic; 
	if (matco2 != NULL)			delete []matco2; 
	if (matdox_s != NULL)		delete []matdox_s; 
	if (matbod_s != NULL)		delete []matbod_s; 
	if (matno3_s != NULL)		delete []matno3_s; 
	if (mattam_s != NULL)		delete []mattam_s; 
	if (matno2_s != NULL)		delete []matno2_s; 
	if (matpo4_s != NULL)		delete []matpo4_s; 
	if (matsnh4_s != NULL)		delete []matsnh4_s; 
	if (matspo4_s != NULL)		delete []matspo4_s; 
	if (matosnh4_s != NULL)		delete []matosnh4_s; 
	if (matospo4_s != NULL)		delete []matospo4_s; 
	if (matphy_s != NULL)		delete []matphy_s; 
	if (matzoo_s != NULL)		delete []matzoo_s; 
	if (matorn_s != NULL)		delete []matorn_s; 
	if (matorp_s != NULL)		delete []matorp_s; 
	if (matorc_s != NULL)		delete []matorc_s; 
	if (mattic_s != NULL)		delete []mattic_s; 
	if (matco2_s != NULL)		delete []matco2_s; 
	if (readox != NULL)			delete []readox; 
}

//+ + + PURPOSE + + +
//Simulate accumulation of a quality constituent on the land surface
int CLSPCMODEL::BUILDUP(int DAYFG,int VQOFG,int ADCNFG,int ADFXFG,int QSOFG,
						int DAY,int NDAYS,int MON,int NXTMON,double DELT60,
						double PREC,double SLIQO,double ADFLX,double ADCNC,
						double *ADFXMN,double *ADCNMN,double *ADFXFX,double *ADCNFX,
						double *ACQOP,double *REMQOP,double *ACQOPM,double *REMQOM,
						double *ADTOT,double *SQO)
{ 
//+ + + ARGUMENT DEFINITIONS + + +
//DAYFG  - flag for first day or day change
//VQOFG  - ???
//ACQOPM - ???
//REMQOM - ???
//MON    - calendar month
//NXTMON - next calendar month
//DAY    - day of month
//NDAYS  - no. of days in this month
//PREC   - precipitation during current interval in inches
//ADFXFG - flag indicating source of dry deposition flux
//         positive means monthly, -1 means time series,
//         0 means none
//ADCNFG - flag indicating source of wet deposition flux
//         postive means monthly, -1 means time series,
//         0 means none
//ADFXMN - monthly dry atmospheric deposition in qty/ac
//ADCNMN - monthly wet atmospheric deposition in qty/ac.inch
//ADFLX  - current dry atmospheric deposition in qty/ac
//ADCNC  - current wet atmospheric deposition in qty/ac.inch
//SLIQO  - lateral inflow of qualof
//ACQOP  - ???
//REMQOP - ???
//SQO    - ???
//ADFXFX - actual dry atmospheric deposition flux for current interval
//ADCNFX - actual wet atmospheric deposition flux for current interval
//ADTOT  - actual total atmospheric deposition flux for current interval
 
	//+ + + LOCAL VARIABLES + + +
	double DUMMY = 0.0;
	double UNIT = 1/LB_FT3_TO_MG_L;  /* mg/l -> lb/ft^3  */
 
	if (DAYFG == 1) 
	{
		//it is the first interval of the day
        if (VQOFG == 1) 
		{
			//accumulation rate of this quality constituent is allowed
			//to vary throughout the year
			//interpolate for the daily value
			//linearly interpolate acqop between two values from the
			//monthly array acqopm(12) for this overland flow associated
			//quality constituent (no. qofp)
			*ACQOP= dayval(&ACQOPM[MON],&ACQOPM[NXTMON],&DAY,&NDAYS);
			//removal unit rate of this quality constituent is allowed
			//to vary throughout the year
			//interpolate for the daily value
			//linearly interpolate remqop between two values from the
			//monthly array remqom(12) for this overland flow associated
			//quality constituent (no. qofp)
			*REMQOP= dayval(&REMQOM[MON],&REMQOM[NXTMON],&DAY,&NDAYS);
        }
        if (QSOFG == 1)	// accumulation and removal occurs on daily basis
			//update storage due to accumulation and removal which occurs
			//independent of runoff - units are qty/acre
			*SQO = *ACQOP + *SQO * (1.0 - *REMQOP);
	}
 
	//handle atmospheric deposition
	//dry deposition	(lb/acre/ivl)
	if (ADFXFG <= -1) 
		//dry flux has been input as a time series
		*ADFXFX = ADFLX;	// not supported
	else if (ADFXFG >= 1) 
        //dry flux is taken from monthly values
        *ADFXFX = dayval(&ADFXMN[MON],&ADFXMN[NXTMON],&DAY,&NDAYS) * (DELT60 / 24.0);
	else
        *ADFXFX = ADFLX * (DELT60 / 24.0);
       
	//wet deposition	(lb/acre/ivl)
	if (ADCNFG <= -1) 
        //wet deposition concentration has been input as a time series
        *ADCNFX = PREC * ADCNC;	// not supported 
	else if (ADCNFG >= 1) 
        //wet deposition concentration is taken from monthly values
        *ADCNFX = PREC * dayval(&ADCNMN[MON],&ADCNMN[NXTMON],&DAY,&NDAYS) * UNIT * IN_ACRE_TO_FT3;
	else
        *ADCNFX = PREC * ADCNC * UNIT * IN_ACRE_TO_FT3;	// in/ivl * mg/l * (mg/l -> lb/ft3) * (lb/ft3 -> lb/acre-in) --> lb/acre/ivl
       
	*ADTOT = *ADFXFX + *ADCNFX;	// - units are lb/acre/ivl
 
	if (QSOFG == 2)	// accumulation and removal occurs per interval
	{
        //update storage due to accumulation and removal which occurs
        //independent of runoff - units are qty/acre
		if ((*ACQOP / *REMQOP) > 0)
			DUMMY = *REMQOP + (*ADTOT + SLIQO) / (*ACQOP / *REMQOP);
        if (DUMMY > 1.0) 
			DUMMY = 1.0;
        *SQO = *ACQOP * (DELT60 / 24.0) + *SQO * pow((1.0 - DUMMY),(DELT60/24.0));
	}
	else
	{
		//update storage (qty/acre)
		*SQO = *SQO + SLIQO + *ADTOT;
	}
 
	return 0;
}

//+ + + PURPOSE + + +
//Simulate removal of a quality constituent on the land surface using a 
//constant unit rate and by direct washoff by overland flow
int CLSPCMODEL::WASHOFF(double SURO,double WSFAC,
						double *SQO,double *SOQO,double *SOQOC)
{ 
	//+ + + ARGUMENT DEFINITIONS + + +
	//SURO   - surface output
	//WSFAC  - ???
	//SQO    - ???
	//SOQO   - ???
	//SOQOC  - ???
 
	//+ + + LOCAL VARIABLES + + +
	double DUMMY = 0.0;
 
	//simulate washoff by overland flow - units are qty/acre-ivl
	if (SURO > 0.0) 
	{
        //there is overland flow
        if (*SQO > 0.0) 
		{
			//there is some quality constituent (no. qofp) in storage;
			//washoff can occur
			DUMMY = SURO * WSFAC; // added from qualof (09-13-05)
			if (DUMMY < 1e-5)
			{
				//washoff too small for stable calculation - set to zero  
				*SOQO = 0.0;
			}
			else
			{
				// calculate washoff
				DUMMY = 1.0 - exp(-DUMMY);
				*SOQO = *SQO * DUMMY;
			}
			//update storage of constituent - units are in qty/acre
			*SQO = *SQO - *SOQO;
        }
		else
		{
			//no washoff load
			*SOQO= 0.0;
		}
	}
	else
	{
		*SOQO= 0.0;
	}
 
	//compute and output concentration - units are qty/acre-in.
	if (SURO > 0.0) 
		//define concentration
		*SOQOC= *SOQO / SURO;
	else
		//soqoc is undefined
		*SOQOC= 0.0; //-1.0E30;
       
	return 0;
}

      //+ + + PURPOSE + + +
      //Simulate accumulation of a quality constituent on the land
      //surface and its removal using a constant unit rate and by direct
      //washoff by overland flow
 
int CLSPCMODEL::WASHOF(int DAYFG,int VQOFG, double *ACQOPM,double *REMQOM,
					double SURO,double WSFAC,int MON,int NXTMON,int DAY,
					int NDAYS,double PREC,int ADFXFG,int ADCNFG,double *ADFXMN,
					double *ADCNMN,double ADFLX,double ADCNC,double SLIQO,
					double DELT60,int QSOFG,double *ACQOP,double *REMQOP,
					double *SQO,double *SOQO,double *SOQOC,double *ADFXFX,
					double *ADCNFX,double *ADTOT)
{ 
	//+ + + ARGUMENT DEFINITIONS + + +
	//DAYFG  - flag for first day or day change
	//VQOFG  - ???
	//ACQOPM - ???
	//REMQOM - ???
	//SURO   - surface output
	//WSFAC  - ???
	//MON    - calendar month
	//NXTMON - next calendar month
	//DAY    - day of month
	//NDAYS  - no. of days in this month
	//PREC   - precipitation during current interval in inches
	//ADFXFG - flag indicating source of dry deposition flux
	//         positive means monthly, -1 means time series,
	//         0 means none
	//ADCNFG - flag indicating source of wet deposition flux
	//         postive means monthly, -1 means time series,
	//         0 means none
	//ADFXMN - monthly dry atmospheric deposition in qty/ac
	//ADCNMN - monthly wet atmospheric deposition in qty/ac.inch
	//ADFLX  - current dry atmospheric deposition in qty/ac
	//ADCNC  - current wet atmospheric deposition in qty/ac.inch
	//SLIQO  - lateral inflow of qualof
	//ACQOP  - ???
	//REMQOP - ???
	//SQO    - ???
	//SOQO   - ???
	//SOQOC  - ???
	//ADFXFX - actual dry atmospheric deposition flux for current interval
	//ADCNFX - actual wet atmospheric deposition flux for current interval
	//ADTOT  - actual total atmospheric deposition flux for current interval
 
	//+ + + LOCAL VARIABLES + + +
	double DUMMY = 0.0;
	double UNIT = 1/LB_FT3_TO_MG_L;  /* mg/l -> lb/ft^3  */
 
	if (DAYFG == 1) 
	{
		//it is the first interval of the day
        if (VQOFG == 1) 
		{
			//accumulation rate of this quality constituent is allowed
			//to vary throughout the year
			//interpolate for the daily value
			//linearly interpolate acqop between two values from the
			//monthly array acqopm(12) for this overland flow associated
			//quality constituent (no. qofp)
			*ACQOP= dayval(&ACQOPM[MON],&ACQOPM[NXTMON],&DAY,&NDAYS);
			//removal unit rate of this quality constituent is allowed
			//to vary throughout the year
			//interpolate for the daily value
			//linearly interpolate remqop between two values from the
			//monthly array remqom(12) for this overland flow associated
			//quality constituent (no. qofp)
			*REMQOP= dayval(&REMQOM[MON],&REMQOM[NXTMON],&DAY,&NDAYS);
        }
        if (QSOFG == 1)	// accumulation and removal occurs on daily basis
			//update storage due to accumulation and removal which occurs
			//independent of runoff - units are qty/acre
			*SQO = *ACQOP + *SQO * (1.0 - *REMQOP);
	}
 
	//handle atmospheric deposition
	//dry deposition	(lb/acre/ivl)
	if (ADFXFG <= -1) 
		//dry flux has been input as a time series
		*ADFXFX = ADFLX;	// not supported
	else if (ADFXFG >= 1) 
        //dry flux is taken from monthly values
        *ADFXFX = dayval(&ADFXMN[MON],&ADFXMN[NXTMON],&DAY,&NDAYS) * (DELT60 / 24.0);
	else
        *ADFXFX = ADFLX * (DELT60 / 24.0);
//        *ADFXFX = 0.0;
       
	//wet deposition	(lb/acre/ivl)
	if (ADCNFG <= -1) 
        //wet deposition concentration has been input as a time series
        *ADCNFX = PREC * ADCNC;	// not supported 
	else if (ADCNFG >= 1) 
        //wet deposition concentration is taken from monthly values
        *ADCNFX = PREC * dayval(&ADCNMN[MON],&ADCNMN[NXTMON],&DAY,&NDAYS) * UNIT * IN_ACRE_TO_FT3;
	else
        *ADCNFX = PREC * ADCNC * UNIT * IN_ACRE_TO_FT3;	// in/ivl * mg/l * (mg/l -> lb/ft3) * (lb/ft3 -> lb/acre-in) --> lb/acre/ivl
//        *ADCNFX = 0.0;
       
	*ADTOT = *ADFXFX + *ADCNFX;	// - units are lb/acre/ivl
 
	if (QSOFG == 2)	// accumulation and removal occurs per interval
	{
        //update storage due to accumulation and removal which occurs
        //independent of runoff - units are qty/acre
		if ((*ACQOP / *REMQOP) > 0)
			DUMMY = *REMQOP + (*ADTOT + SLIQO) / (*ACQOP / *REMQOP);
        if (DUMMY > 1.0) 
			DUMMY = 1.0;
        *SQO = *ACQOP * (DELT60 / 24.0) + *SQO * pow((1.0 - DUMMY),(DELT60/24.0));
	}
	else
	{
		//update storage (qty/acre)
		*SQO = *SQO + SLIQO + *ADTOT;
	}
 
	//simulate washoff by overland flow - units are qty/acre-ivl
	if (SURO > 0.0) 
	{
        //there is overland flow
        if (*SQO > 0.0) 
		{
			//there is some quality constituent (no. qofp) in storage;
			//washoff can occur
			DUMMY = SURO * WSFAC; // added from qualof (09-13-05)
			if (DUMMY < 1e-5)
			{
				//washoff too small for stable calculation - set to zero  
				*SOQO = 0.0;
			}
			else
			{
				// calculate washoff
				DUMMY = 1.0 - exp(-DUMMY);
				*SOQO = *SQO * DUMMY;
			}
			//update storage of constituent - units are in qty/acre
			*SQO = *SQO - *SOQO;
        }
		else
		{
			//no washoff load
			*SOQO= 0.0;
		}
	}
	else
	{
		*SOQO= 0.0;
	}
 
	//compute and output concentration - units are qty/acre-in.
	if (SURO > 0.0) 
		//define concentration
		*SOQOC= *SOQO / SURO;
	else
		//soqoc is undefined
		*SOQOC= 0.0; //-1.0E30;
       
	return 0;
}

//     + + + PURPOSE + + +  
//     Simulate removal of a quality constituent from the land  
//     surface by association with sediment  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     DAYFG  - flag for first day or day change  
//     VPFWFG - ??? 
//     VPFSFG - ??? 
//     WSSD   - ??? 
//     SCRSD  - ??? 
//     POTFWM - ??? 
//     POTFSM - ??? 
//     MON    - calendar month  
//     NXTMON - next calendar month  
//     DAY    - day of month  
//     NDAYS  - no. of days in this month  
//     POTFW  - ??? 
//     POTFS  - ??? 
//     WASHQS - ??? 
//     SCRQS  - ??? 
//     SOQS   - ??? 

//     + + + FUNCTIONS + + +  

//     + + + C   EXTERNALALS + + +  
//   EXTERNAL   DAYVAL  

//     + + + INTRINSICS + + +  

//     + + + END SPECIFICATIONS + + +  

int CLSPCMODEL::qualsd(double *wssd, double *scrsd, double *potfw, double *potfs, 
					   double *washqs, double *scrqs, double *soqs)
{
	// associate with washoff of detached sediment - units are qty/acre-ivl 
    if (fabs(*wssd) <= 0.0)
		*washqs = 0.0;
	else
		*washqs = *wssd * *potfw;
	
	// associate with scouring of soil matrix - units are qty/acre-ivl  
    if (fabs(*scrsd) <= 0.0)
		*scrqs = 0.0;
	else
		*scrqs = *scrsd * *potfs;
	
	// sum removals  
    *soqs = *washqs + *scrqs;
	
    return 0;
}

//      SUBROUTINE   DISCH
 
//     + + + PURPOSE + + +
//     Find the discharge rate(s) at the start of the run, based on
//     initial conditions

//	+ + + ARGUMENT DEFINITIONS + + +
//  nIndex   - reach index
//	CONVF    - f(vol) adjustment factor
//  nFTindex - Ftable record index
//	V        - volume in the reach
//	RO       - total rate of outflow from reach at end of interval

int CLSPCMODEL::DISCH(int nIndex,double CONVF,int *nFTindex,double V,double *RO)
{
	int nRes = 0;
	int nStart = pReachFtable[nIndex].nFTstart;
	int nRecord = pReachFtable[nIndex].nFTrecord;
	int nEXIT = pChannelInfo[nIndex].nDSchan;

	double A1,A2,ROD1,ROD2,V1,V2;

	double *OD1 = NULL, *OD2 = NULL;
	if (nEXIT > 0)
	{
		OD1 = new double[nEXIT];
		OD2 = new double[nEXIT];
	}
	
	for (int i=nStart; i<nStart+nRecord-1; i++)
	{
		//get the volumes which apply to this segment
		V1 = pFtable[i].vol; 
		V2 = pFtable[i+1].vol;

		//check whether v is between v1 and v2. 
		if (V >= V1 && V <= V2)
		{
			//found the solution -- break the loop
			*nFTindex = i;
			break;
		}
		else if (i == nStart+nRecord-2)
		{
			//error -- extrapolation of rchtab is required
			CString strErr;
			strErr.Format("%d",pReachInfo[nIndex].rchid);
			AfxMessageBox("error -- extrapolation of reach: " + strErr + " is required");
			nRes = 2;
			goto A01;
		}
	}

	//get the outflow demands which apply to 
	//this segment of the o vs vol curve

	DEMAND(nIndex, *nFTindex, CONVF, OD1, &ROD1);
	DEMAND(nIndex, *nFTindex+1, CONVF, OD2, &ROD2);

    // interpolate
	A1 = 0.0;
	if ((V2 - V1) > 0)
		A1 = (V2 - V)/(V2 - V1);
    A2 = 1.0 - A1;

	*RO = A1 * ROD1 + A2 * ROD2;

	for (i=0; i<nEXIT; i++)
		pChannelInfo[nIndex].down_flow[i] = A1 * OD1[i] + A2 * OD2[i];

A01: 
	if (OD1 != NULL)	delete[]OD1;
	if (OD2 != NULL)	delete[]OD2;

	return nRes;
}

//	+ + + PURPOSE + + +
//	Find the state of the reach or reservoir at the end of
//	the time interval and the outflows from it, used if one or more
//	of the outflow demands depend on VOL.

//	+ + + ARGUMENT DEFINITIONS + + +
//  nIndex - reach index
//	DAYFG  - flag for first day or day change
//	VCONFG - flag indicating outflow demand varies by month
//	CONVFM - monthly f(vol) adjustment factor
//	DELTS  - simulation interval in seconds
//	KS     - weighting factor
//	COKS   - complement of KS (1-KS)
//	ROS    - total rate of outflow from reach at start of interval
//	VOLT   - volume in the reach after inflow, precip and evap
//	FACTA1 - term in eq 18 = 1.0/(COKS*DELTS)
//	MON    - calendar month
//	NXTMON - next calendar month
//	DAY    - day of month
//	NDAYS  - no. of days in this month
//	CONVF  - f(vol) adjustment factor
//	VOL    - volume of water in reach above bed
//	RO     - total rate of outflow from reach at end of interval
//	OVOL   - volume of water leaving reach in an interval by exit
//	ROVOL  - total volume of water leaving reach in an interval

int CLSPCMODEL::ROUTE(int nIndex,int DAYFG,int VCONFG,double *CONVFM, double DELTS,
					  double KS,double COKS,double ROS,double VOLT,double FACTA1,
					  int MON,int NXTMON, int DAY,int NDAYS,double& CONVF,
					  int *nFTindex,double *VOL,double *RO)
{
	int nRes = 0;
	int nPreference = 0;	// place holdre for outlet preference for solution case 2
	int nStart = pReachFtable[nIndex].nFTstart;
	int nEXIT = pChannelInfo[nIndex].nDSchan;
	double *ODZ = NULL, *OSEFF = NULL;
	if (nEXIT > 0)
	{
		ODZ = new double[nEXIT];
		OSEFF = new double[nEXIT];
	}
	
	double RODZ,TRO,ROSEFF,OINTSP,OINT,VOLINT;

// 	if (DAYFG == 1)		// computing for each time step otherwise introduce intermediate variable to save the value for next time step
//	{
		//first interval of the day
 		if (VCONFG == 1)  
			//conversion factor for f(vol) discharge components is
			//allowed to vary monthly throughout the year,
			//interpolate for the daily value
 			CONVF = dayval(&CONVFM[MON],&CONVFM[NXTMON],&DAY,&NDAYS);
 		else
			//conversion factor for f(vol) discharge components does not
			//vary throughout the year
 			CONVF = 1.0;
//	}
 
	ROSEFF = ROS;

	for (int i=0; i<nEXIT; i++)
		OSEFF[i] = pChannelInfo[nIndex].down_flow[i];

	//find intercept of EQ 4 on VOL axis
	VOLINT = VOLT - KS * ROSEFF * DELTS;

	if (fabs (VOLINT) < VOLT*1.0E-5)  
		//prevent underflow
		VOLINT = 0.0;
 
	if (VOLINT <= 0.0) 
	{
		//case 3 -- no solution to simultaneous equations
		//set state variables to reflect empty condition
		*VOL = 0.0;
		*RO = VOLT / DELTS;
		for (int i=0; i<nEXIT; i++)
		{
			if (ROSEFF > 0.0)  
				//prorate by starting flow rates
				pChannelInfo[nIndex].down_flow[i] = *RO * OSEFF[i] / ROSEFF;
			else
				//divide equally among exits
				pChannelInfo[nIndex].down_flow[i] = *RO / nEXIT;
		}
	}
	else
	{
        //case 1 or 2 -- solve simultaneous equations
        //find intercept on o axis (coks is 1.0 - ks)
		OINT = 0.0;
		if ((DELTS * COKS) > 0)
			OINT = VOLINT / (DELTS * COKS);
        OINTSP = OINT;
 
        //find outflow demand for zero volume
		DEMAND(nIndex, nStart, CONVF, ODZ, &RODZ);

        if (OINTSP > RODZ) 
		{
			//case 1 -- outflow demands can be met in full
			//solve simultaneous equations
			if (SOLVE(nIndex, CONVF, FACTA1, OINT, nFTindex, VOL, RO) == 2)
			{
				nRes = 2;
				goto A01;
			}
        }
		else
		{
			if (nPreference == 0)
			{
				*VOL = 0.0;
				*RO = OINTSP;
				for (int i=0; i<nEXIT; i++)
				{
					if (ROSEFF > 0.0)  
						//prorate by starting flow rates
						pChannelInfo[nIndex].down_flow[i] = *RO * OSEFF[i] / ROSEFF;
					else
						//divide equally among exits
						pChannelInfo[nIndex].down_flow[i] = *RO / nEXIT;
				}
			}
			else
			{
				//case 2 -- outflow demands cannot be met in full
 				*VOL = 0.0;

				//find the actual outflows -- satisfy as many as poss in full
				//satisfy others partially or not at all
 				*RO = 0.0;

				for (int i=0; i<nEXIT; i++)
				{
					TRO = *RO + ODZ[i];
					if (TRO <= OINTSP) 
					{
						//demand met
						pChannelInfo[nIndex].down_flow[i] = ODZ[i];
						*RO = TRO;
					}
					else
					{
						//demand part met
						pChannelInfo[nIndex].down_flow[i] = OINTSP - *RO;
						*RO = OINTSP;
					}
				}
			}
        }
 
        //estimate the volumes of outflow
//        *ROVOL = (KS * ROSEFF + COKS * *RO) * DELTS;

//		for (i=0; i<nEXIT; i++)
//			OVOL[i] = (KS * OSEFF[i] + COKS * pChannelInfo[nIndex].down_flow[i]) * DELTS;
    }
A01:
	if (ODZ != NULL)	delete[]ODZ;
	if (OSEFF != NULL)	delete[]OSEFF;

	return nRes;
}

//	+ + + PURPOSE + + +
//	Solve the simultaneous equations used in case 1.  This might
//	involve searching thru RCHTAB to find the appropriate
//	segment of the O vs VOL curve.

//	+ + + ARGUMENT DEFINITIONS + + +
//  nIndex - reach index
//	CONVF  - f(vol) adjustment factor
//	FACTA1 - term in eq 18 = 1.0/(COKS*DELTS)
//	OINT   - intercept of eq 4 on the o axis
//	VOL    - volume of water in reach above bed
//	RO     - total rate of outflow from reach at end of interval
 

int CLSPCMODEL::SOLVE(int nIndex,double CONVF,double FACTA1,double OINT,int *nFTindex,double *VOL,double *RO)
{
	int nRes = 0;
	int nStart = pReachFtable[nIndex].nFTstart;
	int nRecord = pReachFtable[nIndex].nFTrecord;
	int nEXIT = pChannelInfo[nIndex].nDSchan;

	double DIFF,FACTR,ROD1,ROD2,V1,V2,DET,DETV,FACTA2,FACTB2,FACTC2,V;

	double *OD1 = NULL, *OD2 = NULL;
	if (nEXIT > 0)
	{
		OD1 = new double[nEXIT];
		OD2 = new double[nEXIT];
	}
	
	for (int i=nStart; i<nStart+nRecord-1; i++)
	{
		//get the volumes and outflow demands which apply to this
		//segment of the o vs vol curve
		V1 = pFtable[i].vol; 
		V2 = pFtable[i+1].vol;

		DEMAND(nIndex, i, CONVF, OD1, &ROD1);
		DEMAND(nIndex, i+1, CONVF, OD2, &ROD2);

		//do a trial solve of the equations
		//facta1 is evaluated by the run interpreter= 1/(coks*delts)
		//factb1= 1,
		//factc1= oint
 
        FACTA2 = ROD1 - ROD2;
        FACTB2 = V2 - V1;
        FACTC2 = V2 * ROD1 - V1 * ROD2;
 
        //find the determinants
        DET = FACTA1 * FACTB2 - FACTA2;
        if ((fabs(DET)) <= 0.0) 
		{
			//error -- system is indeterminate
			AfxMessageBox("error -- system is indeterminate");
			nRes = 2;
			goto A01;
        }
        DETV = OINT * FACTB2 - FACTC2;
		V = 0.0;
		if (DET > 0)
			V = DETV / DET;

        if (V < 0.0)  
			//avoid underflow
			V= 0.0;
         
		//check whether v is between v1 and v2. 
		if (V >= V1 && V <= V2)
		{
			//found the solution -- break the loop
			*nFTindex = i;
			break;
		}
		else if (i == nStart+nRecord-2)
		{
			//error -- extrapolation of rchtab is required
			CString strErr;
			strErr.Format("%d",pReachInfo[nIndex].rchid);
			AfxMessageBox("error -- extrapolation of reach: " + strErr + " is required");
			nRes = 2;
			goto A01;
		}
	}

	//found the solution
	*VOL = V;
	*RO = OINT - FACTA1 * *VOL;
	if (*VOL < 1.0E-5) 
	{
		//avoid underflow
		//next line added to make material balance correct
		*RO = OINT;
		*VOL = 0.0;
	}

	if (*RO < 1.0E-10)  
		//avoid underflow
		*RO = 0.0;
       
	if (fabs(*RO) <= 0.0) 
	{
		//no total outflow, so no exit outflow
		for (int i=0; i<nEXIT; i++)
			pChannelInfo[nIndex].down_flow[i] = 0.0;
	}
	else
	{
		DIFF = *VOL - V1;
		if (DIFF < 0.01)
		{
			//avoid underflow
			FACTR = 0.0;
		}
		else
		{
			//interpolate values of individual outflow rates
			FACTR = 0.0;
			if ((V2 - V1) > 0)
				FACTR = (DIFF)/(V2 - V1);
		}

		for (int i=0; i<nEXIT; i++)
			pChannelInfo[nIndex].down_flow[i] = OD1[i] + (OD2[i] - OD1[i]) * FACTR;
	}
A01: 
	if (OD1 != NULL)	delete[]OD1;
	if (OD2 != NULL)	delete[]OD2;

	return nRes;
}

//	+ + + PURPOSE + + +
//	Find OD(*),ROD which apply at a specified row in FTABLE.

//	+ + + ARGUMENT DEFINITIONS + + +
//  nIndex   - reach index
//  nFTindex - Ftable record index
//	CONVF    - f(vol) adjustment factor
//	OD       - rate of demanded outflow for end of interval by exit
//	ROD      - total rate of demanded outflow for end of interval

int CLSPCMODEL::DEMAND(int nIndex,int nFTindex,double CONVF,double *OD,double *ROD)
{
	int nEXIT = pChannelInfo[nIndex].nDSchan;

    //get function of volume demand
	for (int i=0; i<nEXIT; i++)
		OD[i] = pFtable[nFTindex].disch[i] * CONVF;
    
	//find total outflow demand
    *ROD = pFtable[nFTindex].disch1 * CONVF;

	return 0;
}

//	+ + + PURPOSE + + +
//	Compute depth, stage, surface area, average depth, topwidth,
//	and hydraulic radius.

//	+ + + ARGUMENT DEFINITIONS + + +
//  nFTindex - Ftable record index
//	VOL      - volume of water in reach above bed
//	STCOR    - stage correction factor
//	LEN      - length of reach
//	DEP      - depth of reach at deepest point
//	STAGE    - water stage at deepest point within reach
//	SAREA    - surface area of reach
//	AVDEP    - reach average depth (volume/surface area)
//	TWID     - reach top width (surface area/length)
//	HRAD     - hydraulic radius

int CLSPCMODEL::AUXIL(int nFTindex,double VOL,double LEN,double *DEP,double *SAREA,
					  double *XAREA,double *HRAD)
{
 	int    COUNT;
 	double A,B,C,DEP1,DEP2,DFRDEP,FRDEP,RDEP1,RDEP2,SA1,SA2,VOL1,VOL2,AVDEP,TWID;

	if (VOL > 0.0) 
	{
		//compute depth of flow -- start by evaluating
		//coefficients for search using Newton's method
		//manual eq (34,35)
		SA1 = pFtable[nFTindex].area;
		SA2 = pFtable[nFTindex+1].area;
		A = SA2 - SA1;
		B = 2.0 * SA1;
		VOL1 = pFtable[nFTindex].vol; 
		VOL2 = pFtable[nFTindex+1].vol;
		C = 0.0;
		if ((VOL2 - VOL1) > 0)
			C = -(VOL - VOL1)/(VOL2 - VOL1)*(B + A);
 
        //search using newton's method
		RDEP1 = 0.0;
        RDEP2 = 0.5;
        COUNT = 0;

        while (fabs(RDEP2 - RDEP1) >= 0.001)
		{
			RDEP1 = RDEP2;
			COUNT = COUNT + 1;
			FRDEP = A * pow(RDEP1,2) + B * RDEP1 + C;
			DFRDEP = 2.0 * A * RDEP1 + B;
			RDEP2 = 0.0;
			if (DFRDEP > 0)
				RDEP2 = RDEP1 - FRDEP / DFRDEP;
 
			if (COUNT > 100) 
			{
				//error -- no convergence
				AfxMessageBox("error -- no convergence for reach depth in FTable");
				return 2;
			}
		}
 
//        if (RDEP2 > 1.0 || RDEP2 < 0.0) 
		if (RDEP2 > 1.00001 || RDEP2 < -0.00001)
		{
			//error -- solution converged to point outside valid range
			AfxMessageBox("error -- solution converged to point outside valid range for reach depth in FTable");
			return 2;
        }

		if (RDEP2 > 1.0) RDEP2 = 1.0;
		if (RDEP2 < 0.0) RDEP2 = 0.0;
 
        //depth, manual eq (36)
        DEP1 = pFtable[nFTindex].depth;
        DEP2 = pFtable[nFTindex+1].depth;
        *DEP = DEP1 + RDEP2 * (DEP2 - DEP1);
 
        //surface area calculation, manual eq (38)
        *SAREA = SA1 + A * RDEP2;
 
		//cross-sectional area
		*XAREA = 0.0;
		if (LEN > 0)
			*XAREA = VOL / LEN;	
		
        //average depth calculation, manual eq (39)
		AVDEP = 0.0;
		if (*SAREA > 0)
			AVDEP = VOL / *SAREA;
 
        //top-width calculation, manual eq (40)
		TWID = 0.0;
		if (LEN > 0)
			TWID = *SAREA / LEN;
 
        //hydraulic radius, manual eq (41)
		*HRAD = 0.0;
		if ((2.0 * AVDEP + TWID) > 0)
			*HRAD = (AVDEP * TWID)/(2.0 * AVDEP + TWID);
	}
	else
	{
		//no water
		*DEP = 0.0;
		*SAREA = 0.0;
		*XAREA = 0.0;
		*HRAD = 0.0;
	}
 
	//stage calculation and output, manual eq (37)
//	*STAGE = *DEP + STCOR;
 
	return 0;
}

int CLSPCMODEL::route(int nf,int nIndex,double vin,int dayfg,int vconfg,double *convfm, 
					  int mon,int nxtmon,int day,int ndays,double& convf,double delts,
					  int *st,double *fq,double *fh,double *fv,double *fa,double *fr,
					  double *fsa,double *qh,double *XA,double *HR,double *SA,double *v2,
					  double *q2)
{
// 	if (dayfg == 1)		// computing for each time step otherwise introduce intermediate variable to save the value for next time step
//	{
		//first interval of the day
 		if (vconfg == 1)  
			//conversion factor for f(vol) discharge components is
			//allowed to vary monthly throughout the year,
			//interpolate for the daily value
 			convf = dayval(&convfm[mon],&convfm[nxtmon],&day,&ndays);
 		else
			//conversion factor for f(vol) discharge components does not
			//vary throughout the year
 			convf = 1.0;
//	}

    if(vin <= 0.0)
	{
        //no water
		vin = 0.0;
		*q2 = 0.0;
		*v2 = 0.0;
        *qh = 0.0;
        *SA = 0.0;
        *XA = 0.0;
        *HR = 0.0;
    }
	else
	{
		for(int i=0; i<nf-1; i++)
		{
			*q2 = (fv[i+1] * fq[i] - fv[i] * fq[i+1] + (fq[i+1] - fq[i]) * vin) / 
				(fv[i+1] - fv[i] + (fq[i+1] - fq[i]) * delts);				
			*v2 = (vin * (fv[i+1] - fv[i]) / delts + fv[i] * fq[i+1] - fv[i+1] * fq[i]) / 
				((fv[i+1] - fv[i]) / delts + fq[i+1] - fq[i]);	

			if((*q2 >= fq[i]) && (*q2 <= fq[i+1]) && (*v2 >= fv[i]) && (*v2 <= fv[i+1]))
			{
				*qh = fh[i] + (*v2-fv[i]) * (fh[i+1]-fh[i]) / (fv[i+1]-fv[i]);
				*XA = fa[i] + (*v2-fv[i]) * (fa[i+1]-fa[i]) / (fv[i+1]-fv[i]);			
				*HR = fr[i] + (*v2-fv[i]) * (fr[i+1]-fr[i]) / (fv[i+1]-fv[i]);			
				*SA = fsa[i] + (*v2-fv[i]) * (fsa[i+1]-fsa[i]) / (fv[i+1]-fv[i]);		
				
				// limit minimum outflow to be 1E-6 cfs    (03-2004)
				if (*q2 < LIMITNUM)
				{
					*v2 = *v2 + *q2 * delts;
					*q2 = 0.0;
				}

				// check if outflow volume is available
				if (*q2 * delts > vin)
				{
					*q2 = vin/delts;
					*v2 = 0;
				}

				// apply conversion factor for f(vol) discharge 
				*q2 *= convf;

				// apply conversion factor for f(vol) discharge 
				*v2 += (1-convf)* *q2/convf * delts;
				if (*v2<0)	*v2 = 0.0;
							
				pChannelInfo[nIndex].down_flow[0] = *q2;

				*st = i;
				return 0;
			}
			else
				*st = -1;
		}
	}
    return 0;
}

int CLSPCMODEL::routine(double volt, int dayfg, int vconfg, double *convfm, int mon, 
						int nxtmon, int day, int ndays, double& convf, double delts, 
						double *fq, double *fh, double *fv, double *fa, double *fr,
						double *fsa, double *XA, double *HR, double *SA, double *q1,
						double *q2, double *v1, double *v2, double *qh, double *qk,
						int *st, int *nf, int *nIndex,int routemethod)
{
// 	if (dayfg == 1)		// computing for each time step otherwise introduce intermediate variable to save the value for next time step
//	{
		//first interval of the day
 		if (vconfg == 1)  
			//conversion factor for f(vol) discharge components is
			//allowed to vary monthly throughout the year,
			//interpolate for the daily value
 			convf = dayval(&convfm[mon],&convfm[nxtmon],&day,&ndays);
 		else
			//conversion factor for f(vol) discharge components does not
			//vary throughout the year
 			convf = 1.0;
//	}

	double vin  = volt;								

    if(vin <= 0.0)
	{
        //no water
		vin = 0.0;
		*q2 = 0.0;
		*v2 = 0.0;
        *qh = 0.0;
        *SA = 0.0;
        *XA = 0.0;
        *HR = 0.0;

		for (int j=0; j<pChannelInfo[*nIndex].nDSchan; j++)
			pChannelInfo[*nIndex].down_flow[j] = 0.0;
    }
	else
	{
		int nStart  = pReachFtable[*nIndex].nFTstart;
		int nRecord = pReachFtable[*nIndex].nFTrecord;

		if (nRecord > 0)
		{
			if (nRecord == 1)
			{
				// no routing 
				*q2 = vin/delts;	//(outflow = inflow)
				*v2 = 0.0;
				*qh = 0.0;
				*SA = 0.0;
				*XA = 0.0;
				*HR = 0.0;
				for (int j=0; j<pChannelInfo[*nIndex].nDSchan; j++)
					pChannelInfo[*nIndex].down_flow[j] = *q2 * pReachFtable[*nIndex].bypass_fr[j];
			}
			else
			{
				for(int i=nStart; i<nStart+nRecord-1; i++)
				{
					if(pFtable[i].rchid == pChannelInfo[*nIndex].rchid)										
					{
						double qsum = 0;
						for (int j=0; j<pChannelInfo[*nIndex].nDSchan; j++)
						{
							pChannelInfo[*nIndex].down_flow[j] = (pFtable[i+1].vol * pFtable[i].disch[j] - pFtable[i].vol * pFtable[i+1].disch[j] + (pFtable[i+1].disch[j] - pFtable[i].disch[j]) * vin) / 
								(pFtable[i+1].vol - pFtable[i].vol + (pFtable[i+1].disch[j]	- pFtable[i].disch[j]) * delts); // cfs	
							qsum += pChannelInfo[*nIndex].down_flow[j];
						}
						if (routemethod == 1)
						{
							*q2 = (pFtable[i+1].vol * pFtable[i].disch1 - pFtable[i].vol * pFtable[i+1].disch1 + (pFtable[i+1].disch1 - pFtable[i].disch1) * vin) / 
								(pFtable[i+1].vol - pFtable[i].vol + (pFtable[i+1].disch1 - pFtable[i].disch1) * delts);				// cfs				
							*v2 = (vin * (pFtable[i+1].vol - pFtable[i].vol) / delts + pFtable[i].vol * pFtable[i+1].disch1 - pFtable[i+1].vol * pFtable[i].disch1) / 
								((pFtable[i+1].vol - pFtable[i].vol) / delts + pFtable[i+1].disch1 - pFtable[i].disch1);		// ft^3	
						}
						else
						{
							*q2 = pFtable[i].disch1 + (vin - pFtable[i].vol) * (pFtable[i+1].disch1 - pFtable[i].disch1) / (pFtable[i+1].vol - pFtable[i].vol);	// cfs
							*v2 = vin;	
						}
						if((*q2 >= pFtable[i].disch1) && (*q2 <= pFtable[i+1].disch1) && (*v2 >= pFtable[i].vol) && (*v2 <= pFtable[i+1].vol))
						{
							double SA1 = pFtable[i].area;
							double SA2 = pFtable[i+1].area;
							double A = SA2 - SA1;
							double B = 2.0 * SA1;
							double VOL1 = pFtable[i].vol;
							double VOL2 = pFtable[i+1].vol;
							double VOL = *v2;
							double C = 0.0;
							if (VOL2 > VOL1 )
								C = -(VOL - VOL1)/(VOL2 - VOL1)*(B + A);

							//search using newton's method
							double FRDEP = 0.0;
							double DFRDEP = 0.0;
							double RDEP1 = 0.0;
							double RDEP2 = 0.5;
							int COUNT = 0;

							while(fabs(RDEP2 - RDEP1) >= 0.001)
							{
								RDEP1 = RDEP2;
								COUNT = COUNT + 1;
								FRDEP = A * pow(RDEP1,2.0) + B * RDEP1 + C;
								DFRDEP= 2.0 * A * RDEP1 + B;
								if (DFRDEP > 0)
									RDEP2 = RDEP1 - FRDEP / DFRDEP;
								if (COUNT > 100) 
								{
									//error -- no convergence
									AfxMessageBox("error -- no convergence for reach depth in FTable");
									return 2;
								}
							}
							if (RDEP2 > 1.00001 || RDEP2 < -0.00001)
							{
								//error -- solution converged to point outside valid range
								AfxMessageBox("error -- solution converged to point outside valid range for reach depth in FTable");
								return 2;
							}
							if (RDEP2 > 1.0) RDEP2 = 1.0;
							if (RDEP2 < 0.0) RDEP2 = 0.0;

							if (routemethod != 1)		// (01-05-06)
							{
								// update out flow (cfs) 
								double Q1 = pFtable[i].disch1;
								double Q2 = pFtable[i+1].disch1;
								*q2 = Q1 + RDEP2 * (Q2 - Q1);
								if (*q2 < 0) *q2 = 0.0;
								
								// update volume
								*v2 = vin - *q2 * delts;
								if (*v2<0)	*v2 = 0.0;
							}

							// limit minimum outflow to be 1E-6 cfs    (03-2004)
							if (*q2 < LIMITNUM)
							{
								*v2 = *v2 + *q2 * delts;
								*q2 = 0.0;
							}

							// check if outflow volume is available
							if (*q2 * delts > vin)
							{
								*q2 = vin/delts;
								*v2 = 0;
							}

							// apply conversion factor for f(vol) discharge 
							*q2 *= convf;

							// apply conversion factor for f(vol) discharge 
							*v2 += (1-convf)* *q2/convf * delts;
							if (*v2<0)	*v2 = 0.0;
							
							//depth, manual eq (36)
							double DEP1 = pFtable[i].depth;
							double DEP2 = pFtable[i+1].depth;
							*qh = DEP1 + RDEP2 * (DEP2 - DEP1);		// depth

							//surface area calculation, manual eq (38)
							*SA = SA1 + A * RDEP2;

							*XA = 0.0;
							if (pReachInfo[*nIndex].length > 0)
								*XA = *v2 / (pReachInfo[*nIndex].length * MILE_TO_FEET);		// ft^2
							double avdepth = 0.0;
							double topwidth = 0.0;
							if (*SA > 0)
								avdepth = *v2 / *SA;			// ft
							if (pReachInfo[*nIndex].length > 0)
								topwidth = *SA / (pReachInfo[*nIndex].length * MILE_TO_FEET);		// ft
							*HR = 0.0;
							if (avdepth > 0 || topwidth > 0)
								*HR = (topwidth * avdepth) / (2.0 * avdepth + topwidth);	// ft

							for (j =0; j<pChannelInfo[*nIndex].nDSchan; j++)
							{
								if (qsum > 0)
									pChannelInfo[*nIndex].down_flow[j] = pChannelInfo[*nIndex].down_flow[j] / qsum * *q2;
							}

							*st = i;
							return 0;
						}
						else
							*st = -1;
					}
				}
			}
		}

		if(nRecord == 0 && pReachInfo[*nIndex].lkfg != 0)
		{
			// it is a lake without pre-defined Ftable, so call routinelake function
			return 1; 
		}
		else if(nRecord == 0 && pReachInfo[*nIndex].lkfg == 0)
		{
			// internal Ftable
			if (pReachInfo[*nIndex].routefg == 0)
			{
				// no routing 
				*q2 = vin/delts;	//(outflow = inflow)
				*v2 = 0.0;
				*qh = 0.0;
				*SA = 0.0;
				*XA = 0.0;
				*HR = 0.0;
						
				pChannelInfo[*nIndex].down_flow[0] = *q2;
			}
			else
			{
				for(int i=0; i<*nf-1; i++)
				{
					*q2 = (fv[i+1] * fq[i] - fv[i] * fq[i+1] + (fq[i+1] - fq[i]) * vin) / 
						(fv[i+1] - fv[i] + (fq[i+1] - fq[i]) * delts);				
					*v2 = (vin * (fv[i+1] - fv[i]) / delts + fv[i] * fq[i+1] - fv[i+1] * fq[i]) / 
						((fv[i+1] - fv[i]) / delts + fq[i+1] - fq[i]);	

					if((*q2 >= fq[i]) && (*q2 <= fq[i+1]) && (*v2 >= fv[i]) && (*v2 <= fv[i+1]))
					{
						*qh = fh[i] + (*v2-fv[i]) * (fh[i+1]-fh[i]) / (fv[i+1]-fv[i]);
						*XA = fa[i] + (*v2-fv[i]) * (fa[i+1]-fa[i]) / (fv[i+1]-fv[i]);			
						*HR = fr[i] + (*v2-fv[i]) * (fr[i+1]-fr[i]) / (fv[i+1]-fv[i]);			
						*SA = fsa[i] + (*v2-fv[i]) * (fsa[i+1]-fsa[i]) / (fv[i+1]-fv[i]);		
						
						// limit minimum outflow to be 1E-6 cfs    (03-2004)
						if (*q2 < LIMITNUM)
						{
							*v2 = *v2 + *q2 * delts;
							*q2 = 0.0;
						}

						// check if outflow volume is available
						if (*q2 * delts > vin)
						{
							*q2 = vin/delts;
							*v2 = 0;
						}

						// apply conversion factor for f(vol) discharge 
						*q2 *= convf;

						// apply conversion factor for f(vol) discharge 
						*v2 += (1-convf)* *q2/convf * delts;
						if (*v2<0)	*v2 = 0.0;
							
						pChannelInfo[*nIndex].down_flow[0] = *q2;

						*st = i;
						return 0;
					}
					else
					{
						*st = -1;
					}
				}
			}
		}
	}
    return 0;
}

int CLSPCMODEL::routinelake(int nIndex,double qin,double ptwd,double irrwd,double delt60,
							double prec,double pet,double v1,double& v2,double& q2, 
							double& hh)
{
	int    i__1			= 1;	
	double g			= 32.2;							// ft/sec2
	double ks			= pReachInfo[nIndex].slope;			// in/hr
	double lakedepth	= pReachInfo[nIndex].depth;			// ft
	double lakewidth	= pReachInfo[nIndex].width;			// ft
	double lakelength	= pReachInfo[nIndex].length*MILE_TO_FEET;	// ft
	double weircrest	= pReachInfo[nIndex].mann;			// ft
	double orifheight	= pReachInfo[nIndex].r1;			// ft
	double orificedia	= pReachInfo[nIndex].r2;			// ft
	double orifice_area = 3.14159/4.0*pow(orificedia,2);// ft2

	double inft			= 0.0;	// potential infiltration rate (ft/ivl)
	double infilt		= 0.0;	// actual infiltration volume ft3/ivl
	double weir			= 0.0;
	double inflow		= 0.0;
	double outflow		= 0.0;
	double ovolume		= 0.0;
	double nvolume		= 0.0;
	double ostage		= 0.0;
	double r__1			= 0.0;
	double o_orifice	= 0.0;
	double orificecoef	= 1.0;
	double evapvolume	= 0.0;
	double evapvol      = 0.0;

	double delts2 = delts;
	if (deltm > 5)
	{
		i__1 = int(deltm / 5 + 0.2);	// number of intervals per 5 min time step
		delts2 = 5 * 60;				// 5 min time step for routing
	}

	// calculate volume coming in the lake (ft3)
	inflow = (qin - ptwd - irrwd) * delts2;	// ft3	
	
	// calculate infiltration per ivl (infiltration is constant)
	inft = ks /12.0 * delts2/3600;		// in/hr to ft/ivl

	// initial volume of the lake
	ovolume = v1;	// ft3 

	for (int i=0; i<i__1; i++) 
	{
		// CALCULATE DIRECT PRECIP & EVAPORATION FROM THE SURFACE 
		if ((ovolume + inflow) > 0.0 && kc > 0)		//   (02-2005)
			evapvolume = lakelength * lakewidth * (pet/kc  - prec)/(i__1*12);	// ft3
		else
			evapvolume = 0;

		if (evapvolume > (ovolume + inflow))
			evapvolume = ovolume + inflow;

		evapvol += evapvolume;

		// calculate new volume of lake 
		nvolume = ovolume + inflow - evapvolume;	// ft3

		// calculate infiltration volume per interval (ft)
		if (nvolume > 0.0)
			infilt = inft * lakelength * lakewidth;		// ft3
		else
			infilt = 0.0;

		// check available volume of water in lake
		if (infilt > nvolume)
			infilt = nvolume;

		// calculate new volume of lake 
		nvolume -= infilt;	// ft3

		// CALCULATE PRESENT STORED WATER STAGE 
		if (lakelength > 0 && lakewidth > 0)
			ostage = nvolume / (lakelength * lakewidth);  //ft
		else
			ostage = 0.0;

		if (ostage > orifheight)
		{
			// CALCULATE ORIFICE FLOW
			r__1 = ostage - orifheight;	// height of water above the orifice
			o_orifice = sqrt(g * 2.0 * r__1) * orifice_area * orificecoef * delts2;  //cfs to ft^3/timestep	
			if (o_orifice > nvolume)
				o_orifice = nvolume;

			// calculate new volume of lake 
			nvolume -= o_orifice;	// ft3

			outflow += o_orifice;
		}

		// CALCULATE PRESENT STORED WATER STAGE 
		if (lakelength > 0 && lakewidth > 0)
			ostage = nvolume / (lakelength * lakewidth);  //ft
		else
			ostage = 0.0;

		if (ostage > lakedepth)
		{
			// CALCULATE WEIR OVERFLOW  
			r__1 = ostage - lakedepth;		// ft (excess water check)
			double availvol = r__1 * lakelength * lakewidth;												// h is the lookup index1 for weir coefficient
			if ((pReachInfo[nIndex].lkfg % 2) == 1)	// rectangular weir type
			{
				//Added by John Riverson 1/5/2004 - Chow Equation, Replaces Linsey lookup table for weir coefficient
				double c_weir;
				if (lakedepth > 0 && r__1 / lakedepth < 10)
					c_weir = 3.27 + 0.4 * r__1 / lakedepth;
				else if (r__1 > 0)
					c_weir = 5.68 * pow(1 + lakedepth / r__1, 1.5);
				weir = c_weir * weircrest * sqrt(r__1 * r__1 * r__1) * delts2;  //cfs to ft3/timestep				//	(  4/9/04)
			}
			else // triangular weir type
			{
				double weirangle = min(179.9, max(1.0, weircrest));
				double r1 = 3.141592653 * weirangle / 180.0;
				double r2 = tan(r1 / 2);
				double r3 = pow(r__1, 2.5);
				     weir = 2.4824 * r2 * r3 * delts2;  //cfs to ft^3/timestep				//	(  4/9/04)
			}

			if (weir > availvol)
				weir = availvol;		// (03-2005)
			
			// calculate new volume of lake 
			nvolume -= weir;	// ft3

			outflow += weir;
		}
	
		// CALCULATE PRESENT STORED WATER STAGE 
		if (lakelength > 0 && lakewidth > 0)
			ostage = nvolume / (lakelength * lakewidth);  //ft
		else
			ostage = 0.0;

		ovolume = nvolume;
	}
	q2 = outflow/(delts2*i__1);					// cfs
	pChannelInfo[nIndex].down_flow[0] = q2;		// cfs
	v2 = nvolume;								// ft3
	hh = ostage;								// ft

    return 0;
}
 
/*
int CLSPCMODEL::ftable(int *nt, double *fh, double *fv, double *fq, double *fs, double *fa, double *fr, double *fb, double *fp, double *qk, double *b0, double *h0,
					double *r1, double *r2, double *w1, double *dx, double *s, double *mn)
{
    double d1;
    double b,bb;
    int i;
    double dfeet, a0, p0, r0, db, bi, dh, hm, pi, db2, tga1, tga2;
	double qq0, aa0;
	//   s= slope 
	//   b0= bank width 
	//   h0= depth 
	//   r1 = ratio of bottom width to b0 
	//   w1 = width of flood plane (one side) 
	//   r2 = side slope of flood plane. 
	
	bb=40.0,
	hm = *h0 * bb;
	*w1= *w1 * *b0;
    dh = hm / (*nt-1);
    fv[0] = 0.0;
    fs[0] = 0.0;
    fq[0] = 0.0;
    tga1 = *h0 * 2 / (*b0 * (1 - *r1));
	*r2 =1.0/ *r2;
    tga2 = *r2;
    b = *r1 * *b0;
    dfeet = 1.49;
    a0 = (*b0 + b) * *h0 * 0.5;
    db = *h0 / tga1;
    p0 = b + sqrt(*h0 * *h0 + db * db) * 2.0;
    r0 = a0 / p0;
	
	fh[0] = 0.0;
    for (i = 1; i < 11; ++i)
	{
		fh[i] = fh[i-1] + dh*0.25;
    }
    for (i = 11; i < 21; ++i)
	{
		fh[i] = fh[i-1] + dh;
    }
    for (i = 21; i < *nt; ++i)
	{
		fh[i] = fh[i-1] + dh*1.25;
    }
    fh[*nt-1] = *h0 * bb;
    for (i = 0; i <= *nt-1; ++i) 
	{
		if (fh[i] <= *h0 + 1e-5) 
		{
			db = fh[i] / tga1;
			bi = b + db * 2;
			fb[i] = bi;
			fa[i] = (b + fh[i] / tga1) * fh[i];
			pi = b + sqrt(db * db + fh[i] * fh[i]) * 2;
			fp[i] = pi;
			fr[i] = fa[i] / pi;
			fs[i] = bi * *dx;
			fv[i] = fa[i] * *dx;
			d1 =  fr[i];
			fq[i] = dfeet / *mn * fa[i] * pow(d1, 0.6666666666666666) * sqrt(*s);
            qq0= fq[i];
			aa0 =fa[i];
		}
		else
		{
			db2 = (fh[i] - *h0) / tga2;
			bi = *w1 * 2 + *b0 + db2 * 2;
			fb[i] = bi;
			fa[i] = (*w1 * 2 + *b0 + db2)  * (fh[i] - *h0) + a0;
			pi = *w1 * 2 + sqrt(db2 * db2 + (fh[i] - *h0) * (fh[i] - *h0)) * 2.0 + *b0; //+ p0;
			fp[i] = pi;
			fr[i] = fa[i] / pi ;
			fs[i] = bi * *dx;
			fv[i] = fa[i] * *dx;
			d1 =  fr[i];
			fq[i] = dfeet / *mn * (fa[i]-aa0) * pow(d1, 0.6666666666666666) * sqrt(*s);
			fq[i] += qq0;
		}
    }    
	for (i = 0; i <= *nt-2; ++i)
	{
		qk[i] = (fv[i + 1] - fv[i]) / (fq[i + 1] - fq[i]);
    }
    return 0;
}
*/


//+ + + PURPOSE + + +
//Prepare to simulate advection of fully entrained constituents

int CLSPCMODEL::ADCALC(double VOLS, double ROS, double RO, double CRRAT,
					double DELTS,double& SROVOL, double& EROVOL)
{
	//+ + + LOCAL VARIABLES + + +
	double COJS,JS,RAT;
 
		//calculate weighting factors given to rate of outflow of
		//constituents at start (js) and end (cojs) of interval,
		//in calculating mean rate of outflow over the ivl
 
		if (ROS > 1.0e-7) 
		{
			//calculate ratio of volume to outflow volume; delts is the
			//simulation interval in seconds

			RAT = VOLS / (ROS*DELTS);
			if (RAT < CRRAT) 
				//part of water in outflow volume entered control volume as
				//inflow during same interval; hence, concentration of
				//inflowing material will affect outflow concentration and
				//js will be < 1.0
				JS = RAT / CRRAT;
			else
				//all water in outflow volume was contained in control volume
				//at beginning of ivl; mean rate of outflow over ivl will be
				//wholly dependent upon rate of outflow of constituents at
				//start of ivl
				JS = 1.0;
		}
		else
		{
			//reach/res has no outflow at start of ivl
			JS = 0.0;
		}
 
		//cojs is the complement of js
		COJS = 1.0 - JS;

		//calculate weighted volumes of outflow at start of ivl (srovol),
		//and end of ivl (erovol)
		SROVOL = JS * ROS * DELTS;
		EROVOL = COJS * RO * DELTS;

		return 0;
} 
 
/*     + + + PURPOSE + + + */
/*     Simulate advection of constituent totally entrained in water */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     IMAT   - input mass */
/*     VOLS   - Volumn at start */
					/*     SROVOL - outflow at n . Return wirh outflow volumn. */
/*     VOL    - volume of water in reach above bed at (n+1) */
/*     EROVOL - outflow at n+1 (q).Return wirh outflow volumn. */
/*     CONC   - concentration at n. return with value at n+1 */
/*     ROMAT  - mass outoff reach */
/*     + + +   + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::advect(int admod, double volt, double *imat, double *vols, 
					   double *srovol1, double *vol, double *erovol1, double *conc, 
					   double *romat, double delts, double *js, double crrat)
{
	double cojs, concs, ro, ros,srovol,erovol;
	double fThreshold= 1.0e-7;

	// save starting concentration value 
    concs = *conc;
    ros = *srovol1;
    ro = *erovol1;

	if (fabs(ros) > fThreshold)
	{
		double rat = *vols / (ros * delts);
		if (rat < crrat)
			*js = rat/crrat;
		else
			*js = 1.0;
	}
	else
	{
		*js = 0.0;
	}
    cojs = 1.0 - *js;
	srovol = *js * ros * delts;
	erovol = cojs * ro * delts;

    if (fabs(*vol) > fThreshold)
	{
		// reach/res contains water; perform advection normally  
		// calculate new concentration of material in reach/res based  
		// on quantity of material entering during interval (imat),  
		// weighted volume of outflow based on conditions at start of  
		// ivl (srovol), and weighted volume of outflow based on  
		// conditions at end of ivl (erovol)  
		if (admod == 1)
		{		
			*conc = (*imat + concs * (*vols - srovol)) / (*vol + erovol);				
			if (*conc < 0)	*conc = 0;
			// calculate total amount of material leaving reach/res during  
			// interval  

			if (ro > 0)
			{
				*romat = srovol * concs + erovol * *conc;									
				if (*romat < 0)	*romat = 0;
			}
			else
				*romat = 0;	
		}
		else
		{
			if (volt > 0)
			{
				*conc = (*imat + concs * *vols) / volt;				
				if (*conc < 0)	*conc = 0;
				*romat = ro * delts * *conc;
			}
			else
			{
				*conc = 0.0;
				*romat = *imat + concs * *vols;	
			}
		}
    }
	else
	{
		// reach/res has gone dry during the interval; set conc equal to  
		// an undefined value  
		// *conc = -1e10;
		*conc = 0;
		// calculate total amount of material leaving during interval;  
		// this is equal to material inflow + material initially present  

		if (ro > 0)
		{
			*romat = *imat + concs * *vols;	
			if (*romat < 0)	*romat = 0;
		}
		else
		{
			*romat = 0;	
		}
    }
    return 0;
}

//+ + + PURPOSE + + +
//Simulate advection of constituent totally entrained in water

//+ + + DUMMY ARGUMENTS + + +
//INTEGER    NEXITS
//REAL       EOVOL(5),EROVOL,IMAT,OMAT(5),ROMAT,SOVOL(5),
//$           SROVOL
//DOUBLE PRECISION CONC,VOL,VOLS

//+ + + ARGUMENT DEFINITIONS + + +
//IMAT   - ???
//VOLS   - ???
//SROVOL - ???
//VOL    - volume of water in reach above bed
//EROVOL - ???
//SOVOL  - ???
//EOVOL  - ???
//NEXITS - number of exits from the operation
//CONC   - ???
//ROMAT  - ???
//OMAT   - ???

int CLSPCMODEL::ADVECT(int ADMOD, double VOLT, double IMAT, double VOLS, double SROVOL, double VOL, 
					double EROVOL, double *CONC, double *ROMAT)
{
	//save starting concentration value
	double CONCS = *CONC;

	if (VOL > 1.0e-7) 
	{
		//reach/res contains water; perform advection normally

		//calculate new concentration of material in reach/res based
		//on quantity of material entering during interval (imat),
		//weighted volume of outflow based on conditions at start of
		//ivl (srovol), and weighted volume of outflow based on
		//conditions at end of ivl (erovol)
		if (ADMOD == 1)
		{
			*CONC = (IMAT + CONCS * (VOLS - SROVOL)) / (VOL + EROVOL);

			//calculate total amount of material leaving reach/res during
			//interval
			*ROMAT = SROVOL * CONCS + EROVOL * *CONC;
		}
		else
		{
			*CONC = (IMAT + CONCS * VOLS) / VOLT;

			//calculate total amount of material leaving reach/res during
			//interval
			*ROMAT = EROVOL * *CONC;
		}
	}
	else
	{
		//reach/res has gone dry during the interval; set conc equal to
		//an undefined value
		*CONC = 0.0;

		//calculate total amount of material leaving during interval;
		//this is equal to material inflow + material initially present
		*ROMAT = IMAT + (CONCS * VOLS);
	}
    return 0;
}

	//SUBROUTINE   ADECAY

	//+ + + PURPOSE + + +
	//Simulate decay of material in adsorbed state

int CLSPCMODEL::ADECAYSS(double *ADDCPM, double TW20, double *RSED, double *SQAL, double *SQDEC)
{

	int		i;
	double	DCONC,DK,FACT;

	if (ADDCPM[1] > 0.0)	// array starting from 1
	{
		//calculate temp-adjusted decay rate
		DK  = ADDCPM[1] * pow(ADDCPM[2],TW20);
		FACT= 1.0 - exp(-DK);
 
		for (i=1; i<4; i++)
		{
			//particle size loop
			if (SQAL[i] > 1.0E-30) 
			{
				DCONC   = SQAL[i] * FACT;
				SQAL[i] = SQAL[i] - DCONC;
				SQDEC[i]= DCONC * RSED[i];
			}
			else
			{
				SQDEC[i]= 0.0;
			}
		}
	}
	else
	{
		for (i=1; i<4; i++)
			SQDEC[i] = 0.0;
    }
 
    return 0;
}

int CLSPCMODEL::ADECAYBS(double *ADDCPM, double TW20, double *RSED, double *SQAL, double *SQDEC)
{

	int		i;
	double	DCONC,DK,FACT;

	if (ADDCPM[3] > 0.0)	// array starting from 1
	{
		//calculate temp-adjusted decay rate
		DK  = ADDCPM[3] * pow(ADDCPM[4],TW20);
		FACT= 1.0 - exp(-DK);
 
		for (i=4; i<7; i++)
		{
			//particle size loop
			if (SQAL[i] > 1.0E-30) 
			{
				DCONC   = SQAL[i] * FACT;
				SQAL[i] = SQAL[i] - DCONC;
				SQDEC[i]= DCONC * RSED[i];
			}
			else
			{
				SQDEC[i]= 0.0;
			}
		}
	}
	else
	{
		for (i=4; i<7; i++)
			SQDEC[i] = 0.0;
    }
 
    return 0;
}

	//SUBROUTINE   ADSDES

	//+ + + PURPOSE + + +
	//Simulate exchange of a constituent between the dissolved
	//state and adsorbed state-note that 6 adsorption site classes are
	//considered: 1- suspended sand  2- susp. silt  3- susp. clay
	//4- bed sand  5- bed silt  6- bed clay

int CLSPCMODEL::ADSDES(double VOL, double *RSED, double *ADPM1, double *ADPM2, 
					   double *ADPM3, double TW20, double& DQAL, double *SQAL, 
					   double *ADQAL)
{
	int j;
	double AKJ,DENOM,NUM,TEMP;
	double AINV[7],CAINV[7];

	for (j=0; j<7; j++)	// 1-6
	{
		AINV[j] = 0.0;
		CAINV[j] = 0.0;
	}
 
	if (VOL > 0.0) // m3
	{
		//adsorption/desorption can take place

		//first find the new dissolved conc.
		NUM  = VOL * DQAL;	// g
		DENOM= VOL;			// m3

		for (j=1; j<7; j++)
		{
			if (RSED[j] > 0.0)	// g
			{
				//this sediment class is present-evaluate terms due to it

				//transfer rate, corrected for water temp
				AKJ = ADPM2[j] * pow(ADPM3[j],TW20);
				TEMP= 1.0/(1.0 + AKJ);

				//calculate 1/a and c/a
				AINV[j] = AKJ * ADPM1[j] * TEMP;	// l/mg = m3/g
				CAINV[j]= SQAL[j] * TEMP;			// mg/mg

				//accumulate terms for numerator and denominator
				//in dqal equation
				NUM  = NUM + (SQAL[j] - CAINV[j])*RSED[j];	// g
				DENOM= DENOM + RSED[j]*AINV[j];				// m3
			}
		}

		//calculate new dissolved concentration-units are conc/l
		DQAL = NUM/DENOM;	// g/m3 = mg/l
		if (DQAL < 0) DQAL = 0.0;

		//calculate new conc on each sed class and the corresponding
		//adsorption/desorption flux
		ADQAL[7] = 0.0;

		for (j=1; j<7; j++)
		{
			if (RSED[j] > 0.0)	// g
			{
				//this sediment class is present-calculate data
				//pertaining to it

				//new concentration
				TEMP= CAINV[j] + DQAL*AINV[j];

				//quantity of material transferred
				ADQAL[j]= (TEMP - SQAL[j])*RSED[j];	// g
				SQAL[j] = TEMP;

				//accumulate total adsorption/desorption flux
				ADQAL[7]= ADQAL[7] + ADQAL[j];
			}
			else
			{
				//this sediment class is absent
				ADQAL[j]= 0.0;
				//sqal[j] is unchanged-"undefined"
			}
		}
	}
	else
	{
		//no water, no adsorption/desorption
		for (j=1; j<8; j++)
			ADQAL[j] = 0.0;
			//sqal(1 thru 3) and dqal should already have been set to
			//undefined values
	}

	return 0;
}

	//SUBROUTINE   ADVQAL

	//+ + + PURPOSE + + +
	//Simulate the advective processes, including deposition and
	//scour for the quality constituent attached to one sediment size
	//fraction

int CLSPCMODEL::ADVQAL(double ISQAL, double RSED, double BSED, double DEPSCR, double ROSED,
					   double RSQALS, double RBQALS, double& SQAL, double& BQAL, 
					   double& DSQAL, double& ROSQAL)
{
	// all units are in gram
	double	DENOM,RBQAL;

	if (DEPSCR < 0.0) 
	{
		//there was scour during the interval

		if ((fabs(BSED)) <= 0.0) 
		{
			//bed was scoured "clean"
			BQAL = 0.0; // -1.0E30;
			DSQAL= RBQALS;	//g		// dsqal is qual in deposition/scour
		}
		else
		{
			//there is still bed material left
			BQAL = RBQALS/(BSED - DEPSCR);	// mg/mg	
			DSQAL= BQAL*DEPSCR;				// g
		}

		//calculate concentration in suspension-under these conditions,
		//denominator should never be zero
		SQAL  = (ISQAL + RSQALS - DSQAL)/(RSED + ROSED);	// mg/mg
		ROSQAL= ROSED*SQAL;	// g
	}
	else
	{
		//there was deposition or no scour/deposition
		//during the interval
		DENOM= RSED + DEPSCR + ROSED;

		if ((fabs(DENOM)) <= 0.0) 
		{
			//there was no sediment in suspension during the interval
			SQAL  = 0.0; //-1.0E30;
			ROSQAL= 0.0;
			DSQAL = 0.0;

			if ((fabs(ISQAL)) > 0.0 || (fabs(RSQALS)) > 0.0) 
			{
				//error-under these conditions these values should be zero
//				AfxMessageBox("error -- under these conditions these values should be zero");
//				return 2;
			}
		}
		else
		{
	        //there was some suspended sediment during the interval

			//calculate conc on suspended sed
			SQAL  = (ISQAL + RSQALS)/DENOM;
			ROSQAL= ROSED*SQAL;
			DSQAL = DEPSCR*SQAL;

			if ((fabs(RSED)) <= 0.0) 
				//rchres ended up without any suspended sediment-revise
				//value for sqal, but values obtained for rsqal,
				//rosqal, and dsqal are still ok
				SQAL= 0.0; //-1.0E30;
		}

		//calculate conditions on the bed

		if ((fabs(BSED)) <= 0.0) 
		{
			//no bed sediments at end of interval
			BQAL= 0.0; //-1.0E30;

			if ((fabs(DSQAL)) > 0.0 || (fabs(RBQALS)) > 0.0) 
			{
				//error-under this condition these values should be zero
//				AfxMessageBox("error -- under these conditions these values should be zero");
//				return 2;
			}
		}
		else
		{
			 //there is bed sediment at the end of the interval
			 RBQAL= DSQAL + RBQALS;
			 BQAL = RBQAL/BSED;
		}

	}

//	if (NEXITS > 1) 
//	{
		//we need to compute outflow through each individual exit

//		if ((fabs(ROSED)) <= 0.0) 
//		{
			//all zero
//			for (j=1; j<=NEXITS; j++)
//				OSQAL[j]=0.0;
//		}
//		else
//		{
//			for (i=1; i<=NEXITS; i++)
//				OSQAL[i]= ROSQAL*OSED[i]/ROSED;
//		}

//   }

	return 0;
}

	//SUBROUTINE   DDECAY

	//+ + + PURPOSE + + +
	//Estimate decay of dissolved constituent

int CLSPCMODEL::DDECAY(int *QALFG, double TW20, double *HYDPM, double PHVAL, double *ROXPM,
					   double ROC, double *FACT2, double FACT1, double *PHOTPM, double KOREA,
					   double CFGAS, double *BIOPM, double BIO, double *GENPM, double VOLSP,
					   double DQAL, int HR, double DELT60, double *DDQAL)
{
	int		i,j;
	double	FACT3,K[8],KHYD,KROX;

	for (i=0; i<8; i++)
		K[i] = 0.0;

	if (DQAL > 1.0E-25) 
	{
		//simulate decay

		if (QALFG[1] == 1) 
		{
			//simulate hydrolysis
			KHYD = HYDPM[1] * pow(10.0,(-PHVAL)) + HYDPM[2] * pow(10.0,(PHVAL - 14.0)) 
				   + HYDPM[3];
			//adjust for temperature
			K[1] = KHYD * pow(HYDPM[4],TW20);
		}
		else
		{
			K[1] = 0.0;
		}

		if (QALFG[2] == 1) 
		{
			//simulate oxidation by free radical processes
			KROX= ROXPM[1] * ROC;
			//adjust for temperature
			K[2]= KROX * pow(ROXPM[2],TW20);
		}
		else
		{
			K[2] = 0.0;
		}

		if (QALFG[3] == 1) 
		{
			//simulate photolysis
			//go through summation over 18 wave-length intervals
			FACT3 = 0.0;

			for (j=1; j<19; j++)
				FACT3 = FACT3 + FACT2[j] * PHOTPM[j];

			K[3] = FACT1 * PHOTPM[19] * FACT3 * pow(PHOTPM[20],TW20);
		}
		else
		{
			K[3] = 0.0;
		}

		if (DELT60 < 24.) 
		{
			if (HR >= 6 && HR < 18) 
				//it is a daylight hour; photolysis rate is doubled
				//for this interval
				K[3] = 2.0*K[3];
			else
				//it is not a daylight hour; photolysis does not occur
				K[3] = 0.0;
		}
		else
		{
			//simulation interval is greater than 24 hours;
			//no correction is made to photolysis rate to
			//represent diurnal fluctuation
		}

		if (QALFG[4] == 1) 
			//simulate volatilization
			K[4] = KOREA*CFGAS;
		else
			K[4] = 0.0;

		if (QALFG[5] == 1) 
			//simulate biodegradation
			K[5] = BIOPM[1] * BIO * pow(BIOPM[2],TW20);
		else
			K[5] = 0.0;

		if (QALFG[6] == 1) 
			//simulate simple first-order decay
			K[6] = GENPM[1] * pow(GENPM[2],TW20);
		else
			K[6] = 0.0;

		//get total decay rate
		K[7] = 0.0;

		for (i=1; i<7; i++)
			K[7] = K[7] + K[i];

		//calculate the total change in material due to decay-units are
		//conc*vol/l.ivl
		DDQAL[7] = DQAL * (1.0 - exp(-K[7])) * VOLSP;

		//prorate among the individual decay processes- the method used
		//for proration is linear, which is not strictly correct, but
		//should be a good approximation under most conditions

		for (i=1; i<7; i++)
		{
			if (K[7] > 0.0) 
				DDQAL[i] = K[i]/K[7]*DDQAL[7];
			else
				DDQAL[i] = 0.0;
		}
	}
	else
	{
		//too little dissolved material to simulate decay
		for (i=1; i<8; i++)
			DDQAL[i] = 0.0;
	}

	return 0;
}
/*
void CLSPCMODEL::MapReach2SWS()
{
	for(int i=0; i < nch;++i)
	{
		for(int j=0; j < nsws; ++j)
		{
			if(pChannelInfo[i].rchid == pswsinfo[j].subbasin)
			{
				pChannelInfo[i].nIndexSWS = j;
				break;
			}
		}
	}
}
*/
bool CLSPCMODEL::AssignReachOrder()
{
	//NETWORK
	//first, remove all the elements in the lists of each channel
	//which contains the upper streams information
	for(int i=0; i<nch;++i)
	{
		pChannelInfo[i].nSelfOrder = -1;
		pChannelInfo[i].cListUppersOrder.RemoveAll();
		pChannelInfo[i].cListUppersOriginal.RemoveAll();
	}

	//update the Original list with all the upper streams information
	for(i=0; i<nch;++i)
	{
		int nReachID = pChannelInfo[i].rchid;
		//if the down stream is not valid
		if(pChannelInfo[i].nDSchan <= 0)				 
			continue;
		else
		{
			for(int j=0; j<pChannelInfo[i].nDSchan; j++)				 
			{
				if(ExistReach(pChannelInfo[i].down_ch[j]))
				{
					//self link detected
					if(pChannelInfo[i].down_ch[j] == nReachID)
					{
						CString str;
						str.Format("Check the steam network table, reach %d cannot\n"\
							" be the upstream of itself",nReachID);
						AfxMessageBox(str);
						return false;
					}

					int nOrder = FindIndexOrder(pChannelInfo[i].down_ch[j]);
					//additional check is required to prevent duplicated entry
					bool bFind = false;
					int nNum = pChannelInfo[nOrder].cListUppersOriginal.GetSize();
					if(nNum > 0)
					{
						for(int j=0; j<nNum; ++j)
						{
							int nExistReach = pChannelInfo[nOrder].cListUppersOriginal.GetAt(j);
							if(nExistReach == nReachID)
							{
								bFind = true;
								break;
							}
						}
					}
					if(nOrder >= 0 && !bFind)
						pChannelInfo[nOrder].cListUppersOriginal.Add(nReachID);
				}
			}
		}
	}
	//now assigned the order to each channel
	//for those without upper stream, assign orders first
	int nOrder = 0;
	for(i=0; i<nch; ++i)
	{
		int nNum = pChannelInfo[i].cListUppersOriginal.GetSize();
		if(nNum == 0)
			pChannelInfo[i].nSelfOrder = nOrder++;
	}
	//now process all the channels
	
	int nLastOrderID = nOrder;

	while(true)
	{
		//if each channel is assigned an order
		if(nOrder == nch)
			break;
		for(i=0; i<nch;++i)
		{
			// order already assigned, ignore it
			if(pChannelInfo[i].nSelfOrder >= 0)
				continue;
			//if the order is not assigned, check all up channels 
			bool bAllUpperChecked = true;
			int nNum = pChannelInfo[i].cListUppersOriginal.GetSize();
			if(nNum > 0)
			{
				for(int j=0; j<nNum; ++j)
				{
					int nUpperReach = pChannelInfo[i].cListUppersOriginal.GetAt(j);
					if(ExistReach(nUpperReach))
					{
						int nUOrder = FindSelfOrder(nUpperReach);
						if(nUOrder < 0)
						{
							bAllUpperChecked = false;
							break;
						}
					}
				}
			}
			if(bAllUpperChecked)
				pChannelInfo[i].nSelfOrder = nOrder++;
		}

		if(nLastOrderID == nOrder)
		{
			// there is no order assigned for this cycle
			// which means a circle exists
			AfxMessageBox("Check the stream network table, an illegal circle detected!");
			return false;
		}
		nLastOrderID = nOrder;
	}

	//fill in the cListUppersOrder of each reach
	for(i=0; i<nch; ++i)
	{
		int nNum = pChannelInfo[i].cListUppersOriginal.GetSize();
		if(nNum > 0)
		{
			for(int j=0; j<nNum; ++j)
			{
				int nUpperReach = pChannelInfo[i].cListUppersOriginal.GetAt(j);
				if(ExistReach(nUpperReach))
				{
					int nUOrder = FindIndexOrder(nUpperReach);
					pChannelInfo[i].cListUppersOrder.Add(nUOrder);
				}
			}
		}
	}
/*	// need to update this part of code   (01-2005)
	//assign the down stream ID as it is used for TMDL control
	for(i = 0; i < nch;++i)
	{
		for(j=0; j < pChannelInfo[i].nDSchan;++j)				  
		{
			int nNum = pChannelInfo[i].down;
			if(nNum > 0)
				pChannelInfo[i].nIndexD = FindSelfOrder(nNum);
		}
	}

*/

	//testing code to find whether the generated result is correct or not
	//successfully tested, commented to avoid CPU usage
	
	for(i=0; i<nch;++i)
	{
		TRACE("Reach = %d\n",pChannelInfo[i].rchid);
		TRACE("Order = %d\n",pChannelInfo[i].nSelfOrder);
		
		
		int nNum = pChannelInfo[i].cListUppersOriginal.GetSize();
		if(nNum > 0)
		{
			TRACE("Upper Channels:\n");
			for(int j=0; j<nNum; ++j)
			{
				int nUpperReach = pChannelInfo[i].cListUppersOriginal.GetAt(j);
				int nOrder = pChannelInfo[i].cListUppersOrder.GetAt(j);
				TRACE("%d(%d)\n",nUpperReach,nOrder);
			}
		}
//		TRACE("Down index =%d\n",pChannelInfo[i].nIndexD);
		TRACE("*************\n");
	}

	return true;
}

bool CLSPCMODEL::ExistReach(int nReach)
{
	for(int i=0; i<nch;++i)
		if(pChannelInfo[i].rchid == nReach)
			return true;
	return false;
}

int CLSPCMODEL::FindSelfOrder(int nReach)
{
	for(int i=0; i < nch;++i)
	{
		if(pChannelInfo[i].rchid == nReach)
		{
		/*
		if(pChannelInfo[i].nSelfOrder < 0)
		return 1;
		else
			*/
			return pChannelInfo[i].nSelfOrder;
		}
	}
	return -1;
}

int CLSPCMODEL::FindIndexOrder(int nReach)
{
	for(int i=0; i<nch; ++i)
	{
		if(pChannelInfo[i].rchid == nReach)
		{
			return i;
		}
	}
	return -1;
}

int CLSPCMODEL::FindReach(int nOrder)
{
	for(int i=0; i<nch; ++i)
	{
		if(pChannelInfo[i].nSelfOrder == nOrder)
			return i;
	}
	return -1;
}

int CLSPCMODEL::FindReachIndex(int nRchID)
{
	for(int i=0; i<nch; ++i)
	{
		if(pChannelInfo[i].rchid == nRchID)
			return i;
	}
	return -1;
}
	
bool CLSPCMODEL::ReadLinkageFile(CString strFileName, Link435& plink435)
{
	long lNumRecords;

	if (nLinkFiles == 0)
		return true;

	FILE *fpin = NULL;
	char strLine[MAXLINE];
	CString strError = "";
	
	// open the file for reading
	fpin = fopen (strFileName, "rt");
	if(fpin == NULL)
	{
		AfxMessageBox("Cannot open file "+strFileName+" for reading");
		Log("Cannot open file "+strFileName+" for reading");
		return false;
	}

	// skip the comment line start with a 'C'
	SkipCommentLine(fpin);

	memset (strLine, 0, MAXLINE);
	if(fgets (strLine, MAXLINE, fpin) == NULL)
	{
		AfxMessageBox("Cannot read file "+strFileName);
		Log("Cannot read file "+strFileName);
		return false;
	}
	else
	{
		int nYear,nMonth,nDay,nTimestep,nNumQuals,nNumSediment;
		CString str(strLine);
		CStringToken strToken(str);
		sscanf(LPCSTR(strToken.NextToken()),"%d/%d/%d",&nMonth,&nDay,&nYear);
		COleDateTime SimStart = COleDateTime(nYear,nMonth,nDay,0,0,0);
		int nSYear = tStart.GetYear();
		int nSMonth = tStart.GetMonth();
		int nSDay = tStart.GetDay();
		if (nSYear != nYear || nSMonth != nMonth || nSDay != nDay)
		{
			AfxMessageBox("Wrong Start Simulation Date in file "+strFileName);
			Log("Wrong Start Simulation Date in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d/%d/%d",&nMonth,&nDay,&nYear);
		COleDateTime SimEnd = COleDateTime(nYear,nMonth,nDay,23,59,59);
		nSYear = tEnd.GetYear();
		nSMonth = tEnd.GetMonth();
		nSDay = tEnd.GetDay();
		if (nSYear != nYear || nSMonth != nMonth || nSDay != nDay)
		{
			AfxMessageBox("Wrong End Simulation Date in file "+strFileName);
			Log("Wrong End Simulation Date in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nTimestep);
		if (nTimestep != deltm)
		{
			AfxMessageBox("Wrong Simulation Interval in file "+strFileName);
			Log("Wrong Simulation Interval in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nNumQuals);
		if (nNumQuals != nQuals)
		{
			AfxMessageBox("Wrong number of quals in file "+strFileName);
			Log("Wrong number of quals in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nNumSediment);
		if (nNumSediment != NumSed)
		{
			AfxMessageBox("Wrong number of sediments in file "+strFileName);
			Log("Wrong number of sediments in file "+strFileName);
			return false;
		}

		COleDateTimeSpan SimSpan = SimEnd - SimStart;
		lNumRecords = SimSpan.GetTotalMinutes()/nTimestep+1;
	}

	memset (strLine, 0, MAXLINE);
	if(fgets (strLine, MAXLINE, fpin) == NULL)
	{
		AfxMessageBox("Cannot read file "+strFileName);
		Log("Cannot read file "+strFileName);
		return false;
	}
	else
	{
		int nTempFlag,nSedFlag,nQualFlag,nOxFlag,nNutFlag,nPlkFlag,npHFlag;
		CString str(strLine);
		CStringToken strToken(str);
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nTempFlag);
		if (nTempFlag != tempfg)
		{
			AfxMessageBox("Invalid temperature flag in file "+strFileName);
			Log("Invalid temperature flag in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nSedFlag);
		if (nSedFlag != sedfg)
		{
			AfxMessageBox("Invalid sediment flag in file "+strFileName);
			Log("Invalid sediment flag in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nQualFlag);
		if (nQualFlag != pqalfg)
		{
			AfxMessageBox("Invalid gqual flag in file "+strFileName);
			Log("Invalid gqual flag in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nOxFlag);
		if (nOxFlag != oxfg)
		{
			AfxMessageBox("Invalid do/bod flag in file "+strFileName);
			Log("Invalid do/bod flag in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nNutFlag);
		if (nNutFlag != nutfg)
		{
			AfxMessageBox("Invalid nutrient flag in file "+strFileName);
			Log("Invalid nutrient flag in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nPlkFlag);
		if (nPlkFlag != plkfg)
		{
			AfxMessageBox("Invalid plankton flag in file "+strFileName);
			Log("Invalid plankton flag in file "+strFileName);
			return false;
		}
		sscanf(LPCSTR(strToken.NextToken()),"%d",&npHFlag);
		if (npHFlag != phfg)
		{
			AfxMessageBox("Invalid pH flag in file "+strFileName);
			Log("Invalid pH flag in file "+strFileName);
			return false;
		}
	}
	
	// allocate memory
	if(plink435.pLinkData != NULL)
	{
		delete []plink435.pLinkData;
		plink435.pLinkData = NULL;
	}

	if(lNumRecords > 0)
		plink435.pLinkData = new LINKAGEDATA[lNumRecords];

	long lRecord = 0;
	while(true)
	{
		int nYear,nMonth,nDay,nHour,nMinute;
		memset (strLine, 0, MAXLINE);
		// read the data line
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			AfxMessageBox("Cannot read file "+strFileName);
			Log("Cannot read file "+strFileName);
			return false;
		}

		CString str(strLine);
		CStringToken strToken(str);
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nYear);
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nMonth);
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nDay);
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nHour);
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nMinute);

		plink435.pLinkData[lRecord].tTime = COleDateTime(nYear,nMonth,nDay,nHour,nMinute,0);
		plink435.pLinkData[lRecord].flow = atof(LPCSTR(strToken.NextToken()));
		
		if (tempfg == 1)
		{
			plink435.pLinkData[lRecord].temp = atof(LPCSTR(strToken.NextToken()));
		}
		
		if (sedfg == 1 && NumSed > 0)
		{
			// allocate memory
			if(plink435.pLinkData[lRecord].pSed != NULL)
				delete []plink435.pLinkData[lRecord].pSed;
			plink435.pLinkData[lRecord].pSed = new double[NumSed];
			
			for (int i=0; i<NumSed; i++)
				plink435.pLinkData[lRecord].pSed[i] = atof(LPCSTR(strToken.NextToken()));
		}			
		
		if (pqalfg == 1 && nQuals > 0)
		{
			// allocate memory
			if(plink435.pLinkData[lRecord].pQual != NULL)
				delete []plink435.pLinkData[lRecord].pQual;
			plink435.pLinkData[lRecord].pQual = new double[nQuals];

			if(plink435.pLinkData[lRecord].pSedQual != NULL)
				delete []plink435.pLinkData[lRecord].pSedQual;
			plink435.pLinkData[lRecord].pSedQual = new double[nQuals*3];
			
			for (int i=0; i<nQuals; i++)
			{
				plink435.pLinkData[lRecord].pQual[i] = atof(LPCSTR(strToken.NextToken()));
				for (int j=0; j<3; j++)
					plink435.pLinkData[lRecord].pSedQual[i*3+j] = atof(LPCSTR(strToken.NextToken()));
			}
		}			
		
		if (oxfg == 1)
		{
			plink435.pLinkData[lRecord].dox = atof(LPCSTR(strToken.NextToken()));
			plink435.pLinkData[lRecord].bod = atof(LPCSTR(strToken.NextToken()));
		}
		
		if (nutfg == 1)
		{
			plink435.pLinkData[lRecord].no3 = atof(LPCSTR(strToken.NextToken()));
			plink435.pLinkData[lRecord].tam = atof(LPCSTR(strToken.NextToken()));
			plink435.pLinkData[lRecord].no2 = atof(LPCSTR(strToken.NextToken()));
			plink435.pLinkData[lRecord].po4 = atof(LPCSTR(strToken.NextToken()));
			for (int i=0; i<3; i++)
				plink435.pLinkData[lRecord].snh4[i] = atof(LPCSTR(strToken.NextToken()));

			for (i=0; i<3; i++)
				plink435.pLinkData[lRecord].spo4[i] = atof(LPCSTR(strToken.NextToken()));
		}
		
		if (plkfg == 1)
		{
			plink435.pLinkData[lRecord].phy = atof(LPCSTR(strToken.NextToken()));
			plink435.pLinkData[lRecord].zoo = atof(LPCSTR(strToken.NextToken()));
			plink435.pLinkData[lRecord].orn = atof(LPCSTR(strToken.NextToken()));
			plink435.pLinkData[lRecord].orp = atof(LPCSTR(strToken.NextToken()));
			plink435.pLinkData[lRecord].orc = atof(LPCSTR(strToken.NextToken()));
		}			
		
		if (phfg == 1)
		{
			plink435.pLinkData[lRecord].tic = atof(LPCSTR(strToken.NextToken()));
			plink435.pLinkData[lRecord].co2 = atof(LPCSTR(strToken.NextToken()));
		}
		lRecord += 1;

		if (lRecord >= lNumRecords)
			break;
	}

	return true;
}

void CLSPCMODEL::ReadPointSource(CString strFileName)
{
	if(pPSData != NULL)
	{
		delete []pPSData;
		pPSData = NULL;
	}

	if(nPtSource <= 0 || pPSReduction == NULL)
		return;

	FILE *fpin = NULL;
	char strLine[MAXLINE];
	CString strError = "";
	
	// open the file for reading
	fpin = fopen (strFileName, "rt");
	if(fpin == NULL)
	{
		AfxMessageBox("Cannot open file "+strFileName+" for reading");
		Log("Cannot open file "+strFileName+" for reading");
		return;
	}

	// allocate memory
	pPSData = new PSData[nPtSource];
	
	int i,j;
	int nNum = nPtQuals;
	int nSection = -1;
	CString strErrorMsg;
	
	// skip the line start with a 'C'
	SkipCommentLine(fpin);

	while(true)
	{
		int nRecord = 0;
		int nPID = 0;
		double fFlow = 1.0;
		double fLU = 1.0;
		double flow = 0.0;
		double withdrawal = 0.0;
		double *pfNew = NULL;
		CString strTemp = "";
		
		memset (strLine, 0, MAXLINE);
		// read this line
		if(fgets (strLine, MAXLINE, fpin) == NULL)
		{
			TRACE("\nPoint source file reading done!\n");
			Log("\nPoint source file reading done!\n");
			break;
		}
		CString str(strLine);
		CStringToken strToken(str);
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nRecord);
		sscanf(LPCSTR(strToken.NextToken()),"%lf",&fFlow);
		sscanf(LPCSTR(strToken.NextToken()),"%lf",&fLU);
		sscanf(LPCSTR(strToken.NextToken()),"%d",&nPID);

		int subbasin = atoi(LPCSTR(strToken.NextToken()));
		CString strPermit = strToken.NextToken();
		CString strPipe	= strToken.NextToken();

		//get the PSindex from the PSReduction card 660
		nSection = GetPSIndex(subbasin,strPermit,strPipe);

		//Point Source does not exist in card 660 (skip this section)
		if(nSection == -1)
		{
			for(i=0; i<nRecord; ++i)
				if(fgets (strLine, MAXLINE, fpin) == NULL)
				{
					strErrorMsg.Format("\n subbasin:%d, strPermit:%s, strPipe:%s \n",subbasin,strPermit,strPipe);
					AfxMessageBox("Point source file error for reading: "+strErrorMsg+" ");
					Log("Point source file error for reading: "+strErrorMsg+" ");
					TRACE("Point source file error for reading: "+strErrorMsg+" ");
					
					fclose(fpin);
					return;
				}
				continue;
		}

		pPSData[nSection].rchid = subbasin;
		pPSData[nSection].strPermit = strPermit;
		pPSData[nSection].strPipe = strPipe;

		// allocate memory
		pPSData[nSection].pData = new PSREALDATA[nRecord+2];

		if (nNum > 0)
		{
			pfNew = new double[nNum];
			for(i=0; i<nRecord+2; ++i)
				pPSData[nSection].pData[i].pPollutant = new double[nNum];
		}
		
		pPSData[nSection].nRecord = 0;
		
		for(i=0; i<nRecord; ++i)
		{
			memset (strLine, 0, MAXLINE);
			if(fgets (strLine, MAXLINE, fpin) == NULL)
			{
				strErrorMsg.Format("\n subbasin:%d, strPermit:%s, strPipe:%s \n",subbasin,strPermit,strPipe);
				AfxMessageBox("Point source file error for reading: "+strErrorMsg+" ");
				Log("Point source file error for reading: "+strErrorMsg+" ");
				TRACE("Point source file error for reading: "+strErrorMsg+" ");
				break;
			}
			// intepret it
			CString str(strLine);
			CStringToken strToken(str);
			int nYear, nMonth, nDay, nHour, nMinute;
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nYear);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nMonth);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nDay);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nHour);
			sscanf(LPCSTR(strToken.NextToken()),"%d",&nMinute);
			sscanf(LPCSTR(strToken.NextToken()),"%lf",&flow);
			sscanf(LPCSTR(strToken.NextToken()),"%lf",&withdrawal);
			for(j=0; j<nNum; ++j)
				sscanf(LPCSTR(strToken.NextToken()),"%lf",&pfNew[j]);

			COleDateTime dtNew = COleDateTime(nYear,nMonth,nDay,nHour,nMinute,0);

			if(pPSData[nSection].nRecord == 0)
			{
				//if the first record time is not start time,
				// add an additional record to the top
				if(tStart < dtNew)
				{
					// update flow
					pPSData[nSection].pData[pPSData[nSection].nRecord].flow = flow*fFlow;
					pPSData[nSection].pData[pPSData[nSection].nRecord].withdrawal = withdrawal*fFlow;
					// update pollutants
 					for(j=0; j<nNum; j++)
 						pPSData[nSection].pData[pPSData[nSection].nRecord].pPollutant[j] = pfNew[j]*fLU;
					// update date/time
					pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  tStart - COleDateTimeSpan(0,0,deltm,0);		
					++pPSData[nSection].nRecord;
				}

				// update flow
				pPSData[nSection].pData[pPSData[nSection].nRecord].flow = flow*fFlow;
				pPSData[nSection].pData[pPSData[nSection].nRecord].withdrawal = withdrawal*fFlow;
				// update pollutants
 				for(j=0; j<nNum; j++)
 					pPSData[nSection].pData[pPSData[nSection].nRecord].pPollutant[j] = pfNew[j]*fLU;
				// update date/time
				pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  dtNew;
				++pPSData[nSection].nRecord;
			}
			else // not the first record
			{
				if(dtNew == pPSData[nSection].pData[pPSData[nSection].nRecord-1].tTime)
				{
					// update flow
					pPSData[nSection].pData[pPSData[nSection].nRecord-1].flow += flow*fFlow;
					pPSData[nSection].pData[pPSData[nSection].nRecord-1].withdrawal += withdrawal*fFlow;
					//update pollutants
 					for(j=0; j<nNum; j++)
 						pPSData[nSection].pData[pPSData[nSection].nRecord-1].pPollutant[j] += pfNew[j]*fLU;
				}
				else // new time series
				{
					// update flow
					pPSData[nSection].pData[pPSData[nSection].nRecord].flow = flow*fFlow;
					pPSData[nSection].pData[pPSData[nSection].nRecord].withdrawal = withdrawal*fFlow;
					// update pollutants
 					for(j=0; j<nNum; j++)
 						pPSData[nSection].pData[pPSData[nSection].nRecord].pPollutant[j] = pfNew[j]*fLU;
					// update date/time
					pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  dtNew;
					++pPSData[nSection].nRecord;
				}
			}
		}
		
		//if the last record time is not end time, 
		//add an additional record at the end
		if(pPSData[nSection].pData[pPSData[nSection].nRecord-1].tTime  <  tEnd)		
		{
			// update flow
			pPSData[nSection].pData[pPSData[nSection].nRecord].flow = 
				pPSData[nSection].pData[pPSData[nSection].nRecord-1].flow;
			pPSData[nSection].pData[pPSData[nSection].nRecord].withdrawal = 
				pPSData[nSection].pData[pPSData[nSection].nRecord-1].withdrawal;
			//update pollutants
 			for(j=0; j<nNum; j++)
 				pPSData[nSection].pData[pPSData[nSection].nRecord].pPollutant[j] = 
 				pPSData[nSection].pData[pPSData[nSection].nRecord-1].pPollutant[j];
			// update date/time
			pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  tEnd;		
		}
 		if (pfNew != NULL) delete []pfNew;
	}

	//check if any point source is missing! 
	for (i=0; i<nPtSource; i++)
	{
		bool bPSexists = false;
		for (j=0; j<nPtSource; j++)
		{
			if(pPSReduction[i].rchid == pPSData[j].rchid &&
			   pPSReduction[i].strPermitName.CompareNoCase(pPSData[j].strPermit) == 0 &&
			   pPSReduction[i].strPipeName.CompareNoCase(pPSData[j].strPipe) == 0)
			{
				bPSexists = true;
				break;
			}
		}
		if (bPSexists == false)
		{
			strErrorMsg.Format("\n subbasin:%d, strPermit:%s, strPipe:%s \n",
				pPSReduction[i].rchid,pPSReduction[i].strPermitName,
				pPSReduction[i].strPipeName);
			AfxMessageBox("Point source data is missing for: "+strErrorMsg+" ");
			Log("Point source data is missing for: "+strErrorMsg+" ");
			TRACE("Point source data is missing for: "+strErrorMsg+" ");
			break;
		}
	}

	fclose(fpin);
	return;
}

double CLSPCMODEL::GetFlow(int nIndex,COleDateTime tCurrent)
{
	if(pPSReduction == NULL)
		return 0;

//	int PSindex = 0;
	double flow = 0.0;

	for(int i=0; i<nPtSource; ++i)
	{
		if(pChannelInfo[nIndex].rchid == pPSReduction[i].rchid)
		{
			if(pPSReduction[i].nPSindex > 0)
			{
				int ii = pPSReduction[i].nPSindex - 1;
				int nIndex0 = FindPSIndex(ii,tCurrent);
				if(nIndex0 != -1)
				{
					double lfFlow = 0.0;
					if(nIndex0 == 0)
					{
						lfFlow = pPSData[ii].pData[nIndex0].flow * (1.0 - pPSReduction[ii].fReduction_flow);
					}
					else
					{
						COleDateTimeSpan t1 = tCurrent - pPSData[ii].pData[nIndex0-1].tTime;    
						COleDateTimeSpan t2 = pPSData[ii].pData[nIndex0].tTime - tCurrent; 
						double d1 = t1.GetTotalHours();        
						double d2 = t2.GetTotalHours();      
						if(d1 == 0 || d2 == 0)
						{
							if(d1 == 0)
								lfFlow = pPSData[ii].pData[nIndex0-1].flow * (1.0 - pPSReduction[ii].fReduction_flow);
							else
								lfFlow = pPSData[ii].pData[nIndex0].flow * (1.0 - pPSReduction[ii].fReduction_flow);
						}
						else
						{
							lfFlow = (d2*pPSData[ii].pData[nIndex0-1].flow+d1*pPSData[ii].pData[nIndex0].flow)/(d1+d2) * (1.0 - pPSReduction[ii].fReduction_flow);
						}
					}

					flow += lfFlow;

					// for point source summary
					if (tCurrent >= toStart && tCurrent <= toEnd && nPSsummary > 0)
					{
						POSITION pos = pChannelInfo[nIndex].cListPointSources.GetHeadPosition();
						while (pos != NULL)
						{
							PS_SUMMARY& pPS_SUMMARY = (PS_SUMMARY&) pChannelInfo[nIndex].cListPointSources.GetNext(pos);
							if(pPS_SUMMARY.strPermit.CompareNoCase(pPSReduction[i].strPermitName) == 0 && pPS_SUMMARY.strPipe.CompareNoCase(pPSReduction[i].strPipeName) == 0)
							{
								pPS_SUMMARY.lfFlow += lfFlow * delts;	// ft3
								break;
							}
						}
					}
				}
			}
		}
	}
	return flow;
}

void CLSPCMODEL::GetTotalH(int nIndex,COleDateTime tCurrent,double& THDN,double& THDP,double& THADSN,double& THADSP)
{
	//initialize
	THDN = 0.0;		//mole/hr
	THDP = 0.0;		//mole/hr
	THADSN = 0.0;	//mole/hr
	THADSP = 0.0;	//mole/hr

	if(pPSReduction == NULL || pPSData == NULL)
		return;

	for(int i=0; i<nPtSource; ++i)
	{
		if(pChannelInfo[nIndex].rchid == pPSReduction[i].rchid)
		{
			if(pPSReduction[i].nPSindex > 0)
			{
				int ii = pPSReduction[i].nPSindex - 1;
				int nIndex0 = FindPSIndex(ii,tCurrent);
				if(nIndex0 != -1)
				{
					if(nIndex0 == 0)
					{
						THDN += pPSData[ii].pData[nIndex0].THDN;
						THDP += pPSData[ii].pData[nIndex0].THDP;
						THADSN += pPSData[ii].pData[nIndex0].THADSN;
						THADSP += pPSData[ii].pData[nIndex0].THADSP;
					}
					else
					{
						COleDateTimeSpan t1 = tCurrent - pPSData[ii].pData[nIndex0-1].tTime;    
						COleDateTimeSpan t2 = pPSData[ii].pData[nIndex0].tTime - tCurrent; 
						double d1 = t1.GetTotalHours();        
						double d2 = t2.GetTotalHours();      
						if(d1 == 0 || d2 == 0)
						{
							if(d1 == 0)
							{
								THDN += pPSData[ii].pData[nIndex0-1].THDN;
								THDP += pPSData[ii].pData[nIndex0-1].THDP;
								THADSN += pPSData[ii].pData[nIndex0-1].THADSN;
								THADSP += pPSData[ii].pData[nIndex0-1].THADSP;
							}
							else
							{
								THDN += pPSData[ii].pData[nIndex0].THDN;
								THDP += pPSData[ii].pData[nIndex0].THDP;
								THADSN += pPSData[ii].pData[nIndex0].THADSN;
								THADSP += pPSData[ii].pData[nIndex0].THADSP;
							}
						}
						else
						{
							THDN += (d2*pPSData[ii].pData[nIndex0-1].THDN+d1*pPSData[ii].pData[nIndex0].THDN)/(d1+d2);
							THDP += (d2*pPSData[ii].pData[nIndex0-1].THDP+d1*pPSData[ii].pData[nIndex0].THDP)/(d1+d2);
							THADSN += (d2*pPSData[ii].pData[nIndex0-1].THADSN+d1*pPSData[ii].pData[nIndex0].THADSN)/(d1+d2);
							THADSP += (d2*pPSData[ii].pData[nIndex0-1].THADSP+d1*pPSData[ii].pData[nIndex0].THADSP)/(d1+d2);
						}
					}
				}
			}
		}
	}
	return;
}

double CLSPCMODEL::GetWithdrawal(int nIndex,COleDateTime tCurrent)
{
	double withdrawal = 0.0;

	if(pPSReduction == NULL)
		return 0;

	for(int i=0; i<nPtSource; ++i)
	{
		if(pChannelInfo[nIndex].rchid == pPSReduction[i].rchid)
		{
			if(pPSReduction[i].nPSindex > 0)
			{
				int ii = pPSReduction[i].nPSindex - 1;
				int nIndex0 = FindPSIndex(ii,tCurrent);
				if(nIndex0 != -1)
				{
					if(nIndex0 == 0)
					{
						withdrawal += pPSData[ii].pData[nIndex0].withdrawal * (1.0 - pPSReduction[ii].fReduction_flow);
					}
					else
					{
						COleDateTimeSpan t1 = tCurrent - pPSData[ii].pData[nIndex0-1].tTime;    
						COleDateTimeSpan t2 = pPSData[ii].pData[nIndex0].tTime - tCurrent; 
						double d1 = t1.GetTotalHours();        
						double d2 = t2.GetTotalHours();      
						if(d1 == 0 || d2 == 0)
						{
							if(d1 == 0)
								withdrawal += pPSData[ii].pData[nIndex0-1].withdrawal * (1.0 - pPSReduction[ii].fReduction_flow);
							else
								withdrawal += pPSData[ii].pData[nIndex0].withdrawal * (1.0 - pPSReduction[ii].fReduction_flow);
						}
						else
						{
							withdrawal += (d2*pPSData[ii].pData[nIndex0-1].withdrawal+d1*pPSData[ii].pData[nIndex0].withdrawal)/(d1+d2) * (1.0 - pPSReduction[ii].fReduction_flow);
						}
					}
				}
			}
		}
	}
	return withdrawal;
}

double CLSPCMODEL::GetTargetWithDrawal(int nPSIndex,COleDateTime tCurrent)
{
	double wd_flow = 0.0;

	if(pPSData == NULL || pPSReduction == NULL)
		return 0;

	if(pPSReduction[nPSIndex].nPSindex > 0)
	{
		int ii = pPSReduction[nPSIndex].nPSindex - 1;
		int nIndex0 = FindPSIndex(ii,tCurrent);
		if(nIndex0 != -1)
		{
			if(nIndex0 == 0)
			{
				wd_flow = pPSData[ii].pData[nIndex0].withdrawal * (1.0 - pPSReduction[ii].fReduction_flow);
			}
			else
			{
				COleDateTimeSpan t1 = tCurrent - pPSData[ii].pData[nIndex0-1].tTime;    
				COleDateTimeSpan t2 = pPSData[ii].pData[nIndex0].tTime - tCurrent; 
				double d1 = t1.GetTotalHours();        
				double d2 = t2.GetTotalHours();      
				if(d1 == 0 || d2 == 0)
				{
					if(d1 == 0)
						wd_flow = pPSData[ii].pData[nIndex0-1].withdrawal * (1.0 - pPSReduction[ii].fReduction_flow);
					else
						wd_flow = pPSData[ii].pData[nIndex0].withdrawal * (1.0 - pPSReduction[ii].fReduction_flow);
				}
				else
				{
					wd_flow = (d2*pPSData[ii].pData[nIndex0-1].withdrawal+d1*pPSData[ii].pData[nIndex0].withdrawal)/(d1+d2) * (1.0 - pPSReduction[ii].fReduction_flow);
				}
			}
		}
	}

	return wd_flow;
}
/*
int CLSPCMODEL::FindWeatherShift(int ii, COleDateTime tCurrent)
{
	if(tmList[ii].pRecord != NULL)
	{
		for(int j=tmList[ii].nShift; j<tmList[ii].nNum; j++)
		{
			if(tmList[ii].pRecord[j].tm >= tCurrent)
			{
				tmList[ii].nShift = j;
				return j;
			}
		}
	}
	return -1;
}

int CLSPCMODEL::GetWeatherData(int nIndex, int tempfg, COleDateTime tCurrent, double *precip, double *pet,
						   double *airtemp, double *windvel, double *solarrad, double *dewtemp,
						   double *cloudcover)
{
	if(tmList == NULL)
		return -1;

	for(int i=0; i<pswsinfo[nIndex].nwst; ++i)
	{
		if(tmList[pswsinfo[nIndex].wsti[i]-1].pRecord != NULL)
		{
			int nIndex0 = FindWeatherShift(i, tCurrent);
			if(nIndex0 != -1)
			{
				if(nIndex0 == 0)
				{
					*precip     += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[0]*pswsinfo[nIndex].wti[i];
					*pet        += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[1]*pswsinfo[nIndex].wti[i]; 
					if (tempfg == 1)
					{
						*airtemp    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[2]*pswsinfo[nIndex].wti[i]; 
						*windvel    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[3]*pswsinfo[nIndex].wti[i]; 
						*solarrad   += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[4]*pswsinfo[nIndex].wti[i];
						*dewtemp    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[5]*pswsinfo[nIndex].wti[i]; 
						*cloudcover += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[6]*pswsinfo[nIndex].wti[i];
					}
				}
				else
				{
					COleDateTimeSpan t1 = tCurrent - tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].tm;    
					COleDateTimeSpan t2 = tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].tm - tCurrent; 
					COleDateTimeSpan t3;
					if (nIndex0 > 1)
						t3 = tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].tm - tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-2].tm; 
					
					double d1 = t1.GetTotalMinutes();        
					double d2 = t2.GetTotalMinutes();      
					double d3 = d1 + d2;
					if (nIndex0 > 1)
						d3 = t3.GetTotalMinutes();      

					if ((d1+d2) >= delt)
					{
						if(d1 == 0 || d2 == 0)
						{
							if(d1 == 0)
							{
								*precip     += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[0]*delt/d3*pswsinfo[nIndex].wti[i];
								*pet        += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[1]*delt/d3*pswsinfo[nIndex].wti[i]; 
								if (tempfg == 1)
								{
									*airtemp    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[2]*pswsinfo[nIndex].wti[i]; 
									*windvel    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[3]*delt/d3*pswsinfo[nIndex].wti[i]; 
									*solarrad   += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[4]*delt/d3*pswsinfo[nIndex].wti[i];
									*dewtemp    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[5]*pswsinfo[nIndex].wti[i]; 
									*cloudcover += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[6]*pswsinfo[nIndex].wti[i];
								}
							}
							else
							{
								*precip     += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[0]*delt/(d1+d2)*pswsinfo[nIndex].wti[i];
								*pet        += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[1]*delt/(d1+d2)*pswsinfo[nIndex].wti[i]; 
								if (tempfg == 1)
								{
									*airtemp    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[2]*pswsinfo[nIndex].wti[i]; 
									*windvel    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[3]*delt/(d1+d2)*pswsinfo[nIndex].wti[i]; 
									*solarrad   += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[4]*delt/(d1+d2)*pswsinfo[nIndex].wti[i];
									*dewtemp    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[5]*pswsinfo[nIndex].wti[i]; 
									*cloudcover += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[6]*pswsinfo[nIndex].wti[i];
								}
							}
						}
						else
						{
							*precip     += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[0]*delt/(d1+d2)*pswsinfo[nIndex].wti[i];
							*pet        += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[1]*delt/(d1+d2)*pswsinfo[nIndex].wti[i]; 
							if (tempfg == 1)
							{
								*airtemp    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[2]*pswsinfo[nIndex].wti[i]; 
								*windvel    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[3]*delt/(d1+d2)*pswsinfo[nIndex].wti[i]; 
								*solarrad   += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0].fNum[4]*delt/(d1+d2)*pswsinfo[nIndex].wti[i];
								*dewtemp    += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[5]*pswsinfo[nIndex].wti[i]; 
								*cloudcover += tmList[pswsinfo[nIndex].wsti[i]-1].pRecord[nIndex0-1].fNum[6]*pswsinfo[nIndex].wti[i];
							}
						}
					}
					else
					{
						AfxMessageBox("time step larger than airfile time interval is not supported yet");
						return -1;
					}
				}
			}
			break;
		}
	}
	return 1;
}
*/
/*     + + + PURPOSE + + + */
/*     Calculates the irrigation withdrawal rate of water from each stream */

/*     wsIndex  - stream index -- to find out the watersheds withdrawing water */
/*     delts  - number of seconds per timestep */
/*     avgFlow - average flow of water in the stream - cfs */
//     vol1 - volume at the beginning of the timestep - ft3
//	   Author - Sabu Paul
double CLSPCMODEL::GetIrrWD(int wsIndex,double delts,double vol1,COleDateTime tCurrent) //,double *demand)
{
	//get the total volume of water per timestep
//	double avgVol = avgFlow * delts ;	
	double avgVol = vol1; 
	double irriWDRate = 0.0;
	double irriWDVolume = 0.0;
	for(int i=0; i<nsws; i++)
	{
		//find the watersheds withdrawing water from the current stream
		if(pirrigwdinfo[i].streamid == pChannelInfo[wsIndex].rchid)
		{
			wsIrrigDemand[i] = 0.0;
			for(int k=0; k<nlandp; k++)
			{
				double lfAREA = pluinfop[i*nlandp+k].area;
				if (cLU.nLUchangeFlag == 1 && pluinfop[i*nlandp+k].bLUchange == true)
					lfAREA = cLU.GetLanduseArea(tCurrent, &pluinfop[i*nlandp+k]);
				
				wsIrrigDemand[i] += irrigDemand[i*nlandp+k] * lfAREA; 
			}

			irriWDVolume += wsIrrigDemand[i]; 
		}
	}

	//check if the irriWDVolume < stream.vol 
	//irriWDVolume in acre.in
	//wdVolcf in cubic feet
	double wdVolcf = irriWDVolume * IN_ACRE_TO_FT3; 
	double wdFraction = 0.0;	

	//if the available volume is less than the demand
	//proportionally modify the irrigation withdrawal rate
	//and also modify the actually irrigation application rate
	//based on the availability (multiply by the same fraction)
	if(avgVol < wdVolcf) 
	{
//		Log("\nDemand is more than available! Demand = %lf, Available = %lf\n",wdVolcf,avgVol);
		wdFraction = avgVol / wdVolcf;	//when the irrigation demand exceeds the availability
										//then reduce the demand proportionally
		wdVolcf = avgVol;
		
		for(int i=0; i<nsws; i++)
		{	
            if(pirrigwdinfo[i].streamid == pChannelInfo[wsIndex].rchid)
            {
				for(int k=0; k<nlandp; k++)
				{
					irrigDemand[i*nlandp+k] =  irrigDemand[i*nlandp+k] * wdFraction;
					wsIrrigDemand[i] = wsIrrigDemand[i] * wdFraction; 
				}
			}
		}
	}
	//irriWDRate in cfs
	//irriWDRate =  irriWDVolume * 3630 / delts ; //volume in acre.in => 3630 cubic feet
												//volume in acre.ft => 43560 cubic feet
	//Withdrawal rate in cfs
	irriWDRate =  wdVolcf / delts;

	return irriWDRate;
}

double CLSPCMODEL::GetLoad(int sqalfg,int nIndex,int nQualid,COleDateTime tCurrent)
{
	if(pPSReduction == NULL)
		return 0;

	int j = -1;
	int Num = nPtQuals;

	// get the index for point source qual
	for (int i=0; i<Num; i++)
	{
		if (pPtQual[i].qualid == nQualid)
		{
			j = i;
			break;
		}
	}

	// return 0 if qual does not exist in point sources
	if (j == -1)
		return 0;

	double load = 0.0;

	for(i=0; i<nPtSource; ++i)
	{
		if(pChannelInfo[nIndex].rchid == pPSReduction[i].rchid)
		{
			if(pPSReduction[i].nPSindex > 0)
			{
				int ii = pPSReduction[i].nPSindex - 1;
				int nIndex0 = FindPSIndex(ii,tCurrent);
				if(nIndex0 != -1)
				{
					double psload = 0.0;
					if(nIndex0 == 0)
					{
						if (sqalfg == 1)	
							// dissolved part
							psload = pPSData[ii].pData[nIndex0].pPollutant[j]*(1 - pPtQual[j].sqalfr);
						else if (sqalfg == 2)	
							// sediment associated part
							psload = pPSData[ii].pData[nIndex0].pPollutant[j]*pPtQual[j].sqalfr;
						else	
							// total load
							psload = pPSData[ii].pData[nIndex0].pPollutant[j];
						//apply reduction
						psload *= (1.0 - pPSReduction[ii].fReduction_qual[j]);
					}
					else
					{
						COleDateTimeSpan t1 = tCurrent -pPSData[ii].pData[nIndex0-1].tTime;    
						COleDateTimeSpan t2 = pPSData[ii].pData[nIndex0].tTime - tCurrent;
						double d1 = t1.GetTotalHours();
						double d2 = t2.GetTotalHours();
						if(d1 ==0 || d2 ==0 )
						{
							if(d1 == 0)
							{
								if (sqalfg == 1)	
									// dissolved part
									psload = pPSData[ii].pData[nIndex0-1].pPollutant[j]*(1 - pPtQual[j].sqalfr);
								else if (sqalfg == 2)	
									// sediment associated part
									psload = pPSData[ii].pData[nIndex0-1].pPollutant[j]*pPtQual[j].sqalfr;
								else	
									// total load
									psload = pPSData[ii].pData[nIndex0-1].pPollutant[j];
								//apply reduction
								psload *= (1.0 - pPSReduction[ii].fReduction_qual[j]);
							}
							else
							{
								if (sqalfg == 1)	
									// dissolved part
									psload = pPSData[ii].pData[nIndex0].pPollutant[j]*(1 - pPtQual[j].sqalfr);
								else if (sqalfg == 2)	
									// sediment associated part
									psload = pPSData[ii].pData[nIndex0].pPollutant[j]*pPtQual[j].sqalfr;
								else	
									// total load
									psload = pPSData[ii].pData[nIndex0].pPollutant[j];
								//apply reduction
								psload *= (1.0 - pPSReduction[ii].fReduction_qual[j]);
							}
						}
						else
						{
							if (sqalfg == 1)	
								// dissolved part
								psload = (d2*pPSData[ii].pData[nIndex0-1].pPollutant[j]+d1*pPSData[ii].pData[nIndex0].pPollutant[j]) / (d1+d2) * (1 - pPtQual[j].sqalfr);
							else if (sqalfg == 2)	
								// sediment associated part
								psload = (d2*pPSData[ii].pData[nIndex0-1].pPollutant[j]+d1*pPSData[ii].pData[nIndex0].pPollutant[j]) / (d1+d2) * pPtQual[j].sqalfr;
							else	
								// total load
								psload = (d2*pPSData[ii].pData[nIndex0-1].pPollutant[j]+d1*pPSData[ii].pData[nIndex0].pPollutant[j]) / (d1+d2);
							//apply reduction
							psload *= (1.0 - pPSReduction[ii].fReduction_qual[j]);
						}
					}

					load += psload;

					// for point source summary
					if (tCurrent >= toStart && tCurrent <= toEnd && nPSsummary > 0)
					{
						POSITION pos = pChannelInfo[nIndex].cListPointSources.GetHeadPosition();
						while (pos != NULL)
						{
							PS_SUMMARY& pPS_SUMMARY = (PS_SUMMARY&) pChannelInfo[nIndex].cListPointSources.GetNext(pos);
							if(pPS_SUMMARY.strPermit.CompareNoCase(pPSReduction[i].strPermitName) == 0 && pPS_SUMMARY.strPipe.CompareNoCase(pPSReduction[i].strPipeName) == 0)
							{
								if (nQualid == PS_SAND)
									pPS_SUMMARY.psQual[Index_SAND] += psload*delt60;//lb/ivl
								else if (nQualid == PS_SILT)
									pPS_SUMMARY.psQual[Index_SILT] += psload*delt60;
								else if (nQualid == PS_CLAY)
									pPS_SUMMARY.psQual[Index_CLAY] += psload*delt60;
								else if (nQualid == PS_DOX)
									pPS_SUMMARY.psQual[Index_DOX] += psload*delt60;
								else if (nQualid == PS_BOD)
									pPS_SUMMARY.psQual[Index_BOD] += psload*delt60;
								else if (nQualid == PS_NOX)
									pPS_SUMMARY.psQual[Index_NOX] += psload*delt60;
								else if (nQualid == PS_TAM)
									pPS_SUMMARY.psQual[Index_TAM] += psload*delt60;
								else if (nQualid == PS_PO4)
									pPS_SUMMARY.psQual[Index_PO4] += psload*delt60;
								else if (nQualid == PS_ORN)
									pPS_SUMMARY.psQual[Index_ORN] += psload*delt60;
								else if (nQualid == PS_ORP)
									pPS_SUMMARY.psQual[Index_ORP] += psload*delt60;
								else if (nQualid == PS_ORC)
									pPS_SUMMARY.psQual[Index_ORC] += psload*delt60;
								else if (nQualid == PS_CLA)
									pPS_SUMMARY.psQual[Index_CLA] += psload*delt60;
								else
								{
									for(int k=0; k<nQuals; k++)
									{
										if (nQualid == pQual[k].qualid)
										{

											pPS_SUMMARY.pGQual[k] += psload*delt60;//lb/ivl
											break;
										}
									}
								}
								break;
							}
						}
					}
				}
			}
		}
	}
	return load;
}

double CLSPCMODEL::GetLoad2(int sqalfg,int nIndex,int nQualid,COleDateTime tCurrent)
{
	if(pPSReduction == NULL)
		return UNKNOWN;

	int j = -1;
	int Num = nPtQuals;

	// get the index for point source qual
	for (int i=0; i<Num; i++)
	{
		if (pPtQual[i].qualid == nQualid)
		{
			j = i;
			break;
		}
	}

	// return UNKNOWN if qual does not exist in point sources
	if (j == -1)
		return UNKNOWN;

	double load = 0.0;

	for(i=0; i<nPtSource; ++i)
	{
		if(pChannelInfo[nIndex].rchid == pPSReduction[i].rchid)
		{
			if(pPSReduction[i].nPSindex > 0)
			{
				int ii = pPSReduction[i].nPSindex - 1;
				int nIndex0 = FindPSIndex(ii,tCurrent);
				if(nIndex0 != -1)
				{
					double psload = 0.0;
					if(nIndex0 == 0)
					{
						if (sqalfg == 1)	
							// dissolved part
							psload = pPSData[ii].pData[nIndex0].pPollutant[j]*(1 - pPtQual[j].sqalfr);
						else if (sqalfg == 2)	
							// sediment associated part
							psload = pPSData[ii].pData[nIndex0].pPollutant[j]*pPtQual[j].sqalfr;
						else	
							// total load
							psload = pPSData[ii].pData[nIndex0].pPollutant[j];
						//apply reduction
						psload *= (1.0 - pPSReduction[ii].fReduction_qual[j]);
					}
					else
					{
						COleDateTimeSpan t1 = tCurrent -pPSData[ii].pData[nIndex0-1].tTime;    
						COleDateTimeSpan t2 = pPSData[ii].pData[nIndex0].tTime - tCurrent;
						double d1 = t1.GetTotalHours();
						double d2 = t2.GetTotalHours();
						if(d1 ==0 || d2 ==0 )
						{
							if(d1 == 0)
							{
								if (sqalfg == 1)	
									// dissolved part
									psload = pPSData[ii].pData[nIndex0-1].pPollutant[j]*(1 - pPtQual[j].sqalfr);
								else if (sqalfg == 2)	
									// sediment associated part
									psload = pPSData[ii].pData[nIndex0-1].pPollutant[j]*pPtQual[j].sqalfr;
								else	
									// total load
									psload = pPSData[ii].pData[nIndex0-1].pPollutant[j];
								//apply reduction
								psload *= (1.0 - pPSReduction[ii].fReduction_qual[j]);
							}
							else
							{
								if (sqalfg == 1)	
									// dissolved part
									psload = pPSData[ii].pData[nIndex0].pPollutant[j]*(1 - pPtQual[j].sqalfr);
								else if (sqalfg == 2)	
									// sediment associated part
									psload = pPSData[ii].pData[nIndex0].pPollutant[j]*pPtQual[j].sqalfr;
								else	
									// total load
									psload = pPSData[ii].pData[nIndex0].pPollutant[j];
								//apply reduction
								psload *= (1.0 - pPSReduction[ii].fReduction_qual[j]);
							}
						}
						else
						{
							if (sqalfg == 1)	
								// dissolved part
								psload = (d2*pPSData[ii].pData[nIndex0-1].pPollutant[j]+d1*pPSData[ii].pData[nIndex0].pPollutant[j]) / (d1+d2) * (1 - pPtQual[j].sqalfr);
							else if (sqalfg == 2)	
								// sediment associated part
								psload = (d2*pPSData[ii].pData[nIndex0-1].pPollutant[j]+d1*pPSData[ii].pData[nIndex0].pPollutant[j]) / (d1+d2) * pPtQual[j].sqalfr;
							else	
								// total load
								psload = (d2*pPSData[ii].pData[nIndex0-1].pPollutant[j]+d1*pPSData[ii].pData[nIndex0].pPollutant[j]) / (d1+d2);
							//apply reduction
							psload *= (1.0 - pPSReduction[ii].fReduction_qual[j]);
						}
					}
						
					load += psload;

					// for point source summary
					if (tCurrent >= toStart && tCurrent <= toEnd && nPSsummary > 0)
					{
						POSITION pos = pChannelInfo[nIndex].cListPointSources.GetHeadPosition();
						while (pos != NULL)
						{
							PS_SUMMARY& pPS_SUMMARY = (PS_SUMMARY&) pChannelInfo[nIndex].cListPointSources.GetNext(pos);
							if(pPS_SUMMARY.strPermit.CompareNoCase(pPSReduction[i].strPermitName) == 0 && pPS_SUMMARY.strPipe.CompareNoCase(pPSReduction[i].strPipeName) == 0)
							{
								pPS_SUMMARY.psQual[Index_TEMP] += psload*delt60;// degree C * ft3/ivl
								break;
							}
						}
					}
				}
			}
		}
	}
	return load;
}

int CLSPCMODEL::FindPSIndex(int ii, COleDateTime tCurrent)
{
	if(pPSData == NULL || pPSData[ii].pData == NULL)
		return -1;

	for(int i = 0 ; i < pPSData[ii].nRecord; ++i)
	{
		if(tCurrent <= pPSData[ii].pData[i].tTime)
			return i;
	}
	return -1;
}

bool CLSPCMODEL::GetDBInfo()
{
	CMainFrame *pWnd = (CMainFrame *)AfxGetMainWnd();
	int *gpid = NULL;
	int *gpidx = NULL;
	int *tgpid = NULL;
	int *tgpidx = NULL;
	int nIndex = 0;
	Log("Read model inputs from database");
	CDatabase db;
	BOOL bCanOpen = FALSE;
	CString strErrorMsg;
	CString strTemp;
	CString strCard = "";
	CString strStr;
	CString strSQL;
	CString *strArray = NULL;
	infomsg = "These outlets flow out of the selected project area:\n";
	try
	{
		strSQL = CLSPCApp::GetMDBDriver();
		if(strSQL.IsEmpty())
		{
			AfxMessageBox("Cannot find the Microsoft Access ODBC driver.");
			Log("Cannot find the Microsoft Access ODBC driver.");
			return false;
		}
		bCanOpen = db.OpenEx(strSQL,CDatabase::noOdbcDialog);
	}
	catch(CException e)
	{
		AfxMessageBox("ODBC Error ---Cannot open database for reading.");
		Log("ODBC Error ---Cannot open database for reading.");
		return false;
	}
	if(!bCanOpen)
	{
		AfxMessageBox("ODBC Error ---Cannot open database for reading.");
		Log("ODBC Error ---Cannot open database for reading.");
		return false;
	}
	TRY
	{
		CRecordsetEx rs(&db);
		// card 0
		TRACE("Reading card 0\n");
		Log("Reading card 0\n");
		CString strSQL;
		BOOL bRet;
		strCard = "table0";
		strSQL = "SELECT * FROM table0";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			// skip first value
			rs.GetFieldValue((short)1, strTemp);
			snowfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)2, strTemp);
			pwatfg = (atoi(LPCSTR(strTemp)) == 0)?1:1;	// required (always on)
			rs.GetFieldValue((short)3, strTemp);
			sedfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)4, strTemp);
			pqalfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)5, strTemp);
			tempfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)6, strTemp);
			oxfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)7, strTemp);
			nutfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)8, strTemp);
			plkfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)9, strTemp);
			phfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;

			if(phfg == 1)
			{
				tempfg = 1;
				pqalfg = 1;
				oxfg = 1;
				nutfg = 1;
				plkfg = 1;
			}
			else if(plkfg == 1)
			{
				tempfg = 1;
				pqalfg = 1;
				oxfg = 1;
				nutfg = 1;
			}
			else if(nutfg == 1)
			{
				tempfg = 1;
				pqalfg = 1;
				oxfg = 1;
			}
			else if(oxfg == 1)
			{
				pqalfg = 1;
				tempfg = 1;
			}
			else if(snowfg == 1)
			{
				tempfg = 1;
			}
		}
		rs.Close();
		
		// card 10
		TRACE("Reading card 10\n");
		Log("Reading card 10\n");
		strCard = "table10";
		if(cWD.pWFILEINFO != NULL)
			delete []cWD.pWFILEINFO;

		strSQL = "select count(*) from table10";
		strCard = "table10";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			rs.GetFieldValue((short)0, strTemp);
			cWD.nNumWeatherFiles = atoi(LPCSTR(strTemp));
		}
		rs.Close();

		if(cWD.nNumWeatherFiles > 0)
		{
			cWD.pWFILEINFO = new WFILEINFO[cWD.nNumWeatherFiles];
			strSQL = "SELECT * FROM table10";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					cWD.pWFILEINFO[nRecord].nWFileID = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					cWD.pWFILEINFO[nRecord].strWFile = strTemp;
					rs.GetFieldValue((short)2, strTemp);
					cWD.pWFILEINFO[nRecord].nWParam = atoi(LPCSTR(strTemp));

					if (cWD.pWFILEINFO[nRecord].nWParam > 0)
						cWD.pWFILEINFO[nRecord].m_nParamID = new int[cWD.pWFILEINFO[nRecord].nWParam];
					for(int j=0; j<cWD.pWFILEINFO[nRecord].nWParam; j++)
					{
						rs.GetFieldValue((short)3+j, strTemp);
						cWD.pWFILEINFO[nRecord].m_nParamID[j] = atoi(LPCSTR(strTemp));
					}
					++nRecord;
					if(nRecord >= cWD.nNumWeatherFiles)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 15
		TRACE("Reading card 15\n");
		Log("Reading card 15\n");
		strCard = "table15";
		if(cWD.pWSTATIONINFO != NULL)
			delete []cWD.pWSTATIONINFO;

		strSQL = "select count(*) from table15";
		strCard = "table15";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			rs.GetFieldValue((short)0, strTemp);
			cWD.nNumWeatherStations = atoi(LPCSTR(strTemp));
		}
		rs.Close();

		if(cWD.nNumWeatherStations > 0)
		{
			cWD.pWSTATIONINFO = new WSTATIONINFO[cWD.nNumWeatherStations];
			strSQL = "SELECT * FROM table15";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					cWD.pWSTATIONINFO[nRecord].nWStationID = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					cWD.pWSTATIONINFO[nRecord].nWFile = atoi(LPCSTR(strTemp));

					cWD.nNumWeatherParam = 0;

					if (cWD.pWSTATIONINFO[nRecord].nWFile > 0)
						cWD.pWSTATIONINFO[nRecord].m_nWFileIndex = new int[cWD.pWSTATIONINFO[nRecord].nWFile];
					for(int j=0; j<cWD.pWSTATIONINFO[nRecord].nWFile; j++)
					{
						rs.GetFieldValue((short)2+j, strTemp);
						int nID = atoi(LPCSTR(strTemp));
						int nIndex = cWD.FindFileIndex(nID);
						cWD.pWSTATIONINFO[nRecord].m_nWFileIndex[j] = nIndex;
						cWD.nNumWeatherParam += cWD.pWFILEINFO[nIndex].nWParam;
					}

					//check the number of weather parameters for this weather station
					if (cWD.nNumWeatherParam < 2)
					{
						CString strError;
						strError.Format("Weather Station %d: Precipitation and ET data is required to run the model",cWD.pWSTATIONINFO[nRecord].nWStationID);
						AfxMessageBox(strError);
						TRACE(strError);
						Log(strError);
						return false;
					}

					if ((snowfg == 1 || tempfg == 1) && cWD.nNumWeatherParam < 6)
					{
						CString strError;
						strError.Format("Weather Station %d: Missing weather parameter(s) to simulate snow/temperature",cWD.pWSTATIONINFO[nRecord].nWStationID);
						AfxMessageBox(strError);
						TRACE(strError);
						Log(strError);
						return false;
					}
					++nRecord;
					if(nRecord >= cWD.nNumWeatherStations)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 20
		TRACE("Reading card 20\n");
		Log("Reading card 20\n");
		strCard = "table20";
		if(cWD.pWSTATIONINFO == NULL)
		{
			TRACE("Wrong reading %s",strCard);
			Log("Wrong reading %s",strCard);
			return false;
		}

		if(cWD.nNumWeatherStations > 0)
		{
			strSQL = "SELECT * FROM table20";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{

					rs.GetFieldValue((short)0, strTemp);
					int nID = atoi(LPCSTR(strTemp));
					//find the station index
					int nIndex = cWD.FindStationIndex(nID);

					//allocate memory
					if (cWD.pWSTATIONINFO[nIndex].m_lfMultiplier != NULL)
						delete[]cWD.pWSTATIONINFO[nIndex].m_lfMultiplier;

					if(cWD.nNumWeatherParam > 0)
						cWD.pWSTATIONINFO[nIndex].m_lfMultiplier = new double[cWD.nNumWeatherParam];

					for (int j=0; j<cWD.nNumWeatherParam; j++)
					{
						rs.GetFieldValue((short)1+j, strTemp);
						cWD.pWSTATIONINFO[nIndex].m_lfMultiplier[j] = atof(LPCSTR(strTemp));
					}
					++nRecord;
					if(nRecord >= cWD.nNumWeatherStations)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}
		// card 30
		TRACE("Reading card 30\n");
		Log("Reading card 30\n");
		strCard = "table30";
		strSQL = "SELECT * FROM table30";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			rs.GetFieldValue((short)0, strTemp);
			m_strModelResultLocation = strTemp;
			rs.GetFieldValue((short)1, strTemp);
			cWD.strWeatherFolderPath = strTemp;

			//check if weather data directory path is correct
			if (!FolderExists(cWD.strWeatherFolderPath))
			{
				//open dialog box to select the folder
				CDirDialog dlg;
				dlg.m_strSelDir = cWD.strWeatherFolderPath;
				dlg.m_strTitle = "Weather Station Data Directory:";
				if(dlg.DoBrowse() == 1)
					cWD.strWeatherFolderPath = dlg.m_strPath;
			}

			if(m_strModelResultLocation.GetAt(m_strModelResultLocation.GetLength()-1) != '\\'
				&& m_strModelResultLocation.GetAt(m_strModelResultLocation.GetLength()-1) != '/')
				m_strModelResultLocation += "\\";
			if(cWD.strWeatherFolderPath.GetAt(cWD.strWeatherFolderPath.GetLength()-1) != '\\'
				&& cWD.strWeatherFolderPath.GetAt(cWD.strWeatherFolderPath.GetLength()-1) != '/')
				cWD.strWeatherFolderPath += "\\";
		}
		rs.Close();

		// card 40
		TRACE("Reading card 40\n");
		Log("Reading card 40\n");
		strCard = "table40";
		strSQL = "SELECT * FROM table40";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			rs.GetFieldValue((short)0, strTemp);
			nsws = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)1, strTemp);
			nch = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)2, strTemp);
			nrgroup = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)3, strTemp);
			ngroup = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)4, strTemp);
			nlandp = atoi(LPCSTR(strTemp));
		}
		rs.Close();

		// card 45
		TRACE("Reading card 45\n");
		Log("Reading card 45\n");
		strCard = "table45";
		strSQL = "SELECT * FROM table45";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			// skip first record 
			rs.GetFieldValue((short)1, strTemp);
			nDefault = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)2, strTemp);
			nSnow = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)3, strTemp);
			nHydro = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)4, strTemp);
			nSed = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)5, strTemp);
			nGQUAL = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)6, strTemp);
			nRQUAL = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)7, strTemp);
			nCustom = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)8, strTemp);
			nLUsummary = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)9, strTemp);
			nCHsummary = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)10, strTemp);
			nPSsummary = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)11, strTemp);
			nThreshold = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)12, strTemp);
			nSUSTAIN = (atoi(LPCSTR(strTemp)) == 0)?0:1;

			if (nLUsummary > 0)
			{
				if (nLUsummary > 3) nLUsummary = 1;
				summarylevel = nLUsummary - 1;
			}
			if (nCHsummary > 0)
			{
				if (nLUsummary > 0) 
					nCHsummary = nLUsummary;
				else if (nCHsummary > 3) 
					nCHsummary = 1;
				summarylevel = nCHsummary - 1;
			}
			if (nPSsummary > 0)
			{
				if (nLUsummary > 0) 
					nPSsummary = nLUsummary;
				else if (nCHsummary > 0) 
					nPSsummary = nCHsummary;
				else if (nPSsummary > 3) 
					nPSsummary = 1;
				summarylevel = nPSsummary - 1;
			}

			if (nDefault == 1)
			{
				nSnow = 0;
				nHydro = 0;
				nSed = 0;
				nGQUAL = 0;
				nRQUAL = 0;
				nCustom = 0;
			}
			else if (nSnow == 1 || nHydro == 1 || nSed == 1 || nGQUAL == 1 || nRQUAL == 1)
			{
				nDefault = 0;
				nCustom = 0;
			}
			else if (nCustom == 1)
			{
				nDefault = 0;
				nSnow = 0;
				nHydro = 0;
				nSed = 0;
				nGQUAL = 0;
				nRQUAL = 0;
			}
		}
		rs.Close();

		// card 46
		TRACE("Reading card 46\n");
		Log("Reading card 46\n");

		if(nCustom == 1)
		{
			strCard = "table46";
			strSQL = "SELECT * FROM table46";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nTemp = 0;
				for(int i=0; i<PARA_NUM; ++i)
				{
					// skip first record 
					rs.GetFieldValue((short)i+1, strTemp);
					nTemp = atoi(LPCSTR(strTemp));
					cOP.blistOutput[i] = (nTemp == 1)?true:false;
				}
			}
			rs.Close();
		}

		// card 50
		TRACE("Reading card 50\n");
		Log("Reading card 50\n");
		strCard = "table50";
		strSQL = "SELECT * FROM table50";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			int nYear,nMonth,nDay;
			rs.GetFieldValue((short)0, strTemp);
			sscanf(LPCSTR(strTemp),"%d-%d-%d ",&nYear,&nMonth,&nDay);
			tStart = COleDateTime(nYear,nMonth,nDay,0,0,0);
			rs.GetFieldValue((short)1, strTemp);
			sscanf(LPCSTR(strTemp),"%d-%d-%d ",&nYear,&nMonth,&nDay);
			tEnd = COleDateTime(nYear,nMonth,nDay,23,59,59);
			rs.GetFieldValue((short)2, strTemp);
			deltm = atoi(LPCSTR(strTemp));								
			rs.GetFieldValue((short)3, strTemp);
			sscanf(LPCSTR(strTemp),"%d-%d-%d ",&nYear,&nMonth,&nDay);
			toStart = COleDateTime(nYear,nMonth,nDay,0,0,0);
			rs.GetFieldValue((short)4, strTemp);
			sscanf(LPCSTR(strTemp),"%d-%d-%d ",&nYear,&nMonth,&nDay);
			toEnd = COleDateTime(nYear,nMonth,nDay,23,59,59);
			rs.GetFieldValue((short)5, strTemp);
			optlevel = atoi(LPCSTR(strTemp));								

			//only support daily or time step output
			if(optlevel > 2)	
				optlevel = 1;                                                 

			delts = deltm * 60.;	// sec	
			delt60 = deltm / 60.;	// hour
			deltd = deltm / 1440.;	// day	

		}
		rs.Close();

		// card 60
		if(pswsinfo != NULL)
			delete []pswsinfo;

		if(nsws > 0)
		{
			TRACE("Reading card 60\n");
			Log("Reading card 60\n");
			strCard = "table60";

			pswsinfo = new swsinfo[nsws];
			strSQL = "SELECT * FROM table60";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					pswsinfo[nRecord].subbasin = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pswsinfo[nRecord].gid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					pswsinfo[nRecord].nwst = atoi(LPCSTR(strTemp));
					if (pswsinfo[nRecord].nwst > 0)
					{
						if (pswsinfo[nRecord].wstindex != NULL)
							delete[]pswsinfo[nRecord].wstindex;
						pswsinfo[nRecord].wstindex = new int[pswsinfo[nRecord].nwst];
						if (pswsinfo[nRecord].wti != NULL)
							delete[]pswsinfo[nRecord].wti;
						pswsinfo[nRecord].wti = new double[pswsinfo[nRecord].nwst];
					}
					for(int i=0; i<pswsinfo[nRecord].nwst; i++)
					{
						rs.GetFieldValue((short)3+i*2, strTemp);
						int nID = atoi(LPCSTR(strTemp));
						//find the weather station index
						pswsinfo[nRecord].wstindex[i] = cWD.FindStationIndex(nID);
						rs.GetFieldValue((short)4+i*2, strTemp);
						pswsinfo[nRecord].wti[i] = atof(LPCSTR(strTemp));
					}
					++nRecord;
					if(nRecord >= nsws)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		if(ngroup > 0)
		{
			if (gpid != NULL)	delete []gpid;
			if (gpidx != NULL)	delete []gpidx;
			gpid = new int[ngroup];
			gpidx = new int[ngroup];
			strSQL = "SELECT Table60.DEFID FROM Table60 GROUP BY Table60.DEFID";
			strCard = "table60";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					gpid[nRecord] = atoi(LPCSTR(strTemp));
					gpidx[nRecord] = nRecord;
					++nRecord;
					if(nRecord >= ngroup)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
			for(int l=0; l<nsws; l++)
			{
				for(int k=0; k<ngroup; k++)
				{
					if(pswsinfo[l].gid == gpid[k])
					{
						pswsinfo[l].gindex = gpidx[k];
						break;
					}
				}
			}
			if (gpid != NULL)	
			{
				delete []gpid;
				gpid = NULL;
			}
			if (gpidx != NULL)
			{
				delete []gpidx;
				gpidx = NULL;
			}
		}
		
		// card 70
		TRACE("Reading card 70\n");
		Log("Reading card 70\n");
		strCard = "table70";
		if(ppluinfo != NULL)
			delete []ppluinfo;
		if(nlandp > 0)
		{
			ppluinfo = new LandUsePInfo[nlandp];
			strSQL = "SELECT * FROM table70";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					ppluinfo[nRecord].luidp = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					ppluinfo[nRecord].plusname = strTemp;
					rs.GetFieldValue((short)2, strTemp);
					ppluinfo[nRecord].luPREmult = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					ppluinfo[nRecord].luPETmult = atof(LPCSTR(strTemp));
					++nRecord;
					if(nRecord >= nlandp)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}
		
		// card 80
		TRACE("Reading card 80\n");
		Log("Reading card 80\n");
		strCard = "table80";
		if(pLURoute != NULL)
			delete []pLURoute;

		int nNum = ngroup*nlandp;
		if(nNum > 0)
		{
			pLURoute = new LURoute[nNum];
			strSQL = "SELECT * FROM table80";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					pLURoute[nRecord].gid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pLURoute[nRecord].luid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					pLURoute[nRecord].input_suro = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					pLURoute[nRecord].input_ifwo = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					pLURoute[nRecord].input_agwo = atof(LPCSTR(strTemp));

					//validate the route_suro
					if (pLURoute[nRecord].input_suro >= 1)
					{
						pLURoute[nRecord].route_suro = 1;
						pLURoute[nRecord].bypass_suro = 0;
					}
					else if (pLURoute[nRecord].input_suro <= -1)
					{
						pLURoute[nRecord].route_suro = 0;
						pLURoute[nRecord].bypass_suro = 0;
					}
					else if(pLURoute[nRecord].input_suro >= 0)
					{
						pLURoute[nRecord].route_suro = pLURoute[nRecord].input_suro;
						pLURoute[nRecord].bypass_suro = 1-pLURoute[nRecord].route_suro;
					}
					else // it is negative (by pass water is lost from the system)
					{
						pLURoute[nRecord].route_suro = 1+pLURoute[nRecord].input_suro;
						pLURoute[nRecord].bypass_suro = 0;
					}

					//validate the route_ifwo
					if (pLURoute[nRecord].input_ifwo >= 1)
					{
						pLURoute[nRecord].route_ifwo = 1;
						pLURoute[nRecord].bypass_ifwo = 0;
					}
					else if (pLURoute[nRecord].input_ifwo <= -1)
					{
						pLURoute[nRecord].route_ifwo = 0;
						pLURoute[nRecord].bypass_ifwo = 0;
					}
					else if(pLURoute[nRecord].input_ifwo >= 0)
					{
						pLURoute[nRecord].route_ifwo = pLURoute[nRecord].input_ifwo;
						pLURoute[nRecord].bypass_ifwo = 1-pLURoute[nRecord].route_ifwo;
					}
					else // it is negative (by pass water is lost from the system)
					{
						pLURoute[nRecord].route_ifwo = 1+pLURoute[nRecord].input_ifwo;
						pLURoute[nRecord].bypass_ifwo = 0;
					}

					//validate the route_agwo
					if (pLURoute[nRecord].input_agwo >= 1)
					{
						pLURoute[nRecord].route_agwo = 1;
						pLURoute[nRecord].bypass_agwo = 0;
					}
					else if (pLURoute[nRecord].input_agwo <= -1)
					{
						pLURoute[nRecord].route_agwo = 0;
						pLURoute[nRecord].bypass_agwo = 0;
					}
					else if(pLURoute[nRecord].input_agwo >= 0)
					{
						pLURoute[nRecord].route_agwo = pLURoute[nRecord].input_agwo;
						pLURoute[nRecord].bypass_agwo = 1-pLURoute[nRecord].route_agwo;
					}
					else // it is negative (by pass water is lost from the system)
					{
						pLURoute[nRecord].route_agwo = 1+pLURoute[nRecord].input_agwo;
						pLURoute[nRecord].bypass_agwo = 0;
					}

					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 90
		TRACE("Reading card 90\n");
		Log("Reading card 90\n");
		strCard = "table90";
		if(pluinfop != NULL)
			delete []pluinfop;

		nNum = nlandp*nsws;
		if(nNum > 0)
		{
			pluinfop = new LUInfo[nNum];
			strSQL = "SELECT * FROM table90";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				nIndex = -1;
				nlandimp = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					pluinfop[nRecord].subbasin = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pluinfop[nRecord].luid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					pluinfop[nRecord].luname = strTemp;
					rs.GetFieldValue((short)3, strTemp);
					pluinfop[nRecord].piid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					pluinfop[nRecord].area = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)5, strTemp);
					pluinfop[nRecord].slsur = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)6, strTemp);
					pluinfop[nRecord].lsur = atof(LPCSTR(strTemp));

					//flag no landuse change as default
					pluinfop[nRecord].bLUchange = false;
					pluinfop[nRecord].sindex = -1;
					pluinfop[nRecord].records = 0;
					pluinfop[nRecord].m_fileOut = NULL;

					//count the number of impervious land uses
					if (nIndex == -1)
						nIndex = pluinfop[nRecord].subbasin;
					if (pluinfop[nRecord].piid == 1 && pluinfop[nRecord].subbasin == nIndex)
						nlandimp++;

					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 32
		TRACE("Reading Landuse_TS\n");
		Log("Reading Landuse_TS\n");
		strSQL = "SELECT * FROM Landuse_TS";
		strCard = "Landuse_TS";
		TRY
		{
			bRet = rs.ExecDirect(strSQL);
			rs.GetFieldValue((short)0, strTemp);
			cLU.nLUchangeFlag = 1;
			//get the database file path
			CLSPCApp *pApp = (CLSPCApp *) AfxGetApp();
			cLU.strLUchangeFilePath = pApp->strDBFilePath+pApp->strDBFileName;;
		}
		CATCH(CException, e)
		{
			cLU.nLUchangeFlag = 0;
			cLU.strLUchangeFilePath = "";
		}
		END_CATCH;

		rs.Close();

		//the snow related information
		//card 92
		TRACE("Reading card 92\n");
		Log("Reading card 92\n");
		strCard = "table92";
		if(pSnowCtl2 != NULL)
			delete []pSnowCtl2;
		if(snowfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				pSnowCtl2 = new CSnowControl2[nNum];
				
				strSQL = "SELECT * FROM table92";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pSnowCtl2[nRecord].nGrpid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pSnowCtl2[nRecord].luid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pSnowCtl2[nRecord].ICEFLAG = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pSnowCtl2[nRecord].lfForest = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pSnowCtl2[nRecord].fzg = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pSnowCtl2[nRecord].fzgl = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		 
		//card 93
		TRACE("Reading card 93\n");
		Log("Reading card 93\n");
		strCard = "table93";
		if(pSnowParam1 != NULL)
			delete []pSnowParam1;
		if(snowfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				pSnowParam1 = new CSnowParam1[nNum];
				strSQL = "SELECT * FROM table93";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pSnowParam1[nRecord].nGrpid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pSnowParam1[nRecord].luid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pSnowParam1[nRecord].LAT = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pSnowParam1[nRecord].MELEV = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pSnowParam1[nRecord].SHADE = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pSnowParam1[nRecord].SNOWCF = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pSnowParam1[nRecord].COVIND = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		//card 94
		TRACE("Reading card 94\n");
		Log("Reading card 94\n");
		strCard = "table94";
		if(pSnowParam2 != NULL)
			delete []pSnowParam2;
		if(snowfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				pSnowParam2 = new CSnowParam2[nNum];
				strSQL = "SELECT * FROM table94";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pSnowParam2[nRecord].nGrpid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pSnowParam2[nRecord].luid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pSnowParam2[nRecord].RDCSN = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pSnowParam2[nRecord].TSNOW = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pSnowParam2[nRecord].SNOEVP = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pSnowParam2[nRecord].CCFACT = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pSnowParam2[nRecord].MWATER = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pSnowParam2[nRecord].MGMELT = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		//card 96
		TRACE("Reading card 96\n");
		Log("Reading card 96\n");
		strCard = "table96";
		if(pSnowInit1 != NULL)
			delete []pSnowInit1;
		if(snowfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				pSnowInit1 = new CSnowInit1[nNum];
				
				strSQL = "SELECT * FROM table96";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pSnowInit1[nRecord].nGrpid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pSnowInit1[nRecord].luid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pSnowInit1[nRecord].packsnow = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pSnowInit1[nRecord].packice = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pSnowInit1[nRecord].packwatr = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pSnowInit1[nRecord].RDENPF = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pSnowInit1[nRecord].DULL = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pSnowInit1[nRecord].PAKTMP = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pSnowInit1[nRecord].COVINX = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pSnowInit1[nRecord].XLNMLT = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pSnowInit1[nRecord].SKYCLR = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 100
		TRACE("Reading card 100\n");
		Log("Reading card 100\n");
		strCard = "table100";
		strSQL = "SELECT * FROM table100";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			// skip first value
			rs.GetFieldValue((short)1, strTemp);
			vcsfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)2, strTemp);
			vuzfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)3, strTemp);
			vnnfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)4, strTemp);
			vifwfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)5, strTemp);
			vircfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)6, strTemp);
			vlefg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
		}
		rs.Close();

		// card 110
		TRACE("Reading card 110\n");
		Log("Reading card 110\n");
		strCard = "table110";
		if(ppw_param2!=NULL)
			delete []ppw_param2;
		nNum = nlandp*ngroup;
		if(nNum > 0)
		{
			ppw_param2 = new PW_PARA2[nNum];
			strSQL = "SELECT * FROM table110";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					ppw_param2[nRecord].gid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					ppw_param2[nRecord].lid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					ppw_param2[nRecord].lzsn_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					ppw_param2[nRecord].infilt_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					ppw_param2[nRecord].kvary_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)5, strTemp);
					ppw_param2[nRecord].agwr_p = atof(LPCSTR(strTemp));
					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}
		
		// card 120
		TRACE("Reading card 120\n");
		Log("Reading card 120\n");
		strCard = "table120";
		if(ppw_param3!=NULL)
			delete []ppw_param3;
		nNum = nlandp*ngroup;
		if(nNum > 0)
		{
			ppw_param3 = new PW_PARA3[nNum];
			strSQL = "SELECT * FROM table120";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					ppw_param3[nRecord].gid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					ppw_param3[nRecord].lid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					ppw_param3[nRecord].petmax_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					ppw_param3[nRecord].petmin_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					ppw_param3[nRecord].infexp_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)5, strTemp);
					ppw_param3[nRecord].infild_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)6, strTemp);
					ppw_param3[nRecord].deepfr_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)7, strTemp);
					ppw_param3[nRecord].basetp_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)8, strTemp);
					ppw_param3[nRecord].agwetp_p = atof(LPCSTR(strTemp));
					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 130
		TRACE("Reading card 130\n");
		Log("Reading card 130\n");
		strCard = "table130";
		if(ppw_param4!=NULL)
			delete []ppw_param4;
		nNum = nlandp*ngroup;
		if(nNum > 0)
		{
			ppw_param4 = new PW_PARA4[nNum];
			strSQL = "SELECT * FROM table130";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					ppw_param4[nRecord].gid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					ppw_param4[nRecord].lid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					ppw_param4[nRecord].cepsc_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					ppw_param4[nRecord].uzsn_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					ppw_param4[nRecord].nsur_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)5, strTemp);
					ppw_param4[nRecord].intfw_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)6, strTemp);
					ppw_param4[nRecord].irc_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)7, strTemp);
					ppw_param4[nRecord].lzetp_p = atof(LPCSTR(strTemp));
					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 140
		TRACE("Reading card 140\n");
		Log("Reading card 140\n");
		strCard = "table140";
		if(ppw_state!=NULL)
			delete []ppw_state;
		nNum = nlandp*ngroup;
		if(nNum > 0)
		{
			ppw_state = new PW_STATE[nNum];
			strSQL = "SELECT * FROM table140";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					ppw_state[nRecord].gid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					ppw_state[nRecord].lid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					ppw_state[nRecord].ceps_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					ppw_state[nRecord].surs_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					ppw_state[nRecord].uzs_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)5, strTemp);
					ppw_state[nRecord].ifws_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)6, strTemp);
					ppw_state[nRecord].lzs_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)7, strTemp);
					ppw_state[nRecord].agws_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)8, strTemp);
					ppw_state[nRecord].gwvs_p = atof(LPCSTR(strTemp));
					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 150
		if(cepscm_p!=NULL)
			delete []cepscm_p;

		if(vcsfg==1)
		{
			TRACE("Reading card 150\n");
			Log("Reading card 150\n");
			strCard = "table150";

			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				cepscm_p = new MON_DATE[nNum];
				strSQL = "SELECT * FROM table150";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						cepscm_p[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						cepscm_p[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						cepscm_p[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						cepscm_p[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						cepscm_p[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						cepscm_p[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						cepscm_p[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						cepscm_p[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						cepscm_p[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						cepscm_p[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						cepscm_p[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						cepscm_p[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						cepscm_p[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						cepscm_p[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 160
		TRACE("Reading card 160\n");
		Log("Reading card 160\n");
		strCard = "table160";
		if(uzsnm_p!=NULL)
			delete []uzsnm_p;
		if(vuzfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				uzsnm_p = new MON_DATE[nNum];
				strSQL = "SELECT * FROM table160";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						uzsnm_p[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						uzsnm_p[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						uzsnm_p[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						uzsnm_p[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						uzsnm_p[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						uzsnm_p[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						uzsnm_p[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						uzsnm_p[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						uzsnm_p[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						uzsnm_p[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						uzsnm_p[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						uzsnm_p[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						uzsnm_p[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						uzsnm_p[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 170
		if(nsurm_p!=NULL)
			delete []nsurm_p;
		
		if(vnnfg==1)
		{
			TRACE("Reading card 170\n");
			Log("Reading card 170\n");
			strCard = "table170";

			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				nsurm_p = new MON_DATE[nNum];
				strSQL = "SELECT * FROM table170";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						nsurm_p[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						nsurm_p[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						nsurm_p[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						nsurm_p[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						nsurm_p[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						nsurm_p[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						nsurm_p[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						nsurm_p[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						nsurm_p[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						nsurm_p[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						nsurm_p[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						nsurm_p[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						nsurm_p[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						nsurm_p[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 180
		TRACE("Reading card 180\n");
		Log("Reading card 180\n");
		strCard = "table180";
		if(intfwm_p!=NULL)
			delete []intfwm_p;
		if(vifwfg==1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				intfwm_p = new MON_DATE[nNum];
				strSQL = "SELECT * FROM table180";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						intfwm_p[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						intfwm_p[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						intfwm_p[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						intfwm_p[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						intfwm_p[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						intfwm_p[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						intfwm_p[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						intfwm_p[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						intfwm_p[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						intfwm_p[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						intfwm_p[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						intfwm_p[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						intfwm_p[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						intfwm_p[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 190
		TRACE("Reading card 190\n");
		Log("Reading card 190\n");
		strCard = "table190";
		if(ircm_p!=NULL)
			delete []ircm_p;
		if(vircfg==1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				ircm_p = new MON_DATE[nNum];
				strSQL = "SELECT * FROM table190";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						ircm_p[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						ircm_p[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						ircm_p[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						ircm_p[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						ircm_p[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						ircm_p[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						ircm_p[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						ircm_p[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						ircm_p[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						ircm_p[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						ircm_p[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						ircm_p[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						ircm_p[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						ircm_p[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 200
		TRACE("Reading card 200\n");
		Log("Reading card 200\n");
		strCard = "table200";
		if(lzetpm_p!=NULL)
			delete []lzetpm_p;
		if(vlefg==1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				lzetpm_p = new MON_DATE[nNum];
				strSQL = "SELECT * FROM table200";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						lzetpm_p[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						lzetpm_p[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						lzetpm_p[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						lzetpm_p[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						lzetpm_p[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						lzetpm_p[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						lzetpm_p[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						lzetpm_p[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						lzetpm_p[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						lzetpm_p[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						lzetpm_p[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						lzetpm_p[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						lzetpm_p[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						lzetpm_p[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		
		//Card 201
        TRACE("Reading card 201\n");
        Log("Reading card 201\n");
        strCard = "table201";	
		strSQL = "SELECT * FROM table201";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			//skip first field
			rs.GetFieldValue((short)1, strTemp);
			irrigfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)2, strTemp);
			petfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)3, strTemp);
			monVaryIrrig = (atoi(LPCSTR(strTemp)) == 0)?0:1;
		}
		rs.Close();

		//Card 202
        TRACE("Reading card 202\n");
        Log("Reading card 202\n");
        strCard = "table202";
		if(pirrigpet != NULL)
            delete []pirrigpet;
		if(irrigfg == 1 && petfg == 1)
		{
			nNum = ngroup;
			if(nNum > 0)
			{
				pirrigpet = new IrrigPET[nNum];
				strSQL = "SELECT * FROM table202";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pirrigpet[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pirrigpet[nRecord].petval = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		//Card 203
        TRACE("Reading card 203\n");
        Log("Reading card 203\n");
        strCard = "table203";
		if(pirriginfop != NULL)
            delete []pirriginfop;
		if(irrigfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				pirriginfop = new IrrigInfo[nNum];
				strSQL = "SELECT * FROM table203";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pirriginfop[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pirriginfop[nRecord].luid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pirriginfop[nRecord].startmonth = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pirriginfop[nRecord].endmonth = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pirriginfop[nRecord].fraction1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pirriginfop[nRecord].fraction2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pirriginfop[nRecord].fraction3 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pirriginfop[nRecord].fraction4 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pirriginfop[nRecord].fraction5 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pirriginfop[nRecord].etcoeff = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pirriginfop[nRecord].etdays = atoi(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		//Card 204
        TRACE("Reading card 204\n");
        Log("Reading card 204\n");
        strCard = "table204";
		if(pmonetcinfop != NULL)
            delete []pmonetcinfop;
		if(irrigfg == 1 && monVaryIrrig == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				pmonetcinfop = new MonETCInfo[nNum];
				strSQL = "SELECT * FROM table204";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pmonetcinfop[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pmonetcinfop[nRecord].luid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pmonetcinfop[nRecord].monETCs[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pmonetcinfop[nRecord].monETCs[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pmonetcinfop[nRecord].monETCs[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pmonetcinfop[nRecord].monETCs[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pmonetcinfop[nRecord].monETCs[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pmonetcinfop[nRecord].monETCs[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pmonetcinfop[nRecord].monETCs[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pmonetcinfop[nRecord].monETCs[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pmonetcinfop[nRecord].monETCs[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						pmonetcinfop[nRecord].monETCs[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						pmonetcinfop[nRecord].monETCs[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						pmonetcinfop[nRecord].monETCs[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		//Card 205
        TRACE("Reading card 205\n");
        Log("Reading card 205\n");
        strCard = "table205";
		if(pirrigwdinfo != NULL)
            delete []pirrigwdinfo;
		if(irrigfg == 1)
		{
			nNum = nsws;
			if(nNum > 0)
			{
				pirrigwdinfo = new IrrigWDInfo[nNum];
				strSQL = "SELECT * FROM table205";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pirrigwdinfo[nRecord].wsid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pirrigwdinfo[nRecord].streamid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pirrigwdinfo[nRecord].irrigdep = atof(LPCSTR(strTemp));
//						pirrigwdinfo[nRecord].extsrc = true;
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		
		// card 250
		if(pQual!=NULL)
			delete []pQual;
			
		if(pqalfg == 1)
		{
			TRACE("Reading card 250 \n");
			Log("Reading card 250 \n");
			strCard = "table250";

			// count the number of records (nQuals*ngroup)
			gqsdfg = 0;
			nQuals = 0;
			strSQL = "SELECT * FROM table250";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				while(!rs.IsEOF())
				{
					++nQuals;
					rs.MoveNext();
				}
			}
			rs.Close();

			// calculate the nQuals
			nQuals /= ngroup;   

			if(nQuals > 0)
			{
				pQual = new QUALS[nQuals*ngroup];
				strSQL = "SELECT * FROM table250";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pQual[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pQual[nRecord].qualid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pQual[nRecord].qname = strTemp;
						rs.GetFieldValue((short)3, strTemp);
						strTemp.MakeLower();
						pQual[nRecord].qunit = strTemp;
						rs.GetFieldValue((short)4, strTemp);
						pQual[nRecord].qsdfg = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pQual[nRecord].gqsdfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
						rs.GetFieldValue((short)6, strTemp);
						pQual[nRecord].qsofg = (atoi(LPCSTR(strTemp)) == 1)?1:2;
						rs.GetFieldValue((short)7, strTemp);
						pQual[nRecord].potfcfg = (atoi(LPCSTR(strTemp)) == 1)?1:2;
						if (pQual[nRecord].gqsdfg == 1) gqsdfg = 1;

						++nRecord;
						if(nRecord >= nQuals*ngroup)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
			
			// card 255
			TRACE("Reading card 255\n");
			Log("Reading card 255\n");

			strSQL = "SELECT * FROM table255";
			strCard = "table255";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				// skip first value
				rs.GetFieldValue((short)1, strTemp);
				vqofg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)2, strTemp);
				qsowfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)3, strTemp);
				vsqcfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)4, strTemp);
				qifwfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)5, strTemp);
				viqcfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)6, strTemp);
				qagwfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)7, strTemp);
				vaqcfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)8, strTemp);
				adfglnd = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)9, strTemp);
				maddfglnd = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)10, strTemp);
				mawdfglnd = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			}
			rs.Close();

			// card 260
			TRACE("Reading card 260\n");
			Log("Reading card 260\n");
			strCard = "table260";
			if(pQualInput!=NULL)
				delete []pQualInput;

			nNum = ngroup*nQuals*nlandp;
			if(nNum > 0)
			{
				pQualInput = new QUAL_INPUT[nNum];
				strSQL = "SELECT * FROM table260";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pQualInput[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pQualInput[nRecord].qualid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pQualInput[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pQualInput[nRecord].sqo = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pQualInput[nRecord].potfw = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pQualInput[nRecord].potfs = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pQualInput[nRecord].potfc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pQualInput[nRecord].acqop = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pQualInput[nRecord].sqolim = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pQualInput[nRecord].wsqop = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pQualInput[nRecord].soqc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						pQualInput[nRecord].ioqc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						pQualInput[nRecord].aoqc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						pQualInput[nRecord].addc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)14, strTemp);
						pQualInput[nRecord].awdc = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}

			// card 270
			TRACE("Reading card 270\n");
			Log("Reading card 270\n");
			strCard = "table270";
			if(pIMonAccum!=NULL)
				delete []pIMonAccum;
			if(vqofg == 1)
			{
				nNum = nlandp*ngroup*nQuals;
				if(nNum > 0)
				{
					pIMonAccum = new IMON_DATE[nNum];
					strSQL = "SELECT * FROM table270";
					bRet = rs.ExecDirect(strSQL);
					if(bRet)
					{
						int nRecord = 0;
						while(true)
						{
							rs.GetFieldValue((short)0, strTemp);
							pIMonAccum[nRecord].gid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)1, strTemp);
							pIMonAccum[nRecord].qualid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)2, strTemp);
							pIMonAccum[nRecord].lid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)3, strTemp);
							pIMonAccum[nRecord].fnum[0] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)4, strTemp);
							pIMonAccum[nRecord].fnum[1] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)5, strTemp);
							pIMonAccum[nRecord].fnum[2] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)6, strTemp);
							pIMonAccum[nRecord].fnum[3] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)7, strTemp);
							pIMonAccum[nRecord].fnum[4] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)8, strTemp);
							pIMonAccum[nRecord].fnum[5] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)9, strTemp);
							pIMonAccum[nRecord].fnum[6] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)10, strTemp);
							pIMonAccum[nRecord].fnum[7] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)11, strTemp);
							pIMonAccum[nRecord].fnum[8] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)12, strTemp);
							pIMonAccum[nRecord].fnum[9] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)13, strTemp);
							pIMonAccum[nRecord].fnum[10] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)14, strTemp);
							pIMonAccum[nRecord].fnum[11] = atof(LPCSTR(strTemp));
							++nRecord;
							if(nRecord >= nNum)
								break;
							rs.MoveNext();
						}
					}
					rs.Close();
				}
			}

			// card 271
			TRACE("Reading card 271\n");
			Log("Reading card 271\n");
			strCard = "table271";
			if(pIMonSQOLIM!=NULL)
				delete []pIMonSQOLIM;
			if(vqofg == 1)
			{
				nNum = nlandp*ngroup*nQuals;
				if(nNum > 0)
				{
					pIMonSQOLIM = new IMON_DATE[nNum];
					strSQL = "SELECT * FROM table271";
					bRet = rs.ExecDirect(strSQL);
					if(bRet)
					{
						int nRecord = 0;
						while(true)
						{
							rs.GetFieldValue((short)0, strTemp);
							pIMonSQOLIM[nRecord].gid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)1, strTemp);
							pIMonSQOLIM[nRecord].qualid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)2, strTemp);
							pIMonSQOLIM[nRecord].lid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)3, strTemp);
							pIMonSQOLIM[nRecord].fnum[0] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)4, strTemp);
							pIMonSQOLIM[nRecord].fnum[1] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)5, strTemp);
							pIMonSQOLIM[nRecord].fnum[2] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)6, strTemp);
							pIMonSQOLIM[nRecord].fnum[3] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)7, strTemp);
							pIMonSQOLIM[nRecord].fnum[4] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)8, strTemp);
							pIMonSQOLIM[nRecord].fnum[5] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)9, strTemp);
							pIMonSQOLIM[nRecord].fnum[6] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)10, strTemp);
							pIMonSQOLIM[nRecord].fnum[7] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)11, strTemp);
							pIMonSQOLIM[nRecord].fnum[8] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)12, strTemp);
							pIMonSQOLIM[nRecord].fnum[9] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)13, strTemp);
							pIMonSQOLIM[nRecord].fnum[10] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)14, strTemp);
							pIMonSQOLIM[nRecord].fnum[11] = atof(LPCSTR(strTemp));
							++nRecord;
							if(nRecord >= nNum)
								break;
							rs.MoveNext();
						}
					}
					rs.Close();
				}
			}

			// card 272
			TRACE("Reading card 272\n");
			Log("Reading card 272\n");
			if(pIMonSUROCONC!=NULL)
				delete []pIMonSUROCONC;
			if(vsqcfg == 1)
			{
				nNum = nlandp*ngroup*nQuals;
				if(nNum > 0)
				{
					pIMonSUROCONC = new IMON_DATE[nNum];
					strSQL = "SELECT * FROM table272";
					strCard = "table272";
					bRet = rs.ExecDirect(strSQL);
					if(bRet)
					{
						int nRecord = 0;
						while(true)
						{
							rs.GetFieldValue((short)0, strTemp);
							pIMonSUROCONC[nRecord].gid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)1, strTemp);
							pIMonSUROCONC[nRecord].qualid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)2, strTemp);
							pIMonSUROCONC[nRecord].lid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)3, strTemp);
							pIMonSUROCONC[nRecord].fnum[0] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)4, strTemp);
							pIMonSUROCONC[nRecord].fnum[1] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)5, strTemp);
							pIMonSUROCONC[nRecord].fnum[2] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)6, strTemp);
							pIMonSUROCONC[nRecord].fnum[3] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)7, strTemp);
							pIMonSUROCONC[nRecord].fnum[4] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)8, strTemp);
							pIMonSUROCONC[nRecord].fnum[5] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)9, strTemp);
							pIMonSUROCONC[nRecord].fnum[6] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)10, strTemp);
							pIMonSUROCONC[nRecord].fnum[7] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)11, strTemp);
							pIMonSUROCONC[nRecord].fnum[8] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)12, strTemp);
							pIMonSUROCONC[nRecord].fnum[9] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)13, strTemp);
							pIMonSUROCONC[nRecord].fnum[10] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)14, strTemp);
							pIMonSUROCONC[nRecord].fnum[11] = atof(LPCSTR(strTemp));
							++nRecord;
							if(nRecord >= nNum)
								break;
							rs.MoveNext();
						}
					}
					rs.Close();
				}
			}

			// card 273
			TRACE("Reading card 273\n");
			Log("Reading card 273\n");
			if(pIMonINTERCONC!=NULL)
				delete []pIMonINTERCONC;
			if(viqcfg == 1)
			{
				nNum = nlandp*ngroup*nQuals;
				if(nNum > 0)
				{
					pIMonINTERCONC = new IMON_DATE[nNum];
					strSQL = "SELECT * FROM table273";
					strCard = "table273";
					bRet = rs.ExecDirect(strSQL);
					if(bRet)
					{
						int nRecord = 0;
						while(true)
						{
							rs.GetFieldValue((short)0, strTemp);
							pIMonINTERCONC[nRecord].gid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)1, strTemp);
							pIMonINTERCONC[nRecord].qualid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)2, strTemp);
							pIMonINTERCONC[nRecord].lid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)3, strTemp);
							pIMonINTERCONC[nRecord].fnum[0] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)4, strTemp);
							pIMonINTERCONC[nRecord].fnum[1] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)5, strTemp);
							pIMonINTERCONC[nRecord].fnum[2] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)6, strTemp);
							pIMonINTERCONC[nRecord].fnum[3] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)7, strTemp);
							pIMonINTERCONC[nRecord].fnum[4] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)8, strTemp);
							pIMonINTERCONC[nRecord].fnum[5] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)9, strTemp);
							pIMonINTERCONC[nRecord].fnum[6] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)10, strTemp);
							pIMonINTERCONC[nRecord].fnum[7] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)11, strTemp);
							pIMonINTERCONC[nRecord].fnum[8] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)12, strTemp);
							pIMonINTERCONC[nRecord].fnum[9] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)13, strTemp);
							pIMonINTERCONC[nRecord].fnum[10] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)14, strTemp);
							pIMonINTERCONC[nRecord].fnum[11] = atof(LPCSTR(strTemp));
							++nRecord;
							if(nRecord >= nNum)
								break;
							rs.MoveNext();
						}
					}
					rs.Close();
				}
			}

			// card 274
			TRACE("Reading card 274\n");
			Log("Reading card 274\n");
			if(pIMonGRNDCONC!=NULL)
				delete []pIMonGRNDCONC;
			if(vaqcfg  == 1)
			{
				nNum = nlandp*ngroup*nQuals;
				if(nNum > 0)
				{
					pIMonGRNDCONC = new IMON_DATE[nNum];
					strSQL = "SELECT * FROM table274";
					strCard = "table274";
					bRet = rs.ExecDirect(strSQL);
					if(bRet)
					{
						int nRecord = 0;
						while(true)
						{
							rs.GetFieldValue((short)0, strTemp);
							pIMonGRNDCONC[nRecord].gid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)1, strTemp);
							pIMonGRNDCONC[nRecord].qualid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)2, strTemp);
							pIMonGRNDCONC[nRecord].lid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)3, strTemp);
							pIMonGRNDCONC[nRecord].fnum[0] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)4, strTemp);
							pIMonGRNDCONC[nRecord].fnum[1] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)5, strTemp);
							pIMonGRNDCONC[nRecord].fnum[2] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)6, strTemp);
							pIMonGRNDCONC[nRecord].fnum[3] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)7, strTemp);
							pIMonGRNDCONC[nRecord].fnum[4] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)8, strTemp);
							pIMonGRNDCONC[nRecord].fnum[5] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)9, strTemp);
							pIMonGRNDCONC[nRecord].fnum[6] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)10, strTemp);
							pIMonGRNDCONC[nRecord].fnum[7] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)11, strTemp);
							pIMonGRNDCONC[nRecord].fnum[8] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)12, strTemp);
							pIMonGRNDCONC[nRecord].fnum[9] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)13, strTemp);
							pIMonGRNDCONC[nRecord].fnum[10] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)14, strTemp);
							pIMonGRNDCONC[nRecord].fnum[11] = atof(LPCSTR(strTemp));
							++nRecord;
							if(nRecord >= nNum)
								break;
							rs.MoveNext();
						}
					}
					rs.Close();
				}
			}
			// card 275
			TRACE("Reading card 275\n");
			Log("Reading card 275\n");
			if(pIMonDRYDEP!=NULL)
				delete []pIMonDRYDEP;
			if(maddfglnd == 1)
			{
				nNum = nlandp*ngroup*nQuals;
				if(nNum > 0)
				{
					pIMonDRYDEP = new IMON_DATE[nNum];
					strSQL = "SELECT * FROM table275";
					strCard = "table275";
					bRet = rs.ExecDirect(strSQL);
					if(bRet)
					{
						int nRecord = 0;
						while(true)
						{
							rs.GetFieldValue((short)0, strTemp);
							pIMonDRYDEP[nRecord].gid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)1, strTemp);
							pIMonDRYDEP[nRecord].qualid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)2, strTemp);
							pIMonDRYDEP[nRecord].lid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)3, strTemp);
							pIMonDRYDEP[nRecord].fnum[0] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)4, strTemp);
							pIMonDRYDEP[nRecord].fnum[1] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)5, strTemp);
							pIMonDRYDEP[nRecord].fnum[2] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)6, strTemp);
							pIMonDRYDEP[nRecord].fnum[3] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)7, strTemp);
							pIMonDRYDEP[nRecord].fnum[4] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)8, strTemp);
							pIMonDRYDEP[nRecord].fnum[5] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)9, strTemp);
							pIMonDRYDEP[nRecord].fnum[6] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)10, strTemp);
							pIMonDRYDEP[nRecord].fnum[7] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)11, strTemp);
							pIMonDRYDEP[nRecord].fnum[8] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)12, strTemp);
							pIMonDRYDEP[nRecord].fnum[9] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)13, strTemp);
							pIMonDRYDEP[nRecord].fnum[10] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)14, strTemp);
							pIMonDRYDEP[nRecord].fnum[11] = atof(LPCSTR(strTemp));
							++nRecord;
							if(nRecord >= nNum)
								break;
							rs.MoveNext();
						}
					}
					rs.Close();
				}
			}
			// card 276
			TRACE("Reading card 276\n");
			Log("Reading card 276\n");
			if(pIMonWETDEP!=NULL)
				delete []pIMonWETDEP;
			if(mawdfglnd == 1)
			{
				nNum = nlandp*ngroup*nQuals;
				if(nNum > 0)
				{
					pIMonWETDEP = new IMON_DATE[nNum];
					strSQL = "SELECT * FROM table276";
					strCard = "table276";
					bRet = rs.ExecDirect(strSQL);
					if(bRet)
					{
						int nRecord = 0;
						while(true)
						{
							rs.GetFieldValue((short)0, strTemp);
							pIMonWETDEP[nRecord].gid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)1, strTemp);
							pIMonWETDEP[nRecord].qualid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)2, strTemp);
							pIMonWETDEP[nRecord].lid = atoi(LPCSTR(strTemp));
							rs.GetFieldValue((short)3, strTemp);
							pIMonWETDEP[nRecord].fnum[0] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)4, strTemp);
							pIMonWETDEP[nRecord].fnum[1] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)5, strTemp);
							pIMonWETDEP[nRecord].fnum[2] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)6, strTemp);
							pIMonWETDEP[nRecord].fnum[3] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)7, strTemp);
							pIMonWETDEP[nRecord].fnum[4] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)8, strTemp);
							pIMonWETDEP[nRecord].fnum[5] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)9, strTemp);
							pIMonWETDEP[nRecord].fnum[6] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)10, strTemp);
							pIMonWETDEP[nRecord].fnum[7] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)11, strTemp);
							pIMonWETDEP[nRecord].fnum[8] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)12, strTemp);
							pIMonWETDEP[nRecord].fnum[9] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)13, strTemp);
							pIMonWETDEP[nRecord].fnum[10] = atof(LPCSTR(strTemp));
							rs.GetFieldValue((short)14, strTemp);
							pIMonWETDEP[nRecord].fnum[11] = atof(LPCSTR(strTemp));
							++nRecord;
							if(nRecord >= nNum)
								break;
							rs.MoveNext();
						}
					}
					rs.Close();
				}
			}
		}		
			
		// card 280
		TRACE("Reading card 280\n");
		Log("Reading card 280\n");

		strSQL = "SELECT * FROM table280";
		strCard = "table280";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			// skip first value
			rs.GetFieldValue((short)1, strTemp);
			adfgrch = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)2, strTemp);
			maddfgrch = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			rs.GetFieldValue((short)3, strTemp);
			mawdfgrch = (atoi(LPCSTR(strTemp)) == 0)?0:1;
		}
		rs.Close();

		// card 281
		if(pQualwq!=NULL)
			delete []pQualwq;

		if(pqalfg == 1)
		{
			TRACE("Reading card 281 \n");
			Log("Reading card 281 \n");
			strCard = "table281";

			nNum = nQuals*nrgroup;
			if(nNum > 0)
			{
				pQualwq = new QUALSWQ[nNum];
				strSQL = "SELECT * FROM table281";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pQualwq[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pQualwq[nRecord].qualid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pQualwq[nRecord].qsdfg = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pQualwq[nRecord].inicon = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pQualwq[nRecord].fstdec = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pQualwq[nRecord].thfst = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pQualwq[nRecord].addc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pQualwq[nRecord].awdc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pQualwq[nRecord].potber = atof(LPCSTR(strTemp));

						if (pQualwq[nRecord].thfst < 1) pQualwq[nRecord].thfst = 1.0;
						if (pQualwq[nRecord].thfst > 2) pQualwq[nRecord].thfst = 2.0;
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		
		// card 282
		TRACE("Reading card 282\n");
		Log("Reading card 282\n");
		if(pMDDrch!=NULL)
			delete []pMDDrch;
		if(pqalfg == 1 && maddfgrch == 1)
		{
			nNum = nrgroup*nQuals;
			if(nNum > 0)
			{
				pMDDrch = new MON_DATA[nNum];
				strSQL = "SELECT * FROM table282";
				strCard = "table282";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pMDDrch[nRecord].rgid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pMDDrch[nRecord].qualid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pMDDrch[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pMDDrch[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pMDDrch[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pMDDrch[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pMDDrch[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pMDDrch[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pMDDrch[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pMDDrch[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pMDDrch[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						pMDDrch[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						pMDDrch[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						pMDDrch[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		// card 283
		TRACE("Reading card 283\n");
		Log("Reading card 283\n");
		if(pMWDrch!=NULL)
			delete []pMWDrch;
		if(pqalfg == 1 && mawdfgrch == 1)
		{
			nNum = nrgroup*nQuals;
			if(nNum > 0)
			{
				pMWDrch = new MON_DATA[nNum];
				strSQL = "SELECT * FROM table283";
				strCard = "table283";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pMWDrch[nRecord].rgid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pMWDrch[nRecord].qualid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pMWDrch[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pMWDrch[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pMWDrch[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pMWDrch[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pMWDrch[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pMWDrch[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pMWDrch[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pMWDrch[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pMWDrch[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						pMWDrch[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						pMWDrch[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						pMWDrch[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
			
		// card 285
		if(pGQ_SEDDECAY!=NULL)
			delete []pGQ_SEDDECAY;

		if (pqalfg == 1 && sedfg == 1)
		{
			TRACE("Reading card 285\n");
			Log("Reading card 285\n");
			strCard = "table285";

			nNum = nrgroup*nQuals;
			if(nNum > 0)
			{
				pGQ_SEDDECAY = new GQ_SEDDECAY[nNum];
				strSQL = "SELECT * FROM table285";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pGQ_SEDDECAY[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pGQ_SEDDECAY[nRecord].qualid = atoi(LPCSTR(strTemp));
						for (int j=0; j<4; j++)
						{
							rs.GetFieldValue((short)j+2, strTemp);
							pGQ_SEDDECAY[nRecord].addcpm[j] = atof(LPCSTR(strTemp));
						}

						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		// card 286
		if(pGQ_KD!=NULL)
			delete []pGQ_KD;

		if (pqalfg == 1 && sedfg == 1)
		{
			TRACE("Reading card 286\n");
			Log("Reading card 286\n");
			strCard = "table286";

			nNum = nrgroup*nQuals;
			if(nNum > 0)
			{
				pGQ_KD = new GQ_KD[nNum];
				strSQL = "SELECT * FROM table286";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pGQ_KD[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pGQ_KD[nRecord].qualid = atoi(LPCSTR(strTemp));
						for (int j=0; j<6; j++)
						{
							rs.GetFieldValue((short)j+2, strTemp);
							pGQ_KD[nRecord].adpm[j] = atof(LPCSTR(strTemp));
						}

						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		// card 287
		if(pGQ_ADRATE!=NULL)
			delete []pGQ_ADRATE;

		if (pqalfg == 1 && sedfg == 1)
		{
			TRACE("Reading card 287\n");
			Log("Reading card 287\n");
			strCard = "table287";

			nNum = nrgroup*nQuals;
			if(nNum > 0)
			{
				pGQ_ADRATE = new GQ_ADRATE[nNum];
				strSQL = "SELECT * FROM table287";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pGQ_ADRATE[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pGQ_ADRATE[nRecord].qualid = atoi(LPCSTR(strTemp));
						for (int j=0; j<6; j++)
						{
							rs.GetFieldValue((short)j+2, strTemp);
							pGQ_ADRATE[nRecord].adpm[j] = atof(LPCSTR(strTemp));
						}

						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		// card 288
		if(pGQ_ADTHETA!=NULL)
			delete []pGQ_ADTHETA;

		if (pqalfg == 1 && sedfg == 1)
		{
			TRACE("Reading card 288\n");
			Log("Reading card 288\n");
			strCard = "table288";

			nNum = nrgroup*nQuals;
			if(nNum > 0)
			{
				pGQ_ADTHETA = new GQ_ADTHETA[nNum];
				strSQL = "SELECT * FROM table288";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pGQ_ADTHETA[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pGQ_ADTHETA[nRecord].qualid = atoi(LPCSTR(strTemp));
						for (int j=0; j<6; j++)
						{
							rs.GetFieldValue((short)j+2, strTemp);
							pGQ_ADTHETA[nRecord].adpm[j] = atof(LPCSTR(strTemp));
						}

						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		// card 289
		if(pGQ_SEDCONC!=NULL)
			delete []pGQ_SEDCONC;

		if (pqalfg == 1 && sedfg == 1)
		{
			TRACE("Reading card 289\n");
			Log("Reading card 289\n");
			strCard = "table289";

			nNum = nrgroup*nQuals;
			if(nNum > 0)
			{
				pGQ_SEDCONC = new GQ_SEDCONC[nNum];
				strSQL = "SELECT * FROM table289";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pGQ_SEDCONC[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pGQ_SEDCONC[nRecord].qualid = atoi(LPCSTR(strTemp));
						for (int j=0; j<6; j++)
						{
							rs.GetFieldValue((short)j+2, strTemp);
							pGQ_SEDCONC[nRecord].sqal[j] = atof(LPCSTR(strTemp));
						}

						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 400
		TRACE("Reading card 400\n");
		Log("Reading card 400\n");
		strSQL = "SELECT * FROM table400";
		strCard = "table400";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			// skip first line
			rs.GetFieldValue((short)1, strTemp);
			admod = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)2, strTemp);		
			kc = atof(LPCSTR(strTemp));
			rs.GetFieldValue((short)3, strTemp);		
			sedber = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)4, strTemp);		
			vconfg = atoi(LPCSTR(strTemp));

			if (admod != 2)	
				admod = 1;
			if (sedber != 1)	
				sedber = 0;
			if (sedber == 1 && sedfg == 0)	
			{
				CString strError;
				strError.Format("Sediment flag must be ON (sedfg=1) to simulate stream bank erosion (sedber=1)");
				AfxMessageBox(strError);
				TRACE(strError);
				Log(strError);
			}
		}
		rs.Close();

		//card 401
		TRACE("Reading card 401\n");
		Log("Reading card 401\n");
		if(pMONTH_COV!=NULL)
			delete []pMONTH_COV;

		if(vconfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				pMONTH_COV = new MONTH_PH[nNum];
				strSQL = "SELECT * FROM table401";
				strCard = "table401";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pMONTH_COV[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pMONTH_COV[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pMONTH_COV[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pMONTH_COV[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pMONTH_COV[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pMONTH_COV[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pMONTH_COV[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pMONTH_COV[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pMONTH_COV[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pMONTH_COV[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pMONTH_COV[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						pMONTH_COV[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						pMONTH_COV[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 405							
		TRACE("Reading card 405\n");
		Log("Reading card 405\n");
		if(pChannelInfo != NULL)
			delete []pChannelInfo;

		if(nch > 0)
		{
			int ncountout = 1;
			pChannelInfo = new ChannelInfo[nch];
			CString noutsys = "";
			strSQL = "SELECT * FROM table405";
			strCard = "table405";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					pChannelInfo[nRecord].rchid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pChannelInfo[nRecord].comp = (atoi(LPCSTR(strTemp)) == 0)?0:1;
					rs.GetFieldValue((short)2, strTemp);
					pChannelInfo[nRecord].nDSchan = atoi(LPCSTR(strTemp));

					// allocate memory here
					if (pChannelInfo[nRecord].nDSchan > 0)
						pChannelInfo[nRecord].down_ch = new int[pChannelInfo[nRecord].nDSchan];
					
					CString strtemp;
					for(int j=0; j<pChannelInfo[nRecord].nDSchan; j++)
					{
						rs.GetFieldValue((short)3+j, strTemp);						
						pChannelInfo[nRecord].down_ch[j] = atoi(LPCSTR(strTemp));

						if (pChannelInfo[nRecord].down_ch[j]<0)
						{
							if (ncountout < 4)
							{
								++ncountout;
								strtemp.Format("Outlet %d of channel %d\t",j+1, pChannelInfo[nRecord].rchid);
							}
							else
							{
								ncountout = 1;
								strtemp.Format("Outlet %d of channel %d\t\n",j+1, pChannelInfo[nRecord].rchid);
							}
							noutsys += strtemp;
						}
					}
					pChannelInfo[nRecord].nSelfOrder = -1;
//					pChannelInfo[nRecord].nIndexSWS = -1;
//					pChannelInfo[nRecord].nIndexUL = -1;
//					pChannelInfo[nRecord].nIndexUR = -1;
//					pChannelInfo[nRecord].nIndexD = -1;

					//populated in card 435
					pChannelInfo[nRecord].cListUpStream.RemoveAll();
					pChannelInfo[nRecord].cListDownStream.RemoveAll();

					++nRecord;
					if(nRecord >= nch)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
			infomsg += noutsys;
		}

		// card 410
		TRACE("Reading card 410\n");
		Log("Reading card 410\n");
		if(pReachInfo != NULL)
			delete []pReachInfo;

		if(nch > 0)
		{
			pReachInfo = new ReachInfo[nch];
			strSQL = "SELECT * FROM table410";
			strCard = "table410";

			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				ncrchOutlets = 0;
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					pReachInfo[nRecord].rchid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pReachInfo[nRecord].gid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					pReachInfo[nRecord].tgid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					pReachInfo[nRecord].lkfg = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					pReachInfo[nRecord].idepth = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)5, strTemp);
					pReachInfo[nRecord].length = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)6, strTemp);
					pReachInfo[nRecord].depth = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)7, strTemp);
					pReachInfo[nRecord].width = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)8, strTemp);
					pReachInfo[nRecord].slope = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)9, strTemp);
					pReachInfo[nRecord].mann = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)10, strTemp);
					pReachInfo[nRecord].r1 = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)11, strTemp);
					pReachInfo[nRecord].r2 = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)12, strTemp);
					pReachInfo[nRecord].w1 = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)13, strTemp);
					pReachInfo[nRecord].crrat = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)14, strTemp);
					pReachInfo[nRecord].ks = atof(LPCSTR(strTemp));

					if(pReachInfo[nRecord].slope < 1.0e-4 && pReachInfo[nRecord].lkfg == 0)
						pReachInfo[nRecord].slope = 1.0e-4;
					if(pReachInfo[nRecord].crrat < 1)
						pReachInfo[nRecord].crrat = 1;

					// check for no routing
					if (pReachInfo[nRecord].length <= 0 || pReachInfo[nRecord].width <= 0 || pReachInfo[nRecord].depth <= 0)
						pReachInfo[nRecord].routefg = 0;

					// count the number of outlets for BMP reaches
					if(pReachInfo[nRecord].lkfg > 10)
						ncrchOutlets += pChannelInfo[nRecord].nDSchan;

					++nRecord;
					if(nRecord >= nch)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}
		if(nrgroup > 0)
		{
			TRY
			{
				int nRecord = 0;
				if (gpid != NULL)	delete []gpid;
				if (gpidx != NULL)	delete []gpidx;
				gpid = new int[nrgroup];
				gpidx = new int[nrgroup];
				strSQL = "SELECT table410.RGID FROM table410 GROUP BY table410.RGID";
				strCard = "table410";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						gpid[nRecord] = atoi(LPCSTR(strTemp));
						gpidx[nRecord] = nRecord+1;
						++nRecord;
						if(nRecord >= nrgroup)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();

				// count the number of records with value greater than zero
				strSQL = "SELECT table410.TRGID FROM table410 GROUP BY table410.TRGID";
				strCard = "table410";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					nRecord = 0;
					while(!rs.IsEOF())
					{
						rs.GetFieldValue((short)0, strTemp);
						int trgpid = atoi(LPCSTR(strTemp));
						if (trgpid > 0)
							++nRecord;
						rs.MoveNext();
					}
				}
				rs.Close();

				ntrgp = nRecord;
				if (ntrgp > 0)
				{
					if (tgpid != NULL)	delete []tgpid;
					if (tgpidx != NULL)	delete []tgpidx;
					tgpid = new int[ntrgp];
					tgpidx = new int[ntrgp];
					strSQL = "SELECT table410.TRGID FROM table410 GROUP BY table410.TRGID";
					strCard = "table410";
					bRet = rs.ExecDirect(strSQL);
					if(bRet)
					{
						nRecord = 0;
						while(true)
						{
							rs.GetFieldValue((short)0, strTemp);
							int trgpid = atoi(LPCSTR(strTemp));
							if (trgpid > 0)
							{
								tgpid[nRecord] = trgpid;
								tgpidx[nRecord] = nRecord+1;
								++nRecord;
							}
							if(nRecord >= ntrgp)
								break;
							rs.MoveNext();
						}
					}
					rs.Close();
				}
			}
			CATCH(CException, e)
			{
				rs.Close();
			}
			END_CATCH;

			for(int l=0; l<nch; ++l)
			{
				for(int k=0; k<nrgroup; ++k)
				{
					if(pReachInfo[l].gid == gpid[k])
					{
						pReachInfo[l].rgid = gpidx[k];
						break;
					}
				}

				pReachInfo[l].trgid = 0;

				for(k=0; k<ntrgp; ++k)
				{
					if(pReachInfo[l].tgid == tgpid[k])
					{
						pReachInfo[l].trgid = tgpidx[k];
						break;
					}
				}
			}
			if (gpid != NULL)	
			{
				delete []gpid;
				gpid = NULL;
			}
			if (gpidx != NULL)
			{
				delete []gpidx;
				gpidx = NULL;
			}
			if (tgpid != NULL)	
			{
				delete []tgpid;
				tgpid = NULL;
			}
			if (tgpidx != NULL)
			{
				delete []tgpidx;
				tgpidx = NULL;
			}
		}
		
		//card 413
		TRACE("Reading card 413\n");
		Log("Reading card 413 for cross section info\n");
		strSQL = "SELECT * FROM table413";
		strCard = "table413";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			int nRecord = 0;
			while(!rs.IsEOF())
			{
				rs.GetFieldValue((short)0, strTemp);
				int rchid = atoi(LPCSTR(strTemp));
				int rid = -1;
				for(int i=0; i<nch; ++i)
				{
					if (rchid == pReachInfo[i].rchid)
					{
						rid = i+1;
						break;
					}
				}
				if(rid < 1)
					continue;

				pReachInfo[rid-1].poly.CPoly_Free();
				pReachInfo[rid-1].poly.bCustomized = TRUE;

				rs.GetFieldValue((short)1, strTemp);
				int nPt = atoi(LPCSTR(strTemp));
				//x and y 
				for (i=0; i<nPt; ++i)
				{
					Point *pt = new Point();
					rs.GetFieldValue((short)i+2, strTemp);
					CStringToken strToken(strTemp);
					pt->x = atof(LPCSTR(strToken.NextToken()));
					pt->y = atof(LPCSTR(strToken.NextToken()));
					pReachInfo[rid-1].poly.pointList.AddTail((CObject *)pt);
				}
				rs.MoveNext();
			}
		}
		rs.Close();
		
		// card 415		  Import Ftable			  
		TRACE("Reading card 415\n");
		Log("Reading card 415\n");
		if(pFtable != NULL)
			delete []pFtable;

		if(pReachFtable != NULL)
			delete []pReachFtable;

		int nRecord = 0;
		int nReach = 0;
		int rchid = -1;

		if(nch > 0)
		{
			pReachFtable = new ReachFtable[nch];
			for (int i=0; i<nch; i++)
			{
				pReachFtable[i].rchid = -1;
				pReachFtable[i].nFTstart = -1;
				pReachFtable[i].nFTrecord = 0;
				if(pChannelInfo[i].nDSchan > 0)
					pReachFtable[i].bypass_fr = new double[pChannelInfo[i].nDSchan];
				for (int j=0; j<pChannelInfo[i].nDSchan; j++)
					pReachFtable[i].bypass_fr[j] = 0.0;
			}
		}

		if(nch > 0)
		TRY
		{
			strSQL = "SELECT * FROM table415";
			strCard = "table415";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				while(!rs.IsEOF())
				{
					++nRecord;
					rs.MoveNext();
				}
			}
			rs.Close();
			FtableRecord = nRecord;
			int np = 0;
			int nNum = FtableRecord;
			if(nNum > 0)
			{
				pFtable = new Ftable_Selected[nNum];
				strSQL = "SELECT * FROM table415";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pFtable[np].rchid = atoi(LPCSTR(strTemp));
						if (rchid != pFtable[np].rchid)
						{	
							for (int j=0; j<nch; j++)
							{
								if (pReachInfo[j].rchid == pFtable[np].rchid)
								{
									pReachFtable[j].rchid = pFtable[np].rchid;
									pReachFtable[j].nFTstart = np;
									break;
								}	
							}
							rchid = pFtable[np].rchid;
							++nReach;
						}
						rs.GetFieldValue((short)1, strTemp);
						pFtable[np].depth = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pFtable[np].area = atof(LPCSTR(strTemp)) * 43559.66;// from acre to ft^2
						rs.GetFieldValue((short)3, strTemp);
						pFtable[np].vol = atof(LPCSTR(strTemp)) * 43559.66;	// from ac-ft to ft^3

						//add a small fraction to make each value different to the other
						pFtable[np].depth += (pFtable[np].depth * np / 1.0E12);
						pFtable[np].area  += (pFtable[np].area  * np / 1.0E12);
						pFtable[np].vol   += (pFtable[np].vol   * np / 1.0E12);

						for (int i=0; i<nch; i++)
						{
							if (pFtable[np].rchid == pChannelInfo[i].rchid)
							{
								pReachFtable[i].nFTrecord += 1;
								pFtable[np].disch1 = 0.0;
								// allocate memory here
								if(pChannelInfo[i].nDSchan > 0)
									pFtable[np].disch = new double[pChannelInfo[i].nDSchan];
								for(int j=0; j<pChannelInfo[i].nDSchan; j++)
								{
									rs.GetFieldValue((short)4+j, strTemp);
									pFtable[np].disch[j] = atof(LPCSTR(strTemp));
									//add a small fraction to make each value different to the other
									pFtable[np].disch[j] += (pFtable[np].disch[j] * np / 1.0E12);
									pFtable[np].disch1 += pFtable[np].disch[j];
									pReachFtable[i].bypass_fr[j] += pFtable[np].disch[j]; // add flow for each outlet
								}
								break;
							}
						}
						++np;
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		CATCH(CException, e)
		{
			rs.Close();
		}
		END_CATCH;
		if (nReach > 0 && pWnd->bRunModel == false && pWnd->bRunNIMS == false)
		{
			CString Ftab;
			Ftab.Format("LSPC has found user-defined F-tables for %d out of %d segments\n\n",nReach,nch);
			Ftab += infomsg;
			AfxMessageBox(Ftab, MB_ICONINFORMATION);
			Log("LSPC has found user-defined F-tables");
		}
		else if (pWnd->bRunModel == false && pWnd->bRunNIMS == false)
		{
			AfxMessageBox("LSPC F-tables generated using stream geometry", MB_ICONINFORMATION);
			Log("LSPC F-tables generated using stream geometry");
		}

		// calculate the bypass fraction for the outlets
		for(int i=0; i<nch; i++)
		{
			double sumflow = 0.0;
			for(int j=0; j<pChannelInfo[i].nDSchan; j++)
				sumflow += pReachFtable[i].bypass_fr[j];

			for(j=0; j<pChannelInfo[i].nDSchan; j++)
			{
				if (sumflow > 0)
					pReachFtable[i].bypass_fr[j] /= sumflow;
				else
					pReachFtable[i].bypass_fr[j]  = 1.0;
			}
		}

		// card 420
		TRACE("Reading card 420\n");
		Log("Reading card 420\n");
		strSQL = "SELECT * FROM table420";
		strCard = "table420";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			rs.GetFieldValue((short)0, strTemp);
			nPtSource = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)1, strTemp);
			nPtQuals = atoi(LPCSTR(strTemp));
		}
		rs.Close();

		// card 425
		TRACE("Reading card 425\n");
		Log("Reading card 425\n");
		if(pPtQual != NULL)
			delete []pPtQual;

		if (nPtQuals > 0)
		{
			// allocate memory here
			pPtQual = new PtQual[nPtQuals];

			strSQL = "SELECT * FROM table425";
			strCard = "table425";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					pPtQual[nRecord].qualindex = nRecord + 1;
					rs.GetFieldValue((short)1, strTemp);
					pPtQual[nRecord].qualname = strTemp;
					rs.GetFieldValue((short)2, strTemp);
					pPtQual[nRecord].qualid = atoi(strTemp);
					rs.GetFieldValue((short)3, strTemp);
					pPtQual[nRecord].sqalfr = atof(strTemp);

					++nRecord;
					if(nRecord >= nPtQuals)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 430
		TRACE("Reading card 430\n");
		Log("Reading card 430\n");
		if(pPtWithDrawal != NULL)
			delete []pPtWithDrawal;

		if (nPtSource > 0)
		{
			// count the number of withdrawal point sources
			nPtWithDrawal = 0;
			strSQL = "SELECT * FROM table430";
			strCard = "table430";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				while(!rs.IsEOF())
				{
					++nPtWithDrawal;
					rs.MoveNext();
				}
			}
			rs.Close();

			if (nPtWithDrawal > 0)
			{
				// allocate memory here
				pPtWithDrawal = new PtWithDrawal[nPtWithDrawal];

				strSQL = "SELECT * FROM table430";
				strCard = "table430";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pPtWithDrawal[nRecord].wdrawlrchid = atoi(strTemp);
						rs.GetFieldValue((short)1, strTemp);
						pPtWithDrawal[nRecord].strPermit = strTemp;
						rs.GetFieldValue((short)2, strTemp);
						pPtWithDrawal[nRecord].strPipe = strTemp;
						rs.GetFieldValue((short)3, strTemp);
						pPtWithDrawal[nRecord].targetrchid = atoi(strTemp);

						++nRecord;
						if(nRecord >= nPtWithDrawal)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 435
		TRACE("Reading card 435\n");
		Log("Reading card 435\n");

		// count the linkage files
		strSQL = "select count(*) from table435";
		strCard = "table435";

		TRY
		{
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				rs.GetFieldValue((short)0, strTemp);
				nLinkFiles = atoi(LPCSTR(strTemp));
			}
			rs.Close();
		}
		CATCH(CException, e)
		{
			rs.Close();
		}
		END_CATCH;

		if (nLinkFiles > 0)
		{
			if (strArray != NULL)	
				delete []strArray;
			strArray = new CString[nLinkFiles];

			strSQL = "SELECT * FROM table435";
			strCard = "table435";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					int rchid = atoi(strTemp);
					rs.GetFieldValue((short)1, strTemp);
					int nOutlet = atoi(strTemp);
					rs.GetFieldValue((short)2, strTemp);
					CString strFilePath = strTemp;
					strFilePath.TrimLeft();
					strFilePath.TrimRight();
					strArray[nRecord] = strFilePath;

					if (nOutlet < 0)
					{
						CString strError;
						strError.Format("Outlet index:%d for reach:%d is not correct in card 435",nOutlet, rchid);
						AfxMessageBox(strError);
						TRACE(strError);
						Log(strError);
						if (strArray != NULL)	
							delete []strArray;
						return false;
					}
					// verify the input file path
					else if (nOutlet == 0)
					{
						if (!FolderExists(strFilePath))
						{
							CString strError;
							strError.Format("Card 435: Invalid Linkage Input File Path: %s for Reach ID: %d",strFilePath,rchid);
							AfxMessageBox(strError);
							TRACE(strError);
							Log(strError);
							if (strArray != NULL)	
								delete []strArray;
							return false;
						}
					}
					else // verify the output folder path
					{
						//find the folder
						int nPathLength = strFilePath.GetLength();
						int nFileLength = nPathLength - strFilePath.ReverseFind('\\') - 1;
						CString strFolderPath = strFilePath.Left(nPathLength - nFileLength);

						if (!FolderExists(strFolderPath))
						{
							CString strError;
							strError.Format("Card 435: Invalid Linkage Output Folder Path: %s for Reach ID: %d",strFolderPath,rchid);
							AfxMessageBox(strError);
							TRACE(strError);
							Log(strError);
							if (strArray != NULL)	
								delete []strArray;
							return false;
						}
					}

					//find the reach index
					int nIndex = FindIndexOrder(rchid);
					if (nIndex == -1)
					{
						CString strError;
						strError.Format("Reach ID: %d: in card 435 not found",rchid);
						AfxMessageBox(strError);
						TRACE(strError);
						Log(strError);
						if (strArray != NULL)	
							delete []strArray;
						return false;
					}

					Link435 plink435;
					plink435.nrchid = rchid;
					plink435.nOutlet = nOutlet;
					plink435.strFilePath = strFilePath;
					plink435.m_linkfile = NULL;
					plink435.pLinkData = NULL;

					if (nOutlet == 0)
						pChannelInfo[nIndex].cListUpStream.AddTail(plink435);
					else
						pChannelInfo[nIndex].cListDownStream.AddTail(plink435);

					++nRecord;
					if(nRecord >= nLinkFiles)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();

			// check the duplicate file paths
			if (DuplicateExists(nLinkFiles,strArray))
			{
				CString strError;
				strError.Format("Duplicate File Paths found in card 435");
				AfxMessageBox(strError);
				TRACE(strError);
				Log(strError);
				if (strArray != NULL)	
					delete []strArray;
				return false;
			}
			
			//release the memory
			if (strArray != NULL)	
				delete []strArray;
		}

		// card 440
		TRACE("Reading card 440\n");
		Log("Reading card 440\n");
		strSQL = "SELECT * FROM table440";
		strCard = "table440";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			// skip first line
			rs.GetFieldValue((short)1, strTemp);
			crvfg = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)2, strTemp);		
			vsivfg = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)3, strTemp);		
			sandfg = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)4, strTemp);		
			sweepfg = atoi(LPCSTR(strTemp));
			if (sandfg > 3)	
				sandfg = 0;
		}
		rs.Close();

		// card 445
		TRACE("Reading card 445\n");
		Log("Reading card 445\n");
		if(psd_sweep!=NULL)
			delete []psd_sweep;

		if(sedfg == 1 && sweepfg != 0)
		{
			nNum = nlandimp*ngroup;
			if(nNum > 0)
			{
				psd_sweep = new SD_SWEEP[nNum];
				strSQL = "SELECT * FROM table445";
				strCard = "table445";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						psd_sweep[nRecord].defid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						psd_sweep[nRecord].deluid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						psd_sweep[nRecord].luname = strTemp;
						rs.GetFieldValue((short)3, strTemp);
						psd_sweep[nRecord].start_month = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						psd_sweep[nRecord].end_month = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						psd_sweep[nRecord].frequency = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						psd_sweep[nRecord].percent_area = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						psd_sweep[nRecord].effic_sand = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						psd_sweep[nRecord].effic_silt = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						psd_sweep[nRecord].effic_clay = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 446
		TRACE("Reading card 446\n");
		Log("Reading card 446\n");
		if(pGQ_sweep!=NULL)
			delete []pGQ_sweep;

		if(sedfg == 1 && pqalfg == 1 && sweepfg == 2)
		{
			nNum = nlandimp*ngroup;
			if(nNum > 0)
			{
				pGQ_sweep = new GQ_SWEEP[nNum];
				strSQL = "SELECT * FROM table446";
				strCard = "table446";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pGQ_sweep[nRecord].defid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pGQ_sweep[nRecord].deluid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pGQ_sweep[nRecord].luname = strTemp;

						if (nQuals > 0)
							pGQ_sweep[nRecord].effic_GQual = new double[nQuals];
						for (int j=0; j<nQuals; j++) 
						{
							rs.GetFieldValue((short)j+3, strTemp);
							pGQ_sweep[nRecord].effic_GQual[j] = atof(LPCSTR(strTemp));
						}
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 450
		TRACE("Reading card 450\n");
		Log("Reading card 450\n");
		if(psd_param1!=NULL)
			delete []psd_param1;

		if(sedfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				psd_param1 = new SD_PARA1[nNum];
				strSQL = "SELECT * FROM table450";
				strCard = "table450";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						psd_param1[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						psd_param1[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						psd_param1[nRecord].smpf_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						psd_param1[nRecord].krer_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						psd_param1[nRecord].jrer_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						psd_param1[nRecord].affix_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						psd_param1[nRecord].cover_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						psd_param1[nRecord].nvsi_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						psd_param1[nRecord].kser_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						psd_param1[nRecord].jser_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						psd_param1[nRecord].kger_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						psd_param1[nRecord].jger_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						psd_param1[nRecord].accsdp_p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						psd_param1[nRecord].remsdp_p = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 451
		TRACE("Reading card 451\n");
		Log("Reading card 451\n");
		if(psd_param2!=NULL)
			delete []psd_param2;

		if(sedfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				psd_param2 = new SD_PARA2[nNum];
				strSQL = "SELECT * FROM table451";
				strCard = "table451";
				//bRet = rs.ExecDirect(strSQL);
				// count the number of columns first
				int ncols = 0;
				TRY
				{
					bRet = rs.ExecDirect(strSQL);
					if(bRet)
						for (ncols=0;;ncols++) 
							rs.GetFieldValue((short)ncols, strTemp);
				}
				CATCH(CException, e)
				{
					rs.Close();
				}
				END_CATCH;

				NumSed = ncols - 5; // sand, silt, and clay

				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						psd_param2[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						psd_param2[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						psd_param2[nRecord].sed_suro = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						psd_param2[nRecord].sed_ifwo = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						psd_param2[nRecord].sed_agwo = atof(LPCSTR(strTemp));

						if (NumSed > 0)
							psd_param2[nRecord].sed = new double[NumSed];
						for (int j=0; j<NumSed; j++) 
						{
							rs.GetFieldValue((short)j+5, strTemp);
							psd_param2[nRecord].sed[j] = atof(LPCSTR(strTemp));
						}
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 452
		TRACE("Reading card 452\n");
		Log("Reading card 452\n");
		if(sed_mapp!=NULL)
			delete []sed_mapp;

		if(pqalfg == 1 && sedfg == 1 && gqsdfg == 1)
		{
			if(nQuals > 0 && ngroup > 0)
			{
				nNum = ngroup*4;
				sed_mapp = new SEDGQUAL_MAPP[nNum];
				strSQL = "SELECT * FROM table452";
				strCard = "table452";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						sed_mapp[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						sed_mapp[nRecord].qualid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						sed_mapp[nRecord].lutype = atoi(LPCSTR(strTemp));
						
						if (NumSed > 0)
							sed_mapp[nRecord].sed = new double[NumSed];
						
						for (int j=0; j<NumSed; j++) 
						{
							rs.GetFieldValue((short)j+3, strTemp);
							sed_mapp[nRecord].sed[j] = atof(LPCSTR(strTemp));
						}
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 453
		TRACE("Reading card 453\n");
		Log("Reading card 453\n");
		if(pCRVm!=NULL)
			delete []pCRVm;

		if(sedfg ==1 && crvfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				pCRVm = new MONTH_TMP[nNum];
				strSQL = "SELECT * FROM table453";
				strCard = "table453";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pCRVm[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pCRVm[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pCRVm[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pCRVm[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pCRVm[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pCRVm[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pCRVm[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pCRVm[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pCRVm[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pCRVm[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pCRVm[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						pCRVm[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						pCRVm[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						pCRVm[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		// card 454
		TRACE("Reading card 454\n");
		Log("Reading card 454\n");
		if(pVSIVm!=NULL)
			delete []pVSIVm;

		if(sedfg ==1 && vsivfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				pVSIVm = new MONTH_TMP[nNum];
				strSQL = "SELECT * FROM table454";
				strCard = "table454";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pVSIVm[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pVSIVm[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pVSIVm[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pVSIVm[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pVSIVm[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pVSIVm[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pVSIVm[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pVSIVm[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pVSIVm[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pVSIVm[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pVSIVm[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						pVSIVm[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						pVSIVm[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						pVSIVm[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		// card 455
		TRACE("Reading card 455\n");
		Log("Reading card 455\n");
		if(rsd_genparam!=NULL)
			delete []rsd_genparam;

		if(sedfg == 1 )
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				rsd_genparam = new STREAMSED_GENPARM[nNum];
				strSQL = "SELECT * FROM table455";
				strCard = "table455";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						rsd_genparam[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						rsd_genparam[nRecord].bedwid = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						rsd_genparam[nRecord].beddep = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						rsd_genparam[nRecord].por = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						rsd_genparam[nRecord].burial = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 456
		TRACE("Reading card 456\n");
		Log("Reading card 456\n");
		if(rsd_param!=NULL)
			delete []rsd_param;

		if(sedfg == 1 )
		{
			nNum = nrgroup*NumSed;
			if(nNum > 0)
			{
				rsd_param = new STREAMSED_PARM[nNum];
				strSQL = "SELECT * FROM table456";
				strCard = "table456";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						rsd_param[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						rsd_param[nRecord].sed_id = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						rsd_param[nRecord].sedflg = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						rsd_param[nRecord].sedo= atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						rsd_param[nRecord].sedfrac= atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						rsd_param[nRecord].d = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						rsd_param[nRecord].w = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						rsd_param[nRecord].rho = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						rsd_param[nRecord].taucd = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						rsd_param[nRecord].taucs = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						rsd_param[nRecord].m = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						rsd_param[nRecord].burial = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 457
		TRACE("Reading card 457\n");
		Log("Reading card 457\n");
		if(rsd_berparam!=NULL)
			delete []rsd_berparam;

		if(sedfg == 1 && sedber == 1)
		{
			nNum = nch;
			if(nNum > 0)
			{
				rsd_berparam = new SD_BER[nNum];
				strSQL = "SELECT * FROM table457";
				strCard = "table457";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						rsd_berparam[nRecord].rchid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						rsd_berparam[nRecord].kber = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						rsd_berparam[nRecord].jber = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						rsd_berparam[nRecord].qber = atof(LPCSTR(strTemp));

						if (NumSed > 0)
							rsd_berparam[nRecord].sed = new double[NumSed];
						for (int j=0; j<NumSed; j++) 
						{
							rs.GetFieldValue((short)j+4, strTemp);
							rsd_berparam[nRecord].sed[j] = atof(LPCSTR(strTemp));
						}
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 460
		TRACE("Reading card 460\n");
		Log("Reading card 460\n");
		if(tempfg ==1)
		{
			strSQL = "SELECT * FROM table460";
			strCard = "table460";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				// skip first value
				rs.GetFieldValue((short)1, strTemp);
				msltfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)2, strTemp);
				miftfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)3, strTemp);
				mgwtfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			}
			rs.Close();
		}

		// card 461
		TRACE("Reading card 461\n");
		Log("Reading card 461\n");
		if(pstmp_parm1!=NULL)
			delete []pstmp_parm1;

		if(tempfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				pstmp_parm1 = new STMP_PARA1[nNum];
				strSQL = "SELECT * FROM table461";
				strCard = "table461";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pstmp_parm1[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pstmp_parm1[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pstmp_parm1[nRecord].tsopfg = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						pstmp_parm1[nRecord].aslt = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						pstmp_parm1[nRecord].bslt = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						pstmp_parm1[nRecord].aift = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						pstmp_parm1[nRecord].bift = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						pstmp_parm1[nRecord].agwt = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						pstmp_parm1[nRecord].bgwt = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						pstmp_parm1[nRecord].islt = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						pstmp_parm1[nRecord].iift = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						pstmp_parm1[nRecord].igwt = atof(LPCSTR(strTemp));

						if(pstmp_parm1[nRecord].tsopfg < 0 || pstmp_parm1[nRecord].tsopfg > 2)
						{
							TRACE("Wrong reading tsopfg=%d",pstmp_parm1[nRecord].tsopfg);
							Log("Wrong reading tsopfg%d",pstmp_parm1[nRecord].tsopfg);
							return false;
						}
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 462
		TRACE("Reading card 462\n");
		Log("Reading card 462\n");
		if(asltm!=NULL)
			delete []asltm;

		if(tempfg == 1 && msltfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				asltm = new MONTH_TMP[nNum];
				strSQL = "SELECT * FROM table462";
				strCard = "table462";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						asltm[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						asltm[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						asltm[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						asltm[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						asltm[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						asltm[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						asltm[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						asltm[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						asltm[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						asltm[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						asltm[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						asltm[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						asltm[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						asltm[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 463
		TRACE("Reading card 463\n");
		Log("Reading card 463\n");
		if(bsltm!=NULL)
			delete []bsltm;

		if(tempfg == 1 && msltfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				bsltm = new MONTH_TMP[nNum];
				strSQL = "SELECT * FROM table463";
				strCard = "table463";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						bsltm[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						bsltm[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						bsltm[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						bsltm[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						bsltm[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						bsltm[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						bsltm[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						bsltm[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						bsltm[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						bsltm[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						bsltm[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						bsltm[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						bsltm[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						bsltm[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 464
		TRACE("Reading card 464\n");
		Log("Reading card 464\n");
		if(aiftm!=NULL)
			delete []aiftm;

		if(tempfg == 1 && miftfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				aiftm = new MONTH_TMP[nNum];
				strSQL = "SELECT * FROM table464";
				strCard = "table464";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						aiftm[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						aiftm[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						aiftm[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						aiftm[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						aiftm[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						aiftm[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						aiftm[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						aiftm[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						aiftm[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						aiftm[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						aiftm[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						aiftm[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						aiftm[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						aiftm[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 465
		TRACE("Reading card 465\n");
		Log("Reading card 465\n");
		if(biftm!=NULL)
			delete []biftm;

		if(tempfg == 1 && miftfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				biftm = new MONTH_TMP[nNum];
				strSQL = "SELECT * FROM table465";
				strCard = "table465";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						biftm[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						biftm[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						biftm[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						biftm[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						biftm[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						biftm[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						biftm[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						biftm[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						biftm[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						biftm[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						biftm[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						biftm[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						biftm[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						biftm[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 466
		TRACE("Reading card 466\n");
		Log("Reading card 466\n");
		if(agwtm!=NULL)
			delete []agwtm;

		if(tempfg == 1 && mgwtfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				agwtm = new MONTH_TMP[nNum];
				strSQL = "SELECT * FROM table466";
				strCard = "table466";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						agwtm[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						agwtm[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						agwtm[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						agwtm[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						agwtm[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						agwtm[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						agwtm[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						agwtm[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						agwtm[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						agwtm[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						agwtm[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						agwtm[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						agwtm[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						agwtm[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 467
		TRACE("Reading card 467\n");
		Log("Reading card 467\n");
		if(bgwtm!=NULL)
			delete []bgwtm;

		if(tempfg == 1 && mgwtfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				bgwtm = new MONTH_TMP[nNum];
				strSQL = "SELECT * FROM table467";
				strCard = "table467";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						bgwtm[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						bgwtm[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						bgwtm[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						bgwtm[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						bgwtm[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						bgwtm[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						bgwtm[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						bgwtm[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						bgwtm[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						bgwtm[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						bgwtm[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						bgwtm[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						bgwtm[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						bgwtm[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 470
		TRACE("Reading card 470\n");
		Log("Reading card 470\n");
		if(ptmp_param1 != NULL)
			delete []ptmp_param1;

		if(tempfg == 1 && nsws > 0)
		{
			ptmp_param1 = new TMP_PARA1[nsws];
			strSQL = "SELECT * FROM table470";
			strCard = "table470";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					ptmp_param1[nRecord].subbasin = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					ptmp_param1[nRecord].elev = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					ptmp_param1[nRecord].eldat = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					ptmp_param1[nRecord].relev = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					ptmp_param1[nRecord].reldat = atof(LPCSTR(strTemp));
					++nRecord;
					if(nRecord >= nch)
						break;
					rs.MoveNext();
				}
				rs.Close();
			}
		}

		// card 474 (optional)
		TRACE("Reading card 474\n");
		Log("Reading card 474\n");
		strCard = "table474";
		strSQL = "SELECT * FROM table474";
		TRY
		{
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					//skip first value
					rs.GetFieldValue((short)1, strTemp);
					lapse[nRecord] = atof(LPCSTR(strTemp));
					++nRecord;
					if(nRecord >= 24)
						break;
					rs.MoveNext();
				}
				rs.Close();
			}
		}
		CATCH(CException, e)
		{
			rs.Close();
		}
		END_CATCH;
			
		// card 475
		TRACE("Reading card 475\n");
		Log("Reading card 475\n");
		if(ptmps_param1 != NULL)
			delete []ptmps_param1;

		if(tempfg == 1 && nrgroup > 0)
		{
			ptmps_param1 = new TMPS_PARA1[nrgroup];
			strSQL = "SELECT * FROM table475";
			strCard = "table475";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					ptmps_param1[nRecord].gid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					ptmps_param1[nRecord].cfsaex_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					ptmps_param1[nRecord].katrad_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					ptmps_param1[nRecord].kcond_p = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					ptmps_param1[nRecord].kevap_p = atof(LPCSTR(strTemp));
					++nRecord;
					if(nRecord >= nrgroup)
						break;
					rs.MoveNext();
				}
				rs.Close();
			}
		}

		// card 480
		TRACE("Reading card 480\n");
		Log("Reading card 480\n");
		if(ptmps_param2 != NULL)
			delete []ptmps_param2;

		if(tempfg == 1 && nrgroup > 0)
		{
			ptmps_param2 = new TMPS_PARA2[nrgroup];
			strSQL = "SELECT * FROM table480";
			strCard = "table480";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					ptmps_param2[nRecord].rgid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					ptmps_param2[nRecord].preflg = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					ptmps_param2[nRecord].bedflg = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					ptmps_param2[nRecord].tgflg = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					ptmps_param2[nRecord].muddep = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)5, strTemp);
					ptmps_param2[nRecord].tgrnd = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)6, strTemp);
					ptmps_param2[nRecord].kmud = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)7, strTemp);
					ptmps_param2[nRecord].kgrnd = atof(LPCSTR(strTemp));

					if (ptmps_param2[nRecord].bedflg > 2)
						ptmps_param2[nRecord].bedflg = 2;
					if (ptmps_param2[nRecord].bedflg > 0)
						bedflg = true;
					if (ptmps_param2[nRecord].tgflg < 2)
						ptmps_param2[nRecord].tgflg = 2;
					if (ptmps_param2[nRecord].tgflg == 3)
						mtgflg = true;

					++nRecord;
					if(nRecord >= nrgroup)
						break;
					rs.MoveNext();
				}
				rs.Close();
			}
		}

		//card 485
		TRACE("Reading card 485\n");
		Log("Reading card 485\n");
		if(ptmps_mon!=NULL)
			delete []ptmps_mon;

		if(tempfg == 1 && bedflg == true && mtgflg == true)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				ptmps_mon = new MONTH_PARM[nNum];
				strSQL = "SELECT * FROM table485";
				strCard = "table485";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						ptmps_mon[nRecord].rgid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						ptmps_mon[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						ptmps_mon[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						ptmps_mon[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						ptmps_mon[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						ptmps_mon[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						ptmps_mon[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						ptmps_mon[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						ptmps_mon[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						ptmps_mon[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						ptmps_mon[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						ptmps_mon[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						ptmps_mon[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 500
		TRACE("Reading card 500\n");
		Log("Reading card 500\n");
		if(land_mapp!=NULL)
			delete []land_mapp;

		if(oxfg == 1)
		{
			nNum = nQuals*nrgroup*4;
			if(nNum > 0)
			{
				land_mapp = new LAND_MAPP[nNum];
				strSQL = "SELECT * FROM table500";
				strCard = "table500";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						land_mapp[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						land_mapp[nRecord].qualid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						land_mapp[nRecord].lutype = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						land_mapp[nRecord].bod = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						land_mapp[nRecord].nox = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						land_mapp[nRecord].tam = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						land_mapp[nRecord].snh4 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						land_mapp[nRecord].po4 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						land_mapp[nRecord].spo4 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						land_mapp[nRecord].orn = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						land_mapp[nRecord].orp = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						land_mapp[nRecord].orc = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 501
		TRACE("Reading card 501\n");
		Log("Reading card 501\n");
		if(atms_mapp!=NULL)
			delete []atms_mapp;

		if(oxfg == 1 && adfgrch == 1)
		{
			nNum = nQuals*nrgroup;
			if(nNum > 0)
			{
				atms_mapp = new ATMS_MAPP[nNum];
				strSQL = "SELECT * FROM table501";
				strCard = "table501";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						atms_mapp[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						atms_mapp[nRecord].qualid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						atms_mapp[nRecord].bod = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						atms_mapp[nRecord].nox = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						atms_mapp[nRecord].tam = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						atms_mapp[nRecord].po4 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						atms_mapp[nRecord].orn = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						atms_mapp[nRecord].orp = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						atms_mapp[nRecord].orc = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 502
		TRACE("Reading card 502\n");
		Log("Reading card 502\n");
		if(oxfg ==1)
		{
			strSQL = "SELECT * FROM table502";
			strCard = "table502";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				// skip first value
				rs.GetFieldValue((short)1, strTemp);
				midofg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)2, strTemp);
				mico2fg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)3, strTemp);
				madofg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)4, strTemp);
				maco2fg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			}
			rs.Close();
		}

		// card 503
		TRACE("Reading card 503\n");
		Log("Reading card 503\n");
		if(doco_parm1!=NULL)
			delete []doco_parm1;

		if(oxfg ==1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				doco_parm1 = new DOCO_PARA1[nNum];
				strSQL = "SELECT * FROM table503";
				strCard = "table503";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						doco_parm1[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						doco_parm1[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						doco_parm1[nRecord].sdoxp = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						doco_parm1[nRecord].sco2p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						doco_parm1[nRecord].idoxp = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						doco_parm1[nRecord].ico2p = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						doco_parm1[nRecord].adoxp = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						doco_parm1[nRecord].aco2p = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 504
		TRACE("Reading card 504\n");
		Log("Reading card 504\n");
		if(idoconc!=NULL)
			delete []idoconc;

		if(oxfg == 1 && midofg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				idoconc = new MONTH_OX[nNum];
				strSQL = "SELECT * FROM table504";
				strCard = "table504";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						idoconc[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						idoconc[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						idoconc[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						idoconc[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						idoconc[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						idoconc[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						idoconc[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						idoconc[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						idoconc[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						idoconc[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						idoconc[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						idoconc[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						idoconc[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						idoconc[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 505
		TRACE("Reading card 505\n");
		Log("Reading card 505\n");
		if(adoconc!=NULL)
			delete []adoconc;

		if(oxfg == 1 && madofg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				adoconc = new MONTH_OX[nNum];
				strSQL = "SELECT * FROM table505";
				strCard = "table505";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						adoconc[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						adoconc[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						adoconc[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						adoconc[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						adoconc[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						adoconc[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						adoconc[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						adoconc[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						adoconc[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						adoconc[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						adoconc[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						adoconc[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						adoconc[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						adoconc[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 506
		TRACE("Reading card 506\n");
		Log("Reading card 506\n");
		if(ico2conc!=NULL)
			delete []ico2conc;

		if(mico2fg  == 1 && oxfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				ico2conc = new MONTH_OX[nNum];
				strSQL = "SELECT * FROM table506";
				strCard = "table506";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						ico2conc[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						ico2conc[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						ico2conc[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						ico2conc[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						ico2conc[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						ico2conc[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						ico2conc[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						ico2conc[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						ico2conc[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						ico2conc[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						ico2conc[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						ico2conc[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						ico2conc[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						ico2conc[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 507
		TRACE("Reading card 507\n");
		Log("Reading card 507\n");
		if(aco2conc!=NULL)
			delete []aco2conc;

		if(maco2fg  == 1 && oxfg == 1)
		{
			nNum = nlandp*ngroup;
			if(nNum > 0)
			{
				aco2conc = new MONTH_OX[nNum];
				strSQL = "SELECT * FROM table507";
				strCard = "table507";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						aco2conc[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						aco2conc[nRecord].lid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						aco2conc[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						aco2conc[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						aco2conc[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						aco2conc[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						aco2conc[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						aco2conc[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						aco2conc[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						aco2conc[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						aco2conc[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						aco2conc[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						aco2conc[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)13, strTemp);
						aco2conc[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 510
		TRACE("Reading card 510\n");
		Log("Reading card 510\n");
		if(oxfg == 1)
		{
			strSQL = "SELECT * FROM table510";
			strCard = "table510";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				// skip first value
				rs.GetFieldValue((short)1, strTemp);
				benrfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)2, strTemp);
				reamfg = atoi(LPCSTR(strTemp));
				if (reamfg > 3 || reamfg < 1)
					reamfg = 2; //default option
			}
			rs.Close();
		}

		// card 511
		TRACE("Reading card 511\n");
		Log("Reading card 511\n");
		if(ox_parm1!=NULL)
			delete []ox_parm1;

		if(oxfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				ox_parm1 = new OX_PARA1[nNum];
				strSQL = "SELECT * FROM table511";
				strCard = "table511";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						ox_parm1[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						ox_parm1[nRecord].kbod20 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						ox_parm1[nRecord].tcbod = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						ox_parm1[nRecord].kodset = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						ox_parm1[nRecord].supsat = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						ox_parm1[nRecord].tcginv = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						ox_parm1[nRecord].reak = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						ox_parm1[nRecord].expred = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						ox_parm1[nRecord].exprev = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						ox_parm1[nRecord].cforea = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 512
		TRACE("Reading card 512\n");
		Log("Reading card 512\n");
		if(ox_parm2!=NULL)
			delete []ox_parm2;

		if(oxfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				ox_parm2 = new OX_PARA2[nNum];
				strSQL = "SELECT * FROM table512";
				strCard = "table512";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						ox_parm2[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						ox_parm2[nRecord].benod = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						ox_parm2[nRecord].tcben = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						ox_parm2[nRecord].expod = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						ox_parm2[nRecord].brbod = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						ox_parm2[nRecord].brbod_inc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						ox_parm2[nRecord].exprel = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 513
		TRACE("Reading card 513\n");
		Log("Reading card 513\n");
		if(oxrx_init!=NULL)
			delete []oxrx_init;

		if(oxfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				oxrx_init = new OXRX_INIT[nNum];
				strSQL = "SELECT * FROM table513";
				strCard = "table513";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						oxrx_init[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						oxrx_init[nRecord].dox = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						oxrx_init[nRecord].bod = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						oxrx_init[nRecord].satdo = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 514
		TRACE("Reading card 514\n");
		Log("Reading card 514\n");
		if(scour_parms!=NULL)
			delete []scour_parms;

		if(oxfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				scour_parms = new SCOUR_PARMS[nNum];
				strSQL = "SELECT * FROM table514";
				strCard = "table514";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						scour_parms[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						scour_parms[nRecord].scrvel = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						scour_parms[nRecord].scrmul = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		
		// card 520
		TRACE("Reading card 520\n");
		Log("Reading card 520\n");
		if(nutfg == 1)
		{
			strSQL = "SELECT * FROM table520";
			strCard = "table520";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				// skip first value
				rs.GetFieldValue((short)1, strTemp);
				tamfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)2, strTemp);
				no2fg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)3, strTemp);
				po4fg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)4, strTemp);
				amvfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)5, strTemp);
				denfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)6, strTemp);
				adnhfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)7, strTemp);
				adpofg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)8, strTemp);
				mphfg = (atoi(LPCSTR(strTemp)) == 0)?0:0;	// not enabled yet (05-2005)
			}
			rs.Close();

			if ((tamfg == 0 && (amvfg == 1 || adnhfg == 1)) || (po4fg == 0 && adpofg == 1))
			{
				AfxMessageBox("error - either: 1) tam is not being simulated, and nh3 volat. or	nh4 adsorption is being simulated; or 2) po4 is not being simulated, and po4 adsorption is being simulated");
				return false;
			}
		}

		// card 521
		TRACE("Reading card 521\n");
		Log("Reading card 521\n");
		if(nut_parm1!=NULL)
			delete []nut_parm1;

		if(nutfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				nut_parm1 = new NUT_PARA1[nNum];
				strSQL = "SELECT * FROM table521";
				strCard = "table521";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						nut_parm1[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						nut_parm1[nRecord].cvbo = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						nut_parm1[nRecord].cvbpc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						nut_parm1[nRecord].cvbpn = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						nut_parm1[nRecord].bpcntc = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						nut_parm1[nRecord].ktam20 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						nut_parm1[nRecord].kno220 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						nut_parm1[nRecord].tcnit = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						nut_parm1[nRecord].kno320 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						nut_parm1[nRecord].tcden = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						nut_parm1[nRecord].denoxt = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 522
		TRACE("Reading card 522\n");
		Log("Reading card 522\n");
		if(nut_parm2!=NULL)
			delete []nut_parm2;

		if(nutfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				nut_parm2 = new NUT_PARA2[nNum];
				strSQL = "SELECT * FROM table522";
				strCard = "table522";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						nut_parm2[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						nut_parm2[nRecord].brtam_1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						nut_parm2[nRecord].brtam_2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						nut_parm2[nRecord].brpo4_1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						nut_parm2[nRecord].brpo4_2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						nut_parm2[nRecord].bnh4_1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						nut_parm2[nRecord].bnh4_2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						nut_parm2[nRecord].bnh4_3 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						nut_parm2[nRecord].bpo4_1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						nut_parm2[nRecord].bpo4_2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						nut_parm2[nRecord].bpo4_3 = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 523
		TRACE("Reading card 523\n");
		Log("Reading card 523\n");
		if(nut_parm3!=NULL)
			delete []nut_parm3;

		if(nutfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				nut_parm3 = new NUT_PARA3[nNum];
				strSQL = "SELECT * FROM table523";
				strCard = "table523";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						nut_parm3[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						nut_parm3[nRecord].anaer = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						nut_parm3[nRecord].adnhpm_1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						nut_parm3[nRecord].adnhpm_2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						nut_parm3[nRecord].adnhpm_3 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						nut_parm3[nRecord].adpopm_1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						nut_parm3[nRecord].adpopm_2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						nut_parm3[nRecord].adpopm_3 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						nut_parm3[nRecord].expnvg = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						nut_parm3[nRecord].expnvl = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 524
		TRACE("Reading card 524\n");
		Log("Reading card 524\n");
		if(nut_init!=NULL)
			delete []nut_init;

		if(nutfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				nut_init = new NUT_INIT[nNum];
				strSQL = "SELECT * FROM table524";
				strCard = "table524";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						nut_init[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						nut_init[nRecord].no3 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						nut_init[nRecord].tam = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						nut_init[nRecord].no2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						nut_init[nRecord].po4 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						nut_init[nRecord].snh4_1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						nut_init[nRecord].snh4_2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						nut_init[nRecord].snh4_3 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						nut_init[nRecord].spo4_1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						nut_init[nRecord].spo4_2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						nut_init[nRecord].spo4_3 = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}
		
		// card 530
		TRACE("Reading card 530\n");
		Log("Reading card 530\n");
		if(plkfg == 1)
		{
			strSQL = "SELECT * FROM table530";
			strCard = "table530";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				// skip first value
				rs.GetFieldValue((short)1, strTemp);
				phyfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)2, strTemp);
				zoofg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)3, strTemp);
				balfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)4, strTemp);
				sdltfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)5, strTemp);
				amrfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)6, strTemp);
				decfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)7, strTemp);
				nsfg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
				rs.GetFieldValue((short)8, strTemp);
				orefg = (atoi(LPCSTR(strTemp)) == 0)?0:1;
			}
			rs.Close();
		}

		// card 531
		TRACE("Reading card 531\n");
		Log("Reading card 531\n");
		if(plank_parm1!=NULL)
			delete []plank_parm1;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				plank_parm1 = new PLANK_PARA1[nNum];
				strSQL = "SELECT * FROM table531";
				strCard = "table531";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						plank_parm1[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						plank_parm1[nRecord].ratclp = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						plank_parm1[nRecord].nonref = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						plank_parm1[nRecord].litsed = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						plank_parm1[nRecord].alnpr = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						plank_parm1[nRecord].extb = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						plank_parm1[nRecord].malgr = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 532
		TRACE("Reading card 532\n");
		Log("Reading card 532\n");
		if(plank_parm2!=NULL)
			delete []plank_parm2;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				plank_parm2 = new PLANK_PARA2[nNum];
				strSQL = "SELECT * FROM table532";
				strCard = "table532";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						plank_parm2[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						plank_parm2[nRecord].cmmlt = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						plank_parm2[nRecord].cmmn = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						plank_parm2[nRecord].cmmnp = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						plank_parm2[nRecord].cmmp = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						plank_parm2[nRecord].talgrh = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						plank_parm2[nRecord].talgrl = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						plank_parm2[nRecord].talgrm = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 533
		TRACE("Reading card 533\n");
		Log("Reading card 533\n");
		if(plank_parm3!=NULL)
			delete []plank_parm3;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				plank_parm3 = new PLANK_PARA3[nNum];
				strSQL = "SELECT * FROM table533";
				strCard = "table533";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						plank_parm3[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						plank_parm3[nRecord].alr20 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						plank_parm3[nRecord].aldh = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						plank_parm3[nRecord].aldl = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						plank_parm3[nRecord].oxald = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						plank_parm3[nRecord].naldh = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						plank_parm3[nRecord].paldh = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 534
		TRACE("Reading card 534\n");
		Log("Reading card 534\n");
		if(plank_parm4!=NULL)
			delete []plank_parm4;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				plank_parm4 = new PLANK_PARA4[nNum];
				strSQL = "SELECT * FROM table534";
				strCard = "table534";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						plank_parm4[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						plank_parm4[nRecord].phycon = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						plank_parm4[nRecord].seed = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						plank_parm4[nRecord].mxstay = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						plank_parm4[nRecord].oref = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						plank_parm4[nRecord].claldh = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						plank_parm4[nRecord].physet = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						plank_parm4[nRecord].refset = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						plank_parm4[nRecord].cfsaex = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						plank_parm4[nRecord].mbal = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						plank_parm4[nRecord].cfbalr = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						plank_parm4[nRecord].cfbalg = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 535
		TRACE("Reading card 535\n");
		Log("Reading card 535\n");
		if(plank_init!=NULL)
			delete []plank_init;

		if(plkfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				plank_init = new PLANK_INIT[nNum];
				strSQL = "SELECT * FROM table535";
				strCard = "table535";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						plank_init[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						plank_init[nRecord].phyto = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						plank_init[nRecord].benal = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						plank_init[nRecord].orn = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						plank_init[nRecord].orp = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						plank_init[nRecord].orc = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 540
		TRACE("Reading card 540\n");
		Log("Reading card 540\n");
		if(phfg == 1)
		{
			strSQL = "SELECT * FROM table540";
			strCard = "table540";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				// skip first value
				rs.GetFieldValue((short)1, strTemp);
				phffg1 = atoi(LPCSTR(strTemp));
				rs.GetFieldValue((short)2, strTemp);
				phffg2 = atoi(LPCSTR(strTemp));
				rs.GetFieldValue((short)3, strTemp);
				phfrc1 = atof(LPCSTR(strTemp));
				rs.GetFieldValue((short)4, strTemp);
				phfrc2 = atof(LPCSTR(strTemp));
			}
			rs.Close();
		}

		// card 541
		TRACE("Reading card 541\n");
		Log("Reading card 541\n");
		if(ph_para!=NULL)
			delete []ph_para;

		if(phfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				ph_para = new PH_PARA[nNum];
				strSQL = "SELECT * FROM table541";
				strCard = "table541";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						ph_para[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						ph_para[nRecord].phcnt = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						ph_para[nRecord].alkcon = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						ph_para[nRecord].cfcinv = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						ph_para[nRecord].brco2_1 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						ph_para[nRecord].brco2_2 = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 542
		TRACE("Reading card 542\n");
		Log("Reading card 542\n");
		if(ph_init!=NULL)
			delete []ph_init;

		if(phfg == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				ph_init = new PH_INIT[nNum];
				strSQL = "SELECT * FROM table542";
				strCard = "table542";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						ph_init[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						ph_init[nRecord].tic = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						ph_init[nRecord].co2 = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						ph_init[nRecord].ph = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 543
		TRACE("Reading card 543\n");
		Log("Reading card 543\n");
		if(mtic_rf!=NULL)
			delete []mtic_rf;

		if(phfg == 1 && phffg1 == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				mtic_rf = new MONTH_PH[nNum];
				strSQL = "SELECT * FROM table543";
				strCard = "table543";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						mtic_rf[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						mtic_rf[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						mtic_rf[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						mtic_rf[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						mtic_rf[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						mtic_rf[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						mtic_rf[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						mtic_rf[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						mtic_rf[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						mtic_rf[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						mtic_rf[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						mtic_rf[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						mtic_rf[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 544
		TRACE("Reading card 544\n");
		Log("Reading card 544\n");
		if(mco2_rf!=NULL)
			delete []mco2_rf;

		if(phfg  == 1 && phffg2 == 1)
		{
			nNum = nrgroup;
			if(nNum > 0)
			{
				mco2_rf = new MONTH_PH[nNum];
				strSQL = "SELECT * FROM table544";
				strCard = "table544";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						mco2_rf[nRecord].gid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						mco2_rf[nRecord].fnum[0] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						mco2_rf[nRecord].fnum[1] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)3, strTemp);
						mco2_rf[nRecord].fnum[2] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)4, strTemp);
						mco2_rf[nRecord].fnum[3] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)5, strTemp);
						mco2_rf[nRecord].fnum[4] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)6, strTemp);
						mco2_rf[nRecord].fnum[5] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)7, strTemp);
						mco2_rf[nRecord].fnum[6] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)8, strTemp);
						mco2_rf[nRecord].fnum[7] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)9, strTemp);
						mco2_rf[nRecord].fnum[8] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)10, strTemp);
						mco2_rf[nRecord].fnum[9] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)11, strTemp);
						mco2_rf[nRecord].fnum[10] = atof(LPCSTR(strTemp));
						rs.GetFieldValue((short)12, strTemp);
						mco2_rf[nRecord].fnum[11] = atof(LPCSTR(strTemp));
						++nRecord;
						if(nRecord >= nNum)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 600
		TRACE("Reading card 600\n");
		Log("Reading card 600\n");
		strSQL = "SELECT * FROM table600";
		strCard = "table600";
		bRet = rs.ExecDirect(strSQL);
		if(bRet)
		{
			int nRecord = 0;
			while(true)
			{
				rs.GetFieldValue((short)0, strTemp);
				ncpt = atoi(LPCSTR(strTemp));
				rs.GetFieldValue((short)1, strTemp);
				ncland = atoi(LPCSTR(strTemp));
				rs.GetFieldValue((short)2, strTemp);
				ncrch = atoi(LPCSTR(strTemp));
				rs.GetFieldValue((short)3, strTemp);
				ntrgp = atoi(LPCSTR(strTemp));
				rs.GetFieldValue((short)4, strTemp);
				ntnum = atoi(LPCSTR(strTemp));
				break;
			}
		}
		rs.Close();

		// card 605							
		TRACE("Reading card 605\n");
		Log("Reading card 605\n");
		if(pThreshold != NULL)
			delete []pThreshold;

		if(ntnum > 0)
		{
			pThreshold = new THR_MAPPING[ntnum];
			strSQL = "SELECT * FROM table605";
			strCard = "table605";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					pThreshold[nRecord].tnum = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pThreshold[nRecord].tqsd = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					pThreshold[nRecord].tqnum = atoi(LPCSTR(strTemp));

					// allocate memory here
					if(pThreshold[nRecord].tqnum > 0)
						pThreshold[nRecord].tqid = new int[pThreshold[nRecord].tqnum];
					for(int j=0; j<pThreshold[nRecord].tqnum; j++)
					{
						rs.GetFieldValue((short)3+j, strTemp);						
						pThreshold[nRecord].tqid[j] = atoi(LPCSTR(strTemp));

					}
					//check the tqsd value
					if (pThreshold[nRecord].tqsd != 1)
						pThreshold[nRecord].tqsd = 2;

					++nRecord;
					if(nRecord >= ntnum)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 610
		TRACE("Reading card 610\n");
		Log("Reading card 610\n");
		strCard = "table610";
		if(pMTDATA != NULL)
			delete []pMTDATA;

		nNum = ntrgp*ntnum;
		if(nNum > 0)
		{
			pMTDATA = new MON_TDATA[nNum];
			strSQL = "SELECT * FROM table610";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(true)
				{
					rs.GetFieldValue((short)0, strTemp);
					pMTDATA[nRecord].trgid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pMTDATA[nRecord].tnum = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					pMTDATA[nRecord].ttype = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)3, strTemp);
					pMTDATA[nRecord].tdays = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)4, strTemp);
					pMTDATA[nRecord].fnum[0] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)5, strTemp);
					pMTDATA[nRecord].fnum[1] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)6, strTemp);
					pMTDATA[nRecord].fnum[2] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)7, strTemp);
					pMTDATA[nRecord].fnum[3] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)8, strTemp);
					pMTDATA[nRecord].fnum[4] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)9, strTemp);
					pMTDATA[nRecord].fnum[5] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)10, strTemp);
					pMTDATA[nRecord].fnum[6] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)11, strTemp);
					pMTDATA[nRecord].fnum[7] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)12, strTemp);
					pMTDATA[nRecord].fnum[8] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)13, strTemp);
					pMTDATA[nRecord].fnum[9] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)14, strTemp);
					pMTDATA[nRecord].fnum[10] = atof(LPCSTR(strTemp));
					rs.GetFieldValue((short)15, strTemp);
					pMTDATA[nRecord].fnum[11] = atof(LPCSTR(strTemp));
					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
			}
			rs.Close();
		}

		// card 660
		TRACE("Reading card 660\n");
		Log("Reading card 660\n");
		if(pPSReduction != NULL)
		{
			delete []pPSReduction;
			pPSReduction = NULL;
		}

		if(nPtSource > 0)
		{
			pPSReduction = new PSReduction[nPtSource];
			// allocate memory here
			int Num = nPtQuals;
			if (Num > 0)
			{
				for (int i=0; i<nPtSource; i++)
					pPSReduction[i].fReduction_qual = new double[Num];
			}

			// get the sws names	
			strSQL = "SELECT * FROM table660";
			strCard = "table660";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(!rs.IsEOF())
				{
					// get all the parameters
					pPSReduction[nRecord].nPSindex = nRecord+1;	// point source index
					rs.GetFieldValue((short)0, strTemp);
					pPSReduction[nRecord].rchid = atoi(LPCSTR(strTemp));

					//added (2-11-2014)
					int nIndex = FindIndexOrder(pPSReduction[nRecord].rchid);
					if (nIndex == -1)
					{
						CString strError;
						strError.Format("Reach ID: %d: in card 660 is not valid",pPSReduction[nRecord].rchid);
						AfxMessageBox(strError);
						TRACE(strError);
						Log(strError);
						return false;
					}
					rs.GetFieldValue((short)1, strTemp);
					pPSReduction[nRecord].strPermitName = strTemp;
					rs.GetFieldValue((short)2, strTemp);
					pPSReduction[nRecord].strPipeName = strTemp;
					rs.GetFieldValue((short)3, strTemp);
					pPSReduction[nRecord].fReduction_flow = atof(LPCSTR(strTemp));
					for (int i=0; i<Num; i++)
					{
						rs.GetFieldValue((short)i+4, strTemp);
						pPSReduction[nRecord].fReduction_qual[i] = atof(LPCSTR(strTemp));
					}

					++nRecord;
					rs.MoveNext();
				}
				rs.Close();
			}
			rs.Close();
		}
		
		// card 670
		TRACE("Reading card 670 \n");
		Log("Reading card 670 \n");
		if(pTMDLDistrib != NULL)
		{
			delete []pTMDLDistrib;
			pTMDLDistrib = NULL;
		}

		if(ncland > 0)
		{
			int Num = nQuals + 1;	// flow is always there
			if (sedfg == 1)
				Num += 3;			// sand, silt, and clay

			int nNum = nsws*nlandp*Num;
			if(nNum > 0 )
			{
				pTMDLDistrib = new TMDL_LU_QUAL_CPARAM[nNum];
				strSQL = "SELECT * FROM Table670";
				strCard = "table670";
				bRet = rs.ExecDirect(strSQL);
				if(bRet)
				{
					int nRecord = 0;
					while(true)
					{
						rs.GetFieldValue((short)0, strTemp);
						pTMDLDistrib[nRecord*Num].subbasin = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)1, strTemp);
						pTMDLDistrib[nRecord*Num].luid = atoi(LPCSTR(strTemp));
						rs.GetFieldValue((short)2, strTemp);
						pTMDLDistrib[nRecord*Num].strLUName = strTemp;
						for (int i=0; i<Num; ++i)
						{
							pTMDLDistrib[nRecord*Num+i].subbasin = pTMDLDistrib[nRecord*Num].subbasin;
							pTMDLDistrib[nRecord*Num+i].luid = pTMDLDistrib[nRecord*Num].luid;
							pTMDLDistrib[nRecord*Num+i].strLUName = pTMDLDistrib[nRecord*Num].strLUName;

							rs.GetFieldValue((short)i+3, strTemp);
							pTMDLDistrib[nRecord*Num+i].fRatio = atof(LPCSTR(strTemp));
						}
						++nRecord;
						if(nRecord >= nsws*nlandp)
							break;
						rs.MoveNext();
					}
				}
				rs.Close();
			}
		}

		// card 680
		TRACE("Reading card 680 \n");
		Log("Reading card 680 \n");
		if(pMON_SWITCH!=NULL)
		{
			delete []pMON_SWITCH;
			pMON_SWITCH = NULL;
		}

		if(ncrch > 0 && ncrchOutlets > 0)
		{
			// allocate memory here
			int nNum = ncrchOutlets;
			pMON_SWITCH = new MON_SWITCH[nNum];

			int Num = 12;

			// read table	
			strSQL = "SELECT * FROM table680";
			strCard = "table680";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(!rs.IsEOF())
				{
					rs.GetFieldValue((short)0, strTemp);
					pMON_SWITCH[nRecord].rchid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pMON_SWITCH[nRecord].nOutletId = atoi(LPCSTR(strTemp));
					for (int i=0; i<Num; i++)
					{
						rs.GetFieldValue((short)i+2, strTemp);
						pMON_SWITCH[nRecord].nSwitch[i] = atoi(LPCSTR(strTemp));
					}
					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
				rs.Close();
			}
			rs.Close();
		}

		// card 685
		TRACE("Reading card 685 \n");
		Log("Reading card 685 \n");
		if(pBMPLimit!=NULL)
		{
			delete []pBMPLimit;
			pBMPLimit = NULL;
		}

		if(ncrch > 0 && ncrchOutlets > 0)
		{
			// allocate memory here
			int nNum = ncrchOutlets;
			pBMPLimit = new BMPLimit[nNum];

			int Num = nQuals;
			if (sedfg == 1 || oxfg == 1)
				Num += 12;	// sand,silt,clay,RQuals 

			if (Num > 0)
			{
				for (int i=0; i<nNum; i++)
					pBMPLimit[i].fLimit_qual = new double[Num];
			}

			// read table	
			strSQL = "SELECT * FROM table685";
			strCard = "table685";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(!rs.IsEOF())
				{
					rs.GetFieldValue((short)0, strTemp);
					pBMPLimit[nRecord].rchid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pBMPLimit[nRecord].nOutletId = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					pBMPLimit[nRecord].fLimit_flow = atof(LPCSTR(strTemp));
					for (int i=0; i<Num; i++)
					{
						rs.GetFieldValue((short)i+3, strTemp);
						pBMPLimit[nRecord].fLimit_qual[i] = atof(LPCSTR(strTemp));
					}
					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
				rs.Close();
			}
			rs.Close();
		}

		// card 690
		TRACE("Reading card 690 \n");
		Log("Reading card 690 \n");
		if(pBMPReduction!=NULL)
		{
			delete []pBMPReduction;
			pBMPReduction = NULL;
		}

		if(ncrch > 0 && ncrchOutlets > 0)
		{
			// allocate memory here
			int nNum = ncrchOutlets;
			pBMPReduction = new BMPReduction[nNum];

			int Num = nQuals;
			if (sedfg == 1 || oxfg == 1)
				Num += 12;	// sand,silt,clay,RQuals 

			if (Num > 0)
			{
				for (int i=0; i<nNum; i++)
					pBMPReduction[i].fReduction_qual = new double[Num];
			}

			// read table	
			strSQL = "SELECT * FROM table690";
			strCard = "table690";
			bRet = rs.ExecDirect(strSQL);
			if(bRet)
			{
				int nRecord = 0;
				while(!rs.IsEOF())
				{
					rs.GetFieldValue((short)0, strTemp);
					pBMPReduction[nRecord].rchid = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)1, strTemp);
					pBMPReduction[nRecord].nOutletId = atoi(LPCSTR(strTemp));
					rs.GetFieldValue((short)2, strTemp);
					pBMPReduction[nRecord].fReduction_flow = atof(LPCSTR(strTemp));
					for (int i=0; i<Num; i++)
					{
						rs.GetFieldValue((short)i+3, strTemp);
						pBMPReduction[nRecord].fReduction_qual[i] = atof(LPCSTR(strTemp));
					}
					++nRecord;
					if(nRecord >= nNum)
						break;
					rs.MoveNext();
				}
				rs.Close();
			}
			rs.Close();
		}
		
		db.Close();
	}
	CATCH(CException, e)
	{
		db.Close();
		AfxMessageBox("Error reading "+strCard);
		Log("Error reading "+strCard);
		return false;
	}
	END_CATCH;
	
	bReadDB = true;
	char szBuf[_MAX_PATH];
	GetModuleFileName(AfxGetInstanceHandle(),szBuf,_MAX_PATH);
	CString strBat(szBuf);
	nIndex = strBat.ReverseFind('\\');
	if(nIndex != -1)
		strBat = strBat.Left(nIndex+1);
	m_strPath = strBat;
	return true;
}

//SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
//EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
//DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD

/*     + + + PURPOSE + + + */
/*     Accumulate and remove solids independent of runoff. */
/*     the calculation is done at the start of each day, if the */
/*     previous day was dry */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     DAYFG  - flag for first day or day change */
/*     PREC   - ??? */
/*     VASDFG - ??? */
/*     ACCSDM - ??? */
/*     REMSDM - ??? */
/*     VRSDFG - ??? */
/*     MON    - calendar month */
/*     NXTMON - next calendar month */
/*     DAY    - day of month */
/*     NDAYS  - no. of days in this month */
/*     DRYDFG - ??? */
/*     ACCSDP - ??? */
/*     REMSDP - ??? */
/*     SLDS   - ??? */

/*     + + + FUNCTIONS + + + */

/*     + + + C   EXTERNALALS + + + */
/*   EXTERNAL   DAYVAL */

/*     + + + END SPECIFICATIONS + + + */

int CLSPCMODEL::accum(int *dayfg, double *prec, int *drydfg, double *accsdp, double *remsdp, double *slds)
{
	if (*dayfg == 0) 
	{
		//it is not the first interval of a new day
		if (*prec > 0.000001) 
			//it is not a dry day
			*drydfg = 0;
	}
	else
	{
		//it is the first interval of a new day
		if (*drydfg == 1) 
		{
			//precipitation did not occur during the previous day

			//update storage due to accumulation and removal which
			//occurs independent of runoff - units are lbs/acre
			*slds = *accsdp + *slds * (1.0 - *remsdp);	// (09-09-05)
		}
		else
		{
			//precipitation did occur during the previous day, so there
			//is no accumulation or removal independent of runoff
		}
		if (*prec > 0.000001) 
			//there is precipitation on the first interval of the new day
			*drydfg = 0;
		else
			//day is dry so far
			*drydfg = 1;
	}
	return 0;
} 

int CLSPCMODEL::accum2(int dayfg, double prec, int& drydfg, double accsdp, double remsdp, 
					   double& slds, double fr_sand_bs, double fr_silt_bs, double fr_clay_bs,
					   double& fr_sand, double& fr_silt, double& fr_clay)
{
	if (dayfg == 0) 
	{
		//it is not the first interval of a new day
		if (prec > 0.000001) 
			//it is not a dry day
			drydfg = 0;
	}
	else
	{
		//it is the first interval of a new day
		if (drydfg == 1) 
		{
			//precipitation did not occur during the previous day

			//update storage due to accumulation and removal which
			//occurs independent of runoff - units are lbs/acre ?
			//slds = accsdp + slds * (1.0 - remsdp);	// (09-09-05)
			
			double oldBuildup_sand = slds * (1.0 - remsdp) * fr_sand;//tons/ac
			double oldBuildup_silt = slds * (1.0 - remsdp) * fr_silt;//tons/ac
			double oldBuildup_clay = slds * (1.0 - remsdp) * fr_clay;//tons/ac

			double newBuildup_sand = accsdp * fr_sand_bs;//tons/ac
			double newBuildup_silt = accsdp * fr_silt_bs;//tons/ac
			double newBuildup_clay = accsdp * fr_clay_bs;//tons/ac

			slds = oldBuildup_sand + oldBuildup_silt + oldBuildup_clay
				 + newBuildup_sand + newBuildup_silt + newBuildup_clay;//tons/ac

			if (fabs(fr_sand - fr_sand_bs) > 0.0000001)
			{
				//street sweeping is applied
				fr_sand = 0.0;
				if (slds > 0)
					fr_sand = (oldBuildup_sand+newBuildup_sand)/slds;
			}
			if (fabs(fr_silt - fr_silt_bs) > 0.0000001)
			{
				//street sweeping is applied
				fr_silt = 0.0;
				if (slds > 0)
					fr_silt = (oldBuildup_silt+newBuildup_silt)/slds;
			}
			if (fabs(fr_clay - fr_clay_bs) > 0.0000001)
			{
				//street sweeping is applied
				fr_clay = 0.0;
				if (slds > 0)
					fr_clay = (oldBuildup_clay+newBuildup_clay)/slds;
			}
		}
		else
		{
			//precipitation did occur during the previous day, so there
			//is no accumulation or removal independent of runoff
		}
		if (prec > 0.000001) 
			//there is precipitation on the first interval of the new day
			drydfg = 0;
		else
			//day is dry so far
			drydfg = 1;
	}
	return 0;
} 

//     + + + PURPOSE + + +  
//     Simulate attachment or compaction of detached sediment on the  
//     surface.  The calculation is done at the start of each day, if  
//     the previous day was dry  

//     + + + KEYWORDS + + +  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     NBLKS  - number of blocks into which pls zones will be subdivided  
//     AFFIX  - ???  
//     NBLKSI - ???  
//     DETS   - ???  
//     DETSB  - ???  

//     + + +   + + +  

//     + + + END SPECIFICATIONS + + +  

//     this subroutine was modified to allow optional  
//     sed loading on dry days (chesapeake bay)  
//     precipitation did not occur during the previous day  
//     the attachment of surface sediment to the soil matrix is  
//     taken into account by decreasing the storage of detached  
//     sediment  

int CLSPCMODEL::atach(double *affix, double *dets)
{
	int i = 0;
	
//    *dets *= 1.0 - *affix/24.0;			
//    *dets *= 1.0 - *affix/(1440.0/deltm);
    *dets *= 1.0 - *affix * deltd;

    return 0;
} 

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   BDEXCH

      + + + PURPOSE + + +
      Simulate deposition and scour of a cohesive sediment 
	  fraction-silt or clay
 
C     + + + ARGUMENT DEFINITIONS + + +
C     AVDEPM - ???
C     W      - ???
C     TAU    - ???
C     TAUCD  - ???
C     TAUCS  - ???
C     M      - ???
C     VOL    - volume of water in reach above bed
C     FRCSED - ???
C     SUSP   - ???
C     BED    - ???
C     DEPSCR - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::BDEXCH(double AVDEPM,double W,double TAU,double TAUCD,double TAUCS,
					   double M,double VOL,double FRCSED,double *SUSP,double *BED,
					   double *DEPSCR)
{
      double DEPMAS,EXPNT,SCR,SCRMAS;
 
      if (W>0.0 && TAU<TAUCD && *SUSP>1.0E-30) 
	  {
        //deposition will occur
        EXPNT = -W/AVDEPM*(1.0 - TAU/TAUCD);
        DEPMAS= *SUSP*(1.0 - exp(EXPNT));		// mg/l*m3
        *SUSP  = *SUSP - DEPMAS;				// mg/l*m3
        *BED   = *BED + DEPMAS;					// mg/l*m3
      }
	  else
	  {
        //no deposition- concentrations unchanged
        DEPMAS= 0.0;							// mg/l*m3
      }
 
      if (TAU>TAUCS && M>0.0) 
	  {
		  if (TAUCS == 0)	TAUCS = 1.0E-15;
        //scour can occur- units are:
         //m- kg/m2.ivl  avdepm- m  scr- mg/l
 
        SCR= FRCSED*M/AVDEPM*1000.*(TAU/TAUCS - 1.0);	// mg/l
 
        //check availability of material
        SCRMAS= SCR*VOL;						// mg/l*m3
 
        if (SCRMAS > *BED) 
          SCRMAS= *BED;							// mg/l*m3
 
        //update storages
        *SUSP= *SUSP + SCRMAS;					// mg/l*m3
        *BED = *BED - SCRMAS;					// mg/l*m3
      }
	  else
	  {
        //no scour
        SCRMAS= 0.0;							// mg/l*m3
      }
      //calculate net deposition or scour
      *DEPSCR= DEPMAS - SCRMAS;					// mg/l*m3

    return 0;
}
  
//    + + + PURPOSE + + +  
//    Simulate behavior of cohesive sediments (silt and clay)  

//    + + + DUMMY ARGUMENTS + + + 

//    + + + ARGUMENT DEFINITIONS + + +  
//    ISED   - ???  
//    VOLS   - ??? 
//    SROVOL - ??? 
//    VOL    - volume of water in reach above bed  
//    EROVOL - ???  
//    SOVOL  - ??? 
//    EOVOL  - ??? 
//    NEXITS - number of exits from the operation  
//    AVDEPM - ???  
//    AVDEPE - ??? 
//    SDPM   - ??? 
//    TAU    - ??? 
//    SSED   - ??? 
//    RSED   - ??? 
//    ROSED  - ??? 
//    OSED   - ??? 
//    DEPSCR - ??? 

//    + + +   + + +  

//    + + + C   EXTERNALALS + + +  
//  EXTERNAL   ADVECT,BDEXCH  

//    + + + END SPECIFICATIONS + + +  
/*
int CLSPCMODEL::cohesv(double *ised, double *vols, double *srovol, double *vol, double *erovol,
					double *sovol, double *eovol, int *nexits, double *avdepm, double *avdepe,
					double *sdpm, double *tau, double *ssed, double *rsed, double *rosed,
					double *osed, double *depscr)
{
    int j;
    double frcsed[2];
    double totbed;
    double dpssed[3];
	
	//     compute bed fractions for scour apportionment 
    
	
	
    //--depscr;
    //osed -= 6;
    //--rosed;
    //--rsed;
    //--ssed;
    //sdpm -= 7;
    //--eovol;
    //--sovol;
    //--ised;
	
    
    totbed = rsed[4] + rsed[5];
	
    if (totbed > 0.0)
	{
		
		frcsed[0] = rsed[4] / totbed;
		frcsed[1] = rsed[5] / totbed;
    }
	else
	{
		//       no bed at start of interval, assume equal fractions 
		frcsed[0] = 0.5;
		frcsed[1] = 0.5;
    }
	
    for (j = 1; j <= 2; ++j)
	{
		
		dpssed[j] = ssed[j];
		
		//advect(&ised[j], vols, srovol, vol, erovol, &sovol[0], &eovol[0],
		//nexits, &dpssed[j], &rosed[j], &osed[j * 5 + 1]);
		
		
		ssed[j] = dpssed[j - 1];
		
		//      calculate exchange between bed and suspended sediment 
		rsed[j] = ssed[j] * *vol;
		
		if (*avdepe > 0.17)
		{
			//        consider deposition and scour 
			
			//			bdexch(avdepm, &sdpm[j * 6 + 2], tau, &sdpm[j * 6 + 4], &sdpm[j *
			//				6 + 5], &sdpm[j * 6 + 6], vol, &frcsed[j - 1], &rsed[j],
			//				&rsed[j + 3], &depscr[j]);
			
		}
		else
		{
			//         rchres depth is less than two inches - 
			//         no deposition or scour is allowed 
			depscr[j] = 0.0;
		}
		
		if (*vol > 0.0)
		{
			//         water is present in the rchres 
			ssed[j] = rsed[j] / *vol;
		} else {
			//         rchres is dry 
			ssed[j] = -1e30;
		}
		
		// L10: 
    }
	
    return 0;
} 
*/

//     + + + PURPOSE + + +  
//     This subroutine uses colby's method to calculate the capacity of  
//     the flow to transport sand.  
//      called by: sandld  
//     the colby method has the following units and applicable ranges of  
//     variables.  
//        average velocity.............v.......fps.........1-10 fps  
//        hydraulic radius.............fhrad...ft..........1-100 ft  
//        median bed material size.....db50....mm..........0.1-0.8 mm  
//        temperature..................tmpr....deg f.......32-100 deg.  
//        fine sediment concentration..fsl.....mg/liter....0-200000 ppm  
//        total sediment load..........gsi.....ton/day.ft..  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//	   V      - average velocity (ft/s)  
//	   DB50M  - median bed sediment diameter (mm)  
//	   FHRAD  - hydraulic radius   (ft)  
//     FSL    - total concentration of suspended silt and clay  
//              (fine sediment) (mg/l)  
//     MESSU  - ftn unit no. to be used for printout of messages  
//     TEMPR  - water temperature (degrees c)  
//     GSI    - total sand transport (tons/day.ft width)  
//     FERROR - fatal error flag (if on, switch to toffaleti method)  
//     D50ERR - ???  
//     HRERR  - ???  
//     VELERR - ???  

//     + + +   + + +  

//     + + + INTRINSICS + + +  

//     + + + DATA INITIALIZATIONS + + +  
//     + + + OUTPUT FORMATS + + +  

//     + + + END SPECIFICATIONS + + +  


int CLSPCMODEL::colby(double *v, double *db50m, double *fhrad, double *fsl,
				   double *tempr, double *gsi, int *ferror,
				   int *d50err, int *hrerr, int *velerr)
{
    // Initialized data 
	
	double g[192] ={1.0, 0.3, 0.06, 0.0, 3.0, 3.3, 2.5, 2.0, 5.4, 9.0,
					10.0, 20.0, 11.0, 26.0,	50.0, 150.0, 17.0, 49.0, 130.0, 500.0,
					29.0, 101.0, 400.0, 1350.0, 44.0, 160.0, 700.0, 2500.0, 60.0, 220.0,
					1e3, 4400.0, 0.38, 0.06, 0.0, 0.0, 1.6, 1.2, 0.65, 0.1,
					3.7, 5.0, 4.0, 3.0, 10.0, 18.0, 30.0, 52.0, 17.0, 40.0,
					80.0, 160.0, 36.0, 95.0, 230.0, 650.0, 60.0, 150.0, 415.0, 1200.0,
					81.0, 215.0, 620.0, 1500.0, 0.14, 0.0, 0.0, 0.0, 1.0, 0.6,
					0.15, 0.0, 3.3, 3.0, 1.7, 0.5, 11.0, 15.0, 17.0, 14.0,
					20.0, 35.0, 49.0, 70.0, 44.0, 85.0, 150.0, 250.0, 71.0, 145.0,
					290.0, 500.0, 100.0, 202.0, 400.0, 700.0, 0.0, 0.0, 0.0, 0.0,
					0.7, 0.3, 0.06, 0.0, 2.9, 2.3, 1.0, 0.06, 11.5, 13.0,
					12.0, 7.0, 22.0, 31.0, 40.0, 50.0, 47.0, 84.0, 135.0, 210.0,
					75.0, 140.0, 240.0, 410.0, 106.0, 190.0, 350.0, 630.0, 0.0, 0.0,
					0.0, 0.0, 0.44, 0.06, 0.0, 0.0, 2.8, 1.8, 0.6, 0.0,
					12.0, 12.5, 10.0, 4.5, 24.0, 30.0, 35.0, 37.0, 52.0, 78.0,
					120.0, 190.0, 83.0, 180.0, 215.0, 380.0, 120.0, 190.0, 305.0, 550.0,
					0.0, 0.0, 0.0, 0.0, 0.3, 0.0, 0.0, 0.0, 2.9, 1.4,
					0.3, 0.0, 14.0, 11.0, 7.7, 3.0, 27.0, 29.0, 30.0, 30.0,
					57.0, 75.0, 110.0, 170.0, 90.0, 140.0, 200.0, 330.0, 135.0, 190.0,
					290.0, 520.0};
    double d50g[6]={0.1, 0.2, 0.3, 0.4, 0.6, 0.8};
    double temp[7]={32.0, 40.0, 50.0, 70.0, 80.0, 90.0, 100.0};
    double f[50] = {1.0, 1.1, 1.6, 2.6, 4.2, 1.0, 1.1, 1.65, 2.75, 4.9,
					1.0, 1.1, 1.7, 3.0, 5.5, 1.0, 1.12, 1.9, 3.6, 7.0,
					1.0, 1.17, 2.05, 4.3, 8.7, 1.0, 1.2, 2.3, 5.5, 11.2,
					1.0, 1.22, 2.75, 8.0, 22.0, 1.0, 1.25, 3.0, 9.6, 29.0,
					1.0, 1.3, 3.5, 12.0, 43.0, 1.0, 1.4, 4.9, 22.0, 120.0};
    double t[28] = {1.2, 1.15, 1.1, 0.96, 0.9, 0.85, 0.82, 1.35, 1.25, 1.12,
					0.92, 0.86, 0.8, 0.75, 1.6, 1.4, 1.2, 0.89, 0.8, 0.72,
					0.66, 2.0, 1.65, 1.3, 0.85, 0.72, 0.63, 0.55};
    double df[10] ={0.1, 0.2, 0.3, 0.6, 1.0, 2.0, 6.0, 10.0, 20.0, 100.0};
    double cf[5] = {0.0, 1e4, 5e4, 1e5, 1.5e5};
    double p[11] = {0.6, 0.9, 1.0, 1.0, 0.83, 0.6, 0.4, 0.25, 0.15, 0.09, 0.05};
    double dp[11] ={0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0};
    double dg[4] = {0.1, 1.0, 10.0, 100.0};
    double vg[8] = {1.0, 1.5, 2.0, 3.0, 4.0, 6.0, 8.0, 10.0};
    double r1, r2, r3;
    double d1;
	
    double gtuc, tmpr;
    int i, j, k;
    double x[4];	// was [2][2] ;
    int i1, j1, j3, k1;
    double p1, p2;
    int ii[2], jj[2], kk[2];
    double xa[2], xd, xf[4]	// was [2][2] 
		, xg[2], xr, xt[4] // was [2][2] 
		, xv, xx[2], yy[2], zz[2];
		int id1, id2, if1, if2, ip1, ip2, it1, it2, iv1, iv2;
    double xn1, xn2, xn3, xn4, db50, cfd, cff, fff, cft, tcf, xct[2],
		xdx, xdy, xdz, xnt;
    int id501, id502;
	
	
    db50 = *db50m;
    tmpr = *tempr * 1.8 + 32.0;
	
	//      fsl....fine sediment (i.e. cohesive sediment or wash) load 
	//      in mg/liter 
	
    *ferror = 0;
    *d50err = 0;
    *hrerr = 0;
    *velerr = 0;
	
    if (db50 >= d50g[0] && db50 <= d50g[5])
	{
		goto L10;
    }
    *ferror = 1;
    *d50err = 1;
L10:
    if (*fhrad >= dg[0] && *fhrad <= dg[3])
	{
		goto L20;
    }
    *ferror = 1;
    *hrerr = 1;
L20:
    if (*v >= vg[0] && *v <= vg[7])
	{
		goto L30;
    }
    *ferror = 1;
    *velerr = 1;
L30:
    if (*ferror != 0)
		goto L400;

    if (tmpr >= 32.0)
		goto L40;

    tmpr = 32.0;
L40:
    if (tmpr <= 100.0)
		goto L45;

    tmpr = 100.0;
L45:
    id1 = 0;
    id2 = 0;
    for (i = 1; i <= 3; ++i)
	{
		if (*fhrad < dg[i - 1] || *fhrad > dg[i])
		{
			goto L50;
		}
		id1 = i;
		id2 = i + 1;
		goto L70;
L50:
		// L60:
		;
    }
L70:
    iv1 = 0;
    iv2 = 0;
    for (i = 1; i <= 7; ++i)
	{
		if (*v < vg[i - 1] || *v > vg[i])
		{
			goto L80;
		}
		iv1 = i;
		iv2 = i + 1;
		goto L100;
L80:
		// L90: 
		;
    }
L100:
    id501 = 0;
    id502 = 0;
    for (i = 1; i <= 5; ++i)
	{
		if (db50 < d50g[i - 1] || db50 > d50g[i])
		{
			goto L110;
		}
		id501 = i;
		id502 = i + 1;
		goto L130;
L110:
		// L120: 
		;
    }
L130:
    ii[0] = id1;
    ii[1] = id2;
    jj[0] = iv1;
    jj[1] = iv2;
    kk[0] = id501;
    kk[1] = id502;
    for (i = 1; i <= 2; ++i)
	{
		i1 = ii[i - 1];
		xx[i - 1] = log10(dg[i1 - 1]);
		for (j = 1; j <= 2; ++j) {
			j1 = jj[j - 1];
			yy[j - 1] = log10(vg[j1 - 1]);
			for (k = 1; k <= 2; ++k) {
				k1 = kk[k - 1];
				zz[k - 1] = log10(d50g[k1 - 1]);
				if (g[i1+(j1+((k1<<3)<<2))-37] > 0.0) 
				{
					goto L160;
				}
				for (j3 = j1; j3 <= 7; ++j3) {
					if (g[i1 + (j3 + ((k1 << 3) << 2)) - 37] > 0.0) {
						goto L150;
					}
					// L140: 
				}
L150:
				r1 = vg[j1 - 1] / vg[j3 - 1];
				r2 = g[i1 + (j3 + 1 + ((k1 << 3) << 2)) - 37] / g[i1 + (j3 + ((
					k1 << 3) << 2)) - 37];
				r3 = vg[j3] / vg[j3 - 1];
				x[j + (k << 1) - 3] = log10(g[i1 + (j3 + ((k1 << 3) << 2)) -
					37]) + log10(r1) * log10(r2) / log10(r3);
				goto L170;
L160:
				x[j + (k << 1) - 3] = log10(g[i1 + (j1 + ((k1 << 3) << 2)) -
					37]);
L170:
				//L180: 
				;
			}
			// L190: 
		}
		xd = log10(db50) - zz[0];
		xn1 = x[2] - x[0];
		xn2 = x[3] - x[1];
		xdz = zz[1] - zz[0];
		xa[0] = x[0] + xn1 * xd / xdz;
		xa[1] = x[1] + xn2 * xd / xdz;
		xv = log10(*v) - yy[0];
		xn3 = xa[1] - xa[0];
		xdy = yy[1] - yy[0];
		xg[i - 1] = xa[0] + xn3 * xv / xdy;
		// L200: 
    }
    xn4 = xg[1] - xg[0];
    xr = log10(*fhrad) - xx[0];
    xdx = xx[1] - xx[0];
    gtuc = xg[0] + xn4 * xr / xdx;
    d1 = gtuc;
    gtuc = pow(10.0, d1);
	
	//       gtuc is uncorrected gt in lb/sec/ft 
	
	//       next apply fine sediment load and temperature /
	//                                             corrections 
	
	//       if (tmpr .ne. 60.) go to 210 
	r1 = tmpr - 60.0;
    if (fabs(r1) > 1e-5)
		goto L210;

    cft = 1.0;
    goto L250;
L210:
    it1 = 0;
    it2 = 0;
    for (i = 1; i <= 6; ++i) {
		if (tmpr < temp[i - 1] || tmpr > temp[i]) {
			goto L220;
		}
		it1 = i;
		it2 = i + 1;
		goto L240;
L220:
		// L230: 
		;
    }
L240:
    xt[0] = log10(t[it1 + id1 * 7 - 8]);
    xt[1] = log10(t[it2 + id1 * 7 - 8]);
    xt[2] = log10(t[it1 + id2 * 7 - 8]);
    xt[3] = log10(t[it2 + id2 * 7 - 8]);
    r1 = tmpr / temp[it1 - 1];
    r2 = temp[it2 - 1] / temp[it1 - 1];
    xnt = log10(r1) / log10(r2);
    xct[0] = xt[0] + xnt * (xt[1] - xt[0]);
    xct[1] = xt[2] + xnt * (xt[3] - xt[2]);
    cft = xct[0] + (xct[1] - xct[0]) * xr / xdx;
    d1 =  cft;
    cft = pow(10.0, d1);
L250:
	
	//        fine sediment load correction 
	
    if (*fsl > 10.0)
		goto L260;

    cff = 1.0;
    goto L350;
L260:
    id1 = 0;
    id2 = 0;
    for (i = 1; i <= 9; ++i) {
		if (*fhrad < df[i - 1] || *fhrad > df[i]) {
			goto L270;
		}
		id1 = i;
		id2 = i + 1;
		goto L290;
L270:
		// L280: 
		;
    }
L290:
    if (*fsl <= 1e5)
		goto L300;

    if1 = 4;
    if2 = 5;
    goto L340;
L300:
    if1 = 0;
    if2 = 0;
    for (i = 1; i <= 4; ++i) {
		if (*fsl < cf[i - 1] || *fsl > cf[i]) {
			goto L310;
		}
		if1 = i;
		if2 = i + 1;
		goto L330;
L310:
		//L320: 
		;
    }
L330:
L340:
    xf[0] = log10(f[if1 + id1 * 5 - 6]);
    xf[3] = log10(f[if2 + id2 * 5 - 6]);
    xf[2] = log10(f[if1 + id2 * 5 - 6]);
    xf[1] = log10(f[if2 + id1 * 5 - 6]);
    xnt = (*fsl - cf[if1 - 1]) / (cf[if2 - 1] - cf[if1 - 1]);
    xct[0] = xf[0] + xnt * (xf[1] - xf[0]);
    xct[1] = xf[2] + xnt * (xf[3] - xf[2]);
    r1 = *fhrad / df[id1 - 1];
    r2 = df[id2 - 1] / df[id1 - 1];
    xnt = log10(r1) / log10(r2);
    cff = xct[0] + xnt * (xct[1] - xct[0]);
    d1 =  cff;
    cff = pow(10.0, d1);
L350:
    tcf = cft * cff - 1.0;
    cfd = 1.0;
    if (db50 >= 0.2 && db50 <= 0.3) {
		goto L390;
    }
    ip1 = 0;
    ip2 = 0;
    for (i = 1; i <= 10; ++i) {
		if (db50 < dp[i - 1] || db50 > dp[i]) {
			goto L360;
		}
		ip1 = i;
		ip2 = i + 1;
		goto L380;
L360:
		// L370: 
		;
    }
L380:
    p2 = log10(p[ip2 - 1]);
    p1 = log10(p[ip1 - 1]);
    r1 = db50 / dp[ip1 - 1];
    r2 = dp[ip2 - 1] / dp[ip1 - 1];
    xnt = log10(r1) / log10(r2);
    cfd = p1 + xnt * (p2 - p1);
    d1 =  cfd;
    cfd = pow(10.0, d1);
L390:
    fff = cfd * tcf;
    fff += 1.0;
    *gsi = fff * gtuc;
	
L400:
    return 0;
} // colby_ 


//     + + + PURPOSE + + +  
//     Detach soil by rainfall  

//     + + + KEYWORDS + + +  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     DAYFG  - flag for first day or day change  
//     CRVFG  - ???  
//     COVERM - ???  
//     MON    - calendar month  
//     NXTMON - next calendar month  
//     DAY    - day of month  
//     NDAYS  - no. of days in this month  
//     RAIN   - ???  
//     CSNOFG - ??? 
//     SNOCOV - ??? 
//     DELT60 - simulation time interval in hours         
//     SMPF   - ???  
//     KRER   - ??? 
//     JRER   - ??? 
//     NBLKS  - number of blocks into which pls zones will be subdivided  
//     COVER  - ???  
//     DETS   - ??? 
//     DETSB  - ??? 
//     DET    - ??? 

//     + + +   + + +  

//     + + + FUNCTIONS + + +  

//     + + + C   EXTERNALALS + + +  
//     EXTERNAL   DAYVAL  

//     + + + END SPECIFICATIONS + + + 
 
int CLSPCMODEL::detach(int *dayfg, int *crvfg, double *coverm, int *mon, int *nxtmon,int *day,
					   int *ndays,double *rain, int *csnofg, double *snocov, double *delt60,
					   double *smpf, double *krer, double *jrer, double *cover,double *dets,
					   double *det)
{
    double d1, d2;
    double cr;
 
//    if (*dayfg != 1) goto L30;

 		// it is the first interval of the day 
		if (*crvfg != 1) goto L10;

			// erosion related cover is allowed to vary throughout the 
			// year 
			// interpolate for the daily value 
			// linearly interpolate cover between two values from the 
			// monthly array coverm(12) 
			*cover = dayval(&coverm[*mon], &coverm[*nxtmon], day, ndays);
			goto L20;

L10:
			// erosion related cover does not vary throughout the year. 
			// cover value has been supplied by the run interpreter 
L20:
 	
//L30:
	if (*rain <= 0.0) goto L80;

		// simulate detachment because it is raining 
		// find the proportion of area shielded from raindrop impact by 
		// snowpack and other cover 
		if (*csnofg == 1) 	//   (08-05-04)
		{
			// snow is being considered 
			if (*snocov > 0.0) 
			{
				// there is a snowpack 
				cr = *cover + (1.0 - *cover) * *snocov;
			} 
			else 
			{
				cr = *cover;
			}
		} 
		else
		{
			cr = *cover;
		}

		// calculate the rate of soil detachment  
		// units are tons/acre-ivl  
		d1 =  (*rain / *delt60);
		d2 =  (*jrer);
		*det = *delt60 * (1.0 - cr) * *smpf * *krer * pow(d1, d2);
		
		// augment detached sediment storage - units are tons/acre  
		*dets += *det;
		goto L90;
L80:
	 	// no rain - either it is snowing or it is "dry"  
	     *det = 0.0;
L90:
    return 0;
}  

//    + + + PURPOSE + + +  
//    Simulate removal of a quality constituent from the land  
//    surface by association with sediment  

//    + + + KEYWORDS + + +  

//    + + + DUMMY ARGUMENTS + + +  

//    + + + ARGUMENT DEFINITIONS + + +  
//    DAYFG  - flag for first day or day change  
//    VPFWFG - ???  
//    VPFSFG - ???  
//    WSSD   - ??? 
//    SCRSD  - ??? 
//    POTFWM - ??? 
//    POTFSM - ??? 
//    MON    - calendar month  
//    NXTMON - next calendar month  
//    DAY    - day of month  
//    NDAYS  - no. of days in this month  
//    POTFW  - ???  
//    POTFS  - ??? 
//    WASHQS - ??? 
//    SCRQS  - ??? 
//    SOQS   - ??? 

//    + + + FUNCTIONS + + +  

//    + + + C   EXTERNALALS + + +  
//    EXTERNAL   DAYVAL  

//    + + + INTRINSICS + + +  

//    + + + END SPECIFICATIONS + + +  

//    + + + PURPOSE + + +  
//    Simulate behavior of sand/gravel  
//    variables are r4 unless otherwise stated  

//    + + + DUMMY ARGUMENTS + + +  

//    + + + ARGUMENT DEFINITIONS + + +  
//    ISAND  - ???  
//    VOLS   - ??? 
//    SROVOL - ??? 
//    VOL    - volume of water in reach above bed  
//    EROVOL - ???  
//    SOVOL  - ??? 
//    EOVOL  - ??? 
//    NEXITS - number of exits from the operation  
//    KSAND  - ??? 
//    AVVELE - ???
//    EXPSND - ???
//    ROM    - ???
//    SANDFG - ???
//    DB50E  - ???
//    HRADE  - ???
//    SLOPE  - ???
//    TW     - water temperature in degrees C  
//    WSANDE - ???  
//    TWIDE  - ??? 
//    DB50M  - ??? 
//    FSL    - ??? 
//    RCHNO  - ??? 
//    MESSU  - ftn unit no. to be used for printout of messages  
//    MSGFL  - fortran unit number of HSPF message file  
//    AVDEPE - ???  
//    SAND   - ??? 
//    RSAND  - ??? 
//    BDSAND - ??? 
//    SDWCT2 - ??? 
//    DEPSCR - ??? 
//    ROSAND - ??? 
//    OSAND  - ??? 
//    DATIM  - date and time  

//    + + +   + + +  

//    + + + C   EXTERNALALS + + +  
//  EXTERNAL   OMSTI,OMSTD,OMSG,OMSTR,COLBY,TOFFAL  

//    + + + END SPECIFICATIONS + + +  

int CLSPCMODEL::sandld(double isand,double vols,double srovol,double vol,double erovol,
					   double ksand,double avvele,double expsnd,double rom,int sandfg, 
					   double db50e,double hrade,double slope,double tw, double wsande,
					   double twide,double db50m,double fsl,double avdepe,double& sand, 
					   double& rsand,double& bdsand,double& depscr,double& rosand)
{
    int d50err, hrerr, ferror, velerr;
	double gsi;
	
    double sands = sand;	// mg/l
	double psand = 0.0;
	double scour = 0.0;
	double prosnd = 0.0;
	double pscour = 0.0;
	
    if (vol > 0.0)	// m3
	{
		// rchres contains water 
		if (rom > 0.0 && avdepe > 0.17)
		{
			// there is outflow from the rchres- perform advection 
			// calculate potential value of sand 
			switch (sandfg)
			{
			case 1:  
				// toffaleti equation 
				toffal(&avvele, &db50e, &hrade, &slope, &tw, &wsande, &gsi);
				
				// convert potential sand transport rate to a concentration 
				// in mg/l 
				psand = gsi * twide * 10.5 / rom;
				break;
			case 2:  
				// colby equation 
				colby(&avvele, &db50m, &hrade, &fsl, &tw, &gsi, &ferror, 
					  &d50err, &hrerr, &velerr);
				
				if (ferror == 1)
				{
					CString WarnMessage;
					WarnMessage.Format("fatal error ocurred in colby method\n - one or more variables went outside valid range\n - switch to toffaleti method\n");

					Log(WarnMessage);
					TRACE(WarnMessage);
					
					// switch to toffaleti method 
					toffal(&avvele, &db50e, &hrade, &slope, &tw, &wsande, &gsi);
				}
				
				// convert potential sand transport rate to conc in mg/l 
				psand = gsi * twide * 10.5 / rom;
				break;
			case 3:  
				// input power function 
				psand = ksand * pow(avvele, expsnd); // mg/l
				break;
			default:
				break;
			}
			
			// calculate potential outflow of sand during ivl (mg/l * m3 = g)
			prosnd = sands * srovol + psand * erovol;
			
			// calculate potential scour from, or to deposition, bed storage
			// scour is expressed as qty.vol/l.ivl (g)
			pscour = vol * psand - vols * sands + prosnd - isand;
			
			if (pscour < bdsand)
			{
				// potential scour is satisfied by bed storage; new conc. 
				// of sandload is potential conc. 
				scour = pscour;
				sand = psand;
				rsand = sand * vol;
				bdsand -= scour;
			}
			else
			{
				// potential scour cannot be satisfied; all of the 
				// available bed storage is scoured 
				scour = bdsand;
				bdsand = 0.0;
				
				// calculate new conc. of suspended sandload 
				sand = (isand + scour + sands * (vols - srovol)) / (vol	+ erovol);
				
				// calculate new storage of suspended sandload 
				rsand = sand * vol;
			}
			
			// calculate total amount of sand leaving rchres during ivl 
			rosand = srovol * sands + erovol * sand;
		} 
		else 
		{
			// no outflow (still water) or water depth less than two inches 
			sand = 0.0;
			rsand = 0.0;
			scour = -(isand) - sands * vols;
			bdsand -= scour;
			rosand = 0.0;
		}
	} 
	else 
	{
		// rchres is dry; set sand equal to an undefined number 
		sand = 0.0;
		rsand = 0.0;
		
		// calculate total amount of sand settling out during interval; 
		// this is equal to sand inflow + sand initially present 
		scour = -(isand) - sands * vols;
		
		// update bed storage 
		bdsand -= scour;
		
		// assume zero outflow of sand 
		rosand = 0.0;
    }
	
	// calculate depth of bed scour or deposition; positive for 
	// deposition 
    depscr = -scour;

    return 0;
}  


//     + + + PURPOSE + + +  
//     Warning,  this method of computing sediment removal contains a  
//     dimensionally non-homogeneous term (surs+ suro).  this introduces  
//     additional dependence of the results on the simulation interval  
//     delt.  so far, it has only been used with delt of 15 and 5  
//     minutes.  

//     + + + KEYWORDS + + +  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     NBLKS  - number of blocks into which pls zones will be subdivided  
//     SURO   - surface output  
//     SURS   - ???  
//     SUROB  - ??? 
//     SURSB  - ??? 
//     DELT60 - simulation time interval in hours            
//     KSER   - ???  
//     JSER   - ??? 
//     KGER   - ??? 
//     JGER   - ??? 
//     NBLKSI - ??? 
//     DETS   - ??? 
//     DETSB  - ??? 
//     WSSD   - ??? 
//     SCRSD  - ??? 
//     SOSED  - ??? 
//     WSSDB  - ??? 
//     SCRSDB - ??? 
//     SOSDB  - ??? 
//     STCAP  - ??? 
//     STCAPB - ??? 

//     + + +   + + +  

//     + + + END SPECIFICATIONS + + +  

int CLSPCMODEL::sosed1(double *suro,double *surs,double *delt60, double *kser, double *jser, 
					double *kger, double *jger,double *dets,double *wssd, double *scrsd,
					double *sosed)
{
    double d1, d2;
	double arg,stcap;
	
	// Remove both detached surface sediment and soil matrix by surface  
	// Flow using method 1  
    if (*suro <= 0.0) goto L30;

		// surface runoff occurs, so sediment and soil matrix  
		// particles may be removed, delt60= delt/60  
		// get argument used in transport equations  
		arg = *surs + *suro;
		
		// calculate capacity for removing detached sediment - units  
		// are tons/acre-ivl  
		d1 =  (arg / *delt60);
		d2 =  (*jser);
		stcap = *delt60 * *kser * pow(d1, d2);
		
		if (stcap <= *dets) goto L10;

			// there is insufficient detached storage, base sediment  
			// removal on that available, wssd is in tons/acre-ivl  
			*wssd = *dets * *suro / arg;
			goto L20;
L10:
	// there is sufficient detached storage, base sediment  
	// removal on the calculated capacity  
	*wssd = stcap * *suro / arg;
L20:
	*dets -= *wssd;
	
	// calculate scour of matrix soil by surface runoff -  
	// units are tons/acre-ivl  
	d1 =  (arg / *delt60);
	d2 =  (*jger);
	*scrsd = *delt60 * *kger * pow(d1, d2);
	*scrsd = *scrsd * *suro / arg;
	
	// total removal by runoff  
	*sosed = *wssd + *scrsd;
	goto L40;
L30:
	// no runoff occurs, so no removal by runoff  
	*wssd = 0.0;
    *scrsd = 0.0;
    *sosed = 0.0;
L40:
    return 0;
}

//     + + + PURPOSE + + +  
//     Warning,  this method of computing sediment removal has not  
//     been tested.  but it is dimensionally homogeneous  

//     + + + KEYWORDS + + +  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     NBLKS  - number of blocks into which pls zones will be subdivided  
//     SURO   - surface output  
//     SUROB  - ???  
//     DELT60 - simulation time interval in hours           
//     KSER   - ???  
//     JSER   - ??? 
//     KGER   - ??? 
//     JGER   - ??? 
//     NBLKSI - ??? 
//     DETS   - ??? 
//     DETSB  - ??? 
//     WSSD   - ??? 
//     SCRSD  - ??? 
//     SOSED  - ??? 
//     WSSDB  - ??? 
//     SCRSDB - ??? 
//     SOSDB  - ??? 
//     STCAP  - ??? 
//     STCAPB - ??? 

//     + + +   + + +  

//     + + + END SPECIFICATIONS + + +  
/*
int CLSPCMODEL::sosed2(double *suro,double *delt60,double *kser, double *jser, double *kger, 
					double *jger,double *dets,double *wssd,double *scrsd, double *sosed)
{
    double d1,d2,stcap;

	// scrsd = scour of matrix
	// wssd  = washoff of detached sed.
	// sosed = total sed. outflow

	// Remove both detached surface sediment and soil matrix by surface flow 
	// using method 2  
	
	// surface and near-surface zones of the land segment have not  
	// been subdivided into blocks  
	
    if (*suro <= 0.0)	goto L30;

	// surface runoff occurs, so sediment and soil matrix  
	// particles may be removed, delt60= delt/60  
	
	// calculate capacity for removing detached sediment - units  
	// are tons/acre-ivl  

    d1 =  (*suro / *delt60);
    d2 =  (*jser);
	stcap = *delt60 * *kser * pow(d1, d2);
	
    if (stcap <= *dets)	goto L10;

	// there is insufficient detached storage, base sediment  
	// removal on that available, wssd is in tons/acre-ivl  
    *wssd = *dets;
    *dets = 0.0;
    goto L20;
L10:
	// there is sufficient detached storage, base sediment  
	// removal on the calculated capacity  
    *wssd = stcap;
    *dets -= *wssd;
L20:
	
	// calculate scour of matrix soil by surface runoff -  
	// units are tons/acre-ivl  
    d1 =  (*suro / *delt60);
    d2 =  (*jger);
    *scrsd = *delt60 * *kger * pow(d1, d2);
	
	// total removal by runoff  
    *sosed = *wssd + *scrsd;
	
    goto L40;
L30:
	// no runoff occurs, so no removal by runoff  
    *wssd = 0.0;
    *scrsd = 0.0;
    *sosed = 0.0;
	
L40:
    goto L110;
	// surface and near-surface zones of the land segment have  
	// been subdivided into blocks  
	// initialize segment-wide variables  
    *wssd = 0.0;
    *scrsd = 0.0;
    *sosed = 0.0;
    *dets = 0.0;
	
L110:
    return 0;
} 
*/
int CLSPCMODEL::berflow(int nIndex, double delts, int nRecord, int nf, double vin,
						double *fv, double *fq, double *fa, double *fr, int *st, 
						double *XA, double *HR, double *q2)
{
	int nStart = pReachFtable[nIndex].nFTstart;
	double v2 = 0.0;

	if (nRecord > 0)	
	{
		// external Ftable
		for(int i=nStart; i<nStart+nRecord-1; i++)
		{
			if(pFtable[i].rchid == pChannelInfo[nIndex].rchid)											
			{
				if (*q2 < 0)	// qber is at the bank full depth
				{
					*q2 = (pFtable[i+1].vol * pFtable[i].disch1 - pFtable[i].vol * pFtable[i+1].disch1 + (pFtable[i+1].disch1 - pFtable[i].disch1) * vin) / 
						(pFtable[i+1].vol - pFtable[i].vol + (pFtable[i+1].disch1 - pFtable[i].disch1) * delts);				// cfs				
					v2 = (vin * (pFtable[i+1].vol - pFtable[i].vol) / delts + pFtable[i].vol * pFtable[i+1].disch1 - pFtable[i+1].vol * pFtable[i].disch1) / 
						((pFtable[i+1].vol - pFtable[i].vol) / delts + pFtable[i+1].disch1 - pFtable[i].disch1);		// ft^3	
				}
				else	// qber is already defined (+ve number)
				{
					v2 = pFtable[i].vol + (*q2 - pFtable[i].disch1) * (pFtable[i+1].vol - pFtable[i].vol) / (pFtable[i+1].disch1 - pFtable[i].disch1);	// ft3
				}

				if((*q2 >= pFtable[i].disch1) && (*q2 <= pFtable[i+1].disch1) && (v2 >= pFtable[i].vol) && (v2 <= pFtable[i+1].vol))
				{
					double SA1 = pFtable[i].area;
					double SA2 = pFtable[i+1].area;
					double A = SA2 - SA1;
					double B = 2.0 * SA1;
					double VOL1 = pFtable[i].vol;
					double VOL2 = pFtable[i+1].vol;
					double VOL = v2;
					double C = 0.0;
					if (VOL2 > VOL1 )
						C = -(VOL - VOL1)/(VOL2 - VOL1)*(B + A);

					//search using newton's method
					double FRDEP = 0.0;
					double DFRDEP = 0.0;
					double RDEP1 = 0.0;
					double RDEP2 = 0.5;
					int COUNT = 0;

					while(fabs(RDEP2 - RDEP1) >= 0.001)
					{
						RDEP1 = RDEP2;
						COUNT = COUNT + 1;
						FRDEP = A * pow(RDEP1,2.0) + B * RDEP1 + C;
						DFRDEP= 2.0 * A * RDEP1 + B;
						if (DFRDEP > 0)
							RDEP2 = RDEP1 - FRDEP / DFRDEP;
						if (COUNT > 100) 
						{
							//error -- no convergence
							AfxMessageBox("error -- no convergence for reach depth in FTable");
							return 2;
						}
					}
					if (RDEP2 > 1.00001 || RDEP2 < -0.00001)
					{
						//error -- solution converged to point outside valid range
						AfxMessageBox("error -- solution converged to point outside valid range for reach depth in FTable");
						return 2;
					}
					if (RDEP2 > 1.0) RDEP2 = 1.0;
					if (RDEP2 < 0.0) RDEP2 = 0.0;

					//depth, manual eq (36)
					double DEP1 = pFtable[i].depth;
					double DEP2 = pFtable[i+1].depth;

					//surface area calculation, manual eq (38)
					double SA = SA1 + A * RDEP2;

					*XA = 0.0;
					if (pReachInfo[nIndex].length > 0)
						*XA = VOL / (pReachInfo[nIndex].length * MILE_TO_FEET);		// ft^2
					double avdepth = 0.0;
					double topwidth = 0.0;
					if (SA > 0)
						avdepth = VOL / SA;			// ft
					if (pReachInfo[nIndex].length > 0)
						topwidth = SA / (pReachInfo[nIndex].length * MILE_TO_FEET);	// ft
					*HR = 0.0;
					if (avdepth > 0 || topwidth > 0)
						*HR = (topwidth * avdepth) / (2.0 * avdepth + topwidth);// ft

					*st = i;
					return 0;
				}
				else
					*st = -1;
			}
		}
	}
	else
	{
		// internal Ftable
		for(int i=0; i<nf-1; i++)
		{
			
			if (*q2 < 0)	// qber is at the bank full depth
			{
				*q2 = (fv[i+1] * fq[i] - fv[i] * fq[i+1] + (fq[i+1] - fq[i]) * vin) / 
					(fv[i+1] - fv[i] + (fq[i+1] - fq[i]) * delts);				
				v2 = (vin * (fv[i+1] - fv[i]) / delts + fv[i] * fq[i+1] - fv[i+1] * fq[i]) / 
					((fv[i+1] - fv[i]) / delts + fq[i+1] - fq[i]);	
			}
			else	// qber is already defined (+ve number)
			{
				v2 = fv[i] + (*q2 - fq[i]) * (fv[i+1] - fv[i]) / (fq[i+1] - fq[i]);	// ft3
			}

			if((*q2 >= fq[i]) && (*q2 <= fq[i+1]) && (v2 >= fv[i]) && (v2 <= fv[i+1]))
			{
				*XA = fa[i] + (v2-fv[i]) * (fa[i+1]-fa[i]) / (fv[i+1]-fv[i]);			
				*HR = fr[i] + (v2-fv[i]) * (fr[i+1]-fr[i]) / (fv[i+1]-fv[i]);			
				*st = i;
				return 0;
			}
			else
				*st = -1;
		}
	}

    return 0;
}

//     + + + PURPOSE + + +  


//     + + + ARGUMENT DEFINITIONS + + +  

//     JBER   - term to represent non-linear stream flow influence 
//     KBER   - term to relate bank stability index
//	   RCHLEN - reach length in ft  
//     DELT60 - simulation time interval in hours           
//     Q_ACT  - current stream flow through a particular reach segment in cfs
//     Q_THR  - threshold stream flow through a particular reach segment in cfs
//     XA_ACT - current stream crossectional area in ft^2
//     XA_THR - threshold stream crossectional area in ft^2
//     HR_ACT - current stream hydraulic radius in ft
//     HR_THR - threshold stream hydraulic radius in ft
//     BERSD  - scour of matrix from stream bank in tons/acre/ivl

//     + + + END SPECIFICATIONS + + +  

int CLSPCMODEL::bersed(double jber, double kber, double rchlen, double delt60,
					   double q_act, double q_thr, double xa_act, double xa_thr, 
					   double hr_act, double hr_thr, double *bersd)
{
//	double delts = delt60 * 3600;

	// calculate wetted perimeter
	double wp1=0.;
	if (hr_act > 0)
		wp1 = xa_act / hr_act;

    double wp2=0.;
	if (hr_thr > 0)
		wp2 = xa_thr / hr_thr;

	// check flow causing stream bank erosion
	if (q_act > q_thr)
	{
		// calculate unit area bank overflow volume (acre-in/ivl)
		double uaro=0.;
		if (wp1 > 0 && rchlen > 0)
			//uaro = (q_act - q_thr) * 3630 / ((wp1 - wp2) * rchlen * 0.00002295675) * delts;
			uaro = (q_act * IN_ACRE_TO_FT3) / (wp1 * rchlen * 0.00002295675) * delts;

		if (uaro > 0.0)	
		{
			// calculate scour of matrix soil by surface runoff -  
			// units are tons/acre-ivl  
			double d1 = uaro / delt60;
			double d2 = jber;
			*bersd = delt60 * kber * pow(d1, d2);
		}
		else
		{
			// no runoff occurs, so no removal by runoff  
			*bersd = 0.0;
		}
	}
	else
	{
		// no runoff occurs, so no removal by runoff  
		*bersd = 0.0;
	}

	// convert units from tons/acre-ivl to gram/ivl
	*bersd = *bersd * (wp1 - wp2) * rchlen * 0.00002295675 * 907184.7;
	
    return 0;
} 

//     + + + PURPOSE + + +  
//     Warning: this method of computing solids washoff contains a  
//     dimensionally non-homogeneous term (surs + suro). this introduces  
//     additional dependence of the results on the simulation interval  
//     delt. so far, it has only been used with a delt of 15 minutes  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     SURO   - surface output  
//     SURS   - ???  
//     DELT60 - simulation time interval in hours         
//     KEIM   - ???  
//     JEIM   - ???  
//     SLDS   - ???  
//     SOSLD  - ???  

//     + + +   + + +  

//     + + + END SPECIFICATIONS + + +  

int CLSPCMODEL::sosld1(double *suro, double *surs, double *delt60, double *keim, double *jeim, double *slds, double *sosld)
{
    double d1, d2;
    static double stcap, arg;
	
	// Washoff solids from the impervious segment using method 1  
    if (*suro > 0.0) 
	{
		// impervious surface runoff occurs, so solids may be removed;  
		// delt60= delt/60  
		// get argument used in transport equations  
		arg = *surs + *suro;
		
		// calculate capacity for removing solids - units  
		// are tons/acre-ivl  
		d1 =  (arg / *delt60);
		d2 =  (*jeim);
		stcap = *delt60 * *keim * pow(d1, d2);
		if (stcap > *slds) 
		{
			// there is insufficient solids storage, base solids  
			// removal on that available, sosld is in tons/acre-ivl  
			*sosld = *slds * *suro / arg;
		} 
		else 
		{
			// there is sufficient solids storage, base solids  
			// removal on the calculated capacity  
			*sosld = stcap * *suro / arg;
		}
		*slds -= *sosld;
    } 
	else 
	{
		// no runoff occurs, so no removal by runoff  
		*sosld = 0.0;
    }
    return 0;
} 


//     + + + PURPOSE + + +  
//     Warning: this method of computing solids washoff has not  
//     been tested. but it is dimensionally homogeneous  

//     + + + ARGUMENT DEFINITIONS + + +  
//     SURO   - surface output  
//     DELT60 - simulation time interval in hours        
//     KEIM   - ??? 
//     JEIM   - ??? 
//     SLDS   - ??? 
//     SOSLD  - ??? 

//     + + + END SPECIFICATIONS + + +  
/*
int CLSPCMODEL::sosld2(double *suro, double *delt60, double *keim, double *jeim, double *slds, double *sosld)
{
    double d1, d2, stcap;
	
	// Washoff solids from the impervious segment using method 2  
    if (*suro > 0.0) 
	{
		// impervious surface runoff occurs, so solids may be removed  
		// calculate capacity for removing solids - units  
		// are tons/acre-ivl  
		d1 =  (*suro / *delt60);
		d2 =  (*jeim);
		stcap = *delt60 * *keim * pow(d1, d2);
		if (stcap > *slds) 
		{
			// there is insufficient solids storage, base solids 
			// removal on that available, sosld is in tons/acre-ivl  
			*sosld = *slds;
			*slds = 0.0;
		} 
		else 
		{
			// there is sufficient solids storage, base solids  
			// removal on the calculated capacity  
			*sosld = stcap;
			*slds -= *sosld;
		}
    } 
	else 
	{
		// no runoff occurs, so no removal by runoff  
		*sosld = 0.0;
    }
    return 0;
}  
*/

//     + + + PURPOSE + + +  
//     This subroutine uses toffaleti's method to calculate the capacity  
//     of the flow to transport sand.  
//      called by: sandld  

//     + + + ARGUMENT DEFINITIONS + + +  
//     V     - average velocity of flow (ft/s)  
//     FDIAM - median bed sediment diameter (ft)  
//     FHRAD - hydraulic radius (ft) 
//     SLOPE - energy or river bed slope  
//     TEMPR - water temperature (deg c)  
//     VSET  - settling velocity (ft/s)  
//     GSI   - total capacity of the rchres (tons/day.ft)  
 
//     + + + END SPECIFICATIONS + + +  

int CLSPCMODEL::toffal(double *v, double *fdiam, double *fhrad, double *slope, double *tempr, double *vset, double *gsi)
{
    double d1, d2, d3, d4, d5, d6, d7, d8;
	
    double oczl, oczm, oczu, tmpr, zinv, afunc, ustar, k4, p1, k4func,
		ac, d65, cz, zi, zm, tt, zn, zo, zp, zq, c2d, rprime, zo2, fd11,
		fd25, cli, cmi, gsb, gsl, cnv, gsm, gsu, vis, ack4;
	
	
	
	// Convert water temp from degrees c to degrees f  
    tmpr = *tempr * 1.8 + 32.0;
	
	
	// For water temperatures greater than 32f and less than 100f  
	// The kinematic viscosity can be written as the following:  
    d1 =  tmpr;
    vis = pow(d1, -0.864) * 4.106e-4;
	
	// Assuming the d50 grain size is approximately equal to the  
	// Geometric mean grain size and sigma-g = 1.5, the d65 grain  
	// Size can be determined as 1.17*d50.  
	
    d65 = *fdiam * 1.17;
    cnv = tmpr * 4.8e-4 + 0.1198;
    cz = 260.67 - tmpr * 0.667;
    tt = (tmpr * 9e-5 + 0.051) * 1.1;
    zi = *vset * *v / (cz * *fhrad * *slope);
    if (zi < cnv) 
		zi = cnv * 1.5;
	
	// The manning-strickler equation is used here to  
	// Determine the hydraulic radius component due to
	// Grain roughness (r').  taken from the 1975 asce
	// "sedimentation engineering",pg. 128.  
	
    d1 =  (*v);
    d2 =  d65;
    d3 =  (*slope);
    rprime = pow(d1, 1.5) * pow(d2, 0.25) / pow(d3, 0.75) * 0.00349;
    d1 =  (rprime * *slope * 32.2);
    ustar = pow(d1, 0.5);
    d1 =  (vis * 1e5);
    afunc = pow(d1, 0.333) / (ustar * 10.0);
    if (afunc <= 0.5) 
	{
		d1 =  (afunc / 4.89);
		ac = pow(d1, -1.45);
    } 
	else if (afunc <= 0.66) 
	{
		d1 =  (afunc / 0.0036);
		ac = pow(d1, 0.67);
    } 
	else if (afunc <= 0.72) 
	{
		d1 =  (afunc / 0.29);
		ac = pow(d1, 4.17);
    } 
	else if (afunc <= 1.25) 
	{
		ac = 48.0;
    } 
	else if (afunc > 1.25) 
	{
		d1 =  (afunc / 0.304);
		ac = pow(d1, 2.74);
    }
	
    k4func = afunc * *slope * d65 * 1e5;
    if (k4func <= 0.24) 
	{
		k4 = 1.0;
    } 
	else if (k4func <= 0.35) 
	{
		d1 =  k4func;
		k4 = pow(d1, 1.1) * 4.81;
    } 
	else if (k4func > 0.35) 
	{
		d1 =  k4func;
		k4 = pow(d1, -1.05) * 0.49;
    }
	
    ack4 = ac * k4;
    if (ack4 - 16.0 < 0.0) 
	{
		ack4 = 16.0;
		k4 = 16.0 / ac;
    }
    oczu = cnv + 1.0 - zi * 1.5;
    oczm = cnv + 1.0 - zi;
    oczl = cnv + 1.0 - zi * 0.756;
    zinv = cnv - zi * 0.758;
    zm = -zinv;
    zn = zinv + 1.0;
    zo = zi * -0.736;
    zp = zi * 0.244;
    zq = zi * 0.5;
	
	// Cli has been multiplied by 1.0e30 to keep it from  
	// Exceeding the computer overflow limit  
	
    d1 =  (*v);
    d2 =  (*fhrad);
    d3 =  zm;
    d4 =  (tt * ac * k4 * *fdiam);
    d5 =  (*fhrad / 11.24);
    d6 =  zn;
    d7 =  (*fdiam * 2.0);
    d8 =  oczl;
    cli = oczl * 5.6e22 * pow(d1, 2.333) / pow(d2, d3)
		/ pow(d4, 1.667) / (cnv + 1.0) / (pow(d5,d6) - pow(d7, d8));
	
    zo2 = zo / 2.0;
    d1 =  (*fdiam * 2.0 / *fhrad);
    d2 =  zo2;
    p1 = pow(d1, d2);
    c2d = cli * p1;
    c2d = c2d * p1 / 1e30;
	
	// Check to see if the calculated value is reasonable  
	// (< 100.0), and adjust it if it is not.  
	
    if (c2d > 100.0) 
		cli = cli * 100.0 / c2d;
	
	
	// Cmi has been multiplied by 1.0e30 to keep it from  
	// Exceeding the computer overflow limit  
	
    d1 =  (*fhrad);
    d2 =  zm;
    cmi = cli * 43.2 * (cnv + 1.0) * *v * pow(d1, d2);
	
	// Calculate transport capacity of the upper layer  
	
    fd11 = *fhrad / 11.24;
    fd25 = *fhrad / 2.5;
    d1 =  fd11;
    d2 =  zp;
    d3 =  fd25;
    d4 =  zq;
    d5 =  (*fhrad);
    d6 =  oczu;
    d7 =  fd25;
    d8 =  oczu;
    gsu = cmi * pow(d1, d2) * pow(d3, d4) * (pow(d5,d6) - pow(d7, d8)) / (oczu * 1e30);
	
	// Calculate the capacity of the middle layer  
	
    d1 =  fd11;
    d2 =  zp;
    d3 =  fd25;
    d4 =  oczm;
    d5 =  fd11;
    d6 =  oczm;
    gsm = cmi * pow(d1, d2) * (pow(d3, d4) - pow(d5, d6)) / (oczm * 1e30);
	
	// Calculate the capacity of the lower layer  
	
    d1 =  fd11;
    d2 =  zn;
    d3 =  (*fdiam * 2.0);
    d4 =  oczl;
    gsl = cmi * (pow(d1, d2) - pow(d3, d4)) / (oczl * 1e30);
	
	// Calculate the capacity of the bed layer  
	
    d1 =  (*fdiam * 2.0);
    d2 =  zn;
    gsb = cmi * pow(d1, d2) / 1e30;
	
	// Total capacity of the rchres (gsi has units of tons/day/ft)  
	
    *gsi = gsu + gsm + gsl + gsb;
    if (*gsi <= 0.0)
		*gsi = 0.0;
	
    return 0;
}  

//     + + + PURPOSE + + +  
//     Simulate washoff of a quality constituent from the land surface  
//     by association with solids 

//     + + + KEYWORDS + + +  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     DAYFG  - flag for first day or day change  
//     VPFWFG - ???  
//     SOSLD  - ???  
//     POTFWM - ???  
//     MON    - calendar month  
//     NXTMON - next calendar month  
//     DAY    - day of month  
//     NDAYS  - no. of days in this month  
//     POTFW  - ???  
//     SOQS   - ???  

//     + + + FUNCTIONS + + +  

//     + + + C   EXTERNALALS + + +  
//     EXTERNAL   DAYVAL  

//     + + + INTRINSICS + + +  

//     + + + END SPECIFICATIONS + + +  

/* 
int CLSPCMODEL::washsd(int *dayfg, int *vpfwfg, double *sosld, double *potfwm,
					int *mon, int *nxtmon, int *day, int *ndays, double *potfw, double *soqs)
{
    if (*dayfg == 1) 
	{
		// it is the first interval of the day  
		
		if (*vpfwfg == 1) 
		{
			//         washoff potency factors are allowed to vary throughout the  
			//         year 
			//         interpolate for the daily value  
			//         linearly interpolate potfw between two values from the  
			//         monthly array potfwm(12) for this solids associated quality  
			//         constituent (no. qsfp)  
			*potfw = dayval(&potfwm[*mon], &potfwm[*nxtmon], day, ndays);
		} 
		else 
		{
			//         washoff potency factors do not vary throughout the year.  
			//         potfw value has been supplied by the run interpreter  
		}
		
    }
	
	//     associate with washoff of solids - units are qty/acre-ivl  
	
	//     if (sosld.eq.0.0) then 
    if (fabs(*sosld) <= 0.0)
		*soqs = 0.0;
	else
		*soqs = *sosld * *potfw;
	
    return 0;
} 
*/
int CLSPCMODEL::phcarb(double *ph, double *alk, double *tic, double *co2, 
					double *tw, double *vol, int *convfg, int *phdbfg)
{
    double d1;
    double hest, hest1, k1equ, k2equ, hllim;
    int phcnt;
    double hulim, hplus, kwequ;
    int messu;
    double coeff1, coeff2, coeff3, coeff4, hllim1, hulim1;
    double twkelv;
	
//cilist io___18 = { 0, 6, 0, 0, 0 };
	
    if (*vol > 0.0)
	{
		twkelv = *tw + 273.16;
		d1 =  (-4470.99 / twkelv + 6.0875 -	twkelv * 0.01706);
		kwequ = pow(10, d1);
		
		// calculate first dissociation constant of carbonic acid  
		d1 =  (-3404.71 / twkelv + 14.8435 - twkelv * 0.032786);
		k1equ = pow(10, d1);
		
		// calculate second dissociation constant of carbonic acid  
		d1 =  (-2902.39 / twkelv + 6.498 - twkelv * 0.02379);
		k2equ = pow(10, d1);
		
		// assign values to variables and coefficients used in the  
		// solution algorithm 
		
		// set ph to 7.0 if it is undefined (due to no water in reach)  
		if (*ph < 0.0)	*ph = 7.0;
		
		d1 =  -(*ph);
		hest = pow(10, d1);
		hllim = 0.0;
		hulim = 1.0;
		coeff1 = *alk + k1equ;
		coeff2 = -kwequ + *alk * k1equ + k1equ * k2equ - *tic * k1equ;
		coeff3 = k1equ * -2.0 * k2equ * *tic - k1equ * kwequ + *alk * k1equ * k2equ;
		coeff4 = -k1equ * k2equ * kwequ;
		
		// store initial values for hest, hllim, and hulim; these  
		// values will be used again if the solution technique for ph  
		// does not produce a satisfactory solution within the allowed  
		// number of iterations (phcnt)  
		hest1 = hest;
		hllim1 = hllim;
		hulim1 = hulim;
		
		// set printing option for internal variables in the  
		// ph solution 0  
		// PHDBFG= 0  
		phcnt = 50;
		
		// calculate ph  
		phcalc(phdbfg, &phcnt, &coeff1, &coeff2, &coeff3, &coeff4, &messu, &hest,
			&hllim, &hulim, ph, convfg, &hplus);
		if (*convfg == 0)
		{
			// set printing option for internal variables in the ph  
			// solution 1  
			*phdbfg = 1;
			
			phcalc(phdbfg, &phcnt, &coeff1, &coeff2, &coeff3, &coeff4,
				&messu, &hest1, &hllim1, &hulim1, ph, convfg, &hplus);
			
		}
    }
	else
	{
		// reach/res has gone dry during the interval; set ph  
		// equal to an undefined value  
		*ph = -1e20;
    }
	
    return 0;
} 

//     + + + PURPOSE + + +   
//     Calculate ph   

//     + + + ARGUMENT DEFINITIONS + + +   
//     PHDBFG - ???   
//     PHCNT  - ???   
//     COEFF1 - ???   
//     COEFF2 - ???   
//     COEFF3 - ???   
//     COEFF4 - ???   
//     MESSU  - ftn unit no. to be used for printout of messages   
//     HEST   - ???   
//     HLLIM  - ???   
//     HULIM  - ???   
//     PH     - ???    
//     CONVFG - ???   
//     HPLUS  - ???   

int CLSPCMODEL::phcalc(int *phdbfg, int *phcnt, double *coeff1, double *coeff2, double *coeff3, double *coeff4, int *messu, double *hest, double *hllim, double *hulim, double *ph, int *convfg, double *hplus)
{
    double r1;
    double dfdh, quadh;
    int count;
	
    if (*phdbfg == 1)
	{
		//
    }
    *convfg = 0;
    count = 1;
	
	// dountil count> phcnt or convfg= 1  
L10:
	
	// evaluate quadratic and slope for solution equation  
    quadh = (((*hest + *coeff1) * *hest + *coeff2) * *hest + *coeff3) * *hest + *coeff4;
    dfdh = ((*hest * 4.0 + *coeff1 * 3.0) * *hest + *coeff2 * 2.0) * *hest + *coeff3;
    count++;
	
    if (dfdh <= 0.0)
	{
		// slope of solution equation is zero or negative; solution  
		// for hplus is not meaningful for such a slope; update 
		// values for hllim, hulim, and hest to force convergence  
		if (quadh < 0.0)
		{
			if (*hest >= *hllim)
			{
				*hllim = *hest;
				*hest *= 10.0;
			}
		}
		else
		{
			if (*hest <= *hulim)
			{
				*hulim = *hest;
				*hest *= 0.1;
			}
		}
		
		if (*phdbfg == 1)
		{
			//
		}
    }
	else
	{
		// calculate new hydrogen ion concentration  
		*hplus = *hest - quadh / dfdh;
		
		r1 = *hplus - *hest;
		if (fabs(r1) / *hplus > 0.1)
		{
			// difference between posterior estimate and prior  
			// estimate is greater than 10 percent; adjust prior  
			// estimate for next iteration  
			
			if (*hplus <= *hllim)
			{
				// assign value midway between prior estimate and  
				// lower limit to prior estimate for next iteration  
				*hest = (*hest + *hllim) / 2.0;
			}
			else
			{
				if (*hplus >= *hulim)
				{
					// assign value midway between prior estimate and  
					// upper limit to prior estimate for next iteration  
					*hest = (*hest + *hulim) / 2.0;
				}
				else
				{
					// assign value of posterior estimate to prior  
					// estimate for next iteration  
					*hest = *hplus;
				}
			}
		}
		else
		{
			// solution for hplus is complete; drop out of dountil  
			// loop by turning on convergence indicator flag  
			*convfg = 1;
		}
		
		if (*phdbfg == 1)
		{
			//
		}
    }

    if (count <= *phcnt && *convfg != 1)
		goto L10;
	
	// calculate ph  
    *ph = -log10(*hplus);
	
    return 0;
}  

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	  SUBROUTINE   PHCALC

      + + + PURPOSE + + +
      Calculate ph

      + + + ARGUMENT DEFINITIONS + + +
      PHDBFG - ???
      PHCNT  - ???
      COEFF1 - ???
      COEFF2 - ???
      COEFF3 - ???
      COEFF4 - ???
      MESSU  - ftn unit no. to be used for printout of messages
      HEST   - ???
      HLLIM  - ???
      HULIM  - ???
      PH     - ???
      CONVFG - ???
      HPLUS  - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::PHCALC(int PHDBFG,int PHCNT,double COEFF1,double COEFF2,double COEFF3,
					double COEFF4,double *HEST,double *HLLIM,double *HULIM,double *PH,
					int *CONVFG,double *HPLUS)
{
      int    COUNT;
      double DFDH,QUADH;
 
      *CONVFG= 0;
      COUNT = 1;
 
      //dountil count> phcnt or convfg= 1
 //10   CONTINUE
K10: 
        //evaluate quadratic and slope for solution equation
        QUADH= (((*HEST + COEFF1)* *HEST + COEFF2)* *HEST + COEFF3)* *HEST + COEFF4;
        DFDH = ((4.* *HEST + 3.*COEFF1)* *HEST + 2.*COEFF2)* *HEST + COEFF3;
        COUNT= COUNT + 1;
 
        if (DFDH <= 0.0) 
		{
          //slope of solution equation is zero or negative; solution
          //for hplus is not meaningful for such a slope; update
          //values for hllim, hulim, and hest to force convergence
 
          if (QUADH < 0.0) 
		  {
            if (*HEST >= *HLLIM) 
			{
              *HLLIM= *HEST;
              *HEST = 10.0* *HEST;
            }
          }
		  else
		  {
            if (*HEST <= *HULIM) 
			{
              *HULIM= *HEST;
              *HEST = 0.10* *HEST;
            }
          }
          //IF (PHDBFG .EQ. 1) THEN
          //  WRITE (MESSU,2010)  HEST, QUADH, DFDH, HLLIM, HULIM
          //END IF
        }
		else
		{
          //calculate new hydrogen ion concentration
          *HPLUS= *HEST - QUADH/DFDH;
 
          if ((fabs(*HPLUS- *HEST) / *HPLUS) > 0.10) 
		  {
            //difference between posterior estimate and prior
            //estimate is greater than 10 percent; adjust prior
            //estimate for next iteration
 
            if (*HPLUS <= *HLLIM) 
              //assign value midway between prior estimate and
              //lower limit to prior estimate for next iteration
              *HEST= (*HEST + *HLLIM)/2.0;
            else
			{
              if (*HPLUS >= *HULIM) 
                //assign value midway between prior estimate and
                //upper limit to prior estimate for next iteration
                *HEST= (*HEST + *HULIM)/2.0;
              else
                //assign value of posterior estimate to prior
                //estimate for next iteration
                *HEST= *HPLUS;
            }
          }
		  else
		  {
            //solution for hplus is complete; drop out of dountil
            //loop by turning on convergence indicator flag
            *CONVFG= 1;
          }
 
          //IF (PHDBFG .EQ. 1) THEN
          //  WRITE (MESSU,2010)  HEST,QUADH,DFDH,HLLIM,HULIM,HPLUS
          //END IF
        }
      if (COUNT <= PHCNT && *CONVFG != 1) goto K10;
 
      //calculate ph
      *PH= -log10(*HPLUS);
    return 0;
}
/*
int CLSPCMODEL::updateco2(double *delt60, double *co1, double *co2, double *avdepe, 
					   double *avvele, double *tw, int *reamfg, int *decfg, double *p, 
					   double *r, double *ben, double *deltcd,double *co2sa)
{
    double d1, d2, d3, d4, d5, d6;
	double reak, korea, satco2, cfpres, expred, trandp, tcginv, exprev, twkelv, aco;
	double cfcinv =0.9;
	
	// cfcinv correction for reaeration
	//  update CO2 
	// 	AVDEPE =average depth  (ft) 
	//     AVVELE =velocity 
	//     REAMFG = reaeration calculate flag 
	//              1 use O'Connor, Owens, Churchill Equations 
	//     TCGINV = temerature adjust 
	//     TW     = temperature 
	//     DECFG  = decay falg 
	//     P = production	 (g/m^3/day) 
	//     R =respiration	 (g/m^3/day) 
	//     Ben =bottom release	 (g/m^3/day) 
	//     CO1 = CO2 concentration at time N   (M/l) 
	//     CO2 = CO2 concentration at time N+1	(M/l) 
	//     delt60 time step in hour                      
	//     CFPRES = elavation correction 
	//     DELTCD = net change of CO2 
	
	*co1 /= 12000.0;
	*co2 /= 12000.0;   // in M 
	
    aco = 0.03125;
    cfpres = 1.0;
    tcginv = 1.024;
    if (*decfg == 0)
	{
		*r = 0.0;
		*p = 0.0;
		*ben = 0.0;
    }
	
    if (*reamfg > 0)
	{
		//           calculate reaeration coefficient as a power function of 
		//           average hydraulic depth and velocity; determine exponents 
		//           to depth and velocity terms and assign value to reak 
		if (*avdepe <= 2.0)
		{
			//             use owen's formulation for reaeration 
			reak = 0.906;
			exprev = 0.67;
			expred = -1.85;
		}
		else
		{
			//             calculate transition depth; transition depth determines 
			//             which method of calculation is used given the current 
			//             velocity 
			if (*avvele < 1.7)
			{
				trandp = 0.0;
			}
			else
			{
				d1 =  (*avvele);
				trandp = pow(d1, 2.9135) * 0.4263;
			}
			
			if (*avdepe - trandp <= 0.0)
			{
				//               use churchill's formulation for reaeration 
				reak = 0.484;
				exprev = 0.969;
				expred = -1.673;
			}
			else
			{
				//               use o'connor-dobbins formulation for reaeration 
				reak = 0.538;
				exprev = 0.5;
				expred = -1.5;
			}
		}
		
		//         calculate reaeration coefficient 
		d1 =  (*avvele);
		d2 =  exprev;
		d3 =  (*avdepe);
		d4 =  expred;
		d5 =  tcginv;
		d6 =  (*tw - 20.0);
		korea = reak * pow(d1, d2) * pow(d3, d4) * pow(d5, d6);
		
		if (korea > 1.0)
			korea = 0.999;
		korea *= cfcinv;
    }
	else
	{
		korea = 0.0;
    }
	
	//     Adjust (32/M)^0.25 *1000 
	
    korea *= 923.0;
	
    twkelv = *tw + 273.16;
    if (*avdepe > 0.17)
	{
		
		//         calculate molar saturation concentration for co2 (satco2); 
		//         first, calculate henry's constant, s, for co2; s is defined 
		//         as the molar concentration of atmospheric co2/partial 
		//         pressure of co2; cfpres corrects the equation for effects 
		//         of elevation differences from sea level 
		d1 =  (2385.73 / twkelv - 14.0184 + twkelv * 0.0152642);
		satco2 = pow(10, d1);
		satco2 = cfpres * 3.55e-4 * satco2;
		
		*co2 = (*co1 + korea * satco2 * *delt60 + *delt60 * aco * (*r - *p + *ben)) / (*delt60 * korea + 1);
		
		*deltcd = korea * (satco2 - *co2) * *delt60 + *delt60 * aco * (*r - *p + *ben);
		*co2sa = satco2*12000.0; // mg C/l 
    }
	else
	{
		
		//     too little water 
		
		*deltcd = 0.0;
		*co2 = *co1;
    }
	*co2 *= 12000;   // mg/l 
	
    return 0;
} 
*/
//RQUAL (03-2005)

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     SUBROUTINE   SINK

     + + + PURPOSE + + +
     Calculate quantity of material settling out of the control
     volume; determine the change in concentration as a result 
     of sinking

     + + + ARGUMENT DEFINITIONS + + +
     VOL    - volume of water in reach above bed
     AVDEPE - ???
     KSET   - ???
     CONC   - ???
     SNKMAT - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::SINK(double VOL,double AVDEPE,double KSET,double *CONC,double *SNKMAT)
{
	double SNKOUT;
	if (KSET > 0 && AVDEPE > 0.17) 
	{
		//calculate concentration change due to outgoing material;
		//snkout is expressed in mass/liter/ivl; kset is expressed
		//as ft/ivl and avdepe as feet
			if (KSET < AVDEPE) 
				//calculate portion of material which settles out of the
				//control volume during time step; snkout is expressed as
				//mass/liter.ivl; conc is the concentration of material in
				//the control volume
				SNKOUT= *CONC*(KSET/AVDEPE);
			else
				//all material sinks out of control volume
				SNKOUT= *CONC;
		//calculate remaining concentration of material in the control
		//volume
		*CONC= *CONC- SNKOUT;
		//find quantity of material that sinks out; units are
		//mass.ft3/l.ivl in english system, and mass.m3/l.ivl in
		//metric system
		*SNKMAT= SNKOUT*VOL;
	}
	else
	{
		//assume no settling occurs
		SNKOUT= 0.0;
		*SNKMAT= 0.0;
	}
    return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     SUBROUTINE   OXBEN

     + + + PURPOSE + + +
     Simulate benthal oxygen demand and benthal release of BOD

     + + + ARGUMENT DEFINITIONS + + +
     BRBOD  - ???
     BENOD  - ???
     TW     - water temperature in degrees C
     DEPCOR - ???
     SCRFAC - ???
     TCBEN  - ???
     EXPOD  - ???
     EXPREL - ???
     DOX    - dissolved oxygen concentration in mg/l
     BOD    - ???
     DOBEN  - ???
     BODBNR - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::OXBEN(double *BRBOD,double BENOD,double TW,double DEPCOR,
				   double SCRFAC,double TCBEN,double EXPOD,double EXPREL,
				   double *DOX,double *BOD,double *DOBEN,double *BODBNR)
{
	double  BENOX,RELBOD;

	//calculate amount of dissolved oxygen required to satisfy
	//benthal oygen demand (mg/m2.ivl)
	BENOX= BENOD * pow(TCBEN,(TW -20.)) * (1.0 -exp(-EXPOD* *DOX));

	//adjust dissolved oxygen state variable to acount for oxygen
	//lost to benthos, and compute concentration flux
	*DOBEN= *DOX;
	*DOX  = *DOX - BENOX*DEPCOR;
	if (*DOX >= 0.001)
	*DOBEN= BENOX*DEPCOR;

	if (*DOX < 0.001)
	*DOX= 0.0;

	//calculate benthal release of bod; release is a function of
	//dissolved oxygen (dox) and a step function of stream velocity;
	//brbod(1) is the aerobic benthal release rate; brbod(2) is the
	//base increment to benthal release under decreasing do
	//concentration; relbod is expressed as mg bod/m2.ivl
	RELBOD= (BRBOD[1]+BRBOD[2] * exp(-EXPREL* *DOX)) * SCRFAC;

	//add release to bod state variable and compute concentration flux
	*BOD   = *BOD + RELBOD*DEPCOR;
	*BODBNR= RELBOD*DEPCOR;

    return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		SUBROUTINE   OXREA

		+ + + PURPOSE + + +
		Calculate oxygen reaeration coefficient

		+ + + ARGUMENT DEFINITIONS + + +
		LKFG   - ???
		WIND   - ???
		CFOREA - ???
		AVVELE - ???
		AVDEPE - ???
		TCGINV - ???
		REAMFG - ???
		REAK   - ???
		REAKT  - ???
		EXPRED - ???
		EXPREV - ???
		LEN    - ???
		DELTH  - ???
		TW     - water temperature in degrees C
		DELTS  - ???
		DELT60 - simulation time interval in hours
		UUNITS - system of units   1-english, 2-metric
		KOREA  - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::OXREA(int LKFG,double WIND,double CFOREA,double AVVELE,
				   double AVDEPE,double TCGINV,int REAMFG,
				   double *REAK,double REAKT,double *EXPRED,double *EXPREV,
				   double LEN,double DELTH,double TW,double DELTS,
				   double DELT60,double *KOREA)
{
	double DELTHE,FLOTIM,LENE,TRANDP,WINDF,WINDSP;

	if (LKFG != 0)
	{
		//this reach/res is a lake or reservoir

		//calculate reaeration coefficient based on windspeed, surface
		//area, and volume; windsp is windspeed in m/sec; wind is
		//wind movement in m/ivl
		WINDSP= WIND/DELTS;

		if (WINDSP > 6.0)
			//determine windspeed factor empirically
			WINDF= WINDSP*( -.46 + .136*WINDSP);
		else
			//assign value of 2.0 as windspeed factor
			WINDF= 2.0;

		//calculate reaeration coefficient
		*KOREA= (.032808*WINDF*CFOREA/AVDEPE)*DELT60;
	}
	else
	{
		//calculate reaeration coefficient for free-flowing reach

		if (REAMFG == 1) 
		{
			//convert length and drop in energy line along length of
			//rchres to english units, if necessary
//			if (UUNITS == 2)
//			{
				LENE  = LEN*3.28;		// ft
				DELTHE= DELTH*3.28;		// ft
//			}
//			else
//			{
//				LENE  = LEN;
//				DELTHE= DELTH;
//			}

			//calculate reaeration coefficient based on energy
			//dissipation principles (tsivoglou method)
			if ((fabs(AVVELE)) > 0.0) 
			{
				FLOTIM= LENE/AVVELE;
				*KOREA = REAKT*(DELTHE/FLOTIM)* pow(TCGINV,(TW - 20.))*DELTS;
			}
			else
				*KOREA = 0.0;
		}
		else
		{
			if (REAMFG == 2) 
			{
				//calculate reaeration coefficient as a power function of
				//average hydraulic depth and velocity; determine exponents
				//to depth and velocity terms and assign value to reak
				if (AVDEPE <= 2.0) 
				{
					//use owen's formulation for reaeration
					*REAK  = .906;
					*EXPREV= 0.67;
					*EXPRED= -1.85;
				}
				else
				{
					//calculate transition depth; transition depth determines
					//which method of calculation is used given the current
					//velocity
					if (AVVELE < 1.7)
						TRANDP= 0.0;
					else
						TRANDP= .4263*pow(AVVELE,2.9135);

					if ((AVDEPE - TRANDP) <= 0.0) 
					{
						//use churchill's formulation for reaeration
						*REAK  = .484;
						*EXPREV= .969;
						*EXPRED= -1.673;
					}
					else
					{
						//use o'connor-dobbins formulation for reaeration
						*REAK  = .538;
						*EXPREV= 0.5;
						*EXPRED= -1.5;
					}
				}
			}
			else
			{

			//values for reak, exprev, and expred are input by user
			}

			//calculate reaeration coefficient
			*KOREA= *REAK*pow(AVVELE,*EXPREV)*pow(AVDEPE,*EXPRED)*pow(TCGINV,(TW - 20.))*DELT60;
		}
	}
	if (*KOREA > 1.0) 
		*KOREA = .999;
      
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   BODDEC

     + + + PURPOSE + + +
     Calculate bod decay

     + + + ARGUMENT DEFINITIONS + + +
     TW     - water temperature in degrees C
     KBOD20 - ???
     TCBOD  - ???
     BOD    - ???
     DOX    - dissolved oxygen concentration in mg/l
     BODOX  - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::BODDEC(double TW,double KBOD20,double TCBOD,double *BOD,
					double *DOX,double *BODOX)
{
	//calculate concentration of oxygen required to satisfy computed bod
	//decay; bodox is expressed as mg oxygen/liter.ivl
	*BODOX= (KBOD20*pow(TCBOD,(TW -20.)))* *BOD;
	if (*BODOX > *BOD) 
		*BODOX = *BOD;

	//adjust dissolved oxygen state variable to acount for oxygen
	//lost to bod decay, and compute concentration flux
	if (*BODOX >= *DOX) 
	{
		*BODOX= *DOX;
		*DOX  = 0.0;
	}
	else
		*DOX= *DOX - *BODOX;

	//adjust bod state variable to account for bod decayed
	*BOD = *BOD - *BODOX;
	if (*BOD < 0.0001) 
		*BOD= 0.0;

	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   NH3VOL

      + + + PURPOSE + + +
      calculate ammonia volatilization using two-layer theory
 
      + + + ARGUMENT DEFINITIONS + + +
      EXPNVG - exponent to gas film mass transfer equation for ammonia;
               default value is 1/2 as per mills
      EXPNVL - exponent to liquid film mass transfer equation for ammonia;
               default value is 2/3 as per thibodeaux
      KOREA  - oxygen transfer coefficient expressed in units of per
               interval
      WIND   - windspeed expressed as meters per interval
      DELT60 - conversion from units of per hour to units of per interval
      DELTS  - ???
      AVDEPM - average depth of water in reach expressed in meters
      TWKELV - water temperature expressed in degrees kelvin
      TW     - water temperature expressed in degrees c
      PHVAL  - ph of water column
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      NH3VLT - flux of ammonia out of reach due to volatilization, expressed
               in mg/l.ivl

      //+ + + EXTERNALS + + +
      HCINTP
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::NH3VOL(double EXPNVG,double EXPNVL,double KOREA,double WIND,
					double DELT60,double DELTS,double AVDEPM,double TWKELV,
					double TW,double PHVAL,double *TAM,double *NH3VLT)
{
      double NH3KL=0,NH3KG=0,DOKL=0,HCNH3=0,KRINV=0,KR=0,WINDSP=0,KNVOL=0;
 
      if (*TAM > 0.0) 
	  {
        //convert reaeration coefficient into units needed for computatuion
        //of bulk liquid film gas transfer coefficient (cm/hr) based on
        //average depth of water
        DOKL= KOREA*(AVDEPM*100.)/DELT60;
 
        //compute bulk liquid film gas transfer coefficient for ammonia using
        //equation 183 of mccutcheon; 1.8789 equals the ratio of oxygen
        //molecule molecular weight to ammonia molecular weight
        NH3KL= DOKL*pow(1.8789,(EXPNVL/2.));
 
        //convert wind speed from meters/ivl (wind) to meters/sec (windsp)
        WINDSP= WIND/DELTS;
 
        //compute bulk gas film gas transfer coefficient (cm/hr) for ammonia
        //using equation 184 of mccutcheon; the product of the expression
        //(700.*windsp) is expressed in cm/hr; 1.0578 equals the ratio of water
        //molecule molecular weight to ammonia molecular weight
        if (WINDSP <= 0.0) WINDSP = 0.001;
        NH3KG= 700.*WINDSP*pow(1.0578,(EXPNVG/2.));
 
        //compute henry's constant for ammonia as a function of temperature
        HCINTP(PHVAL,TW,&HCNH3);
 
        //compute overall mass transfer coefficient for ammonia (kr) in cm/hr
        //using equation 177 of mccutcheon; first calculate the inverse of kr
        //(krinv); 8.21e-05 equals ideal gas constant value expressed as
        //atm/degrees k mole
        KRINV= (1./NH3KL) + ((8.21E-05)*TWKELV)/(HCNH3*NH3KG);
        KR   = (1./KRINV);
 
        //compute reach-specific gas transfer coefficient (units are /interval)
        KNVOL= (KR/(AVDEPM*100.))*DELT60;
 
        //compute ammonia flux out of reach due to volatilization;  assumes
        //that equilibrium concentration of ammonia is sufficiently small
        //to be considered zero
        *NH3VLT = KNVOL* *TAM;
        if (*NH3VLT >= *TAM) 
		{
          *NH3VLT= 0.99* *TAM;
          *TAM= 0.01* *TAM;
        }
		else
		{
          *TAM= *TAM - *NH3VLT;
        }
      }
	  else
	  {
        //no ammonia present; hence, no volatilization occurs
        *NH3VLT= 0.0;
      }

	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   HCINTP

      + + + PURPOSE + + +
      Calculate Henry's constant for ammonia based on pH and water
      temperature
 
      + + + ARGUMENT DEFINITIONS + + +
      PHVAL  - ph of water column
      TW     - water temperature expressed in degrees c
      HCNH3  - henry's constant for ammonia, expressed as atm.m3/g.mol

      + + + LOCAL VARIABLE DEFINITIONS + + +
      XTW    - array of temperature values for which henry's constant values
               are available
      XHPLUS - array of modified hydrogen ion concentrations for which henry's
               constant values are available
      YHEMC  - two dimensional array of temperature- and ph-dependent
               henry's comnstant values

	  + + + EXTERNALS + + +
      INTRP1
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::HCINTP(double PHVAL,double TW,double *HCNH3)
{
      int     I,J,I4,I5;
      double  HPLUS=0,HCMF=0,TWX=0;
	  double  YTWTMP[4] = {0.0,0.0,0.0,0.0};
      double  YHTMP[5] = {0.0,0.0,0.0,0.0,0.0};

      //+ + + DATA INITIALIZATIONS + + +
	  double  XTW[4] = {4.44,15.56,26.67,37.78};
      double  XHPLUS[5] = {1.,10.,100.,1000.,10000.};
      double  YHENC[4][5]={0.000266,0.000754,0.00198,0.00486,0.00266,0.00753,
                       0.0197,0.0480,0.0263,0.0734,0.186,0.428,0.238,0.586,
                       1.20,2.05,1.2,1.94,2.65,3.31};
 
      //adjust very low or very high values of water temperature to fit limits
      //of henry's contant data range
      if (TW < 4.44)
	  {
        //use low temperature range values for henry's constant (4.4 degrees c
        //or 40 degrees f)
        TWX= 4.44;
      }
	  else
	  {
        if (TW > 37.78) 
          //use high temperature range values for henry's constant (37.78
          //degrees c or 100 degrees f)
          TWX= 37.78;
        else
          //use unmodified water temperature value in interpolation
          TWX= TW;
      }
 
      //convert ph value to a modified version of hydrogen ion concentration
      //because our interpolation routine cant seem to work with small numbers
      HPLUS= pow(10.,(PHVAL))/1.0E6;
 
      //adjust very low or very high values of hydrogen ion concentration to fit
      //limits of henry's constant data range
      if (HPLUS > 10000.) 
	  {
        //use low hydrogen ion concentration range values for henry's constant
        HPLUS= 10000.;
      }
	  else
	  {
        if (HPLUS < 1.0)
		{
          //use high hydrogen ion concentration range values for henry's
          //constant
          HPLUS= 1.0;
        }
		else
		{
          //use unmodified hydrogen ion concentration value in interpolation
        }
      }
 
      //perform two-dimensional interpolation of henry's constant values to
      //estimate henry's constant for water temperature and ph conditions
      //in water column (based on p. 97 of numerical recipes)
      I4= 4;
      I5= 5;
      //DO 10 I= 1, 4
	  for (I=0; I<4; I++)
	  {
        //DO 20 J= 1, 5
		  for (J=0; J<5; J++)
		  {
			  //copy row into temporary storage
			  YHTMP[J]= YHENC[I][J];
		  //20     CONTINUE
		  }
        //perform linear interpolation within row of values
        INTRP1(XHPLUS,YHTMP,I5,HPLUS,&YTWTMP[I]);
	  //10   CONTINUE
	  }
      //do final interpolation in remaining dimension
      INTRP1(XTW,YTWTMP,I4,TWX,&HCMF);
 
      //convert henry's constant from molar fraction form to units of
      //atm.m3/mole:  assume 1) dilute air and water solutions
      //                     2) ideal gas law
      //                     3  stp i.e., 1 atm total pressure
      //                     3) 1 gram water = 1 cm3
 
      // xa(air)                        1
      //--------- * -----------------------------------------
      //xa(water)    (1.e+6 m3/g water)/(18.01 g/mole water)
 
      *HCNH3= HCMF*(18.01/1.E+6);
 
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   INTRP1

      + + + PURPOSE + + +
      Perform one-dimensional interpolation of Henry's constant values
      for ammonia (based on p. 82 of Numerical Recipes)
 
      + + + ARGUMENT DEFINITIONS + + +
      XARR  - one-dimensional array of independent variable values for
              which dependent variable values are available in yarr
      YARR  - one-dimensional array of dependent variable values
      LEN   - number of elements in xarr and yarr (max = 10,
              or modify c,d below)
      XVAL  - value of independent variable for which a value of
              dependent variable is to be determined by interpolation
      YVAL  - interpolated value of dependent variable
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::INTRP1(double *XARR,double *YARR,int LEN,double XVAL,double *YVAL)
{ 
 
	//+ + + LOCAL VARIABLES + + +
	double C[10],D[10],DIF,DIFT,HO,HP,W,DEN,DYVAL;
	int    I,J,NS;

	NS = 1;
	DIF= fabs(XVAL-XARR[0]);
	//find the index ns of the closest array entry
	for (I=0; I<LEN; I++)
	{
		DIFT= fabs(XVAL - XARR[I]);
		if (DIFT < DIF) 
		{
			NS = I;
			DIF= DIFT;
		}

		//initialize correction array values
		C[I]= YARR[I];
		D[I]= YARR[I];
	} 
	//select intial approximation of yval
	*YVAL= YARR[NS];
	NS  = NS - 1;
	//loop over the current values in correction value arrays (c & d)
	//to update them
	for (J=0; J<LEN-1; J++)
	{
		for (I=0; I<LEN-J; I++)
		{
			HO  = XARR[I] - XVAL;
			HP  = XARR[I + J] - XVAL;
			W   = C[I + 1] - D[I];
			DEN = HO - HP;
			DEN = W/DEN;
			//update correction array values
			D[I]= HP*DEN;
			C[I]= HO*DEN;
		}

        //select correction to yval
        if (2*NS < LEN-J) 
	        DYVAL= C[NS + 1];
        else
		{
			DYVAL= D[NS];
			NS   = NS - 1;
        }
 
        //compute yval
        *YVAL= *YVAL + DYVAL;
	}
	
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   ADVNUT

      + + + PURPOSE + + +
      Simulate the advective processes, including deposition and
      scour for the inorganic nutrient adsorbed to one sediment size
      fraction
 
      + + + ARGUMENT DEFINITIONS + + +
      ISNUT  - inflow of adsorbed nutrient to the rchres as a result
               of inflowing sediment fraction, expressed as mg.ft3/l.ivl
               or mg.m3/l.ivl
      RSED   - amount of sediment fraction in suspension at end of
               interval expressed in mg.ft3/l or mg.m3/l
      BSED   - amount of sediment fraction in bed at end of interval
               expressed in mg.ft3/l or mg.m3/l
      DEPSCR - amount of depositon (-) or scour (+) of sediment fraction
               occurring during interval, expressed as mg.ft3/l or mg.m3/l
      ROSED  - amount of sediment fraction contained in outflow from the
               rchres during interval, expressed as mg.ft3/l.ivl or
               mg.m3/l.ivl
      OSED   - amount of sediment fraction contained in outflow to an
               individual gate during interval, expressed as mg.ft3/l.ivl
               or mg.m3/l.ivl
      NEXITS - number of outflow gates from rchres
      RCHNO  - ???
      MESSU  - ftn unit no. to be used for printout of messages
      MSGFL  - fortran unit number of HSPF message file
      NUTID  - ???
      J      - ???
      RSNUTS - storage of inorganic nutrient on suspended sediment fraction
               at start of interval expressed in mg.ft3/l or mg.m3/l
      RBNUTS - storage of inorganic nutrient on bed sediment fraction
               at start of interval expressed in mg.ft3/l or mg.m3/l
      BNUT   - user-specified concentration of adsorbed inorganic nutrient
               on bed sediment fraction expressed in mg/mg
      ECNT   - ???
      SNUT   - concentration of adsorbed inorganic nutrient on suspended
               sediment fraction expressed in mg/mg
      DSNUT  - amount of inorganic nutrient entering or leaving the water
               column due to scour or depositon of a sediment fraction
               expressed in mg.ft3/l.ivl or mg.m3/l.ivl
      ROSNUT - amount of inorganic nutrient leaving the rchres due to
               outflow of sediment fraction, expressed in mg.ft3/l.ivl or
               mg.m3/l.ivl
      OSNUT  - amount of inorganic nutrient leaving the rchres through
               an individual gate due to outflow of sediment fraction,
               expressed as mg.ft3/l.ivl or mg.m3/l.ivl
      DATIM  - date and time

      + + + EXTERNALS + + +
      OMSG,OMSTI,OMSTC,OMSTR,OMSTD
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::ADVNUT(double ISNUT,double RSED,double BSED,double DEPSCR,
					double ROSED,double RSNUTS,double RBNUTS,double BNUT,
					double &SNUT,double &DSNUT,double &ROSNUT)
{
      double DENOM = 0.0;
      if (DEPSCR < 0.0) 
	  {
        //there was sediment scour during the interval
 
        //compute flux of nutrient mass into water column with scoured
        //sediment fraction
        DSNUT = BNUT * DEPSCR;
 
        //calculate concentration in suspension-under these conditions,
        //denominator should never be zero
        SNUT  = (ISNUT + RSNUTS - DSNUT)/(RSED + ROSED);
        ROSNUT= ROSED * SNUT;
      }
	  else
	  {
        //there was deposition or no scour/deposition
        //during the interval
        DENOM= RSED + DEPSCR + ROSED;
 
        if ((fabs(DENOM)) <= 0.0) 
		{
          //there was no sediment in suspension during the interval
          SNUT  = 0.0; //-1.0E30;
          ROSNUT= 0.0;
          DSNUT = 0.0;
 
          //fix sed-nut problem caused by very small sediment loads
          //that are stored in wdm file as zero (due to wdm attribute tolr > 0.0
          //when adsorbed nut load is not zero;
          //changed comparison from 0.0 to 1.0e-3; this should not cause
          //any mass balance errors since the condition is not likely
          //to exist over a long period and will be insignificant compared to
          //the total mass over a printout period; note that
          //1.0e-3 mg*ft3/l is 0.028 mg (a very, very small mass)
 
          if ((fabs(ISNUT)) > 1.0E-3 || (fabs(RSNUTS)) > 1.0E-3) 
		  {
			//error-under these conditions these values should be zero
//			AfxMessageBox("error -- ADVNUT");
//			return 2;
          }
 
        }
		else
		{
          //there was some suspended sediment during the interval
 
          //calculate conc on suspended sed
          SNUT  = (ISNUT + RSNUTS)/DENOM;
          ROSNUT= ROSED * SNUT;
          DSNUT = DEPSCR * SNUT;
 
          if ((fabs(RSED)) <= 0.0) 
            //rchres ended up without any suspended sediment-revise
            //value for snut, but values obtained for rosnut, and dsnut
            //are still ok
            SNUT= 0.0; //-1.0E30;
        }
 
        //calculate conditions on the bed
        if ((fabs(BSED)) <= 0.0) 
		{
          //no bed sediments at end of interval
          if ((fabs(DSNUT)) > 0.0 || (fabs(RBNUTS)) > 0.0) 
		  {
            //error-under this condition these values should be zero
//			AfxMessageBox("error -- ADVNUT");
//			return 2;
          }
        }
		else
		{
          //there is bed sediment at the end of the interval; bed
          //concentration of nutrient is as defined by user
        }
      }

	  return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   AMMION
 
      + + + PURPOSE + + +
      Simulate ionization of ammonia to ammonium using empirical relationships
      developed by Loehr, 1973
 
      + + + ARGUMENT DEFINITIONS + + +
      TW     - water temperature in degrees c
      PH     - ph of water
      TAM    - total ammonia (nh3 + nh4) expressed as mg n/l
      NH3    - free or un-ionized ammonia expressed as mg nh3-n/l
      NH4    - ammonium (nh4) expressed as mg nh4-n/l
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::AMMION(double TW,double PH,double TAM,double *NH3,double *NH4)
{
      double RATIO,FRAC,TWX,PHX;
 
      if (TAM >= 0.0) 
	  {
        //tam is defined, compute fractions
 
        //adjust very low or high values of water temperature to fit limits of dat
        //used to develop empirical relationship
        if (TW < 5.0) 
		{
          TWX= 5.0;
        }
		else
		{
          TWX= TW;
          if (TW > 35.0)
            TWX= 35.0;
        }
        if (PH < 4.0) 
		{
          PHX= 4.0;
        }
		else
		{
          PHX= PH;
          if (PH > 10.0) 
            PHX= 10.0;
        }
 
        //compute ratio of ionization constant values for aqueous ammonia
        //and water at current water temperatue
        RATIO= (-3.39753*log(0.02409*TWX))*pow(10.,(9.));
 
        //compute fraction of total ammonia that is un-ionized
        FRAC= pow(10.,(PHX))/(pow(10.,(PHX)) + RATIO);
 
        //update nh3 and nh4 state variables to account for ionization
        *NH3=  FRAC*TAM;
        *NH4=  TAM - *NH3;
      }
	  else
	  {
        //tam conc undefined
        *NH3= 0.0; //-1.0E30;
        *NH4= 0.0; //-1.0E30;
      }
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   BENTH

      + + + PURPOSE + + +
      Simulate benthal release of constituent
 
      + + + ARGUMENT DEFINITIONS + + +
      DOX    - dissolved oxygen concentration in mg/l
      ANAER  - ???
      BRCON  - ???
      SCRFAC - ???
      DEPCOR - ???
      CONC   - ???
      RELEAS - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::BENTH(double DOX,double ANAER,double *BRCON,double SCRFAC,
				   double DEPCOR,double *CONC,double *RELEAS)
{
      int I;
 
      if (DOX > ANAER) 
        //assign aerobic release rate
        I= 1;
      else
        //assign anaerobic release rate
        I= 2;
 
      //calculate benthal release of constituent; release is a step
      //function of aerobic/anaerobic conditions, and stream velocity;
      //scrfac, the scouring factor dependent on stream velocity and
      //depcor, the conversion factor from mg/m2 to mg/l, are both
      //calculated in rqual; releas is expressed in mg/m2.ivl
      *RELEAS= BRCON[I]*SCRFAC*DEPCOR;
 
      //add release to constituent state variable
      *CONC  = *CONC + *RELEAS;
 
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   NITRIF

      + + + PURPOSE + + +
      Calculate amount of nitrification; nitrification does not
      take place if the DO concentration is less than 2.0 mg/l
 
      + + + ARGUMENT DEFINITIONS + + +
      KTAM20 - ???
      TCNIT  - ???
      TW     - water temperature in degrees C
      NO2FG  - ???
      KNO220 - ???
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      NO2    - ???
      NO3    - dissolved nitrate concentration in mg/l
      DOX    - dissolved oxygen concentration in mg/l
      DODEMD - ???
      TAMNIT - ???
      NO2NTC - ???
      NO3NIT - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::NITRIF(double KTAM20,double TCNIT,double TW,int NO2FG,
					double KNO220,double *TAM,double *NO2,double *NO3,
					double *DOX,double *DODEMD,double *TAMNIT,
					double *NO2NTC,double *NO3NIT)
{
	double NO2NIT = 0.0, RHO = 0.0, RHOC3 = 0.0, RHOC2 = 0.0;

      if (*DOX >= 2.0) 
	  {
        //calculate amount of tam oxidized to no2; tamnit is
        //expressed as mg tam-n/l
        *TAMNIT= 0.0;
        if (*TAM > 0.001) 
		{
          *TAMNIT= KTAM20*pow(TCNIT,(TW-20.))* *TAM;
          *TAM   = *TAM - *TAMNIT;
 
          if (*TAM < 0.001) 
		  {
            //adjust amount of tam oxidized so that tam state variable
            //is not a negative number; set tam to a value of .001 mg/l
            *TAMNIT= *TAMNIT + *TAM - .001;
            *TAM   = .001;
          }
        }
 
        if (NO2FG != 0) 
		{
          //calculate amount of no2 oxidized to no3; no2nit is
          //expressed as mg no2-n/l
          NO2NIT= 0.0;
          if (*NO2 > 0.001) 
            NO2NIT= KNO220*pow(TCNIT,(TW-20.))* *NO2;
 
          //update no2 state variable to account for nitrification
          if (NO2NIT > 0.0) 
		  {
            if ((*NO2+ *TAMNIT-NO2NIT) <= 0.0) 
			{
              NO2NIT= 0.9*(*NO2 + *TAMNIT);
              *NO2   = 0.1*(*NO2 + *TAMNIT);
            }
			else
			{
              *NO2   = *NO2 + *TAMNIT - NO2NIT;
            }
          }
		  else
		  {
            *NO2= *NO2 + *TAMNIT;
          }
          *NO2NTC= *TAMNIT - NO2NIT;
        }
		else
		{
          //no2 is not simulated; tam oxidized is fully oxidized to
         //no3
          NO2NIT= *TAMNIT;
          *NO2NTC= 0.0;
        }
        //update no3 state variable to account for nitrification
        //and compute concentration flux of no3
        *NO3   = *NO3 + NO2NIT;
        *NO3NIT= NO2NIT;
 
        //find oxygen demand due to nitrification
        *DODEMD= 3.22* *TAMNIT + 1.11*NO2NIT;
 
        if (*DOX < *DODEMD) 
		{
          //adjust nitrification demands on oxygen so that dox will
          //not be zero;  routine proportionally reduces tam oxidation
          //to no2 and no2 oxidation to no3
 
          RHO= *DOX / *DODEMD;
          if (RHO < 0.001) 
            RHO=0.0;
           
          RHOC3= (1. - RHO)* *TAMNIT;
          RHOC2= (1. - RHO)*NO2NIT;
          *TAM  = *TAM + RHOC3;
          if (NO2FG != 0) 
            *NO2= *NO2 - RHOC3 + RHOC2;
            
          *NO3   = *NO3 - RHOC2;
          *DODEMD= *DOX;
          *DOX   = 0.0;
          *TAMNIT= *TAMNIT - RHOC3;
           NO2NIT= NO2NIT - RHOC2;
          *NO3NIT= *NO3NIT - RHOC2;
          if (NO2FG != 0) 
            *NO2NTC= *NO2NTC - RHOC3 + RHOC2;
        }
		else
		{
          //projected do value is acceptable
          *DOX= *DOX - *DODEMD;
        }
      }
	  else
	  {
        //nitrification does not occur; set amounts of tam and no2
        //oxidized to zero
        *TAMNIT= 0.0;
         NO2NIT= 0.0;
        *DODEMD= 0.0;
        *NO2NTC= 0.0;
        *NO3NIT= 0.0;
      }
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   DENIT

      + + + PURPOSE + + +
      Calculate amount of denitrification; denitrification does not
      take place if the DO concentration is above user-specified
      threshold DO value (DENOXT)
 
      + + + ARGUMENT DEFINITIONS + + +
      KNO320 - unit denitrification rate of nitrate at 20 degrees c,
               expressed as /ivl
      TCDEN  - temperature correction coefficient for denitrification
      TW     - water temperature, degrees c
      DOX    - dissolved oxygen concentration expressed as mg/l
      DENOXT - threshold value for dissolved oxygen concentration
               above which denitrification does not occur
      NO3    - dissolved nitrate concentration expressed as mg/l
      DENNO3 - flux of nitrate denitrified to nitrogen gas expressed
               as mg n/l.ivl
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::DENIT(double KNO320,double TCDEN,double TW,double DOX,
				   double DENOXT,double *NO3,double *DENNO3)
{ 
      if (DOX <= DENOXT) 
	  {
        //calculate amount of no3 denitirified to nitrogen gas
        *DENNO3= 0.0;
        if (*NO3 > 0.001) 
		{
          *DENNO3= KNO320*pow(TCDEN,(TW-20.))* *NO3;
          *NO3   = *NO3 - *DENNO3;
 
          if (*NO3 < 0.001) 
		  {
            //adjust amount of no3 denitrified so that no3 state variable
            //is not a negative number; set no3 to a value of .001 mg/l
            *DENNO3= *DENNO3 + *NO3 - .001;
            *NO3   = .001;
          }
        }
	  }
      else
	  {
        //denitrification does not occur; set amount of no3 denitrified
        //to zero
        *DENNO3= 0.0;
      }
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   DECBAL

      + + + PURPOSE + + +
      Perform materials balance for transformation from organic to
      inorganic material by decay in reach water
 
      + + + ARGUMENT DEFINITIONS + + +
      TAMFG  - ???
      PO4FG  - ???
      DECNIT - ???
      DECPO4 - ???
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      NO3    - dissolved nitrate concentration in mg/l
      PO4    - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::DECBAL(int TAMFG,int PO4FG,double DECNIT,double DECPO4,
					double *TAM,double *NO3,double *PO4)
{ 
      if (TAMFG != 0)
        //add nitrogen transformed to inorganic nitrogen by biomass
        //decomposition to tam state variable
        *TAM= *TAM + DECNIT;
      else
        //add nitrogen transformed to inorganic nitrogen by biomass
        //decomposition to no3 state variable
        *NO3= *NO3 + DECNIT;
 
      if (PO4FG != 0) 
        //add phosphorus transformed to inorganic phosphorus by
        //biomass decomposition to po4 state variable
        *PO4= *PO4 + DECPO4;
      else
	  {
        //po4 is not simulated
      }
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   ADDSNU

      + + + PURPOSE + + +
      Simulate exchange of nutrient (phosphate or ammonium) between the
      dissolved state and adsorption on suspended sediment- 3 adsorption
      sites are considered: 1- suspended sand  2- susp. silt
      3- susp. clay
       assumes instantaneous linear equilibrium

      + + + ARGUMENT DEFINITIONS + + +
      VOL    - volume of water in reach above bed
      RSED   - storage of sediment fraction suspended in water column
      ADPM   - nutrient partition coefficient for sediment fraction j
      DNUT   - dissolved nutrient concentration in reach water
      SNUT   - concentration of nutrient adsorbed to sediment fractions
      DNUTXX - ???
      ADNUT  - flux of nutrient adsorbed (+) or desorbed (-) from each
               suspended sediment fraction (1-3) and from total suspended
               sediment (4)
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::ADDSNU(double VOL,double *RSED,double *ADPM,double *DNUT,
					   double *SNUT,double *DNUTXX,double *ADNUT)
{
      double DENOM = 0.0, NUM = 0.0, TEMP = 0.0, DNUTIN = 0.0;
 
      if (VOL > 0.0) 
	  {
        //adsorption/desorption can take place
 
        //establish nutrient equilibrium between reach water and suspended
        //sediment; first find the new dissolved nutrient conc. in reach water
        DNUTIN= *DNUT;
        NUM   = VOL* *DNUT;
        DENOM = VOL;
 
		for (int J=1; J<4; J++)
		{
          if (RSED[J] > 0.0) 
		  {
            //accumulate terms for numerator and denominator
            //in dnut equation
            NUM  = NUM + SNUT[J]*RSED[J];
            DENOM= DENOM + ADPM[J]*RSED[J];
          }
		}
 
        //calculate new dissolved concentration-units are mg/l
        *DNUT  = NUM/DENOM;
        //also calculate new tam conc if doing nh4 adsorption
        *DNUTXX= *DNUTXX - (DNUTIN - *DNUT);
 
        //calculate new conc on each sed class and the corresponding
        //adsorption/desorption flux
        ADNUT[4]= 0.0;
 
		for (J=1; J<4; J++)
		{
          if (RSED[J] > 0.0) 
		  {
            //this sediment class is present-calculate data
            //pertaining to it
 
            //new concentration
            TEMP    = *DNUT * ADPM[J];
 
            //quantity of material transferred
            ADNUT[J]= (TEMP - SNUT[J])*RSED[J];
            SNUT[J] = TEMP;
 
            //accumulate total adsorption/desorption flux above bed
            ADNUT[4]= ADNUT[4] + ADNUT[J];
 
          }
		  else
		  {
            //this sediment class is absent
            ADNUT[J]= 0.0;
            //snut(j) is unchanged-"undefined"
          }
		}
      }
	  else
	  {
        //no water, no adsorption/desorption
		for (int J=1; J<8; J++)
		{
          ADNUT[J]= 0.0;
          //snut(1 thru 3) and dnut should already have been set to
          //undefined values
		}
      }
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   ADVPLK

      + + + PURPOSE + + +
      Advect plankton
 
      + + + ARGUMENT DEFINITIONS + + +
      IPLANK - ???
      VOLS   - ???
      SROVOL - ???
      VOL    - volume of water in reach above bed
      EROVOL - ???
      SOVOL  - ???
      EOVOL  - ???
      NEXITS - number of exits from the operation
      OREF   - ???
      MXSTAY - ???
      SEED   - ???
      DELTS  - ???
      PLANK  - ???
      ROPLK  - ???
      OPLK   - ???

      + + + EXTERNALS + + +
      ADVECT
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::ADVPLK(double IPLANK,double VOLS,double SROVOL,double VOL,
					double EROVOL,int ADMOD,double VOLT,double AVVELM, 
					double OREF,double MXSTAY,double SEED,double DELTS,
					double *PLANK,double *ROPLK, double *JS, double CRRAT)
{
	double OFLO,STAY,MSTAY,PLNKAD,DPLKAD;

	//calculate concentration of plankton not subject to advection
	//during interval
	if (ADMOD == 1)
	      OFLO = (*JS * SROVOL + (1 - *JS) * EROVOL);	// m3/s
	else
		OFLO = EROVOL;	

	if (orefg == 1)
		OFLO = AVVELM;	// OREF is velocity (m/s)
 
	if (OREF > 0.0 && OFLO/OREF <= 100.0)
		STAY= (MXSTAY - SEED)*pow(2.0,(-OFLO/OREF)) + SEED;
	else
		STAY= SEED;
      
	if (*PLANK > STAY) 
	{
		//convert stay to units of mass; this mass will be converted
		//back to units of concentration based on the volume of the
		//reach/res at the end of the interval
		MSTAY= STAY*VOLS;
 
        //determine concentration of plankton subject to advection;
        //this value is passed into subroutine advect
        PLNKAD = *PLANK - STAY;
 
        //advect plankton
        DPLKAD= PLNKAD;

        advect(ADMOD, VOLT, &IPLANK, &VOLS, &SROVOL, &VOL, &EROVOL, &DPLKAD, ROPLK,
			   DELTS, JS, CRRAT);

        PLNKAD= DPLKAD;
 
        //determine final concentration of plankton in reach/res after
        //advection
        if (VOL > 0.0) 
	        *PLANK= PLNKAD + MSTAY/VOL;
        else
		    *PLANK=PLNKAD;
	}
	else
	{
        //no plankton leaves the reach/res
        *ROPLK= 0.0;
        MSTAY= *PLANK*VOLS;
 
        if (VOL > 0.0)
	       *PLANK= (MSTAY + IPLANK)/VOL;
        else
		    *PLANK= 0.0; //-1.0E30;
	}
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   LITRCH

      + + + PURPOSE + + +
      Calculate light correction factor to algal growth (cflit);
      determine amount of light available to phytoplankton and benthic
      algae
 
      + + + ARGUMENT DEFINITIONS + + +
      INLIT  - ???
      EXTB   - ???
      EXTCLA - ???
      EXTSED - ???
      AVDEPE - ???
      PHYFG  - ???
      BALFG  - ???
      PHYLIT - ???
      BALLIT - ???
      CFLIT  - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::LITRCH(double INLIT,double EXTB,double EXTCLA,double EXTSED,
					double AVDEPE,int PHYFG,int BALFG,double *PHYLIT,
					double *BALLIT,double *CFLIT)
{
      double EXTCO,EUDEP;
      //INTRINSIC  EXP,AMIN1
 
      if (INLIT > 0.0) 
	  {
        //calculate extinction of light based on the base extinction
        //coefficient of the water incremented by self-shading effects
        //of phytoplankton and light extinction due to total sediment
        //suspension
        EXTCO= EXTB + EXTCLA + EXTSED;
 
        //calculate euphotic depth; euphotic depth is the distance,
        //in feet, below the surface of the water body at which one
        //percent of incident light is present
        EUDEP= 4.60517/EXTCO;
 
        if (EUDEP < AVDEPE) 
		{
          //calculate fraction of layer which is contained in the
          //euphotic zone; this fraction, cflit, will be multiplied
          //by calculated growth in algro to assure that growth only
          //occurs in the euphotic zone
          *CFLIT= EUDEP/AVDEPE;
          if (*CFLIT < .0001) 
            *CFLIT= 0.0;
        }
		else
		{
          *CFLIT= 1.0;
		}
        if (PHYFG != 0) 
		{
          //calculate amount of light available to phytoplankton; all
          //phytoplankton are assumed to be at mid-depth of the reach;
          //light is expressed as langleys per interval 
          *PHYLIT= INLIT*exp(-EXTCO*(.5*min(EUDEP,AVDEPE)));	// langleys/min (07-06-05)
          if (*PHYLIT < .0001) 
            *PHYLIT= 0.0;
        }
        if (BALFG != 0) 
		{
          //calculate amount of light available to benthic algae; all
          //benthic algae are assumed to be at the bottom depth of the
          //reach
          *BALLIT= INLIT*exp(-EXTCO*AVDEPE);
          if (*BALLIT < .0001) 
            *BALLIT=0.0;
        }
      }
	  else
	  {
        //there is no incident solar radiation; algal growth cannot
        //occur
        *CFLIT = 0.0;
        *PHYLIT= 0.0;
        *BALLIT= 0.0;
      }
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   PHYRX

      + + + PURPOSE + + +
      Simulate behavior of phytoplankton, as standing crop, in units
      of umoles P per liter
 
      + + + ARGUMENT DEFINITIONS + + +
      PHYLIT - ???
      TW     - water temperature in degrees C
      TALGRL - ???
      TALGRH - ???
      TALGRM - ???
      MALGR  - ???
      CMMP   - ???
      CMMNP  - ???
      TAMFG  - ???
      AMRFG  - ???
      NSFG   - ???
      CMMN   - ???
      CMMLT  - ???
      DELT60 - simulation time interval in hours
      CFLIT  - ???
      ALR20  - ???
      CVBPN  - ???
      PHFG   - ???
      DECFG  - ???
      CVBPC  - ???
      PALDH  - ???
      NALDH  - ???
      CLALDH - ???
      ALDL   - ???
      ALDH   - ???
      ANAER  - ???
      OXALD  - ???
      ALNPR  - ???
      CVBO   - ???
      REFR   - ???
      CVNRBO - ???
      CVPB   - ???
      CVBCL  - ???
      LIMIT  - ???
      CO2    - ???
      PO4    - ???
      NO3    - dissolved nitrate concentration in mg/l
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      DOX    - dissolved oxygen concentration in mg/l
      ORN    - ???
      ORP    - ???
      ORC    - ???
      BOD    - ???
      PHYTO  - ???
      LIMPHY - ???
      PHYCO2 - ???
      PHYCLA - ???
      DOPHY  - ???
      BODPHY - ???
      TAMPHY - ???
      NO3PHY - ???
      PO4PHY - ???
 
      + + + EXTERNALS + + +
      ALGRO,GROCHK,PHYDTH,ORGBAL,NUTRUP
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::PHYRX(double PHYLIT,double TW,double TALGRL,double TALGRH,
				   double TALGRM,double MALGR,double CMMP,double CMMNP,
				   int TAMFG,int AMRFG,int NSFG,double CMMN,double CMMLT,
				   double DELT60,double CFLIT,double ALR20,double CVBPN,
				   int PHFG,int DECFG,double CVBPC,double PALDH,double NALDH,
				   double CLALDH,double ALDL,double ALDH,double ANAER,
				   double OXALD,double ALNPR,double CVBO,double REFR,
				   double CVNRBO,double CVPB,double CVBCL,CString *LIMIT,
				   double CO2,double *PO4,double *NO3,double *TAM,double *DOX,
				   double *ORN,double *ORP,double *ORC,double *BOD,double *PHYTO,
				   CString *LIMPHY,double *PHYCO2,double *PHYCLA,double *DOPHY,
				   double *BODPHY,double *TAMPHY,double *NO3PHY,double *PO4PHY)
{
      double GROPHY,PHYBD,PHYORC,PHYORN,PHYORP,STC;
 	  double RES = 0;
	  double GRO =0;
	  double DTHPHY =0;
	
      //convert phyto to units of umoles phosphorus (stc) and
      //ug chlorophyll a/l (phycla) for internal calculations
      STC   = *PHYTO/CVPB;
      *PHYCLA= *PHYTO*CVBCL;
 
      //compute unit growth and respiration rates for phytoplankton;
      //determine growth limiting factor
      ALGRO(PHYLIT,PO4,NO3,TW,TALGRL,TALGRH,TALGRM,MALGR,CMMP,
			CMMNP,TAMFG,AMRFG,TAM,NSFG,CMMN,CMMLT,ALR20,CFLIT,
			DELT60,LIMIT,LIMPHY,&GRO,&RES);
 
      //calculate net growth rate of phytoplankton; grophy is
      //expressed as umol phosphorus per liter per interval
      GROPHY= (GRO - RES)*STC;
 
      if (GROPHY > 0.0) 
        //adjust growth rate to account for limitations imposed by
        //availability of required nutrients
        GROCHK(PO4,NO3,TAM,PHFG,DECFG,CO2,CVBPC,CVBPN,NSFG,&GROPHY);
 
      //calculate phytoplankton death
      PHYDTH(NSFG,NO3,TAM,PO4,PALDH,NALDH,PHYCLA,CLALDH,
			 ALDL,ALDH,DOX,ANAER,OXALD,STC,&DTHPHY);
 
      //determine the new phytoplankton population
      STC= STC + GROPHY;
 
      //adjust net growth rate, if necessary, so population does not
      //fall below minimum level
      if (STC < .0025) 
	  {
        GROPHY= GROPHY - (.0025 - STC);
        STC   = .0025;
      }
      STC= STC - DTHPHY;
 
      //adjust death rate, if necessary, so that population does
      //not drop below minimum level
      if (STC < .0025) 
	  {
        DTHPHY= DTHPHY - (.0025 - STC);
        STC   = .0025;
      }
 
      //update do state variable to account for net effect of
      //phytoplankton photosynthesis and respiration
      *DOPHY= (CVPB*CVBO*GROPHY);
      if (*DOX > - *DOPHY) 
	  {
        *DOX= *DOX + *DOPHY;
      }
	  else
	  {
        *DOPHY= - *DOX;
        *DOX  = 0.0;
      }
 
      //calculate amount of refractory organic constituents which
      //result from phytoplankton death
      PHYORN= REFR*DTHPHY*CVBPN*.014;
      PHYORP= REFR*DTHPHY*.031;
      PHYORC= REFR*DTHPHY*CVBPC*.012;
 
      //calculate amount of nonrefractory organics (bod) which result
      //from phytoplankton death
      PHYBD = CVNRBO*CVPB*DTHPHY;
      *BODPHY= PHYBD;
 
      //perform materials balance resulting from phytoplankton death
      ORGBAL(PHYORN,PHYORP,PHYORC,PHYBD,ORN,ORP,ORC,BOD);
 
      //perform materials balance resulting from uptake of nutrients
      //by phytoplankton
      NUTRUP(GROPHY,NSFG,CVBPN,ALNPR,CVBPC,PHFG,DECFG,PO4,TAM,NO3,
			 PHYCO2,TAMPHY,NO3PHY,PO4PHY);
 
      //convert stc to units of mg biomass/l (phyto) and
      //ug chlorophyll a/l (phycla)
      *PHYTO = STC*CVPB;
      *PHYCLA= *PHYTO*CVBCL;
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   BALRX

      + + + PURPOSE + + +
      Simulate behavior of benthic algae in units of umoles P per
      liter; these units are used internally within BALRX so that
      algal subroutines may be shared by PHYTO and BALRX; externally,
      the benthic algae population is expressed in terms of areal
      mass, since the population is resident entirely on the
      bottom surface

      + + + ARGUMENT DEFINITIONS + + +
      BALLIT - ???
      TW     - water temperature in degrees C
      TALGRL - ???
      TALGRH - ???
      TALGRM - ???
      MALGR  - ???
      CMMP   - ???
      CMMNP  - ???
      TAMFG  - ???
      AMRFG  - ???
      NSFG   - ???
      CMMN   - ???
      CMMLT  - ???
      DELT60 - simulation time interval in hours
      CFLIT  - ???
      ALR20  - ???
      CVBPN  - ???
      PHFG   - ???
      DECFG  - ???
      CVBPC  - ???
      PALDH  - ???
      NALDH  - ???
      ALDL   - ???
      ALDH   - ???
      ANAER  - ???
      OXALD  - ???
      CFBALG - ???
      CFBALR - ???
      ALNPR  - ???
      CVBO   - ???
      REFR   - ???
      CVNRBO - ???
      CVPB   - ???
      MBAL   - ???
      DEPCOR - ???
      LIMIT  - ???
      CVBCL  - ???
      CO2    - ???
      PO4    - ???
      NO3    - dissolved nitrate concentration in mg/l
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      DOX    - dissolved oxygen concentration in mg/l
      ORN    - ???
      ORP    - ???
      ORC    - ???
      BOD    - ???
      BENAL  - ???
      LIMBAL - ???
      BALCO2 - ???
      BALCLA - ???
      DOBALG - ???
      BODBAL - ???
      TAMBAL - ???
      NO3BAL - ???
      PO4BAL - ???
 
      + + + EXTERNALS + + +
      ALGRO,GROCHK,BALDTH,ORGBAL,NUTRUP
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::BALRX(double BALLIT,double TW,double TALGRL,double TALGRH,double TALGRM,
				   double MALGR,double CMMP,double CMMNP,int TAMFG,int AMRFG,int NSFG,
				   double CMMN,double CMMLT,double DELT60,double CFLIT,double ALR20,
				   double CVBPN,int PHFG,int DECFG,double CVBPC,double PALDH,
				   double NALDH,double ALDL,double ALDH,double ANAER,double OXALD,
				   double CFBALG,double CFBALR,double ALNPR,double CVBO,double REFR,
				   double CVNRBO,double CVPB,double MBAL,double DEPCOR,CString *LIMIT,
				   double CVBCL,double CO2,double *PO4,double *NO3,double *TAM,double *DOX,
				   double *ORN,double *ORP,double *ORC,double *BOD,double *BENAL,CString *LIMBAL,
				   double *BALCO2,double *BALCLA,double *DOBALG,double *BODBAL,double *TAMBAL,
				   double *NO3BAL,double *PO4BAL)
{
      double BAL,BALORC,BALORN,BALORP,DTHBAL,GRO,GROBAL,MINBAL,RES;
	  RES = 0;
	  GRO = 0;
	  DTHBAL = 0;
 
      //convert benal to units of umoles phosphorus/l (bal) for
      //internal calculations
      BAL= (*BENAL/CVPB)*DEPCOR;
 
      //compute unit growth and respiration rates for benthic algae;
      //determine growth limiting factor
      ALGRO(BALLIT,PO4,NO3,TW,TALGRL,TALGRH,TALGRM,MALGR,CMMP,
			CMMNP,TAMFG,AMRFG,TAM,NSFG,CMMN,CMMLT,ALR20,CFLIT,
			DELT60,LIMIT,LIMBAL,&GRO,&RES);
 
      //calculate net growth rate of algae; grobal is expressed as
      //umoles phosphorus per liter per interval; benthic algae growth
      //will be expressed in terms of volume rather than area for the
      //duration of the subroutines subordinate to balrx; the output
      //values for benthic algae are converted to either mg biomass per
      //sq meter or mg chla per sq meter, whichever the user
      //specifies; cfbalg and cfbalr are the specified ratio of benthic
      //algae growth rate to phytoplankton growth rate and ratio of
      //benthic algae respiration rate to phytoplankton respiration
      //rate, respectively
 
      GROBAL= (GRO*CFBALG - RES*CFBALR)*BAL;
 
      if (GROBAL > 0.0) 
        //adjust growth rate to account for limitations imposed by
        //availability of required nutrients
        GROCHK(PO4,NO3,TAM,PHFG,DECFG,CO2,CVBPC,CVBPN,NSFG,&GROBAL);
 
      //calculate benthic algae death
      BALDTH(NSFG,NO3,TAM,PO4,PALDH,NALDH,ALDL,ALDH,MBAL,
			 DOX,ANAER,OXALD,&BAL,DEPCOR,&DTHBAL);
 
      //determine the new benthic algae population
      BAL= BAL + GROBAL;
 
      //adjust net growth rate, if necessary, so that population
      //does not fall below minimum level
      MINBAL= .0001*DEPCOR;
      if (BAL < MINBAL) 
	  {
        GROBAL= GROBAL - (MINBAL - BAL);
        BAL   = MINBAL;
      }
      BAL= BAL - DTHBAL;
 
      //adjust death rate, if necessary, so that population does not
      //drop below minimum level
      if (BAL < MINBAL) 
	  {
        DTHBAL= DTHBAL - (MINBAL - BAL);
        BAL   = MINBAL;
      }
 
      //update do state variable to account for net effect of benthic
      //algae photosynthesis and respiration
      *DOBALG= CVPB*CVBO*GROBAL;
      *DOX   = *DOX + (CVPB*CVBO*GROBAL);
      if (*DOX > - *DOBALG) 
	  {
        *DOX= *DOX + *DOBALG;
	  }
      else
	  {
        *DOBALG= - *DOX;
        *DOX   = 0.0;
      }
 
      //calculate amount of refractory organic constituents which result
      //from benthic algae death
      BALORN= REFR*DTHBAL*CVBPN*.014;
      BALORP= REFR*DTHBAL*.031;
      BALORC= REFR*DTHBAL*CVBPC*.012;
 
      //calculate amount of nonrefractory organics (bod) which result
      //from benthic algae death
      *BODBAL= CVNRBO*CVPB*DTHBAL;
	  double bodbal = *BODBAL;
 
      //perform materials balance resulting from benthic algae death
      ORGBAL(BALORN,BALORP,BALORC,bodbal,ORN,ORP,ORC,BOD);
 
      //perform materials balance resulting from uptake of nutrients
      //by benthic algae
      NUTRUP(GROBAL,NSFG,CVBPN,ALNPR,CVBPC,PHFG,DECFG,PO4,TAM,
			 NO3,BALCO2,TAMBAL,NO3BAL,PO4BAL);
 
      //convert bal back to external units; benal is expressed as
      //mg biomass/m2 and balcla is expressed as ug chlorophyll a/m2
      *BENAL = (BAL*CVPB)/DEPCOR;
      *BALCLA= *BENAL*CVBCL;
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   ALGRO
 
      + + + PURPOSE + + +
      Calculate unit growth and respiration rates for algae
      population; both are expressed in units of per interval
 
      + + + ARGUMENT DEFINITIONS + + +
      LIGHT  - ???
      PO4    - ???
      NO3    - dissolved nitrate concentration in mg/l
      TW     - water temperature in degrees C
      TALGRL - ???
      TALGRH - ???
      TALGRM - ???
      MALGR  - ???
      CMMP   - ???
      CMMNP  - ???
      TAMFG  - ???
      AMRFG  - ???
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      NSFG   - ???
      CMMN   - ???
      CMMLT  - ???
      ALR20  - ???
      CFLIT  - ???
      DELT60 - simulation time interval in hours
      LIMIT  - ???
      LIMR   - ???
      GRO    - ???
      RES    - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::ALGRO(double LIGHT,double *PO4,double *NO3,double TW,double TALGRL,
				   double TALGRH,double TALGRM,double MALGR,double CMMP,
				   double CMMNP,int TAMFG,int AMRFG,double *TAM,int NSFG,
				   double CMMN,double CMMLT,double ALR20,double CFLIT,double DELT60,
				   CString *LIMIT,CString *LIMR,double *GRO,double *RES)
{
      double TCMALG,MALGRT,GROP,MALGN,LOLIM,MMN,GRON,GROL;
//      char LIM;
 
      if (LIGHT > .001) 
	  {
        //sufficient light to support growth
        if (*PO4 > 0.001 && *NO3 > 0.001) 
		{
          //sufficient nutrients to support growth
          if (TW > TALGRL && TW < TALGRH) 
		  {
            //water temperature allows growth
 
            //calculate temperature correction fraction
            if (TW < TALGRM) 
              TCMALG= (TW - TALGRL)/(TALGRM - TALGRL);
            else
              //no temperature correction to maximum unit growth rate
              //is necessary; water temperature is in the optimum
              //range for phytoplankton growth
              TCMALG= 1.0;
 
            //perform temperature correction to maximum unit growth
            //rate; units of malgrt are per interval
            MALGRT= MALGR*TCMALG;
 
            //calculate maximum phosphorus limited unit growth rate
            GROP= MALGRT* *PO4* *NO3/((*PO4 + CMMP)*(*NO3 + CMMNP));
 
            //calculate the maximum nitrogen limited unit growth rate
            if (TAMFG != 0) 
			{
              //consider influence of tam on growth rate
              if (AMRFG != 0) 
			  {
                //calculate tam retardation to nitrogen limited
                //growth rate
                MALGN= MALGRT - 0.757* *TAM + 0.051* *NO3;
 
                //check that calculated unit growth rate does not
                //exceed maximum allowable growth rate
                if (MALGN > MALGRT) 
				{
                  MALGN= MALGRT;
                }
				else
				{
                  //check that calculated unit growth rate is not
                  //less than .001 of the maximum unit growth rate;
                  //if it is, set the unit growth rate equal to .001
                  //of the maximum unit growth rate
                  LOLIM= .001*MALGRT;
                  if (MALGN < LOLIM)
                    MALGN= LOLIM;
                }
              }
			  else
			  {
                //ammonia retardation is not considered
                MALGN= MALGRT;
              }
 
              if (NSFG != 0) 
                //include tam in nitrogen pool for calculation of
                //nitrogen limited growth rate
                MMN= *NO3 + *TAM;
              else
                //tam is not included in nitrogen pool for calculation
                //of nitrogen limited growth
                MMN= *NO3;
			}
			else
			{
              //tam is not simulated
              MALGN= MALGRT;
              MMN  = *NO3;
            }
 
            //calculate the maximum nitrogen limited unit growth rate
            GRON= (MALGN*MMN)/(CMMN + MMN);
 
            //calculate the maximum light limited unit growth rate
            GROL= (MALGRT*LIGHT)/(CMMLT + LIGHT);
 
            //find the actual algal unit growth rate (gro); gro is
            //the smallest of the three computed unit growth rates
            //(grop,gron,grol) and is expressed in units of per
            //interval; assign a three letter label to lim which will
            //be printed in the output to indicate the growth limiting
            //factor for the interval: limit(1)= 'lit'
            //                         limit(2)= 'non'
            //                         limit(3)= 'tem'
            //                         limit(4)= 'nit'
            //                         limit(5)= 'po4'
            //                         limit(6)= 'none'
            //                         limit(7)= 'wat'
 
            if (GROP < GRON && GROP < GROL) 
			{
              *GRO= GROP;
              *LIMR = LIMIT[4];
			}
			else
			{
              if (GRON < GROL) 
			  {
                *GRO= GRON;
                *LIMR = LIMIT[3];
              }
			  else
			  {
                *GRO= GROL;
                *LIMR = LIMIT[0];
              }
            }
 
            if (*GRO < (.000001*DELT60)) 
              *GRO= 0.0;
 
            if (*GRO > (.95*MALGRT)) 
              //there is no limiting factor to cause less than maximum
              //growth rate
              *LIMR = LIMIT[5];
 
            //adjust growth rate if control volume is not entirely
            //contained within the euphotic zone; e.g. if only one
            //half of the control volume is in the euphotic zone, gro
            //would be reduced to one half of its specified value
            *GRO= *GRO*CFLIT;
          }
		  else
		  {
            //water temperature does not allow algal growth
            *GRO= 0.0;
            *LIMR = LIMIT[2];
          }
        }
		else
		{
          //no algal growth occurs; necessary nutrients are not
          //available
          *GRO= 0.0;
          *LIMR = LIMIT[1];
        }
      }
	  else
	  {
        //no algal growth occurs; necessary light is not available
        *GRO= 0.0;
        *LIMR = LIMIT[0];
      }
 
      //calculate unit algal respiration rate; res is expressed in
      //units of per interval; alr20 is the respiration rate at 20
      //degrees c
      *RES= ALR20*TW/20.;
 
      //save limiting factor character string as real
//      READ(LIM,1000) LIMR
	return 0;
}
 
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   GROCHK

      + + + PURPOSE + + +
      Check whether computed growth rate demands too much of any
      nutrient; adjust growth rate, if necessary, so that at least
      .001 mg/l of each nutrient remains after growth
 
      + + + ARGUMENT DEFINITIONS + + +
      PO4    - ???
      NO3    - dissolved nitrate concentration in mg/l
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      PHFG   - ???
      DECFG  - ???
      CO2    - ???
      CVBPC  - ???
      CVBPN  - ???
      NSFG   - ???
      GROW   - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::GROCHK(double *PO4,double *NO3,double *TAM,int PHFG,int DECFG,double CO2,
					double CVBPC,double CVBPN,int NSFG,double *GROW)
{
      double UPLIMP,UPLIMN,UPLIMC,UPLIM;
 
      //calculate growth rate which results in .001 mg/l of free po4
      //remaining after growth; uplimp is expressed as umoles
      //phosphorus per liter per interval
      UPLIMP= (*PO4 - .001)*32.29;
 
      //calculate growth rate which results in .001 mg/l of free
      //inorganic nitrogen remaining after growth; uplimn is expressed
      //as umoles phosphorus per interval
      if (NSFG == 0) 
        //tam is not considered as a possible nutrient
        UPLIMN= (*NO3 - .001)*71.43/CVBPN;
      else
        UPLIMN= (*NO3 + *TAM - .001)*71.43/CVBPN;
 
      UPLIMC= 1.0E30;
      if (PHFG != 0 && PHFG != 2 && DECFG == 0) 
	  {
        //phcarb is on, and co2 is being considered as a possible
        //limiting nutrient to algal growth
        if (CO2 >= 0.0) 
          //calculate growth rate which results in .001 mg/l of free
          //carbon dioxide remaining after growth; uplimc is expressed
          //as umoles phosphorus per liter per interval
          UPLIMC= (CO2 - .001)*83.33/CVBPC;
      }
 
      //check that calculated growth does not result in less than
      //.001 mg/l of orthophosphate, inorganic nitrogen, or carbon
      //dioxide; if it does, adjust growth
      UPLIM= min(min(UPLIMP,UPLIMN),UPLIMC);
      if (UPLIM < *GROW) 
        //reduce growth rate to limit
        *GROW= UPLIM;
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   PHYDTH

      + + + PURPOSE + + +
      Calculate phytoplankton death
 
      + + + ARGUMENT DEFINITIONS + + +
      NSFG   - ???
      NO3    - dissolved nitrate concentration in mg/l
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      PO4    - ???
      PALDH  - ???
      NALDH  - ???
      PHYCLA - ???
      CLALDH - ???
      ALDL   - ???
      ALDH   - ???
      DOX    - dissolved oxygen concentration in mg/l
      ANAER  - ???
      OXALD  - ???
      STC    - ???
      DTHPHY - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::PHYDTH(int NSFG,double *NO3,double *TAM,double *PO4,double PALDH,
					double NALDH,double *PHYCLA,double CLALDH,double ALDL,
					double ALDH,double *DOX,double ANAER,double OXALD,
					double STC,double *DTHPHY)
{
      double NIT,ALD;
 
      //determine whether to use high or low unit death rate; all unit
      //death rates are expressed in units of per interval
      //determine available inorganic nitrogen pool for test of nutrient
      //scarcity
      if (NSFG != 0) 
        NIT= *NO3 + *TAM;
      else
        NIT= *NO3;
 
      if (*PO4 > PALDH && NIT > NALDH) 
	  {
        //unit death rate is not incremented by nutrient scarcity
        //check for phytoplankton overcrowding
 
        if (*PHYCLA < CLALDH) 
          //unit death rate is not incremented by phytoplankton
          //overcrowding
          ALD= ALDL;
        else
          //augment unit death rate to account for overcrowding
          ALD= ALDH;
      }
	  else
	  {
        //augment unit death rate to account for nutrient scarcity
        ALD= ALDH;
      }
 
      //augment unit death rate if conditions are anaerobic
      if (*DOX < ANAER) 
        ALD= ALD + OXALD;
 
      //use unit death rate to compute death rate; aldth is expressed
      //as umoles of phosphorus per liter per interval
      *DTHPHY= ALD*STC;
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   ORGBAL

      + + + PURPOSE + + +
      Perform materials balance for transformation from living to
      dead organic material
 
      + + + ARGUMENT DEFINITIONS + + +
      DTHORN - ???
      DTHORP - ???
      DTHORC - ???
      DTHBOD - ???
      ORN    - ???
      ORP    - ???
      ORC    - ???
      BOD    - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::ORGBAL(double DTHORN,double DTHORP,double DTHORC,double DTHBOD,
					double *ORN,double *ORP,double *ORC,double *BOD)
{
      //calculate dead refractory organic nitrogen balance
      //subsequent to plankton death; plankton death may be
      //either algal death, zooplankton death, or phytoplankton
      //filtered by zooplankton but not assimilated
      *ORN= *ORN + DTHORN;
 
      //calculate dead refractory organic phosphorus balance
      //subsequent to plankton death
      *ORP= *ORP + DTHORP;
 
      //calculate dead refractory organic carbon balance
      //subsequent to plankton death
      *ORC= *ORC + DTHORC;
 
      //calculate bod balance subsequent to plankton death
      *BOD= *BOD + DTHBOD;
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   NUTRUP

      + + + PURPOSE + + +
      Perform materials balance for transformation from inorganic to
      organic material; uptake of PO4, NO3, TAM, and CO2 are considered
 
      + + + ARGUMENT DEFINITIONS + + +
      GROW   - ???
      NSFG   - ???
      CVBPN  - ???
      ALNPR  - ???
      CVBPC  - ???
      PHFG   - ???
      DECFG  - ???
      PO4    - ???
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      NO3    - dissolved nitrate concentration in mg/l
      ALCO2  - ???
      TAMALG - ???
      NO3ALG - ???
      PO4ALG - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::NUTRUP(double GROW,int NSFG,double CVBPN,double ALNPR,double CVBPC,
					int PHFG,int DECFG,double *PO4,double *TAM,double *NO3,
					double *ALCO2,double *TAMALG,double *NO3ALG,double *PO4ALG)
{
      double GROWN,ALTAM,ALNO3,NO3LIM,TAMLIM,TAMS,NO3S;
 
      //calculate po4 balance subsequent to algal uptake or release;
      //.031 is the conversion from umoles p per liter to mg of p per
      //liter
      *PO4   = *PO4 - .031*GROW;
      *PO4ALG= -.031*GROW;
 
      *TAMALG= 0.0;
      if (NSFG != 0) 
	  {
        //calculate tam balance subsequent to algal uptake or release
        //express calculated growth rate in terms of equivalent
        //nitrogen; grown is expressed as umoles nitrogen per interval
        GROWN= GROW*CVBPN;
 
        if (GROW < 0.0) 
		{
          //algal respiration exceeds growth; nitrogen released by
          //respiration is released in the form of tam; no uptake or
          //release of no3 occurs
          ALTAM= GROWN;
          ALNO3= 0.0;
        }
		else
		{
          //calculate amount of n uptake which is no3 and amount which
          //is tam
          ALNO3= ALNPR*GROWN;
          ALTAM= GROWN - ALNO3;
          //check that computed uptake of no3 does not consume more
          //than 99 percent of available free no3; if it does, satisfy
          //excess demand with free tam; no3lim is expressed as umoles
          //n per liter per interval
          NO3LIM= 70.72* *NO3;
 
          if (ALNO3 > NO3LIM) 
		  {
            ALTAM= ALTAM + ALNO3 - NO3LIM;
            ALNO3= NO3LIM;
          }
		  else
		  {
            //check that calculated uptake of tam does not consume
            //more than 99 percent of available free tam; if it does,
            //satisfy excess demand with free no3; tamlim is expressed
            //as umoles n per liter per interval
            TAMLIM= 70.72* *TAM;
 
            if (ALTAM > TAMLIM) 
			{
              ALNO3= ALNO3 + ALTAM - TAMLIM;
              ALTAM= TAMLIM;
            }
			else
			{
              //calculated uptake of inorganic nitrogen is acceptable
            }
          }
        }
 
        //calculate net uptake or release of tam by algae; .014 is
        //the conversion from umoles of n per liter per interval to
        //mg n per liter per interval
        TAMS  = *TAM;
        *TAMALG= -0.014*ALTAM;
        *TAM   = *TAM - .014*ALTAM;
        if (*TAM < .001) 
          *TAMALG= -TAMS;
         
        if (*TAM < .001) 
          *TAM= 0.0;
      }
	  else
	  {
        //all inorganic n is in the form of no3
        ALNO3= GROW*CVBPN;
      }
 
      //calculate no3 balance subsequent to algal uptake or release;
      //eliminate insignificant values of no3
      NO3S  = *NO3;
      *NO3ALG= -.014*ALNO3;
      *NO3   = *NO3 - .014*ALNO3;
      if (*NO3 < .001) 
        *NO3ALG= -NO3S;
 
      if (*NO3 < .001) 
        *NO3= 0.0;
 
      if (PHFG != 0 && DECFG == 0) 
        //calculate amount of algal uptake of co2; alco2 is expressed
        //as mg co2-c/liter
        *ALCO2= GROW*CVBPC*.012;
      else
        *ALCO2= 0.0;
	return 0;
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      SUBROUTINE   BALDTH

      + + + PURPOSE + + +
      Calculate benthic algae death
 
      + + + ARGUMENT DEFINITIONS + + +
      NSFG   - ???
      NO3    - dissolved nitrate concentration in mg/l
      TAM    - total ammonia (nh3 + nh4) in mg n/l
      PO4    - ???
      PALDH  - ???
      NALDH  - ???
      ALDL   - ???
      ALDH   - ???
      MBAL   - ???
      DOX    - dissolved oxygen concentration in mg/l
      ANAER  - ???
      OXALD  - ???
      BAL    - ???
      DEPCOR - ???
      DTHBAL - ???
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

int CLSPCMODEL::BALDTH(int NSFG,double *NO3,double *TAM,double *PO4,double PALDH,
					double NALDH,double ALDL,double ALDH,double MBAL,double *DOX,
					double ANAER,double OXALD,double *BAL,double DEPCOR,double *DTHBAL)
{
      double NIT,ALD,SLOF,BALMAX;
 
      //determine whether to use high or low unit death rate; all
      //unit death rates are expressed in units of per interval
 
      //determine available inorganic nitrogen pool for test of
      //nutrient scarcity
      if (NSFG != 0) 
        NIT= *NO3 + *TAM;
      else
        NIT= *NO3;
 
      if (*PO4 > PALDH && NIT > NALDH) 
	  {
        //unit death rate is not incremented by nutrient scarcity
        //check for benthic algae overcrowding 
        BALMAX= MBAL*DEPCOR;//micromoles phosphorus/litre
 
        if (*BAL < BALMAX) 
		{
          //unit death rate is not incremented by benthic algae
          //overcrowding
          ALD = ALDL;
          SLOF= 0.0;
        }
		else
		{
          //augment unit death rate to account for benthic algae
          //overcrowding; set bal value equal to maximum; calculate
          //amount of benthic algae in excess of mbal; these benthic
          //algae are added to aldth
          ALD = ALDH;
          SLOF= *BAL - BALMAX;
          *BAL = BALMAX;
        }
      }
	  else
	  {
        //augment unit death rate to account for nutrient scarcity
        ALD= ALDH;
      }
 
      if (*DOX < ANAER) 
        //conditions are anaerobic, augment unit death rate
        ALD= ALD + OXALD;
 
      //use unit death rate to compute death rate; dthbal is expressed
      //as umoles of phosphorus per liter per interval
      *DTHBAL= (ALD * *BAL) + SLOF;
	return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate heat exchange and water temperature */
/*     + + +   + + + */
/*     + + + FUNCTIONS + + + */
/*     + + + INTRINSICS + + + */
/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::caltemp(int dayfg,int day,int ndays,int mon,int nxtmon,int preflg,int bedflg,int tgflg,double solrad,
						double dewtmp,double airtmp,double wind,double cfsaex,double katrad,double kcond,double delt60,
						double kevap,double avdepe,double prec,double kmud,double muddep, double kgrnd,double tws,
						double cfpres,double *tgrndm,double& cloud,double& tw,double& tgrnd,double& tmud,double& tmuddt)
{
	//define vapor function based on temperature (deg c); vapor 
	//pressure is expressed in millibars 
	//adcalc is always active if constituents are being simulated, 
	//so time series obtained from it do not have to be read from 
	//inpad 
	
    if (avdepe > 0.17)
	{
		
		//convert water temperature and air temperature to degrees 
		//kelvin for determination of atmospheric longwave radiation 
		double twkelv = tw + 273.16;
		double takelv = airtmp + 273.16;
		
		//simulate heat exchange with the atmosphere (Shortwave Solar Radiation) 
		
		//calculate solar radiation absorbed(qsolar); *solrad, 
		//which is expressed in langleys/ivl, is the solar 
		//radiation at gage corrected for location of reach; 
		//0.97 accounts for surface reflection (assumed 3 percent); 
		//cfsaex is the ratio of radiation incident to water surface 
		//to gage radiation values (accounts for regional 
		//differences, shading of water surface,etc); 
		//10.0 is the conversion from ly/ivl to kcal/m2.ivl. 
		
		//c      *solrad= PAD(SOLFP + IVL1) 
		double qsolar = cfsaex * 0.97 * solrad * 10.0;
		
		//calculate *cloud cover factor for determination of 
		//atmospheric longwave radiation 
		//c      *cloud = PAD(CCFP+IVL1) 
		//Computing 2nd power

		if (cloud < 0)	cloud = 0;				//   (11-03)
		if (cloud > 10)	cloud = 10;				//   (11-03)

		double r1 = cloud;
		double cldfac = r1 * r1 * 0.0017 + 1.0;
		
		//calculate net flux of longwave radiation; qlongw is expressed 
		//in kcal/m2.ivl; 4.73e-8 is the stephan-boltzmann constant 
		//multiplied by .97 to account for emissivity of water; *katrad 
		//is the atmospheric longwave radiation coefficient 
		//(changed sign of qlongw to make it consistent with other 
		//fluxes; ie, positive = gain of heat by reach; brb 6/95) 
		
		//Computing 4th power 
		r1 = twkelv, r1 *= r1;
		
		//Computing 6th power 
		double r2 = takelv;
		r2 *= r2;
		
		double qlongw = (r1 * r1 - katrad * 1e-6 * cldfac * (r2 * (r2 * r2))) * 4.73e-8 * -1.0;
		
		//calculate conductive-convective heat transport; qcon is 
		//expressed in kcal/m2.ivl; *kcond is the heat transport 
		//coefficient for conduction-convection 
		//(changed sign of qcon to make it consistent with other 
		//fluxes; ie, positive = gain of heat by reach; brb 6/95) 
		
//		double d1 =  ((288.0 - elev * 0.001981) / 288.0);
//		cfpres = pow(d1, 5.256);
		double qcon = cfpres * kcond * 1e-4 * wind * (airtmp - tw);
		
		
		//determine saturation vapor pressure at the water surface; 
		//vpresw is expressed in millibars 
		
		//Computing 8th power 
		r2 = 0.00738 * tw + 0.8072;
		r2 *= r2;
		r2 *= r2;
		r1 = 1.8 * tw + 48.0;
		double vpresw = 33.8639 * (r2 * r2 - 1.9e-5 * fabs(r1) + 0.001316);
		
		//determine vapor pressure of air above water surface; vpresa 
		//is expressed in millibars 
		//Computing 8th power 
		r2 = 0.00738 * dewtmp + 0.8072;
		r2 *= r2;
		r2 *= r2;
		r1 = 1.8 * dewtmp + 48.0;
		double vpresa = 33.8639 * (r2 * r2 - 1.9e-5 * fabs(r1) + 0.001316);
		
		//calculate quantity of water evaporated during interval; evap 
		//is expressed in meters/ivl; *kevap is the evaporation 
		//coefficient 
		
		double evap = kevap * 1e-9 * wind * (vpresw - vpresa);
		
		//calculate heat loss due to evaporation; qevap is expressed in 
		//kcal/m2.ivl; (597300. - 570.**tw)= latent heat of vaporization 
		//(597.3 - .57**tw) multiplied by the density of water 
		//(1000 kg/m3) 
		
		double qevap = (597300.0 - tw * 570.0) * evap * -1.0;
		
		//calculate heat transfer rates for water surface; units are
		//kcal/m2.ivl
		//get quantity of precipitation and convert ft/ivl to m/ivl,
		//if necessary
		double qprec = 0.0;

		if (preflg > 0) 
		{
			//PREC= PAD(PRECFP + IVL1)
			if (prec > 0.0) 
			{
				//if (IUNITS == 2) 
					//MPREC= prec;	//m
				//else
					//MPREC= prec/3.2808;	//m
				double MPREC= prec/39.36996; //convert from inch to meter

				//calculate heat added by precip, assuming temperature is
				//equal to reach/res water temperature
				qprec = MPREC*tw*1000.0;
			}
			else
			{
				qprec= 0.0;
				//MPREC= 0.0;
			}
		}
		else
		{
			//precipitation not considered
			qprec= 0.0;
			//MPREC= 0.0;
		}

		//bed conduction         
		//first get ground temperature if method 1 or 2
		if (bedflg == 1 || bedflg == 2) 
		{
			if (tgflg == 1) 
			{
				//user-defined timeseries of ground temperature
				//TGRND= PAD(TGRNDX + IVL1)
			}
			else if (tgflg == 2) 
			{
				//single user-defined value
			}
			else if (tgflg == 3) 
			{
				//monthly values supplied by user            
				//if (dayfg == 1)
					tgrnd = dayval(&tgrndm[mon], &tgrndm[nxtmon], &day, &ndays); // degree C
			}
		}

		//compute conduction heat flux
		double qbed = 0.0;

		if (bedflg == 1) 
		{
			//one-layer bed conduction model
			qbed= kmud *(tgrnd - tw);
		}
		else if (bedflg == 2) 
		{
			//two-layer bed conduction model - brock/caupp
			bedht2(tws, tw, kmud, kgrnd, muddep, tgrnd, tmud, tmuddt, qbed);
		}
		else if (bedflg == 3) 
		{
			//Jobson's bed conduction model; set qbed to 0 initially
			//in order to compute preliminary deltt which will be
			//used later for computing qbed
			qbed = 0.0;
		}
		else
		{
			//no bed conductance
			qbed = 0.0;
		}

		//calculate total heat exchange at water surface; qtotal is 
		//expressed in kcal/m2.ivl 
		double qtotal = (qsolar + qlongw + qcon + qevap + qprec + qbed) * delt60;
		
		if (fabs(qtotal) > 1.0)
		{
			//if net heat flux > 1 kcal/m2.ivl, calculate new water temperature
			//solution technique requires sum of partial derivatives of 
			//qlongw, qcon, and qevap with respect to water temperature; 
			//this value, spd, is derived by a series of three sets 
			//of operations; the actual value of spd is not derived 
			//until the last operation 
			
			//Computing 3rd power
			//r1 = twkelv;
			//double spd = r1 * (r1 * r1) * 1.892e-7 * delt60 + cfpres * kcond * 1e-4 * wind;
			//spd += kevap * 1e-9 * wind * 588750.0 * (tw * (tw * (tw * 1.3e-7 + 1.124e-5) + 8e-4) + 0.4436);
			//spd *= 0.5;
			
			//code from HSPF v12
			double spd = 18.92E-8*pow(twkelv,3)*delt60 + cfpres*kcond*1.0E-4*wind;
			spd = spd + kevap*1.0E-9*wind*588750.*(.4436+tw*(28.63195E-3+tw*(.8E-3+tw*(.01124E-3+tw*.00013E-3))));
			spd = .5*spd;

			//calculate conversion factor to convert total heat exchange 
			//expressed in kcal/m2.ivl to degrees c/ivl for the volume 
			//of water in the reach; 
			//3.281e-3= (1000 cal/kcal)*(1 m3/10e6 cm3)*(3.281 ft/m) 
			double cvqt = 0.003281 / avdepe;
			double delttw = cvqt * qtotal / (spd * cvqt + 1.);
			double otw = tw;
			tw += delttw;
			if (tw < 0.06)
			{
				delttw = delttw + 0.06 - tw;
				tw = 0.06;
			}
		}
    }
	else
	{
		//there is too little water in reach to simulate heat exchange 
		//with atmosphere; set water temp to air temp 
		tw = airtmp;
		if (tw < 0.06)
			tw = 0.06;
    }
    return 0;
} 

//      SUBROUTINE   BEDHT2
//     I                    (TWS,TW,KMUD,KGRND,MUDDEP,TGRND,
//     M                     TMUD,TMUDDT,
//     O                     QBED)
//C
//C     + + + PURPOSE + + +
//C     Compute bed conduction heat flux using 2-interface model
//C     based on Caupp's and Brock's (1994) model of the Truckee.
//C
//C     + + + DUMMY VARIABLES + + +
//      REAL       TWS,TW,KMUD,KGRND,MUDDEP,TGRND,TMUD,TMUDDT,QBED
//C
//C     + + + ARGUMENT DEFINITIONS + + +
//C     TWS    - water temperature in previous time step (C)
//C     TW     - water temperature at current time (C)
//C     KMUD   - water-mud heat conductance coefficient (kcal/m2/C/ivl)
//C     KGRND  - ground-mud heat conductance coefficient (kcal/m2/C/ivl)
//C     MUDDEP - depth of mud (m)
//C     TGRND  - ground temperature (C)
//C     TMUD   - temperature of mud (C)
//C     TMUDDT - slope of mud temperature-time curve (C/ivl)
//C     QBED   - bed heat flux (kcal/m2/ivl)
//C

int CLSPCMODEL::bedht2(double tws,double tw,double kmud,double kgrnd,double muddep,
					   double tgrnd,double& tmud,double& tmuddt,double& qbed)
{

//C     + + + LOCAL VARIABLES + + +
//      REAL       CPR,BFLUX,BTHALF,BEDINS
//C
//C     CPR = density * specific heat of water (and mud) 
//C     CPR = 1 gm/cm3 * 1 kcal/kg/C * 1000 cm3.kg/m3/g = 1000 kcal/m3/C
//C     this model uses CPR for both water and mud, per Caupp
        double cpr = 1000.0;
//C
//C     compute mud temperature at center of current time step; 
//C     tmuddt is slope of mud temperature curve
        tmud = tmud + tmuddt/2.0;
//C
//C     compute heat flux between mud and water based on water 
//C     temperature in last time step and mud temperature at center
//C     of current time step; BFLUX = kcal/m2/ivl;
//C     CMUD is the heat conductance coefficient (kcal/m2/C/ivl);
//C     it is an input parameter; Caupp uses 0.02 kcal/m2/C/s; 
//C     WQRRS = 0.001; "Oldman River CMUD" = 0.014
        double bflux = (tmud - tws) * kmud;
//C
//C     compute a new mud temperature slope using heat flux and
//C     heat capacity of mud/water and depth ("thermal capacity") of mud
		if (cpr > 0 && muddep > 0)
			tmuddt = -bflux / cpr / muddep;
//C
//C     mud temperature at center of time step 
        double bthalf = tmud;
//C
//C     compute heat flux between ground and mud based on mud temperature
//C     at center of current time step and input ground temperature,
//C     which can be estimated by the mean annual air temperature;
//C     this flux will be used to compute mud temperature at end of  
//C     current time step; the eqn. uses mud depth (m), CPR (kcal/m3/C), 
//C     24 hr/day, and streambed thermal gradient (KGRND kcal/C/ivl/m3) 
//C     to express heat flux (BEDINS) in units of C/ivl; 
//C     depth of water is used in error; should be depth of mud, per Caupp
//C     (KGRND=0.1419 cal/C/hr/cm2 apparently assumes ground depth= 1 m ?)
        double bedins = 0.0;
		if (cpr > 0 && muddep > 0)
			bedins = kgrnd * (tgrnd - tmud) / muddep / cpr;
//C
//C     compute the new mud temperature at end of current time step
//C     first, account for heat flux between water and mud
//C     second, account for heat flux between ground and mud
        tmud = tmud + tmuddt / 2.0 + bedins;
//C
//C     compute heat flux between mud and water using mud temperature
//C     at center of time step and current water temperature;
//C     KMUD is the mud-water heat conductance coefficient (kcal/m2/C/ivl)
        qbed = (bthalf - tw) * kmud;
//C
	return 0;
} 

//     + + + PURPOSE + + + 
//     Correct air temperature for elevation difference between mean 
//     segment elevation and gage elevation 
// int CLSPCMODEL::adjtemp(double *eldat, double *gatmp, double *airtmp, int *hr, double *prec, double *delt60)	//   (09-03)
int CLSPCMODEL::adjtemp(double *eldat, double *gatmp, double *airtmp, int hrfg, double *prec, int *delt, int hr) 
{
	double laps;
	
//    double lapse[24],laps;
	
	// GATMP = gage temperture (C) 
	// AIRTMP = return corrected air temperature (C) 
	// ELDAT  = elevaion difference from gage (ft),> 0 if above gage 
	// changed based on Brian Watson's input (03-08-2011)
/*  // old values  
    lapse[0]  = 0.0035;
    lapse[1]  = 0.0035;
    lapse[2]  = 0.0035;
    lapse[3]  = 0.0035;
    lapse[4]  = 0.0035;
    lapse[5]  = 0.0035;
    lapse[6]  = 0.0037;
    lapse[7]  = 0.0040;
    lapse[8]  = 0.0041;
    lapse[9]  = 0.0043;
    lapse[10] = 0.0046;
    lapse[11] = 0.0047;
    lapse[12] = 0.0048;
    lapse[13] = 0.0049;
    lapse[14] = 0.0050;
    lapse[15] = 0.0050;
    lapse[16] = 0.0048;
    lapse[17] = 0.0046;
    lapse[18] = 0.0044;
    lapse[19] = 0.0042;
    lapse[20] = 0.0040;
    lapse[21] = 0.0038;
    lapse[22] = 0.0037;
    lapse[23] = 0.0036;
	// changed based on Brian Watson's input (03-08-2011)
	// new values
    lapse[0]  = 0.0035;
    lapse[1]  = 0.0035;
    lapse[2]  = 0.0035;
    lapse[3]  = 0.0035;
    lapse[4]  = 0.0035;
    lapse[5]  = 0.0035;
    lapse[6]  = 0.0038;
    lapse[7]  = 0.0042;
    lapse[8]  = 0.0043;
    lapse[9]  = 0.0046;
    lapse[10] = 0.0050;
    lapse[11] = 0.0051;
    lapse[12] = 0.0052;
    lapse[13] = 0.0054;
    lapse[14] = 0.0055;
    lapse[15] = 0.0055;
    lapse[16] = 0.0052;
    lapse[17] = 0.0050;
    lapse[18] = 0.0047;
    lapse[19] = 0.0044;
    lapse[20] = 0.0042;
    lapse[21] = 0.0039;
    lapse[22] = 0.0038;
    lapse[23] = 0.0036;
*/	
	// find precipitation rate during the interval; prrat is 
	// expressed in in/min 
	
	{
	    *gatmp = *gatmp * 1.8 + 32.0;	//degree F
		// *prec *= *delt60;												
		*prec /= *delt;														
		if (*prec > 8.3e-4)
		{
			// use rain period lapse rate expressed as deg c/ft
			// laps = 0.00194;													 
			laps = 0.0035;	//   (09-03) from HSPF code (F/ft)
		}
		else
		{
			// use dry period lapse rate expressed as deg F/ft 
			laps = lapse[hr];
		}
		
		// compute corrected air temperature for the end of the current 
		// interval; airtmp is expressed in degrees c 
		*airtmp = *gatmp - laps * *eldat;
		*airtmp = (*airtmp - 32.0) / 1.8;
	}
	
    return 0;
} 

int CLSPCMODEL::soilgas(double elevgc,int midofg,int madofg,int mico2fg,int maco2fg,int dayfg,
						double *idoxp,double *adoxp,double *ico2p,double *aco2p,double *idoconcm,
						double *adoconcm,double *ico2concm,double *aco2concm,int mon,int nxtmon,
						int day,int ndays,double wt,double suro,double ifwo,double agwo,
						double route_suro,double route_ifwo,double route_agwo,double bypass_suro,
						double bypass_ifwo,double bypass_agwo,double *pdoxout,double *pco2out,
						double *pdoxout_route,double *pco2out_route,double *pdoxout_bypass,
						double *pco2out_bypass)
{
	// compute co2 from land. input co2 in mg/l Output co2 in g after mult area.
	
    double d1,d2;
	double twkelv,satco2,satdox,unit;
	unit = IN_ACRE_TO_FT3*FT3_TO_M3;   
	/*   */
    if (dayfg == 1)
	{
		/*  it is the first interval of the day */
		if (midofg == 1)
			*idoxp = dayval(&idoconcm[mon], &idoconcm[nxtmon], &day, &ndays);
		if (madofg == 1)
			*adoxp = dayval(&adoconcm[mon], &adoconcm[nxtmon], &day, &ndays);
		if (mico2fg == 1)
			*ico2p = dayval(&ico2concm[mon], &ico2concm[nxtmon], &day, &ndays);
		if (maco2fg == 1)
			*aco2p = dayval(&aco2concm[mon], &aco2concm[nxtmon], &day, &ndays);
    }
	
    *pdoxout += ifwo * *idoxp * unit;
    *pdoxout += agwo * *adoxp * unit;
    *pdoxout_route += ifwo * *idoxp * unit * route_ifwo;
    *pdoxout_route += agwo * *adoxp * unit * route_agwo;
    *pdoxout_bypass += ifwo * *idoxp * unit * bypass_ifwo;
    *pdoxout_bypass += agwo * *adoxp * unit * bypass_agwo;
    *pco2out += ifwo * *ico2p * unit;
    *pco2out += agwo * *aco2p * unit;
    *pco2out_route += ifwo * *ico2p * unit * route_ifwo;
    *pco2out_route += agwo * *aco2p * unit * route_agwo;
    *pco2out_bypass += ifwo * *ico2p * unit * bypass_ifwo;
    *pco2out_bypass += agwo * *aco2p * unit * bypass_agwo;
	//oxygen calculation
	d1 =  (wt * (0.007991 - 0.77774e-4 * wt));
	satdox = (14.652 + wt * (-0.41022 + d1)) * elevgc;	// mg/l
	*pdoxout += satdox * suro * unit;
	*pdoxout_route += satdox * suro * unit * route_suro;
	*pdoxout_bypass += satdox * suro * unit * bypass_suro;
	//carbon dioxide calculation
    twkelv = wt + 273.16;
	d2 =  (2385.73 / twkelv - 14.0184 + twkelv * 0.0152642);
	satco2 = pow(10, d2);
	satco2 = satco2 * 3.16e-4 * elevgc * 12000;  /* mg/l */
	*pco2out += satco2 * suro * unit;
	*pco2out_route += satco2 * suro * unit * route_suro;
	*pco2out_bypass += satco2 * suro * unit * bypass_suro;
    return 0;
}

int CLSPCMODEL::inocarbon(double *co2, double *wt, double *ioc, double *ph)
{
    double  f0,phm,d1;
    double  k1equ, k2equ,twkelv,lco2;
	
	twkelv =*wt +273.16;	// water temp in kelvin
	lco2 =*co2 /12000;		// mg/l -> mole 
	
	/*       calculate ionization product of water */
	//		d1 =  (-4470.99 / twkelv + 6.0875 -	twkelv * 0.01706);
	//		kwequ = pow(10, d1);
	
	/*       calculate first dissociation constant of carbonic acid */
	d1 =  (-3404.71 / twkelv + 14.8435 - twkelv * 0.032786);
	k1equ = pow(10, d1);
	
	/*       calculate second dissociation constant of carbonic acid */
	d1 =  (-2902.39 / twkelv + 6.498 - twkelv * 0.02379);
	k2equ = pow(10, d1);
	
	d1 =  -(*ph);
	phm = pow(10, d1);
	f0   = phm * phm/(phm*phm+ k1equ * phm + k1equ * k2equ );
	*ioc = lco2 /f0;
	*ioc *= 12000;
	//TRACE("f0 = ico = pH = %lf  %lf %lf",f0,*ioc,phm);
	//Log("f0 = ico = pH = %lf  %lf %lf",f0,*ioc,phm);
    return 0;
} /* inocarbon */

/*
bool CLSPCMODEL::ReadTempRecord(CString strFileName, int nOrder, TempTimeSeries& wsdr)
{
	// open this file
	FILE *fp = fopen(LPCSTR(strFileName),"r+b");
	if(fp == NULL)
		return false;
	// seek to the correct position
	long nLen = nOrder*sizeof(TempTimeSeries);
	if(fseek(fp,nLen,SEEK_SET))
	{
		fclose(fp);
		return false;
	}
	// read the structure
	if(fread(&wsdr,sizeof(TempTimeSeries),1, fp) != 1)
	{
		fclose(fp);
		return false;
	}
	fclose(fp);
	return true;
}

bool CLSPCMODEL::AddTempRecord(CString strFileName, TempTimeSeries wsdr)
{
	// open the file for appending
	FILE *fp = fopen(LPCSTR(strFileName),"a+b");
	if(fp == NULL)
		return false;
	if(fwrite(&wsdr,sizeof(TempTimeSeries),1, fp) != 1)
	{
		fclose(fp);
		return false;
	}
	fclose(fp);
	return true;
}

int CLSPCMODEL::TempRecordNum(CString strFileName)
{
	// open this file
	FILE *fp = fopen(LPCSTR(strFileName),"r+b");
	if(fp == NULL)
		return 0;
	if(fseek(fp,0,SEEK_END))
		return 0;
	long nLength = ftell(fp);
	int nNum = nLength/sizeof(TempTimeSeries);
	fclose(fp);																		

	return nNum;
}
*/
bool CLSPCMODEL::NetworkProcess()
{
	//NETWORK
	CMainFrame *pWnd = (CMainFrame *)AfxGetMainWnd();
	
	// mapping between watershed and reach
//	MapReach2SWS();
	
	// get order of each stream
	if(!AssignReachOrder())									
		return false;

	return true;
}

bool CLSPCMODEL::WriteOutputHeader(CString strFileName, int j)
{
	CString strMsg, strUnit;
	FILE *fp = NULL;
	fp = fopen(LPCSTR(strFileName), "w+t");
	if(fp == NULL)
	{
		strMsg = "Cannot open file "+strFileName+" for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	TRY
	{
		CString str;
		str.Format("TT %s\n",LSPC_VERSION);

		fputs("TT-----------------------------------------------------------------------------------------\n",fp);
		fputs("TT LSPC -- Loading Simulation Program, C++\n",fp);
	    fputs(LPCSTR(str),fp);
		fputs("TT\n",fp);
		fputs("TT Designed and maintained by:\n",fp);
		fputs("TT     Tetra Tech, Inc.\n",fp);
		fputs("TT     10306 Eaton Place, Suite 340\n",fp);
		fputs("TT     Fairfax, VA 22030\n",fp);
		fputs("TT     (703) 385-6000\n",fp);
		fputs("TT-----------------------------------------------------------------------------------------\n",fp);

		fputs("TT LSPC MODEL OUTPUT FILE\n", fp);
		SYSTEMTIME tm;
		GetLocalTime(&tm);

		str.Format("TT This output file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
		fputs(LPCSTR(str),fp);

		CString outoption, outdaily, outstep;												 
		outdaily.Format("day");																 
		outstep.Format("timestep");															 

		if (optlevel == 1) outoption = outdaily;											 
		if (optlevel == 2) outoption = outstep;												 

		fprintf(fp, "TT Time interval: %d min      Output option: %s\n",deltm,outoption);     
		fputs("TT Label   \n", fp);
		
		if(cOP.blistOutput[PRECP])																			
			fprintf(fp, "TT PREC     precipitation (rain + snow) volume (in-acre/%s)\n",outoption);

		if(snowfg == 1)	
		{
			if(cOP.blistOutput[AIRTMP])	
			{
				if (optlevel == 1)
				{
					fprintf(fp, "TT AIRTMP_MIN   minimum air temperature (degree F)\n");
					fprintf(fp, "TT AIRTMP_MAX   maximum air temperature (degree F)\n");
				}
				fprintf(fp, "TT AIRTMP   air temperature (degree F)\n");
			}
			if(cOP.blistOutput[SNOTMP])																			
				fprintf(fp, "TT SNOTMP   snow temperature (degree F)\n");
			if(cOP.blistOutput[SNOWF])																			
				fprintf(fp, "TT SNOWF    precipitation (snow) volume (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[RAINF])																			
           		fprintf(fp, "TT RAINF    precipitation (rain) volume (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[PRAIN])																			
           		fprintf(fp, "TT PRAIN    rainfall entering snow pack (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[MELT])																			
           		fprintf(fp, "TT MELT     snow melt from the snow pack (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[SNOWE])																			
           		fprintf(fp, "TT SNOWE    evaporation from pack (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[WYIELD])																			
           		fprintf(fp, "TT WYIELD   water yield from pack (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[PACK])																			
				fprintf(fp, "TT PACK     total contents of pack (water equiv) (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[PACKF])																			
				fprintf(fp, "TT PACKF    frozen contents of pack, ie. snow + ice (water equiv) (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[PACKW])																			
				fprintf(fp, "TT PACKW    liquid water in pack (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[PACKI])																			
				fprintf(fp, "TT PACKI    ice in pack (water equiv) (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[PDEPTH])																			
           		fprintf(fp, "TT PDEPTH   pack depth (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[COVINDX])																		
           		fprintf(fp, "TT COVINDX  snow cover index (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[NEGHTS])																			
           		fprintf(fp, "TT NEGHTS   negative heat storage (water equiv) (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[XLNMELT])																		
           		fprintf(fp, "TT XLNMELT  maximum increment to ice in pack (in-acre/%s)\n",outoption);
			if(cOP.blistOutput[RDENPKF])																		
           		fprintf(fp, "TT RDENPKF  relative density of frozen contents of pack (packf/pdepth)\n");
			if(cOP.blistOutput[SKYCLEAR])																		
				fprintf(fp, "TT SKYCLEAR fraction of sky assumed clear\n");
			if(cOP.blistOutput[SNOCOV])																			
				fprintf(fp, "TT SNOCOV   fraction of land-segment covered by pack\n");
			if(cOP.blistOutput[DULLNESS])																		
				fprintf(fp, "TT DULLNESS dullness index of the pack\n");
			if(cOP.blistOutput[ALBEDO])																			
				fprintf(fp, "TT ALBEDO   albedo of the pack \n");
			if(cOP.blistOutput[PAKTEMP])																		
           		fprintf(fp, "TT PAKTEMP  mean temperature of the pack (degree F)\n");
			if(cOP.blistOutput[DEWTMP])																			
           		fprintf(fp, "TT DEWTMP   effective dew point temperature (degree F)\n",outoption);
		}

		if(cOP.blistOutput[SURS])
			fprintf(fp, "TT SURS     surface storage volume (in-acre)\n");
		if(cOP.blistOutput[UZS])
			fprintf(fp, "TT UZS      upper zone storage volume (in-acre)\n");
		if(cOP.blistOutput[LZS])
			fprintf(fp, "TT LZS      lower zone storage volume (in-acre)\n");
		if(cOP.blistOutput[AGWS])
			fprintf(fp, "TT AGWS     groundwater storage volume (in-acre)\n");
		if(cOP.blistOutput[SURO])
 			fprintf(fp, "TT SURO     surface outflow volume (in-acre/%s)\n",outoption);
		if(cOP.blistOutput[IFWO])
			fprintf(fp, "TT IFWO     interflow outflow volume (in-acre/%s)\n",outoption);
		if(cOP.blistOutput[AGWO])
			fprintf(fp, "TT AGWO     groundwater outflow volume (in-acre/%s)\n",outoption);
		if(cOP.blistOutput[PERO])
			fprintf(fp, "TT PERO     total outflow rate volume (in-acre/%s)\n",outoption);
		if(cOP.blistOutput[TAET])
		{
			fprintf(fp, "TT TAET     total simulated ET volume (in-acre/%s)\n",outoption);
			fprintf(fp, "TT CEPE     evaporation from interception (in-acre/%s)\n",outoption);
			fprintf(fp, "TT UZET     evaporation from upper zone (in-acre/%s)\n",outoption);
			fprintf(fp, "TT BASET    evaporation from baseflow (in-acre/%s)\n",outoption);
			fprintf(fp, "TT LZET     evaporation from lower zone (in-acre/%s)\n",outoption);
			fprintf(fp, "TT AGWET    evaporation from groundwater (in-acre/%s)\n",outoption);
		}
		if(cOP.blistOutput[PERC])
		{
//			fprintf(fp, "TT UZI      upper zone inflow volume from surface to upper zone (in-acre/%s)\n",outoption);
//			fprintf(fp, "TT UZET     upper zone ET volume from upper zone (in-acre/%s)\n",outoption);
			fprintf(fp, "TT PERC     percolation volume from upper to lower zone (in-acre/%s)\n",outoption);
		}
		if(cOP.blistOutput[INFIL])
			fprintf(fp, "TT INFIL    infiltration volume from the surface to lower zone (in-acre/%s)\n",outoption);		
		if(cOP.blistOutput[GWI])
			fprintf(fp, "TT GWI      ground water inflow volume (in-acre/%s)\n",outoption);								
		if(cOP.blistOutput[IGWI])
			fprintf(fp, "TT IGWI     deep percolation volume (in-acre/%s)\n",outoption);								
		if(cOP.blistOutput[AGWI])
			fprintf(fp, "TT AGWI     active ground water inflow volume (in-acre/%s)\n",outoption);						
		if(cOP.blistOutput[DEP])
			fprintf(fp, "TT DEP      stream depth (ft)\n");
	
		if(cOP.blistOutput[AVDEP])
			fprintf(fp, "TT AVDEP    stream average depth (ft)\n");				

		if(cOP.blistOutput[HRAD])
			fprintf(fp, "TT HRAD     stream hydraulic radius (ft)\n");			

		if(cOP.blistOutput[AVVEL])
			fprintf(fp, "TT AVVEL    stream average velocity (ft/s)\n");		

		if(cOP.blistOutput[SAREA])
			fprintf(fp, "TT SAREA    stream surface area (acres)\n");			

		if(cOP.blistOutput[TAU])
			if(sedfg == 1)
				fprintf(fp, "TT TAU      bed shear stress (kg/m^2)\n");

		if(cOP.blistOutput[VOLUME])
			fprintf(fp, "TT VOLUME   total volume in RCHRES (ft^3)\n");

		if(cOP.blistOutput[RO])
			fprintf(fp, "TT RO       total rate of outflow from RCHRES (cfs)\n");

		if(sedfg == 1)
		{
			if(cOP.blistOutput[WSSD])
				fprintf(fp, "TT WSSD     washoff of detached sediment (english tons/%s)\n",outoption);
			if(cOP.blistOutput[SCRSD])
				fprintf(fp, "TT SCRSD    scour of matrix (attached) soil (english tons/%s)\n",outoption);
			if(cOP.blistOutput[SOSED])
           		fprintf(fp, "TT SOSED    sediments load from land (english tons/%s)\n",outoption);
			if(cOP.blistOutput[SOBER])
			{
				if(sedber == 1)
           			fprintf(fp, "TT SOBER    sediments load from stream bank erosion (english tons/%s)\n",outoption);
			}
 			if(cOP.blistOutput[SSEDC])
			{
				int rgroup = pReachInfo[j].rgid - 1;
				for(int i=0; i<NumSed; i++)	
				{
					if (sandfg == 0 && rsd_param[rgroup*NumSed+i].sedflg == 0)
						continue;
	        		fprintf(fp, "TT SSED%d   suspended sediment concentration in the RCHRES (mg/l)\n",i+1);
				}
				fprintf(fp, "TT SSED   total suspended solid concentration in the RCHRES (mg/l)\n");
			}
 			if(cOP.blistOutput[LSSED])
			{
				int rgroup = pReachInfo[j].rgid - 1;
				for(int i=0; i<NumSed; i++)	
				{
					if (sandfg == 0 && rsd_param[rgroup*NumSed+i].sedflg == 0)
						continue;
	        		fprintf(fp, "TT SSEDOUT%d suspended sediment concentration in outflow from the RCHRES (mg/l)\n",i+1);
				}
				fprintf(fp, "TT SSEDOUT  total suspended solid concentration in outflow from the RCHRES (mg/l)\n");
			}
			if(cOP.blistOutput[LRSED])
			{
				int rgroup = pReachInfo[j].rgid - 1;
				for(int i=0; i<NumSed; i++)	
				{
					if (sandfg == 0 && rsd_param[rgroup*NumSed+i].sedflg == 0)
						continue;
	        		fprintf(fp, "TT RSED%d sediment bed storage (english tons)\n",i+1);
				}
				fprintf(fp, "TT RSED     sediment bed storage (english tons)\n");
			}
			if(cOP.blistOutput[LBEDDEP])
           		fprintf(fp, "TT BEDDEP   sediment bed depth (ft)\n");
			if(cOP.blistOutput[LDEPSCR])													
			{
				int rgroup = pReachInfo[j].rgid - 1;
				for(int i=0; i<NumSed; i++)	
				{
					if (sandfg == 0 && rsd_param[rgroup*NumSed+i].sedflg == 0)
						continue;
	        		fprintf(fp, "TT DEPSCR%d sediment deposition (positive) or scour (negative) (english tons/%s)\n",i+1,outoption);
				}
         		fprintf(fp, "TT DEPSCR   net sediment deposition (positive) or scour (negative) (english tons/%s)\n",outoption);
			}
			if(cOP.blistOutput[LROSED])
           		fprintf(fp, "TT ROSED    total outflows of sediment from the RCHRES (english tons/%s)\n",outoption);
		}

		if(pqalfg == 1)
		{
			if(cOP.blistOutput[SQO])
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#)");
					else
						strUnit.Format("(lb)");
					fprintf(fp, "TT SQO%d     storage of QUALOF on the surface_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[WASHQS])
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT WASHQS%d  removal of QUALSD by association with detached sediment washoff_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[SCRQS])
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT SCRQS%d   removal of QUALSD by association with scour of matrix soil_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[SOQO])
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT SOQO%d    washoff of QUALOF from surface_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[POQUAL])
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT POQUAL%d  total flux of QUAL from the PLS_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[SOQUAL])													 
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT SOQUAL%d  surface flux of QUAL from the PLS_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[IOQUAL])													 
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT IOQUAL%d  interflow flux of QUAL from the PLS_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[GOQUAL])													 
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT GOQUAL%d  groundflow flux of QUAL from the PLS_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[POQC])
				for(int i=0; i<nQuals; i++)	
					fprintf(fp, "TT POQC%d    concentration of QUAL (total) in total outflow from PLS_" + pQual[i].qname + " " + pQual[i].qunit + " \n", i+1);		 

			if(cOP.blistOutput[CONC])
				for(int i=0; i<nQuals; i++)	
					fprintf(fp, "TT CONC%d    " + pQual[i].qname + " dissolved concentration (average) in RCHRES " + pQual[i].qunit + "\n", i+1);
			
			if(cOP.blistOutput[CONCSQAL])
				for(int i=0; i<nQuals; i++)	
					fprintf(fp, "TT CONCSQAL%d " + pQual[i].qname + " suspended sediment-associated concentration (sand+silt+clay) in RCHRES " + pQual[i].qunit + "\n", i+1);

			if(cOP.blistOutput[CONCOUT])
				for(int i=0; i<nQuals; i++)	
					fprintf(fp, "TT CONCOUT%d " + pQual[i].qname + " total (dissolved + sediment-associated) concentration in outflow from the RCHRES " + pQual[i].qunit + "\n", i+1);
			
			if(cOP.blistOutput[MATSQAL])
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						//strUnit.Format("(#/%s)", outoption);
						strUnit.Format("(#)");
					else
						//strUnit.Format("(lb/%s)", outoption);
						strUnit.Format("(lb)");

					fprintf(fp, "TT MATSQAL%d_1  Storage of sediment-associated " + pQual[i].qname + " on suspended sand " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATSQAL%d_2  Storage of sediment-associated " + pQual[i].qname + " on suspended silt " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATSQAL%d_3  Storage of sediment-associated " + pQual[i].qname + " on suspended clay " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATSQAL%d_4  Storage of sediment-associated " + pQual[i].qname + " on suspended total " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATSQAL%d_5  Storage of sediment-associated " + pQual[i].qname + " on bed sand " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATSQAL%d_6  Storage of sediment-associated " + pQual[i].qname + " on bed silt " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATSQAL%d_7  Storage of sediment-associated " + pQual[i].qname + " on bed clay " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATSQAL%d_8  Storage of sediment-associated " + pQual[i].qname + " on bed total " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[MATIN])
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT MATIN%d  pollutant mass entering the RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[MATOUT])
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT MATOUT%d  pollutant mass in outflow from the RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}

			if(cOP.blistOutput[MATOSQAL])
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);

					fprintf(fp, "TT MATOSQAL%d_1   Total outflow of sand-associated qual from RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATOSQAL%d_2   Total outflow of silt-associated qual from RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATOSQAL%d_3   Total outflow of clay-associated qual from RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
					fprintf(fp, "TT MATOSQAL%d_4   Total outflow of total-associated qual from RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				}
		}

		if(oxfg == 1)		// write to the header file
		{
			if(cOP.blistOutput[DOXC])
				fprintf(fp, "TT DOX      dissolved oxygen instream concentration (mg/l)\n");
			if(cOP.blistOutput[DOXCMIN] && optlevel == 1)
				fprintf(fp, "TT DOXMIN   dissolved oxygen instream minimum concentration (mg/l)\n");
			if(cOP.blistOutput[DOXCMAX] && optlevel == 1)
				fprintf(fp, "TT DOXMAX   dissolved oxygen instream maximum concentration (mg/l)\n");
			if(cOP.blistOutput[DOXCAV] && optlevel == 1)
				fprintf(fp, "TT DOXAV    dissolved oxygen instream average concentration (mg/l)\n");
			if(cOP.blistOutput[DOXL])
				fprintf(fp, "TT DOXX     dissolved oxygen material in outflow (kg/%s)\n",outoption);
			if(cOP.blistOutput[BODC])
				fprintf(fp, "TT BOD      biochemical oxygen demand instream concentration (mg/l)\n");
			if(cOP.blistOutput[BODL])
				fprintf(fp, "TT BODX     biochemical oxygen demand material in outflow (kg/%s)\n",outoption);
		}

		if(nutfg == 1)		// write to the header file
		{
			if(cOP.blistOutput[NO3C])
				fprintf(fp, "TT NO3      nitrate instream concentration (mg/l)\n");
			if(cOP.blistOutput[NO3L])
				fprintf(fp, "TT NO3X     nitrate material in outflow (kg/%s)\n",outoption);
			if(cOP.blistOutput[TAMC])
				fprintf(fp, "TT TAM      total dissolved ammonia instream concentration (mg/l)\n");
			if(cOP.blistOutput[TAML])
				fprintf(fp, "TT TAMX     total ammonia material in outflow (kg/%s)\n",outoption);
			if(cOP.blistOutput[NO2C])
				fprintf(fp, "TT NO2      nitrite instream concentration (mg/l)\n");
			if(cOP.blistOutput[NO2L])
				fprintf(fp, "TT NO2X     nitrite material in outflow (kg/%s)\n",outoption);
			if(cOP.blistOutput[PO4C])
				fprintf(fp, "TT PO4      ortho-phosphorus instream concentration (mg/l)\n");
			if(cOP.blistOutput[PO4L])
				fprintf(fp, "TT PO4X     ortho-phosphorus material in outflow (kg/%s)\n",outoption);
			if(cOP.blistOutput[SNH4C])
			{
				fprintf(fp, "TT CONCSNH4 particulate NH4-N total (sand+silt+clay) concentration in RCHRES (mg/l)\n");
			}
			if(cOP.blistOutput[SNH4L])
			{
				for(int i=1; i<4; i++)
				{
					if (sandfg == 0 && i == 1)
						continue;
					fprintf(fp, "TT SNH4X[%d] particulate NH4-N material in outflow (kg/%s); 1=sand, 2=silt, 3=clay\n",i,outoption);
				}
			}
			if(cOP.blistOutput[SPO4C])
			{
				fprintf(fp, "TT CONCSPO4 particulate PO4-P total (sand+silt+clay) concentrations in RCHRES (mg/l)\n");
			}
			if(cOP.blistOutput[SPO4L])
			{
				for(int i=1; i<4; i++)	
				{
					if (sandfg == 0 && i == 1)
						continue;
					fprintf(fp, "TT SPO4X[%d] particulate PO4-P material in outflow (kg/%s); 1=sand, 2=silt, 3=clay\n",i,outoption);
				}
			}
		}

		if(plkfg == 1)		// write to the header file
		{
			if(cOP.blistOutput[PHYC])
				fprintf(fp, "TT PHYTO    phytoplankton instream concentration (mg/l)\n");
			if(cOP.blistOutput[PHYL])
				fprintf(fp, "TT PHYTOX   phytoplankton material in outflow (kg/%s)\n",outoption);
//				if(cOP.blistOutput[ZOOC])
//					fprintf(fp, "TT ZOO      zooplankton instream concentration (mg/l)\n");
//				if(cOP.blistOutput[ZOOL])
//					fprintf(fp, "TT ZOOX     zooplankton material in outflow (kg/%s)\n",outoption);
			if(cOP.blistOutput[PHYCLAC])
				fprintf(fp, "TT PHYCLA   phytoplankton as chlorophyll a (ug/l)\n");
			if(cOP.blistOutput[BENALC])
				fprintf(fp, "TT BENAL    benthic algae (mg/m2)\n");
			if(cOP.blistOutput[ORNC])
			{
				fprintf(fp, "TT ORN      dead refractory organic nitrogen concentration (mg/l)\n");
				fprintf(fp, "TT TORN     total organic nitrogen concentration (mg/l)\n");
			}
			if(cOP.blistOutput[ORNL])
				fprintf(fp, "TT ORNX     organic nitrogen material in outflow (kg/%s)\n",outoption);
			if(cOP.blistOutput[ORPC])
			{
				fprintf(fp, "TT ORP      dead refractory organic phosphorus concentration (mg/l)\n");
				fprintf(fp, "TT TORP     total organic phosphorus concentration (mg/l)\n");
			}
			if(cOP.blistOutput[ORPL])
				fprintf(fp, "TT ORPX     organic phosphorus material in outflow (kg/%s)\n",outoption);
			if(cOP.blistOutput[ORCC])
			{
				fprintf(fp, "TT ORC      dead refractory organic carbon concentration (mg/l)\n");
				fprintf(fp, "TT TORC     total organic carbon concentration (mg/l)\n");
			}
			if(cOP.blistOutput[ORCL])
				fprintf(fp, "TT ORCX     organic carbon material in outflow (kg/%s)\n",outoption);
		}

		if(phfg == 1)
		{
			if(cOP.blistOutput[LPH])
				fprintf(fp, "TT PH       pH value \n");
			if(cOP.blistOutput[LALK])
				fprintf(fp, "TT ALK      alkalinity value \n");
			if(cOP.blistOutput[TICC])
				fprintf(fp, "TT TIC      total inorganic carbon instream concentration (mg/l)\n");
			if(cOP.blistOutput[TICL])
				fprintf(fp, "TT TICX     total inorganic carbon material in outflow (kg/%s)\n",outoption);
			if(cOP.blistOutput[CO2C])
				fprintf(fp, "TT CO2      carbon dioxide instream concentration (as carbon) (mg/l)\n");
			if(cOP.blistOutput[CO2L])
				fprintf(fp, "TT CO2X     carbon dioxide material in outflow (kg/%s)\n",outoption);
		}
		if(tempfg == 1)
		{
			if(cOP.blistOutput[TEMPC])
			{
				if (optlevel == 1)	//daily
				{
					fprintf(fp, "TT TEMP_MIN   minimum reach temperature (degree C)\n");
					fprintf(fp, "TT TEMP_MAX   maximum reach temperature (degree C)\n");
				}
				fprintf(fp, "TT TEMP     reach temperature (degree C)\n");
			}
		}

		fputs("TT\n", fp);
		pswsinfo[j].m_fileOut = fp;
		//fclose(fp);
	}
	CATCH_ALL(e)
	{
		strMsg = "Cannot open file " + strFileName + " for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	END_CATCH_ALL
	return true;
}

bool CLSPCMODEL::WriteLinkageFileHeader(CString strFileName, Link435& plink435)
{
	int i;
	CString strMsg, strUnit;
	FILE *fp = NULL;
	fp = fopen(LPCSTR(strFileName), "w+t");
//	fp = fopen(LPCSTR(strFileName), "w+b");
	if(fp == NULL)
	{
		strMsg = "Cannot open file "+strFileName+" for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	TRY
	{
		CString str,outoption;
		str.Format("C %s\n",LSPC_VERSION);

		fputs("C-----------------------------------------------------------------------------------------\n",fp);
		fputs("C LSPC -- Loading Simulation Program, C++\n",fp);
	    fputs(LPCSTR(str),fp);
		fputs("C\n",fp);
		fputs("C Designed and maintained by:\n",fp);
		fputs("C     Tetra Tech, Inc.\n",fp);
		fputs("C     10306 Eaton Place, Suite 340\n",fp);
		fputs("C     Fairfax, VA 22030\n",fp);
		fputs("C     (703) 385-6000\n",fp);
		fputs("C-----------------------------------------------------------------------------------------\n",fp);

		fputs("C LSPC MODEL OUTPUT FILE\n", fp);
		SYSTEMTIME tm;
		GetLocalTime(&tm);

		str.Format("C This output file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
		fputs(LPCSTR(str),fp);

		outoption.Format("timestep");

		fprintf(fp, "C Time interval: %d min\n",deltm);     
		fputs("C Label   \n", fp);
		
		fprintf(fp, "C RO            outlet outflow rate from RCHRES (cfs)\n");

		if(tempfg == 1)
		{
			fprintf(fp, "C TEMP          outlet outflow temperature mass from RCHRES (degreeC*ft3/%s)\n",outoption);
		}

		if(sedfg == 1)
		{
			for(i=0; i<NumSed; i++)
			{
           		fprintf(fp, "C ROSED_%d       outlet outflow sediment mass from RCHRES (grams/%s)\n",i+1,outoption);
			}
		}

		if(pqalfg == 1)
		{
			for(i=0; i<nQuals; i++)	
			{
				if (pQual[i].qunit == "(#/100ml)")
					strUnit.Format("(#/%s)", outoption);
				else
					strUnit.Format("(lb/%s)", outoption);

				fprintf(fp, "C MATOUT%d       outlet outflow pollutant mass from RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				fprintf(fp, "C MATOSQAL%d_1   outlet outflow sand-associated qual mass from RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				fprintf(fp, "C MATOSQAL%d_2   outlet outflow silt-associated qual mass from RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
				fprintf(fp, "C MATOSQAL%d_3   outlet outflow clay-associated qual mass from RCHRES_" + pQual[i].qname + " " + strUnit + " \n", i+1);
			}
		}

		if(oxfg == 1)		
		{
			fprintf(fp, "C DO            outlet outflow dissolved oxygen mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C BOD           outlet outflow biochemical oxygen demand mass from RCHRES (g/%s)\n",outoption);
		}

		if(nutfg == 1)		
		{
			fprintf(fp, "C NO3           outlet outflow nitrate mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C TAM           outlet outflow total ammonia mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C NO2           outlet outflow nitrite mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C PO4           outlet outflow ortho-phosphorus mass from RCHRES (g/%s)\n",outoption);

			fprintf(fp, "C SNH4_1        outlet outflow sand-associated NH4 mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C SNH4_2        outlet outflow silt-associated NH4 mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C SNH4_3        outlet outflow clay-associated NH4 mass from RCHRES (g/%s)\n",outoption);

			fprintf(fp, "C SPO4_1        outlet outflow sand-associated PO4 mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C SPO4_2        outlet outflow silt-associated PO4 mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C SPO4_3        outlet outflow clay-associated PO4 mass from RCHRES (g/%s)\n",outoption);
		}

		if(plkfg == 1)		
		{
			fprintf(fp, "C PHY           outlet outflow phytoplankton mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C ZOO           outlet outflow zooplankton mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C ORN           outlet outflow organic nitrogen mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C ORP           outlet outflow organic phosphorus mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C ORC           outlet outflow organic carbon mass from RCHRES (g/%s)\n",outoption);
		}

		if(phfg == 1)
		{
			fprintf(fp, "C TIC           outlet outflow total inorganic carbon mass from RCHRES (g/%s)\n",outoption);
			fprintf(fp, "C CO2           outlet outflow carbon dioxide mass from RCHRES (g/%s)\n",outoption);
		}

		fputs("C\n", fp);
        fputs("C SimStart   SimEnd   Timestep_min   NumQuals   NumSediments\n",fp);
	    fputs("C TempFlag   SedFlag   QualFlag   OxFlag   NutFlag   PlkFlag   pHFlag\n",fp);
		fputs("C\n", fp);
		plink435.m_linkfile = fp;
	}
	CATCH_ALL(e)
	{
		strMsg = "Cannot open file " + strFileName + " for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	END_CATCH_ALL
	return true;
}

bool CLSPCMODEL::WriteLandOutputHeader(CString strFileName, int j, int k)
{
	CString strMsg, strUnit;
	FILE *fp = NULL;
	fp = fopen(LPCSTR(strFileName), "w+t");
	if(fp == NULL)
	{
		strMsg = "Cannot open file "+strFileName+" for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	TRY
	{
		CString str;
		str.Format("TT %s\n",LSPC_VERSION);

		fputs("TT-----------------------------------------------------------------------------------------\n",fp);
		fputs("TT LSPC -- Loading Simulation Program, C++\n",fp);
	    fputs(LPCSTR(str),fp);
		fputs("TT\n",fp);
		fputs("TT Designed and maintained by:\n",fp);
		fputs("TT     Tetra Tech, Inc.\n",fp);
		fputs("TT     10306 Eaton Place, Suite 340\n",fp);
		fputs("TT     Fairfax, VA 22030\n",fp);
		fputs("TT     (703) 385-6000\n",fp);
		fputs("TT-----------------------------------------------------------------------------------------\n",fp);
		fputs("TT UNIT-AREA BASED LAND OUTPUT FILE FOR EPA SUSTAIN MODEL (EXTERNAL TIMESERIES)\n", fp);
		fputs("TT-----------------------------------------------------------------------------------------\n",fp);
		SYSTEMTIME tm;
		GetLocalTime(&tm);

		str.Format("TT This output file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
		fputs(LPCSTR(str),fp);

		CString outoption, outdaily, outstep;												 
		outdaily.Format("day");																 
		outstep.Format("timestep");															 

		if (optlevel == 1) outoption = outdaily;											 
		if (optlevel == 2) outoption = outstep;												 

		fprintf(fp, "TT Time interval: %d min      Output option: %s\n",deltm,outoption);     
		fputs("TT Label   \n", fp);
		
		fprintf(fp, "TT SURO     surface outflow volume (in-acre/%s)\n",outoption);
		fprintf(fp, "TT AGWI     active ground water inflow volume (in-acre/%s)\n",outoption);						

		if(sedfg == 1)
       		fprintf(fp, "TT SOSED    sediments load from land (english tons/%s)\n",outoption);

		if(pqalfg == 1)
		{
			for(int i=0; i<nQuals; i++)	
			{
				if (pQual[i].qunit == "(#/100ml)")
					strUnit.Format("(#/%s)", outoption);
				else
					strUnit.Format("(lb/%s)", outoption);
				fprintf(fp, "TT SOQUAL%d  surface flux of QUAL from the PLS_" + pQual[i].qname + " " + strUnit + " \n", i+1);
			}
		}

		fputs("TT\n", fp);
		pluinfop[j*nlandp+k].m_fileOut = fp;
		//fclose(fp);
	}
	CATCH_ALL(e)
	{
		strMsg = "Cannot open file " + strFileName + " for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	END_CATCH_ALL
	return true;
}

bool CLSPCMODEL::WriteBaseFlowOutputHeader(CString strFileName, int j, int k)
{
	CString strMsg, strUnit;
	FILE *fp = NULL;
	fp = fopen(LPCSTR(strFileName), "w+t");
	if(fp == NULL)
	{
		strMsg = "Cannot open file "+strFileName+" for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	TRY
	{
		CString str;
		str.Format("TT %s\n",LSPC_VERSION);

		fputs("TT-----------------------------------------------------------------------------------------\n",fp);
		fputs("TT LSPC -- Loading Simulation Program, C++\n",fp);
	    fputs(LPCSTR(str),fp);
		fputs("TT\n",fp);
		fputs("TT Designed and maintained by:\n",fp);
		fputs("TT     Tetra Tech, Inc.\n",fp);
		fputs("TT     10306 Eaton Place, Suite 340\n",fp);
		fputs("TT     Fairfax, VA 22030\n",fp);
		fputs("TT     (703) 385-6000\n",fp);
		fputs("TT-----------------------------------------------------------------------------------------\n",fp);
		fputs("TT WATERSHED BASEFLOW OUTPUT FILE FOR EPA SUSTAIN MODEL (EXTERNAL TIMESERIES)\n", fp);
		fputs("TT-----------------------------------------------------------------------------------------\n",fp);
		SYSTEMTIME tm;
		GetLocalTime(&tm);

		str.Format("TT This output file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
		fputs(LPCSTR(str),fp);

		CString outoption, outdaily, outstep;												 
		outdaily.Format("day");																 
		outstep.Format("timestep");															 

		if (optlevel == 1) outoption = outdaily;											 
		if (optlevel == 2) outoption = outstep;												 

		fprintf(fp, "TT Time interval: %d min      Output option: %s\n",deltm,outoption);     
		fputs("TT Label   \n", fp);
		if (k == 1)
		{
			fprintf(fp, "TT IFWO     interflow outflow volume (in-acre/%s)\n",outoption);
			if(sedfg == 1)
       			fprintf(fp, "TT IOSED    sediments load from interflow outflow (english tons/%s)\n",outoption);

			if(pqalfg == 1)
			{
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT IOQUAL%d  " + pQual[i].qname + " load from interflow outflow " + strUnit + " \n", i+1);
				}
			}
			fputs("TT\n", fp);

			pswsinfo[j].m_file_IFWO = fp;
		}
		else
		{
			fprintf(fp, "TT AGWO     active ground water outflow volume (in-acre/%s)\n",outoption);	
			if(sedfg == 1)
       			fprintf(fp, "TT AOSED    sediments load from groundwater outflow (english tons/%s)\n",outoption);

			if(pqalfg == 1)
			{
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
						strUnit.Format("(#/%s)", outoption);
					else
						strUnit.Format("(lb/%s)", outoption);
					fprintf(fp, "TT AOQUAL%d  " + pQual[i].qname + " load from groundwater outflow " + strUnit + " \n", i+1);
				}
			}
			fputs("TT\n", fp);

			pswsinfo[j].m_file_AGWO = fp;
		}

	}
	CATCH_ALL(e)
	{
		strMsg = "Cannot open file " + strFileName + " for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	END_CATCH_ALL
	return true;
}

bool CLSPCMODEL::WriteLanduseSummaryHeader(CString strFileName,COleDateTime toStart,COleDateTime toEnd)
{
	CString strMsg, strUnit;
	FILE *fp = NULL;
	fp = fopen(LPCSTR(strFileName), "w+t");
	if(fp == NULL)
	{
		strMsg = "Cannot open file "+strFileName+" for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	TRY
	{
		if (strFileName.Right(3) == "out")
		{
			CString str;
			str.Format("TT %s\n",LSPC_VERSION);

			fputs("TT-----------------------------------------------------------------------------------------\n",fp);
			fputs("TT LSPC -- Loading Simulation Program, C++\n",fp);
		    fputs(LPCSTR(str),fp);
			fputs("TT\n",fp);
			fputs("TT Designed and maintained by:\n",fp);
			fputs("TT     Tetra Tech, Inc.\n",fp);
			fputs("TT     10306 Eaton Place, Suite 340\n",fp);
			fputs("TT     Fairfax, VA 22030\n",fp);
			fputs("TT     (703) 385-6000\n",fp);
			fputs("TT-----------------------------------------------------------------------------------------\n",fp);

			fputs("TT LSPC MODEL LANDUSE SUMMARY HEADER FILE\n", fp);
			SYSTEMTIME tm;
			GetLocalTime(&tm);

			str.Format("TT This header file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
			fputs(LPCSTR(str),fp);
			
			fprintf(fp, "TT Output start time:  %d/%d/%d\n",toStart.GetMonth(),toStart.GetDay(),toStart.GetYear());     
			fprintf(fp, "TT Output end time:    %d/%d/%d\n",toEnd.GetMonth(),toEnd.GetDay(),toEnd.GetYear());     
			fprintf(fp, "TT Simulation time step:   %d min\n",deltm);     
			fputs("TT Label   \n", fp);
			
			if(nLUsummary == 3)
				strUnit.Format("(in-acre/month)");
			else
				strUnit.Format("(in-acre/year)");

			fprintf(fp, "TT AREA     average area (acre)\n");
			fprintf(fp, "TT PREC     total precipitation (rain + snow) volume " + strUnit + " \n");
			fprintf(fp, "TT SURO     total surface outflow rate volume " + strUnit + " \n");
			fprintf(fp, "TT IFWO     total interflow outflow rate volume " + strUnit + " \n");
			fprintf(fp, "TT AGWO     total groundwater outflow rate volume " + strUnit + " \n");
			fprintf(fp, "TT PERO     total outflow rate volume " + strUnit + " \n");
			fprintf(fp, "TT TAET     total actual evapo-transpiration volume " + strUnit + " \n");
			
			if (sedfg == 1)
			{
				if(nLUsummary == 3)
					strUnit.Format("(tons/month)");
				else
					strUnit.Format("(tons/year)");

				fprintf(fp, "TT SEDLOAD  sediments load from land " + strUnit + " \n");
				fprintf(fp, "TT SEDWSSD  sediments load from land " + strUnit + "\n");
				fprintf(fp, "TT SEDSCRS  sediments load from land " + strUnit + "\n");
				fprintf(fp, "TT SEDSURO  sediments load from land " + strUnit + "\n");
				fprintf(fp, "TT SEDIFWO  sediments load from land " + strUnit + "\n");
				fprintf(fp, "TT SEDAGWO  sediments load from land " + strUnit + "\n");
			}

			if(pqalfg == 1)
			{
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
					{
						if(nLUsummary == 3)
							strUnit.Format("(#/month)");
						else
							strUnit.Format("(#/year)");
					}
					else
					{
						if(nLUsummary == 3)
							strUnit.Format("(lb/month)");
						else
							strUnit.Format("(lb/year)");
					}
					if (nLUsummary == 1)
					{
						fprintf(fp, "TT SO_" + pQual[i].qname + " surface flux of QUAL %s " + strUnit + " \n", pQual[i].qname);
						fprintf(fp, "TT IO_" + pQual[i].qname + " interflow flux of QUAL %s " + strUnit + " \n", pQual[i].qname);
						fprintf(fp, "TT AO_" + pQual[i].qname + " groundwater flux of QUAL %s " + strUnit + " \n", pQual[i].qname);
					}
					fprintf(fp, "TT PO_" + pQual[i].qname + " total flux of QUAL %s " + strUnit + " \n", pQual[i].qname);
					if (pQual[i].qsdfg > 0 && sedfg == 1)
					{
						fprintf(fp, "TT SED_" + pQual[i].qname + " total flux of sediment associated QUAL %s " + strUnit + " \n", pQual[i].qname);
						fprintf(fp, "TT SEDWSSD_" + pQual[i].qname + " total flux of sediment associated QUAL %s " + strUnit + " \n", pQual[i].qname);
						fprintf(fp, "TT SEDSCRS_" + pQual[i].qname + " total flux of sediment associated QUAL %s " + strUnit + " \n", pQual[i].qname);
					}
				}
			}

			if(oxfg == 1)
			{
				if(nLUsummary == 3)
					strUnit.Format("(lb/month)");
				else
					strUnit.Format("(lb/year)");

				for(int i=0; i<11; i++)	
				{
					if (rqflag_s[i] > 0)
						fprintf(fp, "TT RQ_%s   total flux of RQUAL %s " + strUnit + " \n",rqname_s[i],rqname_s[i]);
				}
			}

			fputs("TT\n", fp);
			fputs("TT     This is header file for the landuse summary file landuse.csv\n", fp);
			fclose(fp);
		}
		else
		{
			//csv file header line.
			if (nLUsummary == 1)
				fputs("subbasin,deluid,parmname,value1\n", fp);
			else
				fputs("subbasin,deluid,parmname,date,value1\n", fp);

			m_filelanduse = fp;
		}
	}
	CATCH_ALL(e)
	{
		strMsg = "Cannot open file " + strFileName + " for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	END_CATCH_ALL
	return true;
}

bool CLSPCMODEL::WriteStreamSummaryHeader(CString strFileName,COleDateTime toStart,COleDateTime toEnd)
{
	CString strMsg, strUnit;
	FILE *fp = NULL;
	fp = fopen(LPCSTR(strFileName), "w+t");
	if(fp == NULL)
	{
		strMsg = "Cannot open file "+strFileName+" for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	TRY
	{
		if (strFileName.Right(3) == "out")
		{
			CString str;
			str.Format("TT %s\n",LSPC_VERSION);

			fputs("TT-----------------------------------------------------------------------------------------\n",fp);
			fputs("TT LSPC -- Loading Simulation Program, C++\n",fp);
		    fputs(LPCSTR(str),fp);
			fputs("TT\n",fp);
			fputs("TT Designed and maintained by:\n",fp);
			fputs("TT     Tetra Tech, Inc.\n",fp);
			fputs("TT     10306 Eaton Place, Suite 340\n",fp);
			fputs("TT     Fairfax, VA 22030\n",fp);
			fputs("TT     (703) 385-6000\n",fp);
			fputs("TT-----------------------------------------------------------------------------------------\n",fp);

			fputs("TT LSPC MODEL STREAM SUMMARY HEADER FILE\n", fp);
			SYSTEMTIME tm;
			GetLocalTime(&tm);

			str.Format("TT This header file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
			fputs(LPCSTR(str),fp);
			
			fprintf(fp, "TT Output start time:  %d/%d/%d\n",toStart.GetMonth(),toStart.GetDay(),toStart.GetYear());     
			fprintf(fp, "TT Output end time:    %d/%d/%d\n",toEnd.GetMonth(),toEnd.GetDay(),toEnd.GetYear());     
			fprintf(fp, "TT Simulation time step:   %d min\n",deltm);     
			fputs("TT Label   \n", fp);

			if(nCHsummary == 3)
				strUnit = "month";
			else
				strUnit = "year";

			fprintf(fp, "TT USIF     upstream inflow rate volume (ft^3/%s)\n",strUnit);
			fprintf(fp, "TT LUIF     land inflow rate volume (ft^3/%s)\n",strUnit);
			fprintf(fp, "TT USBP     upstream bypass inflow rate volume (ft^3/%s)\n",strUnit);
			fprintf(fp, "TT LUBP     land bypass flow rate volume (ft^3/%s)\n",strUnit);

			if (nPtSource > 0)
			{
				fprintf(fp, "TT PSIF     pointsource inflow rate volume (ft^3/%s)\n",strUnit);
				fprintf(fp, "TT PSWD     pointsource withdrawal rate volume (ft^3/%s)\n",strUnit);
				fprintf(fp, "TT PSDT     diverted target pointsource withdrawal rate volume (ft^3/%s)\n",strUnit);
			}

			if (irrigfg == 1)
				fprintf(fp, "TT IRWD     irrigation withdrawal rate volume (ft^3/%s)\n",strUnit);

			fprintf(fp, "TT IVOL     total inflow rate volume (ft^3/%s)\n",strUnit);
			fprintf(fp, "TT RO       outflow volume for each outlet (ft^3/%s)\n",strUnit);
			fprintf(fp, "TT BP       bypass volume for each outlet (ft^3/%s)\n",strUnit);
			
			if (tempfg == 1)
			{
				fprintf(fp, "TT USTEMP   upstream heat inflow volume (degree C * ft3/%s)\n",strUnit);
				fprintf(fp, "TT LUTEMP   land heat inflow volume (degree C * ft3/%s)\n",strUnit);
				fprintf(fp, "TT USTEBP   upstream bypass heat inflow volume (degree C * ft3/%s)\n",strUnit);
				fprintf(fp, "TT LUTEBP   land bypass heat volume (degree C * ft3/%s)\n",strUnit);

				if (nPtSource > 0)
				{
					fprintf(fp, "TT PSTEMP   pointsource heat inflow volume (degree C * ft3/%s)\n",strUnit);
					fprintf(fp, "TT PSWDTEMP pointsource heat withdrawal volume (degree C * ft3/%s)\n",strUnit);
					fprintf(fp, "TT PSDTTEMP diverted pointsource heat withdrawal volume (degree C * ft3/%s)\n",strUnit);
				}

				if (irrigfg == 1)
					fprintf(fp, "TT IRWDTEMP irrigation heat withdrawal volume (degree C * ft3/%s)\n",strUnit);
				
				fprintf(fp, "TT ITEMP    total heat inflow volume (degree C * ft3/%s)\n",strUnit);
				fprintf(fp, "TT ROTEMP   heat outflow for each outlet (degree C * ft3/%s)\n",strUnit);
				fprintf(fp, "TT BPTEMP   heat bypass for each outlet (degree C * ft3/%s)\n",strUnit);
			}

			if (sedfg == 1)
			{
				fprintf(fp, "TT USSED    sediments load from the upstream (english tons/%s)\n",strUnit);
				fprintf(fp, "TT LUSED    sediments load from the land (english tons/%s)\n",strUnit);
				fprintf(fp, "TT USSBP    bypass sediments load from the upstream (english tons/%s)\n",strUnit);
				fprintf(fp, "TT LUSBP    bypass sediments load from the land (english tons/%s)\n",strUnit);
				
				if (nPtSource > 0)
				{
					fprintf(fp, "TT PSSED    sediments load from the pointsource inflow (english tons/%s)\n",strUnit);
					fprintf(fp, "TT PSWDSED  sediments load from the pointsource withdrawal (english tons/%s)\n",strUnit);
					fprintf(fp, "TT PSDTSED  diverted sediments load from the pointsource withdrawal (english tons/%s)\n",strUnit);
				}
				
				if (irrigfg == 1)
					fprintf(fp, "TT IRWDSED  sediments load from the irrigation withdrawal (english tons/%s)\n",strUnit);
				
				if (sedber == 1)
					fprintf(fp, "TT BERSED	 sediments load from the bank erosion (english tons/%s)\n",strUnit);
				
				fprintf(fp, "TT ISED     total sediments load (english tons/%s)\n",strUnit);
				fprintf(fp, "TT DEPSCR   net sediment deposition (positive) or scour (negative) (english tons/%s)\n",strUnit);
				fprintf(fp, "TT DEPMASS   sediment deposition (english tons/%s)\n",strUnit);
				fprintf(fp, "TT SCRMASS   sediment scour (english tons/%s)\n",strUnit);
				fprintf(fp, "TT BEDSED   total bed sediment load (english tons/%s)\n",strUnit);
				
				for(int i=0; i<NumSed; i++)	
					fprintf(fp, "TT ROSED_%d  class %d sediments load for each outlet (english tons/%s)\n",i+1,i+1,strUnit);
				
				for(i=0; i<NumSed; i++)	
					fprintf(fp, "TT BPSED_%d  class %d bypass sediments load for each outlet (english tons/%s)\n",i+1,i+1,strUnit);
			}

			if(pqalfg == 1)
			{
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
					{
						if(nCHsummary == 3)
							strUnit.Format("(#/month)");
						else
							strUnit.Format("(#/year)");
					}
					else
					{
						if(nCHsummary == 3)
							strUnit.Format("(lb/month)");
						else
							strUnit.Format("(lb/year)");
					}

					fprintf(fp, "TT USQUAL_" + pQual[i].qname + "     upstream inflow load of QUAL %s " + strUnit + " \n", pQual[i].qname);
					fprintf(fp, "TT LUQUAL_" + pQual[i].qname + "     land inflow load of QUAL %s " + strUnit + " \n", pQual[i].qname);
					fprintf(fp, "TT USQUBP_" + pQual[i].qname + "     bypass upstream inflow load of QUAL %s " + strUnit + " \n", pQual[i].qname);
					fprintf(fp, "TT LUQUBP_" + pQual[i].qname + "     bypass land inflow load of QUAL %s " + strUnit + " \n", pQual[i].qname);
					
					if (nPtSource > 0)
					{
						fprintf(fp, "TT PSQUAL_" + pQual[i].qname + "     pointsource inflow load of QUAL %s " + strUnit + " \n", pQual[i].qname);
						fprintf(fp, "TT PSWDQUAL_" + pQual[i].qname + "   pointsource withdrawal load of QUAL %s " + strUnit + " \n", pQual[i].qname);
						fprintf(fp, "TT PSDTQUAL_" + pQual[i].qname + "   diverted pointsource withdrawal load of QUAL %s " + strUnit + " \n", pQual[i].qname);
					}
					
					if (irrigfg == 1)
						fprintf(fp, "TT IRWDQUAL_" + pQual[i].qname + "   irrigation withdrawal load of QUAL %s " + strUnit + " \n", pQual[i].qname);
				
					if (sedfg == 1 && sedber == 1)
						fprintf(fp, "TT BERQUAL_" + pQual[i].qname + "   bank erosion load of QUAL %s " + strUnit + " \n", pQual[i].qname);

					fprintf(fp, "TT ADTOT_" + pQual[i].qname + "      total atmospheric load of QUAL %s " + strUnit + " \n", pQual[i].qname);
					fprintf(fp, "TT IQUAL_" + pQual[i].qname + "      total inflow load (including atmospheric) of QUAL %s " + strUnit + " \n", pQual[i].qname);
					fprintf(fp, "TT ADQAL_" + pQual[i].qname + "      adsorption/desorption between dissolved state and total bed sediment (sand + silt + clay) of QUAL %s " + strUnit + " \n", pQual[i].qname);
					fprintf(fp, "TT DSQAL_" + pQual[i].qname + "      deposition/scouring (sand + silt + clay) of QUAL %s " + strUnit + " \n", pQual[i].qname);
					fprintf(fp, "TT DEPQAL_" + pQual[i].qname + "      deposition (sand + silt + clay) of QUAL %s " + strUnit + " \n", pQual[i].qname);
					fprintf(fp, "TT SCRQAL_" + pQual[i].qname + "      scouring (sand + silt + clay) of QUAL %s " + strUnit + " \n", pQual[i].qname);
					fprintf(fp, "TT QUAL_" + pQual[i].qname + "     load of QUAL %s " + strUnit + " for each outlet\n", pQual[i].qname);
					fprintf(fp, "TT QUBP_" + pQual[i].qname + "     bypass load of QUAL %s " + strUnit + " for each outlet\n", pQual[i].qname);
				}
			}

			if(oxfg == 1)
			{
				for(int i=0; i<2; i++)	
				{
					if(nCHsummary == 3)
						strUnit.Format("(lb/month)");
					else
						strUnit.Format("(lb/year)");

					fprintf(fp, "TT USRQUAL_%s     upstream inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT LURQUAL_%s     land inflow load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT ATMSRQUAL_%s   atmospheric deposition load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT USRQUBP_%s     bypass upstream inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT LURQUBP_%s     bypass land inflow load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					
					if (nPtSource > 0)
					{
						fprintf(fp, "TT PSRQUAL_%s     pointsource inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
						fprintf(fp, "TT PSWDRQUAL_%s   pointsource withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
						fprintf(fp, "TT PSDTRQUAL_%s   diverted pointsource withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					}
					
					if (irrigfg == 1)
						fprintf(fp, "TT IRWDRQUAL_%s   irrigation withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
				
					fprintf(fp, "TT IRQUAL_%s      total inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT RQUAL_%s      load of RQUAL %s " + strUnit + " for each outlet \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT RQUBP_%s      bypass load of RQUAL %s " + strUnit + " for each outlet \n", rqual_s[i],rqual_s[i]);
				}
			}

			if(nutfg == 1)
			{
				for(int i=2; i<6; i++)	
				{
					if(nCHsummary == 3)
						strUnit.Format("(lb/month)");
					else
						strUnit.Format("(lb/year)");

					fprintf(fp, "TT USRQUAL_%s     upstream inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT LURQUAL_%s     land inflow load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT ATMSRQUAL_%s   atmospheric deposition load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT USRQUBP_%s     bypass upstream inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT LURQUBP_%s     bypass land inflow load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					
					if (nPtSource > 0)
					{
						fprintf(fp, "TT PSRQUAL_%s     pointsource inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
						fprintf(fp, "TT PSWDRQUAL_%s   pointsource withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
						fprintf(fp, "TT PSDTRQUAL_%s   diverted pointsource withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					}
					
					if (irrigfg == 1)
						fprintf(fp, "TT IRWDRQUAL_%s   irrigation withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
				
					fprintf(fp, "TT IRQUAL_%s      total inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT RQUAL_%s      load of RQUAL %s " + strUnit + " for each outlet\n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT RQUBP_%s      bypass load of RQUAL %s " + strUnit + " for each outlet\n", rqual_s[i],rqual_s[i]);

					if (sedfg == 1 && i == 3)
					{
						for (int j=1; j<4; j++)
						{
							fprintf(fp, "TT USRQUAL_SNH4_%d     upstream inflow sediment associated NH4 load " + strUnit + " \n",j);
							fprintf(fp, "TT LURQUAL_SNH4_%d     land inflow sediment associated NH4 load " + strUnit + " \n",j);
							fprintf(fp, "TT IRQUAL_SNH4_%d     total inflow sediment associated NH4 load " + strUnit + " \n",j);
							fprintf(fp, "TT DSRQUAL_SNH4_%d     total deposition/scour sediment associated NH4 load " + strUnit + " \n",j);
							fprintf(fp, "TT DEPRQUAL_SNH4_%d     total deposition sediment associated NH4 load " + strUnit + " \n",j);
							fprintf(fp, "TT SCRRQUAL_SNH4_%d     total scour sediment associated NH4 load " + strUnit + " \n",j);
							fprintf(fp, "TT RQUAL_SNH4_%d     outflow sediment associated NH4 load " + strUnit + " for each outlet\n",j);
							fprintf(fp, "TT RQUAL_SNH4BP_%d     bypass outflow sediment associated NH4 load " + strUnit + " for each outlet\n",j);
						}
					}
					else if (sedfg == 1 && i == 5)
					{
						for (int j=1; j<4; j++)
						{
							fprintf(fp, "TT USRQUAL_SPO4_%d     upstream inflow sediment associated PO4 load " + strUnit + " \n",j);
							fprintf(fp, "TT LURQUAL_SPO4_%d     land inflow sediment associated PO4 load " + strUnit + " \n",j);
							fprintf(fp, "TT IRQUAL_SPO4_%d     total inflow sediment associated PO4 load " + strUnit + " \n",j);
							fprintf(fp, "TT DSRQUAL_SPO4_%d     total deposition/scour sediment associated PO4 load " + strUnit + " \n",j);
							fprintf(fp, "TT DEPRQUAL_SPO4_%d     total deposition sediment associated PO4 load " + strUnit + " \n",j);
							fprintf(fp, "TT SCRRQUAL_SPO4_%d     total scour sediment associated PO4 load " + strUnit + " \n",j);
							fprintf(fp, "TT RQUAL_SPO4_%d     outflow sediment associated PO4 load " + strUnit + " for each outlet\n",j);
							fprintf(fp, "TT RQUAL_SPO4BP_%d     bypass outflow sediment associated PO4 load " + strUnit + " for each outlet\n",j);
						}
					}
					//benthic release
					if (benrfg == 1 && i == 3)
					{
						fprintf(fp, "TT BENRQUAL_NH4     benthic release of NH4 load " + strUnit + "\n");
					}
					else if (benrfg == 1 && i == 5)
					{
						fprintf(fp, "TT BENRQUAL_PO4     benthic release of PO4 load " + strUnit + "\n");
					}
				}
			}

			if(plkfg == 1)
			{
				for(int i=6; i<9; i++)	
				{
					if(nCHsummary == 3)
						strUnit.Format("(lb/month)");
					else
						strUnit.Format("(lb/year)");

					fprintf(fp, "TT USRQUAL_%s     upstream inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT LURQUAL_%s     land inflow load of RQUAL %s " + strUnit + " \n",rqual_s[i], rqual_s[i]);
					fprintf(fp, "TT ATMSRQUAL_%s   atmospheric deposition load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT USRQUBP_%s     bypass upstream inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT LURQUBP_%s     bypass land inflow load of RQUAL %s " + strUnit + " \n",rqual_s[i], rqual_s[i]);
					
					if (nPtSource > 0)
					{
						fprintf(fp, "TT PSRQUAL_%s     pointsource inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
						fprintf(fp, "TT PSWDRQUAL_%s   pointsource withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i], rqual_s[i]);
						fprintf(fp, "TT PSDTRQUAL_%s   diverted pointsource withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i], rqual_s[i]);
					}
					
					if (irrigfg == 1)
						fprintf(fp, "TT IRWDRQUAL_%s   irrigation withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i], rqual_s[i]);
				
					fprintf(fp, "TT IRQUAL_%s      total inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT RQUAL_%s      load of RQUAL %s " + strUnit + " for each outlet\n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT RQUBP_%s      bypass load of RQUAL %s " + strUnit + " for each outlet\n", rqual_s[i],rqual_s[i]);
				}
			}

			if(phfg == 1)
			{
				for(int i=9; i<11; i++)	
				{
					if(nCHsummary == 3)
						strUnit.Format("(lb/month)");
					else
						strUnit.Format("(lb/year)");

					fprintf(fp, "TT USRQUAL_%s     upstream inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT LURQUAL_%s     land inflow load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT ATMSRQUAL_%s   atmospheric deposition load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT USRQUBP_%s     bypass upstream inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT LURQUBP_%s     bypass land inflow load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					
					if (nPtSource > 0)
					{
						fprintf(fp, "TT PSRQUAL_%s     pointsource inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
						fprintf(fp, "TT PSWDRQUAL_%s   pointsource withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
						fprintf(fp, "TT PSDTRQUAL_%s   diverted pointsource withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
					}
					
					if (irrigfg == 1)
						fprintf(fp, "TT IRWDRQUAL_%s   irrigation withdrawal load of RQUAL %s " + strUnit + " \n",rqual_s[i],rqual_s[i]);
				
					fprintf(fp, "TT IRQUAL_%s      total inflow load of RQUAL %s " + strUnit + " \n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT RQUAL_%s      load of RQUAL %s " + strUnit + " for each outlet\n", rqual_s[i],rqual_s[i]);
					fprintf(fp, "TT RQUBP_%s      bypass load of RQUAL %s " + strUnit + " for each outlet\n", rqual_s[i],rqual_s[i]);
				}
			}

			fputs("TT\n", fp);
			fputs("TT     This is header file for the stream summary file stream.csv\n", fp);
			fclose(fp);
		}
		else
		{
			if (nCHsummary == 1)
				fputs("rchid,type,parmname,value1\n", fp);
			else
				fputs("rchid,type,parmname,date,value1\n", fp);

			m_filestream = fp;
		}
	}
	CATCH_ALL(e)
	{
		strMsg = "Cannot open file " + strFileName + " for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	END_CATCH_ALL
	return true;
}

bool CLSPCMODEL::WritePointSourceSummaryHeader(CString strFileName,COleDateTime toStart,COleDateTime toEnd)
{
	CString strMsg, strUnit;
	FILE *fp = NULL;
	fp = fopen(LPCSTR(strFileName), "w+t");
	if(fp == NULL)
	{
		strMsg = "Cannot open file "+strFileName+" for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	TRY
	{
		if (strFileName.Right(3) == "out")
		{
			CString str;
			str.Format("TT %s\n",LSPC_VERSION);

			fputs("TT-----------------------------------------------------------------------------------------\n",fp);
			fputs("TT LSPC -- Loading Simulation Program, C++\n",fp);
		    fputs(LPCSTR(str),fp);
			fputs("TT\n",fp);
			fputs("TT Designed and maintained by:\n",fp);
			fputs("TT     Tetra Tech, Inc.\n",fp);
			fputs("TT     10306 Eaton Place, Suite 340\n",fp);
			fputs("TT     Fairfax, VA 22030\n",fp);
			fputs("TT     (703) 385-6000\n",fp);
			fputs("TT-----------------------------------------------------------------------------------------\n",fp);

			fputs("TT LSPC MODEL POINT SOURCE SUMMARY HEADER FILE\n", fp);
			SYSTEMTIME tm;
			GetLocalTime(&tm);

			str.Format("TT This header file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
			fputs(LPCSTR(str),fp);
			
			fprintf(fp, "TT Output start time:  %d/%d/%d\n",toStart.GetMonth(),toStart.GetDay(),toStart.GetYear());     
			fprintf(fp, "TT Output end time:    %d/%d/%d\n",toEnd.GetMonth(),toEnd.GetDay(),toEnd.GetYear());     
			fprintf(fp, "TT Simulation time step:   %d min\n",deltm);     
			fputs("TT Label   \n", fp);

			if(nPSsummary == 3)
				strUnit = "month";
			else
				strUnit = "year";

			fprintf(fp, "TT PS_FLOW     pointsource inflow rate volume (ft3/%s)\n",strUnit);

			if (tempfg == 1)
				fprintf(fp, "TT PS_TEMP   pointsource heat inflow volume (degree C * ft3/%s)\n",strUnit);

			if (sedfg == 1)
			{
				fprintf(fp, "TT PS_SAND    sand load from the pointsource inflow (english tons/%s)\n",strUnit);
				fprintf(fp, "TT PS_SILT    silt load from the pointsource inflow (english tons/%s)\n",strUnit);
				fprintf(fp, "TT PS_CLAY    clay load from the pointsource inflow (english tons/%s)\n",strUnit);
			}

			if(pqalfg == 1)
			{
				for(int i=0; i<nQuals; i++)	
				{
					if (pQual[i].qunit == "(#/100ml)")
					{
						if(nPSsummary == 3)
							strUnit.Format("(#/month)");
						else
							strUnit.Format("(#/year)");
					}
					else
					{
						if(nPSsummary == 3)
							strUnit.Format("(lb/month)");
						else
							strUnit.Format("(lb/year)");
					}

					fprintf(fp, "TT PS_QUAL_" + pQual[i].qname + "     pointsource inflow load of QUAL %s " + strUnit + " \n", pQual[i].qname);
				}
			}

			if(oxfg == 1)
			{
				if(nPSsummary == 3)
					strUnit.Format("(lb/month)");
				else
					strUnit.Format("(lb/year)");

				fprintf(fp, "TT PS_DOX     pointsource inflow load of DO " + strUnit + " \n");
				fprintf(fp, "TT PS_BOD     pointsource inflow load of BOD " + strUnit + " \n");

				if(nutfg == 1)
				{
					fprintf(fp, "TT PS_NOX     pointsource inflow load of NOX " + strUnit + " \n");
					fprintf(fp, "TT PS_TAM     pointsource inflow load of TAM " + strUnit + " \n");
					fprintf(fp, "TT PS_PO4     pointsource inflow load of PO4 " + strUnit + " \n");

					if(plkfg == 1)
					{
						fprintf(fp, "TT PS_ORN     pointsource inflow load of ORN " + strUnit + " \n");
						fprintf(fp, "TT PS_ORP     pointsource inflow load of ORP " + strUnit + " \n");
						fprintf(fp, "TT PS_ORC     pointsource inflow load of ORC " + strUnit + " \n");

						if(phyfg == 1)
						{
							fprintf(fp, "TT PS_CLA     pointsource inflow load of CLA " + strUnit + " \n");
						}
					}
				}
			}

			fputs("TT\n", fp);
			fputs("TT     This is header file for the point source summary file pointsource.csv\n", fp);
			fclose(fp);
		}
		else
		{
			if (nPSsummary == 1)
				fputs("rchid,permit,pipe,parmname,value1\n", fp);
			else
				fputs("rchid,permit,pipe,parmname,date,value1\n", fp);

			m_filepointsource = fp;
		}
	}
	CATCH_ALL(e)
	{
		strMsg = "Cannot open file " + strFileName + " for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	END_CATCH_ALL
	return true;
}

bool CLSPCMODEL::WriteThresholdAnalysisSummaryHeader(CString strFileName,COleDateTime toStart,COleDateTime toEnd)
{
	CString strMsg;
	FILE *fp = NULL;
	fp = fopen(LPCSTR(strFileName), "w+t");
	if(fp == NULL)
	{
		strMsg = "Cannot open file "+strFileName+" for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	TRY
	{
		if (strFileName.Right(3) == "out")
		{
			CString str;
			str.Format("TT %s\n",LSPC_VERSION);

			fputs("TT-----------------------------------------------------------------------------------------\n",fp);
			fputs("TT LSPC -- Loading Simulation Program, C++\n",fp);
		    fputs(LPCSTR(str),fp);
			fputs("TT\n",fp);
			fputs("TT Designed and maintained by:\n",fp);
			fputs("TT     Tetra Tech, Inc.\n",fp);
			fputs("TT     10306 Eaton Place, Suite 340\n",fp);
			fputs("TT     Fairfax, VA 22030\n",fp);
			fputs("TT     (703) 385-6000\n",fp);
			fputs("TT-----------------------------------------------------------------------------------------\n",fp);

			fputs("TT LSPC MODEL THRESHOLD ANALYSIS SUMMARY HEADER FILE\n", fp);
			SYSTEMTIME tm;
			GetLocalTime(&tm);

			str.Format("TT This header file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
			fputs(LPCSTR(str),fp);
			
			fprintf(fp, "TT Output start time:  %d/%d/%d\n",toStart.GetMonth(),toStart.GetDay(),toStart.GetYear());     
			fprintf(fp, "TT Output end time:    %d/%d/%d\n",toEnd.GetMonth(),toEnd.GetDay(),toEnd.GetYear());     
			fprintf(fp, "TT Simulation time step:   %d min\n",deltm);     
			fputs("TT Label   \n", fp);
			fprintf(fp, "TT rchid    reach ID (only when a threshold is defined, ttype > 0)\n");
			fprintf(fp, "TT tnum     threshold number (as defined by Cards 605 and 610)\n");
			fprintf(fp, "TT date     month and date combination (last day of month)\n");
			fprintf(fp, "TT exceed   threshold exceedences (expressed as fraction of time)\n");
			fprintf(fp, "TT min      minimum value (units are as defined by Card 250)\n");
			fprintf(fp, "TT max      maximum value (units are as defined by Card 250)\n");
			fprintf(fp, "TT mean     average value (units are as defined by Card 250)\n");
			fprintf(fp, "TT sd       standard deviation (units are as defined by Card 250)\n");
			fprintf(fp, "TT 25th     25th percentile Value (units are as defined by Card 250)\n");
			fprintf(fp, "TT median   median value (units are as defined by Card 250)\n");
			fprintf(fp, "TT 75th     75th percentile Value (units are as defined by Card 250)\n");
			fputs("TT\n", fp);
			fputs("TT     This is header file for the threshold analysis summary file threshold.csv\n", fp);
			fclose(fp);
		}
		else
		{
			fputs("rchid,tnum,date,exceed,min,max,mean,sd,25th,median,75th\n", fp);
			m_filethreshold = fp;
		}
	}
	CATCH_ALL(e)
	{
		strMsg = "Cannot open file " + strFileName + " for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	END_CATCH_ALL
	return true;
}

bool CLSPCMODEL::WriteThresholdStatSummaryHeader(CString strFileName,COleDateTime toStart,COleDateTime toEnd)
{
	CString strMsg;
	FILE *fp = NULL;
	fp = fopen(LPCSTR(strFileName), "w+t");
	if(fp == NULL)
	{
		strMsg = "Cannot open file "+strFileName+" for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	TRY
	{
		if (strFileName.Right(3) == "out")
		{
			CString str;
			str.Format("TT %s\n",LSPC_VERSION);

			fputs("TT-----------------------------------------------------------------------------------------\n",fp);
			fputs("TT LSPC -- Loading Simulation Program, C++\n",fp);
		    fputs(LPCSTR(str),fp);
			fputs("TT\n",fp);
			fputs("TT Designed and maintained by:\n",fp);
			fputs("TT     Tetra Tech, Inc.\n",fp);
			fputs("TT     10306 Eaton Place, Suite 340\n",fp);
			fputs("TT     Fairfax, VA 22030\n",fp);
			fputs("TT     (703) 385-6000\n",fp);
			fputs("TT-----------------------------------------------------------------------------------------\n",fp);

			fputs("TT LSPC MODEL THRESHOLD STATISTICS HEADER FILE\n", fp);
			SYSTEMTIME tm;
			GetLocalTime(&tm);

			str.Format("TT This header file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
			fputs(LPCSTR(str),fp);
			
			fprintf(fp, "TT Output start time:  %d/%d/%d\n",toStart.GetMonth(),toStart.GetDay(),toStart.GetYear());     
			fprintf(fp, "TT Output end time:    %d/%d/%d\n",toEnd.GetMonth(),toEnd.GetDay(),toEnd.GetYear());     
			fprintf(fp, "TT Simulation time step:   %d min\n",deltm);     
			fputs("TT Label   \n", fp);
			fprintf(fp, "TT rchid    reach ID (only when a threshold is defined, ttype > 0)\n");
			fprintf(fp, "TT tnum     threshold number (as defined by Cards 605 and 610)\n");
			fprintf(fp, "TT stat     threshold definition\n");
			fprintf(fp, "TT value1   resulting value of defined threshold (excceedence,min,max,mean,sd,nth percentile value)\n");
			fputs("TT\n", fp);
			fputs("TT     This is header file for the threshold statistics file thresholdstat.csv\n", fp);
			fclose(fp);
		}
		else
		{
			fputs("rchid,tnum,stat,value1\n", fp);
			m_filethresholdstat = fp;
		}
	}
	CATCH_ALL(e)
	{
		strMsg = "Cannot open file " + strFileName + " for writing";
		AfxMessageBox(strMsg);
		Log(strMsg);
		return false;
	}
	END_CATCH_ALL
	return true;
}

bool CLSPCMODEL::WriteOutputLine(CString strContent, FILE *fp)
{
	CString strMsg;
	if(fp == NULL)
		return false;

	if(strContent.GetAt(strContent.GetLength()-1) != '\n')
		strContent += "\n";

	TRY
	{
		fputs(LPCSTR(strContent), fp);
	}
	CATCH_ALL(e)
	{
		return false;
	}
	END_CATCH_ALL

	return true;
}

int CLSPCMODEL::lookupsws()
{
	for(int i=0; i<nsws; i++)
		pswsinfo[i].lksws = 0;

	for(i=1; i<nsws; ++i)
	{
		int lgroup = pswsinfo[i].gindex;

		for (int j=0; j<i ; ++j)
		{
			int lgroup2 = pswsinfo[j].gindex;
			for (int k=0; k<nlandp; k++)
			{
				if (pluinfop[i*nlandp+k].lsur != pluinfop[j*nlandp+k].lsur 
					|| pluinfop[i*nlandp+k].slsur != pluinfop[j*nlandp+k].slsur 
					|| pluinfop[i*nlandp+k].bLUchange != pluinfop[j*nlandp+k].bLUchange)
					goto L200;
			}
			if (irrigfg == 1)
			{
				if (pirrigwdinfo[i].streamid != pirrigwdinfo[j].streamid)
					goto L200;

				for (k=0; k<nlandp; k++)
				{
					if (pirriginfop[lgroup*nlandp+k].startmonth != pirriginfop[lgroup2*nlandp+k].startmonth
						|| pirriginfop[lgroup*nlandp+k].endmonth != pirriginfop[lgroup2*nlandp+k].endmonth
						|| pirriginfop[lgroup*nlandp+k].fraction1 != pirriginfop[lgroup2*nlandp+k].fraction1
						|| pirriginfop[lgroup*nlandp+k].fraction2 != pirriginfop[lgroup2*nlandp+k].fraction2
						|| pirriginfop[lgroup*nlandp+k].fraction3 != pirriginfop[lgroup2*nlandp+k].fraction3
						|| pirriginfop[lgroup*nlandp+k].fraction4 != pirriginfop[lgroup2*nlandp+k].fraction4
						|| pirriginfop[lgroup*nlandp+k].fraction5 != pirriginfop[lgroup2*nlandp+k].fraction5
						|| pirriginfop[lgroup*nlandp+k].etdays != pirriginfop[lgroup2*nlandp+k].etdays
						)
						goto L200;
					if (monVaryIrrig != 1)
					{
						if (pirriginfop[lgroup*nlandp+k].etcoeff != pirriginfop[lgroup2*nlandp+k].etcoeff)
							goto L200;
					}
					else
					{
						for(int mon=0 ; mon<12; mon++)
						{
							if (pmonetcinfop[lgroup*nlandp+k].monETCs[mon] != pmonetcinfop[lgroup2*nlandp+k].monETCs[mon])
								goto L200;
						}
					}
				}
			}
			if (tempfg == 1)
			{
				if (ptmp_param1[i].eldat != ptmp_param1[j].eldat || ptmp_param1[i].elev != ptmp_param1[j].elev)
					goto L200;
			}
			if(pswsinfo[i].gindex == pswsinfo[j].gindex && pswsinfo[i].nwst == pswsinfo[j].nwst)
			{
				if (pswsinfo[i].nwst == 1)
				{
					if (pswsinfo[i].wstindex[0] == pswsinfo[j].wstindex[0])
					{
						pswsinfo[i].lksws = j+1;
						goto L200;
					}
				}
				else
				{
					for (k=0; k<pswsinfo[i].nwst; ++k)
					{
						if (pswsinfo[i].wstindex[k] != pswsinfo[j].wstindex[k] 
							|| pswsinfo[i].wti[k] != pswsinfo[j].wti[k])
							goto L200;
					}
					pswsinfo[i].lksws = j+1;
					goto L200;
				}
			}
		}
L200:;
	}

	for (i=0; i<nsws; ++i)
	{
		TRACE("lksws = %d %d\n ",i, pswsinfo[i].lksws);
		Log("lksws = %d %d\n ",i, pswsinfo[i].lksws);
	}
	return true;
}

void CLSPCMODEL::InitialControls()
{
	int i,j,k;
	
	if(pFlowControls != NULL)
	{
		delete []pFlowControls;
		pFlowControls = NULL;
	}
	if(pQualControls != NULL)
	{
		delete []pQualControls;
		pQualControls = NULL;
	}
	if(pSedControls != NULL)
	{
		delete []pSedControls;
		pSedControls = NULL;
	}

	// allocate memory here
	int nNum = nsws*nlandp;
	if(nNum <= 0)
		return;

	pFlowControls = new double[nNum];
	for(i = 0; i < nNum; ++i)
		pFlowControls[i] = 1.0;

	nNum = nsws*nlandp*nQuals;
	if (nNum > 0)
	{
		pQualControls = new double[nNum];
		for(i = 0; i < nNum; ++i)
			pQualControls[i] = 1.0;
	}

	if (sedfg == 1)
	{
		nNum = nsws*nlandp*3;
		if(nNum > 0)
			pSedControls = new double[nNum];
		for(i = 0; i < nNum; ++i)
			pSedControls[i] = 1.0;
	}

	nNum = nsws*nlandp;

	//Set TMDL based on input from each watershed and pollutants
	int Num = nQuals + 1;	// flow
	if (sedfg == 1)
		Num += 3;			// sand, silt, and clay

	if(ncland > 0)
	{
		for(i=0; i<nsws; ++i)
		{
			for(j=0; j<nlandp; ++j)
			{
				pFlowControls[i*nlandp+j] = 1.0 - pTMDLDistrib[(i*nlandp+j)*Num].fRatio;
				for(k = 0; k < nQuals; ++k)
					pQualControls[i*nlandp*nQuals+j*nQuals+k] = 1.0 - pTMDLDistrib[(i*nlandp+j)*Num+k+1].fRatio;
				if (sedfg == 1)
					for(k = 0; k < 3; ++k)
						pSedControls[i*nlandp*3+j*3+k]  = 1.0 - pTMDLDistrib[(i*nlandp+j)*Num+nQuals+k+1].fRatio;
			}
		}
	}
}

void CLSPCMODEL::AssignIndex()
{
	int i, j;

	if(stream != NULL)
		delete []stream;

	if (nsws > 0)
		stream = new Channel[nsws];

	//NETWORK
	for(i=0; i<nch; i++)
	{
		//TRACE("%d\n",pChannelInfo[i].nSelfOrder);
		for(j=0; j<nch; j++)
		{
			if(pChannelInfo[j].nSelfOrder == i)
			{
				stream[i].index = j;
				break;
			}
		}
	}
}

bool CLSPCMODEL::SaveParm2DB(CDatabase& db)
{

	int i, j, nNum;
	CString strSQL;
	CMainFrame *pWnd = (CMainFrame *)AfxGetMainWnd();

	// land to stream routing
	nNum = nlandp*ngroup;
	
	//card 80
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 80");
	for(i=0; i<nNum; i++)
	{
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(pLURoute[i].input_suro), pLURoute[i].gid, pLURoute[i].luid, 8001);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(pLURoute[i].input_ifwo), pLURoute[i].gid, pLURoute[i].luid, 8002);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(pLURoute[i].input_agwo), pLURoute[i].gid, pLURoute[i].luid, 8003);
		db.ExecuteSQL(LPCSTR(strSQL));
	}
 
	//snow related parameters update
	if(snowfg == 1)
	{
		nNum = nlandp*ngroup;
		//card 92
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 92");
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparm set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				pSnowCtl2[i].ICEFLAG, pSnowCtl2[i].nGrpid, GetDefLUID(db,pSnowCtl2[i].nGrpid,pSnowCtl2[i].luid), 9201);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowCtl2[i].lfForest), pSnowCtl2[i].nGrpid, GetDefLUID(db,pSnowCtl2[i].nGrpid,pSnowCtl2[i].luid), 9202);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowCtl2[i].fzg), pSnowCtl2[i].nGrpid, GetDefLUID(db,pSnowCtl2[i].nGrpid,pSnowCtl2[i].luid), 9203);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowCtl2[i].fzgl), pSnowCtl2[i].nGrpid, GetDefLUID(db,pSnowCtl2[i].nGrpid,pSnowCtl2[i].luid), 9204);
			db.ExecuteSQL(LPCSTR(strSQL));
		}
		
		//card 93
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 93");
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam1[i].LAT), pSnowParam1[i].nGrpid, GetDefLUID(db,pSnowParam1[i].nGrpid,pSnowParam1[i].luid), 9301);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam1[i].MELEV), pSnowParam1[i].nGrpid, GetDefLUID(db,pSnowParam1[i].nGrpid,pSnowParam1[i].luid), 9302);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam1[i].SHADE), pSnowParam1[i].nGrpid, GetDefLUID(db,pSnowParam1[i].nGrpid,pSnowParam1[i].luid), 9303);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam1[i].SNOWCF), pSnowParam1[i].nGrpid, GetDefLUID(db,pSnowParam1[i].nGrpid,pSnowParam1[i].luid), 9304);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam1[i].COVIND), pSnowParam1[i].nGrpid, GetDefLUID(db,pSnowParam1[i].nGrpid,pSnowParam1[i].luid), 9305);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		//card 94
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 94");
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam2[i].RDCSN), pSnowParam2[i].nGrpid, GetDefLUID(db,pSnowParam2[i].nGrpid,pSnowParam2[i].luid), 9401);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam2[i].TSNOW), pSnowParam2[i].nGrpid, GetDefLUID(db,pSnowParam2[i].nGrpid,pSnowParam2[i].luid), 9402);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam2[i].SNOEVP), pSnowParam2[i].nGrpid, GetDefLUID(db,pSnowParam2[i].nGrpid,pSnowParam2[i].luid), 9403);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam2[i].CCFACT), pSnowParam2[i].nGrpid, GetDefLUID(db,pSnowParam2[i].nGrpid,pSnowParam2[i].luid), 9404);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam2[i].MWATER), pSnowParam2[i].nGrpid, GetDefLUID(db,pSnowParam2[i].nGrpid,pSnowParam2[i].luid), 9405);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowParam2[i].MGMELT), pSnowParam2[i].nGrpid, GetDefLUID(db,pSnowParam2[i].nGrpid,pSnowParam2[i].luid), 9406);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		//card 96
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 96");
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowInit1[i].packsnow), pSnowInit1[i].nGrpid, GetDefLUID(db,pSnowInit1[i].nGrpid,pSnowInit1[i].luid), 9601);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowInit1[i].packice), pSnowInit1[i].nGrpid, GetDefLUID(db,pSnowInit1[i].nGrpid,pSnowInit1[i].luid), 9602);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowInit1[i].packwatr), pSnowInit1[i].nGrpid, GetDefLUID(db,pSnowInit1[i].nGrpid,pSnowInit1[i].luid), 9603);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowInit1[i].RDENPF), pSnowInit1[i].nGrpid, GetDefLUID(db,pSnowInit1[i].nGrpid,pSnowInit1[i].luid), 9604);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowInit1[i].DULL), pSnowInit1[i].nGrpid, GetDefLUID(db,pSnowInit1[i].nGrpid,pSnowInit1[i].luid), 9605);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowInit1[i].PAKTMP), pSnowInit1[i].nGrpid, GetDefLUID(db,pSnowInit1[i].nGrpid,pSnowInit1[i].luid), 9606);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowInit1[i].COVINX), pSnowInit1[i].nGrpid, GetDefLUID(db,pSnowInit1[i].nGrpid,pSnowInit1[i].luid), 9607);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowInit1[i].XLNMLT), pSnowInit1[i].nGrpid, GetDefLUID(db,pSnowInit1[i].nGrpid,pSnowInit1[i].luid), 9608);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pSnowInit1[i].SKYCLR), pSnowInit1[i].nGrpid, GetDefLUID(db,pSnowInit1[i].nGrpid,pSnowInit1[i].luid), 9609);
			db.ExecuteSQL(LPCSTR(strSQL));
		}
	}

	//hydro parameter           Table defaultparm
    nNum = nlandp*ngroup;

	//card 110
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 110");
	for(i=0; i<nNum; i++)
	{
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param2[i].lzsn_p),ppw_param2[i].gid,GetDefLUID(db,ppw_param2[i].gid,ppw_param2[i].lid),111);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param2[i].infilt_p),ppw_param2[i].gid,GetDefLUID(db,ppw_param2[i].gid,ppw_param2[i].lid),112);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param2[i].kvary_p),ppw_param2[i].gid,GetDefLUID(db,ppw_param2[i].gid,ppw_param2[i].lid),113);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param2[i].agwr_p),ppw_param2[i].gid,GetDefLUID(db,ppw_param2[i].gid,ppw_param2[i].lid),114);
		db.ExecuteSQL(LPCSTR(strSQL));
	}
	
	//card 120
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 120");
	for(i=0; i<nNum; i++)
	{
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param3[i].petmax_p),ppw_param3[i].gid,GetDefLUID(db,ppw_param3[i].gid,ppw_param3[i].lid),121);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param3[i].petmin_p),ppw_param3[i].gid,GetDefLUID(db,ppw_param3[i].gid,ppw_param3[i].lid),122);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param3[i].infexp_p),ppw_param3[i].gid,GetDefLUID(db,ppw_param3[i].gid,ppw_param3[i].lid),123);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param3[i].infild_p),ppw_param3[i].gid,GetDefLUID(db,ppw_param3[i].gid,ppw_param3[i].lid),124);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param3[i].deepfr_p),ppw_param3[i].gid,GetDefLUID(db,ppw_param3[i].gid,ppw_param3[i].lid),125);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param3[i].basetp_p),ppw_param3[i].gid,GetDefLUID(db,ppw_param3[i].gid,ppw_param3[i].lid),126);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param3[i].agwetp_p),ppw_param3[i].gid,GetDefLUID(db,ppw_param3[i].gid,ppw_param3[i].lid),127);
		db.ExecuteSQL(LPCSTR(strSQL));
	}

	//card 130
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 130");
	for(i=0; i<nNum; i++)
	{
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param4[i].cepsc_p),ppw_param4[i].gid,GetDefLUID(db,ppw_param4[i].gid,ppw_param4[i].lid),131);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param4[i].uzsn_p),ppw_param4[i].gid,GetDefLUID(db,ppw_param4[i].gid,ppw_param4[i].lid),132);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param4[i].nsur_p),ppw_param4[i].gid,GetDefLUID(db,ppw_param4[i].gid,ppw_param4[i].lid),133);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param4[i].intfw_p),ppw_param4[i].gid,GetDefLUID(db,ppw_param4[i].gid,ppw_param4[i].lid),134);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param4[i].irc_p),ppw_param4[i].gid,GetDefLUID(db,ppw_param4[i].gid,ppw_param4[i].lid),135);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_param4[i].lzetp_p),ppw_param4[i].gid,GetDefLUID(db,ppw_param4[i].gid,ppw_param4[i].lid),136);
		db.ExecuteSQL(LPCSTR(strSQL));
	}
	
	//card 140
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 140");
	for(i=0; i<nNum; i++)
	{
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_state[i].ceps_p),ppw_state[i].gid,GetDefLUID(db,ppw_state[i].gid,ppw_state[i].lid),141);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_state[i].surs_p),ppw_state[i].gid,GetDefLUID(db,ppw_state[i].gid,ppw_state[i].lid),142);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_state[i].uzs_p),ppw_state[i].gid,GetDefLUID(db,ppw_state[i].gid,ppw_state[i].lid),143);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_state[i].ifws_p),ppw_state[i].gid,GetDefLUID(db,ppw_state[i].gid,ppw_state[i].lid),144);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_state[i].lzs_p),ppw_state[i].gid,GetDefLUID(db,ppw_state[i].gid,ppw_state[i].lid),145);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_state[i].agws_p),ppw_state[i].gid,GetDefLUID(db,ppw_state[i].gid,ppw_state[i].lid),146);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
			GetValueText(ppw_state[i].gwvs_p),ppw_state[i].gid,GetDefLUID(db,ppw_state[i].gid,ppw_state[i].lid),147);
		db.ExecuteSQL(LPCSTR(strSQL));
	}			
		
	//Monthly parameters
	if(vcsfg == 1)
	{
		//card 150
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 150");
		for(i=0; i<nNum; i++)
		{
			for(j=0; j<12; j++)
			{
				int nParm = 15000 + j + 1;
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(cepscm_p[i].fnum[j]),cepscm_p[i].gid,GetDefLUID(db,cepscm_p[i].gid,cepscm_p[i].lid),nParm);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	if(vuzfg == 1)
	{
		//card 160
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 160");
		for(i=0; i<nNum; i++)
		{
			for(j=0; j<12; j++)
			{
				int nParm = 16000 + j + 1;
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(uzsnm_p[i].fnum[j]),uzsnm_p[i].gid,GetDefLUID(db,uzsnm_p[i].gid,uzsnm_p[i].lid),nParm);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	if(vnnfg == 1)
	{
		//card 170
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 170");
		for(i=0; i<nNum; i++)
		{
			for(j=0; j<12; j++)
			{
				int nParm = 17000 + j + 1;
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nsurm_p[i].fnum[j]),nsurm_p[i].gid,GetDefLUID(db,nsurm_p[i].gid,nsurm_p[i].lid),nParm);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	if(vifwfg == 1)
	{
		//card 180
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 180");
		for(i=0; i<nNum; i++)
		{
			for(j=0; j<12; j++)
			{
				int nParm = 18000 + j + 1;
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(intfwm_p[i].fnum[j]),intfwm_p[i].gid,GetDefLUID(db,intfwm_p[i].gid,intfwm_p[i].lid),nParm);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	if(vircfg == 1)
	{
		//card 190
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 190");
		for(i=0; i<nNum; i++)
		{
			for(j=0; j<12; j++)
			{
				int nParm = 19000 + j + 1;
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ircm_p[i].fnum[j]),ircm_p[i].gid,GetDefLUID(db,ircm_p[i].gid,ircm_p[i].lid),nParm);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	if(vlefg == 1)
	{
		//card 200
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 200");
		for(i=0; i<nNum; i++)
		{
			for(j=0; j<12; j++)
			{
				int nParm = 20000 + j + 1;
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(lzetpm_p[i].fnum[j]),lzetpm_p[i].gid,GetDefLUID(db,lzetpm_p[i].gid,lzetpm_p[i].lid),nParm);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	//card 201
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 201");

	int flags[3];
	flags[0] = irrigfg;
	flags[1] = petfg;
	flags[2] = monVaryIrrig;

	for(i=0; i<3; i++)
	{
		strSQL.Format("UPDATE ModelFlags SET VALUE1=%d WHERE PARMID=%d",flags[i],i+20101);
		db.ExecuteSQL(LPCSTR(strSQL));
	}
		
	if(irrigfg ==1)
	{
		nNum = ngroup;
		if (petfg == 1)
		{
			//card 202		Table "defaultparm"	
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 202");
			for(i=0; i<nNum; i++)
			{			
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(pirrigpet[i].petval),pirrigpet[i].gid,0,20201);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
		nNum = nlandp*ngroup;
		//card 203		Table "defaultparm"	
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 203");
		for(i=0; i<nNum; i++)
		{			
			strSQL.Format("UPDATE defaultparm set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				pirriginfop[i].startmonth,pirriginfop[i].gid,pirriginfop[i].luid,20301);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				pirriginfop[i].endmonth,pirriginfop[i].gid,pirriginfop[i].luid,20302);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pirriginfop[i].fraction1),pirriginfop[i].gid,pirriginfop[i].luid,20303);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pirriginfop[i].fraction2),pirriginfop[i].gid,pirriginfop[i].luid,20304);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pirriginfop[i].fraction3),pirriginfop[i].gid,pirriginfop[i].luid,20305);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pirriginfop[i].fraction4),pirriginfop[i].gid,pirriginfop[i].luid,20306);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pirriginfop[i].fraction5),pirriginfop[i].gid,pirriginfop[i].luid,20307);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pirriginfop[i].etcoeff),pirriginfop[i].gid,pirriginfop[i].luid,20308);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				pirriginfop[i].etdays,pirriginfop[i].gid,pirriginfop[i].luid,20309);
			db.ExecuteSQL(LPCSTR(strSQL));
		}
		if(monVaryIrrig == 1)
		{
			//card 204		Table "defaultparm"	
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 204");
			for(i=0; i<nNum; i++)
			{	
				for(int mon=0 ; mon<12; mon++)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(pmonetcinfop[i].monETCs[mon]),pmonetcinfop[i].gid,pmonetcinfop[i].luid,20401 + mon);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
			
		nNum = nsws;
		//card 205
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 205");
		for(i=0; i<nNum; i++)
		{	
			strSQL.Format("UPDATE reachmodel set irrigWD=%d WHERE SUBBASIN=%d",
				pirrigwdinfo[i].streamid,pirrigwdinfo[i].wsid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE reachmodel set irrigDEP=%s WHERE SUBBASIN=%d",
				GetValueText(pirrigwdinfo[i].irrigdep),pirrigwdinfo[i].wsid);
			db.ExecuteSQL(LPCSTR(strSQL));
		}
	}
	
	//Water quality parameter    Table "defaultparmWQ"
	if(pqalfg == 1)
	{
		nNum = ngroup*nQuals;
		//card 250
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 250");
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 25001",
				pQual[i].qsdfg,pQual[i].gid,0,pQual[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 25002",
				pQual[i].gqsdfg,pQual[i].gid,0,pQual[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 25003",
				pQual[i].qsofg,pQual[i].gid,0,pQual[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 25004",
				pQual[i].potfcfg,pQual[i].gid,0,pQual[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		nNum = nlandp*ngroup*nQuals;
		//card 260
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 260");
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26001",
				GetValueText(pQualInput[i].sqo),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26002",
				GetValueText(pQualInput[i].potfw),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26003",
				GetValueText(pQualInput[i].potfs),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26004",
				GetValueText(pQualInput[i].potfc),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26005",
				GetValueText(pQualInput[i].acqop),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26006",
				GetValueText(pQualInput[i].sqolim),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26007",
				GetValueText(pQualInput[i].wsqop),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26008",
				GetValueText(pQualInput[i].soqc),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26009",
				GetValueText(pQualInput[i].ioqc),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26010",
				GetValueText(pQualInput[i].aoqc),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26011",
				GetValueText(pQualInput[i].addc),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 26012",
				GetValueText(pQualInput[i].awdc),pQualInput[i].gid,pQualInput[i].lid,pQualInput[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
		}
		if(vqofg == 1)
		{
			//card 270		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 270");
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					int nParm = 27000 + j + 1;
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
						GetValueText(pIMonAccum[i].fnum[j]),pIMonAccum[i].gid,pIMonAccum[i].lid,pIMonAccum[i].qualid,nParm);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
		if(vqofg == 1)
		{
			//card 271		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 271");
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					int nParm = 27100 + j + 1;
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
						GetValueText(pIMonSQOLIM[i].fnum[j]),pIMonSQOLIM[i].gid,pIMonSQOLIM[i].lid,pIMonSQOLIM[i].qualid,nParm);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		if(vsqcfg == 1)
		{
			//card 272		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 272");
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					int nParm = 27200 + j + 1;
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = %d",
						GetValueText(pIMonSUROCONC[i].fnum[j]),pIMonSUROCONC[i].gid,pIMonSUROCONC[i].lid,pIMonSUROCONC[i].qualid,nParm);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		if(viqcfg == 1)
		{
			//card 273		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 273");
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					int nParm = 27300 + j + 1;
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = %d",
						GetValueText(pIMonINTERCONC[i].fnum[j]),pIMonINTERCONC[i].gid,pIMonINTERCONC[i].lid,pIMonINTERCONC[i].qualid,nParm);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		if(vaqcfg == 1)
		{
			//card 274		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 274");
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					int nParm = 27400 + j + 1;
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = %d",
						GetValueText(pIMonGRNDCONC[i].fnum[j]),pIMonGRNDCONC[i].gid,pIMonGRNDCONC[i].lid,pIMonGRNDCONC[i].qualid,nParm);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
		if(maddfglnd == 1)
		{
			//card 275		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 275");
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					int nParm = 27500 + j + 1;
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = %d",
						GetValueText(pIMonDRYDEP[i].fnum[j]),pIMonDRYDEP[i].gid,pIMonDRYDEP[i].lid,pIMonDRYDEP[i].qualid,nParm);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
		if(mawdfglnd == 1)
		{
			//card 276		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 276");
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					int nParm = 27600 + j + 1;
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = %d",
						GetValueText(pIMonWETDEP[i].fnum[j]),pIMonWETDEP[i].gid,pIMonWETDEP[i].lid,pIMonWETDEP[i].qualid,nParm);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		nNum = nrgroup*nQuals;
		//card 281
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 281");
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 28101",
				pQualwq[i].qsdfg,pQualwq[i].gid,0,pQualwq[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 28102",
				GetValueText(pQualwq[i].inicon),pQualwq[i].gid,0,pQualwq[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 28103",
				GetValueText(pQualwq[i].fstdec),pQualwq[i].gid,0,pQualwq[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 28104",
				GetValueText(pQualwq[i].thfst),pQualwq[i].gid,0,pQualwq[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 28105",
				GetValueText(pQualwq[i].addc),pQualwq[i].gid,0,pQualwq[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 28106",
				GetValueText(pQualwq[i].awdc),pQualwq[i].gid,0,pQualwq[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID = 28107",
				GetValueText(pQualwq[i].potber),pQualwq[i].gid,0,pQualwq[i].qualid);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		if(maddfgrch == 1)
		{
			//card 282		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 282");
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					int nParm = 28200 + j + 1;
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DWQID=%d AND PARMID = %d",
						GetValueText(pMDDrch[i].fnum[j]),pMDDrch[i].rgid,pMDDrch[i].qualid,nParm);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		if(mawdfgrch == 1)
		{
			//card 283		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 283");
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					int nParm = 28300 + j + 1;
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DWQID=%d AND PARMID = %d",
						GetValueText(pMWDrch[i].fnum[j]),pMWDrch[i].rgid,pMWDrch[i].qualid,nParm);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		if(pGQ_SEDDECAY != NULL)
		{
			//card 285		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 285");
			for(i=0; i<nNum; i++)
			{
				for (j=0; j<4; j++)
				{
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID=%d",
						GetValueText(pGQ_SEDDECAY[i].addcpm[j]),pGQ_SEDDECAY[i].gid,0,pGQ_SEDDECAY[i].qualid,28501+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}	
			}
		}

		if(pGQ_KD != NULL)
		{
			//card 286		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 286");
			for(i=0; i<nNum; i++)
			{
				for (j=0; j<6; j++)
				{
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID=%d",
						GetValueText(pGQ_KD[i].adpm[j]),pGQ_KD[i].gid,0,pGQ_KD[i].qualid,28601+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}	
			}
		}

		if(pGQ_ADRATE != NULL)
		{
			//card 287		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 287");
			for(i=0; i<nNum; i++)
			{
				for (j=0; j<6; j++)
				{
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID=%d",
						GetValueText(pGQ_ADRATE[i].adpm[j]),pGQ_ADRATE[i].gid,0,pGQ_ADRATE[i].qualid,28701+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}	
			}
		}

		if(pGQ_ADTHETA != NULL)
		{
			//card 288		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 288");
			for(i=0; i<nNum; i++)
			{
				for (j=0; j<6; j++)
				{
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID=%d",
						GetValueText(pGQ_ADTHETA[i].adpm[j]),pGQ_ADTHETA[i].gid,0,pGQ_ADTHETA[i].qualid,28801+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}	
			}
		}

		if(pGQ_SEDCONC != NULL)
		{
			//card 289		Table "defaultparmWQ"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 289");
			for(i=0; i<nNum; i++)
			{
				for (j=0; j<6; j++)
				{
					strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID=%d",
						GetValueText(pGQ_SEDCONC[i].sqal[j]),pGQ_SEDCONC[i].gid,0,pGQ_SEDCONC[i].qualid,28901+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}	
			}
		}
	}

	//card 400		Table "modelflags"
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 400");

	strSQL.Format("UPDATE modelflags set VALUE1=%d WHERE PARMID=%d",admod,40001);
	db.ExecuteSQL(LPCSTR(strSQL));
	strSQL.Format("UPDATE modelflags set VALUE1=%s WHERE PARMID=%d",GetValueText(kc),40002);
	db.ExecuteSQL(LPCSTR(strSQL));
	strSQL.Format("UPDATE modelflags set VALUE1=%d WHERE PARMID=%d",sedber,40003);
	db.ExecuteSQL(LPCSTR(strSQL));
	strSQL.Format("UPDATE modelflags set VALUE1=%d WHERE PARMID=%d",vconfg,40004);
	db.ExecuteSQL(LPCSTR(strSQL));

	if(vconfg == 1)
	{
		nNum = nrgroup;
		//card 401		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 401");
		for(i=0; i<nNum; i++)
		{
			for(j=0; j<12; j++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(pMONTH_COV[i].fnum[j]),pMONTH_COV[i].gid,0,40101+j);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	//card 405		Table "reachmodel"
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 405");

	for(i=0; i<nch; i++)
	{
		strSQL.Format("UPDATE reachmodel set CONTROL=%d WHERE SUBBASIN=%d",
			pChannelInfo[i].comp, pChannelInfo[i].rchid);
		db.ExecuteSQL(LPCSTR(strSQL));
	}

	//update the cross section table
	if (nch > 0)
	{
		//card 413
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 413");
		strSQL = "DELETE * FROM CROSS_SECTION";
		db.ExecuteSQL(strSQL);
		for(i=0; i<nch; i++)
		{
			int nPoints = pReachInfo[i].poly.pointList.GetCount();
			if(nPoints >= 3)
			{
				for(j=0; j<nPoints; j++)
				{
					POSITION pos = pReachInfo[i].poly.pointList.FindIndex(j);
					Point *pti = (Point *) pReachInfo[i].poly.pointList.GetAt(pos);
					double x = (pti->x - 15) / 419 * pReachInfo[i].width;
					double y = (263 - pti->y) / 258 * pReachInfo[i].depth;
					strSQL.Format("INSERT INTO CROSS_SECTION VALUES('%d',%d,%lf,%lf)",
						pReachInfo[i].rchid,j,x,y);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
	}
			
	if(nPtSource > 0)	// number of point sources
	{
		nNum = nPtWithDrawal;
		if (nNum > 0)
		{
			//card 430 		Table "ps_withdrawal_target"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 430");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE ps_withdrawal_target set WD_Target=%d WHERE SUBBASIN=%d AND PERMIT='%s' AND PIPE='%s'",
					pPtWithDrawal[i].targetrchid,pPtWithDrawal[i].wdrawlrchid,pPtWithDrawal[i].strPermit,pPtWithDrawal[i].strPipe);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	//card 440		Table "modelflags"
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 440");

	strSQL.Format("UPDATE modelflags set VALUE1=%d WHERE PARMID=%d",sandfg,44003);
	db.ExecuteSQL(LPCSTR(strSQL));
	strSQL.Format("UPDATE modelflags set VALUE1=%d WHERE PARMID=%d",sweepfg,44004);
	db.ExecuteSQL(LPCSTR(strSQL));

	if(sedfg == 1)
	{
		if (sweepfg != 0)
		{
			nNum = nlandimp*ngroup;
			if (nNum > 0)
			{
				//card 445 street sweeping for sediment		Table "defaultparm"
				pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 445");
				for(i=0; i<nNum; i++)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(psd_sweep[i].start_month),psd_sweep[i].defid,psd_sweep[i].deluid,44501);
					db.ExecuteSQL(LPCSTR(strSQL));
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(psd_sweep[i].end_month),psd_sweep[i].defid,psd_sweep[i].deluid,44502);
					db.ExecuteSQL(LPCSTR(strSQL));
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(psd_sweep[i].frequency),psd_sweep[i].defid,psd_sweep[i].deluid,44503);
					db.ExecuteSQL(LPCSTR(strSQL));
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(psd_sweep[i].percent_area),psd_sweep[i].defid,psd_sweep[i].deluid,44504);
					db.ExecuteSQL(LPCSTR(strSQL));
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(psd_sweep[i].effic_sand),psd_sweep[i].defid,psd_sweep[i].deluid,44505);
					db.ExecuteSQL(LPCSTR(strSQL));
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(psd_sweep[i].effic_silt),psd_sweep[i].defid,psd_sweep[i].deluid,44506);
					db.ExecuteSQL(LPCSTR(strSQL));
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(psd_sweep[i].effic_clay),psd_sweep[i].defid,psd_sweep[i].deluid,44507);
					db.ExecuteSQL(LPCSTR(strSQL));
				}

				//card 446 street sweeping for GQual    Table "defaultparmWQ"
				if (sweepfg == 2 && pqalfg == 1)
				{
					pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 446");
					for(i=0; i<nNum; i++)
					{
						for (j=0; j<nQuals; j++) 
						{
							strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
								GetValueText(pGQ_sweep[i].effic_GQual[j]),pGQ_sweep[i].defid,pGQ_sweep[i].deluid,pQual[j].qualid,44601);
							db.ExecuteSQL(LPCSTR(strSQL));
						}
					}
				}
			}
		}

		nNum = nlandp*ngroup;
		if (nNum > 0)
		{
			//card 450 defaulthyd		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 450");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].smpf_p),psd_param1[i].gid,psd_param1[i].lid,45001);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].krer_p),psd_param1[i].gid,psd_param1[i].lid,45002);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].jrer_p),psd_param1[i].gid,psd_param1[i].lid,45003);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].affix_p),psd_param1[i].gid,psd_param1[i].lid,45004);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].cover_p),psd_param1[i].gid,psd_param1[i].lid,45005);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].nvsi_p),psd_param1[i].gid,psd_param1[i].lid,45006);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].kser_p),psd_param1[i].gid,psd_param1[i].lid,45007);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].jser_p),psd_param1[i].gid,psd_param1[i].lid,45008);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].kger_p),psd_param1[i].gid,psd_param1[i].lid,45009);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].jger_p),psd_param1[i].gid,psd_param1[i].lid,45010);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].accsdp_p),psd_param1[i].gid,psd_param1[i].lid,45011);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param1[i].remsdp_p),psd_param1[i].gid,psd_param1[i].lid,45012);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 451		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 451");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param2[i].sed_suro),psd_param2[i].gid,GetDefLUID(db,psd_param2[i].gid,psd_param2[i].lid),45101);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param2[i].sed_ifwo),psd_param2[i].gid,GetDefLUID(db,psd_param2[i].gid,psd_param2[i].lid),45102);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(psd_param2[i].sed_agwo),psd_param2[i].gid,GetDefLUID(db,psd_param2[i].gid,psd_param2[i].lid),45103);
				db.ExecuteSQL(LPCSTR(strSQL));

				for (int j=0; j<NumSed; ++j)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(psd_param2[i].sed[j]),psd_param2[i].gid,GetDefLUID(db,psd_param2[i].gid,psd_param2[i].lid),45104+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
			if (sed_mapp != NULL)
			{
				//card 452		Table "defaultparmWQ"
				pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 452");
				nNum = ngroup*4;
				for(i=0; i<nNum; i++)
				{
					for (int j=0; j<NumSed; ++j)
					{
						strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND DWQID=%d AND PARMID=%d",
							GetValueText(sed_mapp[i].sed[j]),sed_mapp[i].gid,sed_mapp[i].lutype,sed_mapp[i].qualid,45201+j);
						db.ExecuteSQL(LPCSTR(strSQL));
					}
				}
			}

			if(crvfg == 1)
			{
				//card 453		Table "defaultparm"
				pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 453");
				for(i=0; i<nNum; i++)
				{
					for(j=0; j<12; j++)
					{
						strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
							GetValueText(pCRVm[i].fnum[j]),pCRVm[i].gid,pCRVm[i].lid,45301+j);
						db.ExecuteSQL(LPCSTR(strSQL));
					}
				}
			}
			if(vsivfg == 1)
			{
				//card 454		Table "defaultparm"
				pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 454");
				for(i=0; i<nNum; i++)
				{
					for(j=0; j<12; j++)
					{
						strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
							GetValueText(pVSIVm[i].fnum[j]),pVSIVm[i].gid,pVSIVm[i].lid,45401+j);
						db.ExecuteSQL(LPCSTR(strSQL));
					}
				}
			}
		}

		//card 455		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 455");
		for(i=0; i<nrgroup; i++)
		{
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(rsd_genparam[i].bedwid),rsd_genparam[i].gid,0,45501);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(rsd_genparam[i].beddep),rsd_genparam[i].gid,0,45502);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(rsd_genparam[i].por),rsd_genparam[i].gid,0,45503);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(rsd_genparam[i].burial),rsd_genparam[i].gid,0,45504);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		//card 456		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 456");
		nNum = NumSed;	// sand, silt, and clay
		for(i=0; i<nrgroup; i++)
		{
			for(j=0; j<nNum; j++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					rsd_param[i*nNum+j].sedflg,rsd_param[i*nNum+j].gid,j+1,45601);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(rsd_param[i*nNum+j].sedo),rsd_param[i*nNum+j].gid,j+1,45602);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(rsd_param[i*nNum+j].sedfrac),rsd_param[i*nNum+j].gid,j+1,45603);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(rsd_param[i*nNum+j].d),rsd_param[i*nNum+j].gid,j+1,45604);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(rsd_param[i*nNum+j].w),rsd_param[i*nNum+j].gid,j+1,45605);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(rsd_param[i*nNum+j].rho),rsd_param[i*nNum+j].gid,j+1,45606);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(rsd_param[i*nNum+j].taucd),rsd_param[i*nNum+j].gid,j+1,45607);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(rsd_param[i*nNum+j].taucs),rsd_param[i*nNum+j].gid,j+1,45608);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(rsd_param[i*nNum+j].m),rsd_param[i*nNum+j].gid,j+1,45609);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(rsd_param[i*nNum+j].burial),rsd_param[i*nNum+j].gid,j+1,45610);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
		//card 457		Table "bankerosion"
		if (sedber == 1)
		{
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 457");
			for(i=0; i<nch; i++)
			{
				if (rsd_berparam[i].qber < 0 && q_bfd != NULL)
					rsd_berparam[i].qber = q_bfd[i];

				strSQL.Format("UPDATE bankerosion set kber=%s  WHERE rchid=%d",
					GetValueText(rsd_berparam[i].kber),rsd_berparam[i].rchid);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE bankerosion set jber=%s WHERE rchid=%d",
					GetValueText(rsd_berparam[i].jber),rsd_berparam[i].rchid);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE bankerosion set qber=%s WHERE rchid=%d",
					GetValueText(rsd_berparam[i].qber),rsd_berparam[i].rchid);
				db.ExecuteSQL(LPCSTR(strSQL));

				for(j=0; j<NumSed; j++)
				{
					strSQL.Format("UPDATE bankerosion set sed_%d=%s WHERE rchid=%d",
						j+1,GetValueText(rsd_berparam[i].sed[j]),rsd_berparam[i].rchid);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
	}

	if(tempfg == 1)
	{
		//card 461		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 461");
		nNum = nlandp*ngroup;
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparm set VALUE1=%d WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				pstmp_parm1[i].tsopfg,pstmp_parm1[i].gid,pstmp_parm1[i].lid,46101);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pstmp_parm1[i].aslt),pstmp_parm1[i].gid,pstmp_parm1[i].lid,46102);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pstmp_parm1[i].bslt),pstmp_parm1[i].gid,pstmp_parm1[i].lid,46103);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pstmp_parm1[i].aift),pstmp_parm1[i].gid,pstmp_parm1[i].lid,46104);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pstmp_parm1[i].bift),pstmp_parm1[i].gid,pstmp_parm1[i].lid,46105);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pstmp_parm1[i].agwt),pstmp_parm1[i].gid,pstmp_parm1[i].lid,46106);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pstmp_parm1[i].bgwt),pstmp_parm1[i].gid,pstmp_parm1[i].lid,46107);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pstmp_parm1[i].islt),pstmp_parm1[i].gid,pstmp_parm1[i].lid,46108);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pstmp_parm1[i].iift),pstmp_parm1[i].gid,pstmp_parm1[i].lid,46109);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(pstmp_parm1[i].igwt),pstmp_parm1[i].gid,pstmp_parm1[i].lid,46110);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		//card 462		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 462");
		for(i=0; i<nNum; i++)
		{
			if(msltfg == 1)
			{
				for(j=0; j<12; j++)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(asltm[i].fnum[j]),asltm[i].gid,asltm[i].lid,46201+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		//card 463		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 463");
		for(i=0; i<nNum; i++)
		{
			if(msltfg == 1)
			{
				for(j=0; j<12; j++)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(bsltm[i].fnum[j]),bsltm[i].gid,bsltm[i].lid,46301+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		//card 464		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 464");
		for(i=0; i<nNum; i++)
		{
			if(miftfg == 1)
			{
				for(j=0; j<12; j++)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(aiftm[i].fnum[j]),aiftm[i].gid,aiftm[i].lid,46401+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		//card 465		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 465");
		for(i=0; i<nNum; i++)
		{
			if(miftfg == 1)
			{
				for(j=0; j<12; j++)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(biftm[i].fnum[j]),biftm[i].gid,biftm[i].lid,46501+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		//card 466		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 466");
		for(i=0; i<nNum; i++)
		{
			if(mgwtfg == 1)
			{
				for(j=0; j<12; j++)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(agwtm[i].fnum[j]),agwtm[i].gid,agwtm[i].lid,46601+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		//card 467		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 467");
		for(i=0; i<nNum; i++)
		{
			if(mgwtfg == 1)
			{
				for(j=0; j<12; j++)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(bgwtm[i].fnum[j]),bgwtm[i].gid,bgwtm[i].lid,46701+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}

		//card 475		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 475");
		nNum = nrgroup;
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(ptmps_param1[i].cfsaex_p),ptmps_param1[i].gid,0,47501);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(ptmps_param1[i].katrad_p),ptmps_param1[i].gid,0,47502);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(ptmps_param1[i].kcond_p),ptmps_param1[i].gid,0,47503);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(ptmps_param1[i].kevap_p),ptmps_param1[i].gid,0,47504);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		//card 480		Table "defaultparm"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 480");
		nNum = nrgroup;
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(ptmps_param2[i].muddep),ptmps_param2[i].rgid,0,48004);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(ptmps_param2[i].tgrnd),ptmps_param2[i].rgid,0,48005);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(ptmps_param2[i].kmud),ptmps_param2[i].rgid,0,48006);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
				GetValueText(ptmps_param2[i].kgrnd),ptmps_param2[i].rgid,0,48007);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		//card 485		Table "defaultparm"
		if (bedflg == true && mtgflg == true)
		{
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 485");
			nNum = nrgroup;
			for(i=0; i<nNum; i++)
			{
				for(j=0; j<12; j++)
				{
					strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
						GetValueText(ptmps_mon[i].fnum[j]),ptmps_mon[i].rgid,0,48501+j);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
	}

	//RQUAL			  
	if(oxfg == 1)	
	{
		//card 500		Table "defaultparmWQ"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 500");
		nNum = nQuals*nrgroup*4;
		for(i=0; i<nNum; i++)
		{
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
				GetValueText(land_mapp[i].bod),land_mapp[i].gid,land_mapp[i].lutype,land_mapp[i].qualid,50001);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
				GetValueText(land_mapp[i].nox),land_mapp[i].gid,land_mapp[i].lutype,land_mapp[i].qualid,50002);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
				GetValueText(land_mapp[i].tam),land_mapp[i].gid,land_mapp[i].lutype,land_mapp[i].qualid,50003);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
				GetValueText(land_mapp[i].snh4),land_mapp[i].gid,land_mapp[i].lutype,land_mapp[i].qualid,50004);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
				GetValueText(land_mapp[i].po4),land_mapp[i].gid,land_mapp[i].lutype,land_mapp[i].qualid,50005);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
				GetValueText(land_mapp[i].spo4),land_mapp[i].gid,land_mapp[i].lutype,land_mapp[i].qualid,50006);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
				GetValueText(land_mapp[i].orn),land_mapp[i].gid,land_mapp[i].lutype,land_mapp[i].qualid,50007);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
				GetValueText(land_mapp[i].orp),land_mapp[i].gid,land_mapp[i].lutype,land_mapp[i].qualid,50008);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
				GetValueText(land_mapp[i].orc),land_mapp[i].gid,land_mapp[i].lutype,land_mapp[i].qualid,50009);
			db.ExecuteSQL(LPCSTR(strSQL));
		}
		
		//card 501		Table "defaultparmWQ"
		if(adfgrch == 1)
		{
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 501");
			nNum = nQuals*nrgroup;
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
					GetValueText(atms_mapp[i].bod),atms_mapp[i].gid,0,atms_mapp[i].qualid,50101);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
					GetValueText(atms_mapp[i].nox),atms_mapp[i].gid,0,atms_mapp[i].qualid,50102);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
					GetValueText(atms_mapp[i].tam),atms_mapp[i].gid,0,atms_mapp[i].qualid,50103);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
					GetValueText(atms_mapp[i].po4),atms_mapp[i].gid,0,atms_mapp[i].qualid,50104);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
					GetValueText(atms_mapp[i].orn),atms_mapp[i].gid,0,atms_mapp[i].qualid,50105);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
					GetValueText(atms_mapp[i].orp),atms_mapp[i].gid,0,atms_mapp[i].qualid,50106);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparmWQ set VALUE1=%s WHERE DEFID=%d AND DELUID=%d  AND DWQID=%d AND PARMID = %d",
					GetValueText(atms_mapp[i].orc),atms_mapp[i].gid,0,atms_mapp[i].qualid,50107);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}

		nNum = nlandp*ngroup;
		if (nNum > 0)
		{
			//card 503		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 503");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(doco_parm1[i].sdoxp),doco_parm1[i].gid,GetDefLUID(db,doco_parm1[i].gid,doco_parm1[i].lid),50301);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(doco_parm1[i].sco2p),doco_parm1[i].gid,GetDefLUID(db,doco_parm1[i].gid,doco_parm1[i].lid),50302);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(doco_parm1[i].idoxp),doco_parm1[i].gid,GetDefLUID(db,doco_parm1[i].gid,doco_parm1[i].lid),50303);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(doco_parm1[i].ico2p),doco_parm1[i].gid,GetDefLUID(db,doco_parm1[i].gid,doco_parm1[i].lid),50304);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(doco_parm1[i].adoxp),doco_parm1[i].gid,GetDefLUID(db,doco_parm1[i].gid,doco_parm1[i].lid),50305);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(doco_parm1[i].aco2p),doco_parm1[i].gid,GetDefLUID(db,doco_parm1[i].gid,doco_parm1[i].lid),50306);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
			//card 504		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 504");
			for(i=0; i<nNum; i++)
			{
				if(midofg == 1)
				{
					for(j=0; j<12; j++)
					{
						int nParm = 50400 + j + 1;
						strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
							GetValueText(idoconc[i].fnum[j]),idoconc[i].gid,GetDefLUID(db,idoconc[i].gid,idoconc[i].lid),nParm);
						db.ExecuteSQL(LPCSTR(strSQL));
					}
				}
			}

			//card 505		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 505");
			for(i=0; i<nNum; i++)
			{
				if(madofg == 1)
				{
					for(j=0; j<12; j++)
					{
						int nParm = 50500 + j + 1;
						strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
							GetValueText(adoconc[i].fnum[j]),adoconc[i].gid,GetDefLUID(db,adoconc[i].gid,adoconc[i].lid),nParm);
						db.ExecuteSQL(LPCSTR(strSQL));
					}
				}
			}

			//card 506		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 506");
			for(i=0; i<nNum; i++)
			{
				if(mico2fg  == 1)
				{
					for(j=0; j<12; j++)
					{
						int nParm = 50600 + j + 1;
						strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
							GetValueText(ico2conc[i].fnum[j]),ico2conc[i].gid,GetDefLUID(db,ico2conc[i].gid,ico2conc[i].lid),nParm);
						db.ExecuteSQL(LPCSTR(strSQL));
					}
				}
			}

			//card 507		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 507");
			for(i=0; i<nNum; i++)
			{
				if(maco2fg  == 1)
				{
					for(j=0; j<12; j++)
					{
						int nParm = 50700 + j + 1;
						strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
							GetValueText(aco2conc[i].fnum[j]),aco2conc[i].gid,GetDefLUID(db,aco2conc[i].gid,aco2conc[i].lid),nParm);
						db.ExecuteSQL(LPCSTR(strSQL));
					}
				}
			}
		}

		//card 510
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 510");

		int flags[2];	
		flags[0] = benrfg;
		flags[1] = reamfg;

		for(i=0; i<2; i++)
		{
			strSQL.Format("UPDATE ModelFlags SET VALUE1=%d WHERE PARMID=%d",flags[i],i+51001);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		nNum = nrgroup;
		if (nNum > 0)
		{
			//card 511		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 511");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm1[i].kbod20),ox_parm1[i].gid,0,51101);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm1[i].tcbod),ox_parm1[i].gid,0,51102);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm1[i].kodset),ox_parm1[i].gid,0,51103);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm1[i].supsat),ox_parm1[i].gid,0,51104);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm1[i].tcginv),ox_parm1[i].gid,0,51105);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm1[i].reak),ox_parm1[i].gid,0,51106);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm1[i].expred),ox_parm1[i].gid,0,51107);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm1[i].exprev),ox_parm1[i].gid,0,51108);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm1[i].cforea),ox_parm1[i].gid,0,51109);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 512		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 512");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm2[i].benod),ox_parm2[i].gid,0,51201);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm2[i].tcben),ox_parm2[i].gid,0,51202);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm2[i].expod),ox_parm2[i].gid,0,51203);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm2[i].brbod),ox_parm2[i].gid,0,51204);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm2[i].brbod_inc),ox_parm2[i].gid,0,51205);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ox_parm2[i].exprel),ox_parm2[i].gid,0,51206);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 513		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 513");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(oxrx_init[i].dox),oxrx_init[i].gid,0,51301);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(oxrx_init[i].bod),oxrx_init[i].gid,0,51302);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(oxrx_init[i].satdo),oxrx_init[i].gid,0,51303);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 514		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 514");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(scour_parms[i].scrvel),scour_parms[i].gid,0,51401);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(scour_parms[i].scrmul),scour_parms[i].gid,0,51402);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}
	if (nutfg == 1)
	{
		//card 520
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 520");

		int flags[8];	
		flags[0] = tamfg;
		flags[1] = no2fg;
		flags[2] = po4fg;
		flags[3] = amvfg;
		flags[4] = denfg;
		flags[5] = adnhfg;
		flags[6] = adpofg;
		flags[7] = mphfg;

		for(i=0; i<8; i++)
		{
			strSQL.Format("UPDATE ModelFlags SET VALUE1=%d WHERE PARMID=%d",flags[i],i+52001);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		nNum = nrgroup;
		if (nNum > 0)
		{
			//card 521		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 521");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].cvbo),nut_parm1[i].gid,0,52101);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].cvbpc),nut_parm1[i].gid,0,52102);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].cvbpn),nut_parm1[i].gid,0,52103);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].bpcntc),nut_parm1[i].gid,0,52104);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].ktam20),nut_parm1[i].gid,0,52105);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].kno220),nut_parm1[i].gid,0,52106);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].tcnit),nut_parm1[i].gid,0,52107);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].kno320),nut_parm1[i].gid,0,52108);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].tcden),nut_parm1[i].gid,0,52109);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm1[i].denoxt),nut_parm1[i].gid,0,52110);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 522		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 522");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].brtam_1),nut_parm2[i].gid,0,52201);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].brtam_2),nut_parm2[i].gid,0,52202);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].brpo4_1),nut_parm2[i].gid,0,52203);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].brpo4_2),nut_parm2[i].gid,0,52204);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].bnh4_1),nut_parm2[i].gid,0,52205);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].bnh4_2),nut_parm2[i].gid,0,52206);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].bnh4_3),nut_parm2[i].gid,0,52207);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].bpo4_1),nut_parm2[i].gid,0,52208);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].bpo4_2),nut_parm2[i].gid,0,52209);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm2[i].bpo4_3),nut_parm2[i].gid,0,52210);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 523		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 523");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm3[i].anaer),nut_parm3[i].gid,0,52301);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm3[i].adnhpm_1),nut_parm3[i].gid,0,52302);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm3[i].adnhpm_2),nut_parm3[i].gid,0,52303);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm3[i].adnhpm_3),nut_parm3[i].gid,0,52304);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm3[i].adpopm_1),nut_parm3[i].gid,0,52305);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm3[i].adpopm_2),nut_parm3[i].gid,0,52306);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm3[i].adpopm_3),nut_parm3[i].gid,0,52307);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm3[i].expnvg),nut_parm3[i].gid,0,52308);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_parm3[i].expnvl),nut_parm3[i].gid,0,52309);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 524		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 524");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].no3),nut_init[i].gid,0,52401);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].tam),nut_init[i].gid,0,52402);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].no2),nut_init[i].gid,0,52403);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].po4),nut_init[i].gid,0,52404);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].snh4_1),nut_init[i].gid,0,52405);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].snh4_2),nut_init[i].gid,0,52406);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].snh4_3),nut_init[i].gid,0,52407);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].spo4_1),nut_init[i].gid,0,52408);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].snh4_2),nut_init[i].gid,0,52409);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(nut_init[i].spo4_3),nut_init[i].gid,0,52410);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}
	if (plkfg == 1)
	{
		//card 530
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 530");

		int flags[8];	
		flags[0] = phyfg;
		flags[1] = zoofg;
		flags[2] = balfg;
		flags[3] = sdltfg;
		flags[4] = amrfg;
		flags[5] = decfg;
		flags[6] = nsfg;
		flags[7] = orefg;

		for(i=0; i<8; i++)
		{
			strSQL.Format("UPDATE ModelFlags SET VALUE1=%d WHERE PARMID=%d",flags[i],i+53001);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		nNum = nrgroup;
		if (nNum > 0)
		{
			//card 531		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 531");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm1[i].ratclp),plank_parm1[i].gid,0,53101);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm1[i].nonref),plank_parm1[i].gid,0,53102);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm1[i].litsed),plank_parm1[i].gid,0,53103);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm1[i].alnpr),plank_parm1[i].gid,0,53104);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm1[i].extb),plank_parm1[i].gid,0,53105);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm1[i].malgr),plank_parm1[i].gid,0,53106);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 532		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 532");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm2[i].cmmlt),plank_parm2[i].gid,0,53201);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm2[i].cmmn),plank_parm2[i].gid,0,53202);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm2[i].cmmnp),plank_parm2[i].gid,0,53203);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm2[i].cmmp),plank_parm2[i].gid,0,53204);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm2[i].talgrh),plank_parm2[i].gid,0,53205);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm2[i].talgrl),plank_parm2[i].gid,0,53206);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm2[i].talgrm),plank_parm2[i].gid,0,53207);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 533		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 533");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm3[i].alr20),plank_parm3[i].gid,0,53301);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm3[i].aldh),plank_parm3[i].gid,0,53302);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm3[i].aldl),plank_parm3[i].gid,0,53303);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm3[i].oxald),plank_parm3[i].gid,0,53304);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm3[i].naldh),plank_parm3[i].gid,0,53305);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm3[i].paldh),plank_parm3[i].gid,0,53306);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 534		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 534");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].phycon),plank_parm4[i].gid,0,53401);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].seed),plank_parm4[i].gid,0,53402);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].mxstay),plank_parm4[i].gid,0,53403);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].oref),plank_parm4[i].gid,0,53404);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].claldh),plank_parm4[i].gid,0,53405);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].physet),plank_parm4[i].gid,0,53406);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].refset),plank_parm4[i].gid,0,53407);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].cfsaex),plank_parm4[i].gid,0,53408);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].mbal),plank_parm4[i].gid,0,53409);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].cfbalr),plank_parm4[i].gid,0,53410);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_parm4[i].cfbalg),plank_parm4[i].gid,0,53411);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 535		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 535");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_init[i].phyto),plank_init[i].gid,0,53501);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_init[i].benal),plank_init[i].gid,0,53502);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_init[i].orn),plank_init[i].gid,0,53503);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_init[i].orp),plank_init[i].gid,0,53504);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(plank_init[i].orc),plank_init[i].gid,0,53505);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	if (phfg == 1)
	{
		//card 540
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 540");

		int flags[2];
		double frac[2];
		flags[0] = phffg1;
		flags[1] = phffg2;
		frac[0] = phfrc1;
		frac[1] = phfrc2;

		for(i=0; i<2; i++)
		{
			strSQL.Format("UPDATE ModelFlags SET VALUE1=%d WHERE PARMID=%d",flags[i],i+54001);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE ModelFlags SET VALUE1=%d WHERE PARMID=%d",frac[i],i+54003);
			db.ExecuteSQL(LPCSTR(strSQL));
		}

		nNum = nrgroup;
		if (nNum > 0)
		{
			//card 541		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 541");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ph_para[i].phcnt),ph_para[i].gid,0,54101);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ph_para[i].alkcon),ph_para[i].gid,0,54102);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ph_para[i].cfcinv),ph_para[i].gid,0,54103);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ph_para[i].brco2_1),ph_para[i].gid,0,54104);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ph_para[i].brco2_2),ph_para[i].gid,0,54105);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			//card 542		Table "defaultparm"
			pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 542");
			for(i=0; i<nNum; i++)
			{
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ph_init[i].tic),ph_init[i].gid,0,54201);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ph_init[i].co2),ph_init[i].gid,0,54202);
				db.ExecuteSQL(LPCSTR(strSQL));
				strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
					GetValueText(ph_init[i].ph),ph_init[i].gid,0,54203);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
			if(phffg1 == 1)
			{
				//card 543		Table "defaultparm"
				pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 543");
				for(i=0; i<nNum; i++)
				{
					for(j=0; j<12; j++)
					{
						int nParm = 54300 + j + 1;
						strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
							GetValueText(mtic_rf[i].fnum[j]),mtic_rf[i].gid,0,nParm);
						db.ExecuteSQL(LPCSTR(strSQL));
					}
				}
			}
			if(phffg2 == 1)
			{
				//card 544		Table "defaultparm"
				pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 544");
				for(i=0; i<nNum; i++)
				{
					for(j=0; j<12; j++)
					{
						int nParm = 54400 + j + 1;
						strSQL.Format("UPDATE defaultparm set VALUE1=%s WHERE DEFID=%d AND DELUID=%d AND PARMID=%d",
							GetValueText(mco2_rf[i].fnum[j]),mco2_rf[i].gid,0,nParm);
						db.ExecuteSQL(LPCSTR(strSQL));
					}
				}
			}
		}
	}

	//card 600		Table "modelflags"
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 600");

	strSQL.Format("UPDATE modelflags set VALUE1=%d WHERE PARMID=%d",ncland,60001);
	db.ExecuteSQL(LPCSTR(strSQL));

	if(ntnum > 0)
	{
		//card 605		Table "TMDLthresholdMAP"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 605");
		for(i=0; i<ntnum; i++)
		{
			for(j=0; j<pThreshold[i].tqnum; j++)
			{
				strSQL.Format("UPDATE TMDLthresholdMAP set TQID=%d WHERE TNUM=%d AND TORDER=%d",
					pThreshold[i].tqid[j], pThreshold[i].tnum, j+1);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}

		//card 610		Table "TMDLthreshold"
		pWnd->m_wndStatusBar.SetPaneText(0, "Updating Table 610");
		for(i=0; i<ntnum*ntrgp; i++)
		{
			strSQL.Format("UPDATE TMDLthreshold set TTYPE=%d WHERE TRGID=%d AND TNUM=%d",
				pMTDATA[i].ttype, pMTDATA[i].trgid, pMTDATA[i].tnum);
			db.ExecuteSQL(LPCSTR(strSQL));
			strSQL.Format("UPDATE TMDLthreshold set TDAYS=%d WHERE TRGID=%d AND TNUM=%d",
				pMTDATA[i].tdays, pMTDATA[i].trgid, pMTDATA[i].tnum);
			db.ExecuteSQL(LPCSTR(strSQL));
			
			for(j=0; j<12; j++)
			{
				strSQL.Format("UPDATE TMDLthreshold set TVALUE=%s WHERE TRGID=%d AND TNUM=%d AND TMONTH=%d",
					GetValueText(pMTDATA[i].fnum[j]), pMTDATA[i].trgid, pMTDATA[i].tnum, j+1);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}
	
	//card 660
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating TMDLtablePS");
	if(pPSReduction != NULL && nPtSource > 0)
	{
		for(i=0; i<nPtSource; i++)
		{
			strSQL.Format("UPDATE TMDLtablePS set Reduce=%s WHERE PSQID=%d AND SUBBASIN=%d AND PERMIT='"+pPSReduction[i].strPermitName+"'AND PIPE='"+pPSReduction[i].strPipeName+"'",
				GetValueText(pPSReduction[i].fReduction_flow),0,pPSReduction[i].rchid);
			db.ExecuteSQL(LPCSTR(strSQL));

			for (int j=0; j<nPtQuals; j++)
			{
				strSQL.Format("UPDATE TMDLtablePS set Reduce=%s WHERE PSQID=%d AND SUBBASIN=%d AND PERMIT='"+pPSReduction[i].strPermitName+"'AND PIPE='"+pPSReduction[i].strPipeName+"'",
					GetValueText(pPSReduction[i].fReduction_qual[j]),pPtQual[j].qualid,pPSReduction[i].rchid);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	// card 670
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating TMDLtable");
	if(pTMDLDistrib != NULL)
	{
		int Num = nQuals + 1;	// flow is always there
		if (sedfg == 1)
			Num += 3;			// sand, silt, and clay

		for(i=0; i<nsws*nlandp; i++)
		{
			strSQL.Format("UPDATE TMDLTable set REDUCE=%s WHERE DWQID=%d AND SUBBASIN=%d AND DELUID=%d",
				GetValueText(pTMDLDistrib[i*Num].fRatio),0,pTMDLDistrib[i*Num].subbasin,pTMDLDistrib[i*Num].luid);
			db.ExecuteSQL(LPCSTR(strSQL));
			for(j=0; j<nQuals; j++)
			{
				strSQL.Format("UPDATE TMDLTable set REDUCE=%s WHERE DWQID=%d AND SUBBASIN=%d AND DELUID=%d",
					GetValueText(pTMDLDistrib[i*Num+j+1].fRatio),pQual[j].qualid,pTMDLDistrib[i*Num+j+1].subbasin,pTMDLDistrib[i*Num+j+1].luid);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
			if (sedfg == 1)
			{
				for(j=0; j<3; j++)
				{
					strSQL.Format("UPDATE TMDLTable set REDUCE=%s WHERE DWQID=%d AND SUBBASIN=%d AND DELUID=%d",
						GetValueText(pTMDLDistrib[i*Num+nQuals+j+1].fRatio),101+j,pTMDLDistrib[i*Num+nQuals+j+1].subbasin,pTMDLDistrib[i*Num+nQuals+j+1].luid);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
	}

	//card 680
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating TMDLTableRCHONOFF");
	if(pMON_SWITCH != NULL && ncrch > 0)
	{
		for(i=0; i<ncrchOutlets; i++)
		{
			for (int j=0; j<12; j++)
			{
				strSQL.Format("UPDATE TMDLTableRCHLIM set SWITCH=%d WHERE MONTH=%d AND OUTLET=%d AND RCHID=%d",
					pMON_SWITCH[i].nSwitch[j],j+1,pMON_SWITCH[i].nOutletId,pMON_SWITCH[i].rchid);
				db.ExecuteSQL(LPCSTR(strSQL));
			}
		}
	}

	//card 685
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating TMDLTableRCHLIM");
	if(pBMPLimit != NULL && ncrch > 0)
	{
		for(i=0; i<ncrchOutlets; i++)
		{
			strSQL.Format("UPDATE TMDLTableRCHLIM set LIMIT=%s WHERE ControlType=%d AND OUTLET=%d AND RCHID=%d",
				GetValueText(pBMPLimit[i].fLimit_flow),0,pBMPLimit[i].nOutletId,pBMPReduction[i].rchid);
			db.ExecuteSQL(LPCSTR(strSQL));

			for (int j=0; j<nQuals; j++)
			{
				strSQL.Format("UPDATE TMDLTableRCHLIM set LIMIT=%s WHERE ControlType=%d AND OUTLET=%d AND RCHID=%d",
					GetValueText(pBMPLimit[i].fLimit_qual[j]),pQual[j].qualid,pBMPLimit[i].nOutletId,pBMPReduction[i].rchid);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			if (sedfg == 1 || oxfg == 1)
			{
				for (int j=0; j<12; j++)
				{
					strSQL.Format("UPDATE TMDLTableRCHLIM set LIMIT=%s WHERE ControlType=%d AND OUTLET=%d AND RCHID=%d",
						GetValueText(pBMPLimit[i].fLimit_qual[nQuals+j]),101+j,pBMPLimit[i].nOutletId,pBMPReduction[i].rchid);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
	}

	//card 690
	pWnd->m_wndStatusBar.SetPaneText(0, "Updating TMDLTableRCHBMP");
	if(pBMPReduction != NULL && ncrch > 0)
	{
		for(i=0; i<ncrchOutlets; i++)
		{
			strSQL.Format("UPDATE TMDLTableRCHBMP set REDUCE=%s WHERE ControlType=%d AND OUTLET=%d AND RCHID=%d",
				GetValueText(pBMPReduction[i].fReduction_flow),0,pBMPReduction[i].nOutletId,pBMPReduction[i].rchid);
			db.ExecuteSQL(LPCSTR(strSQL));

			for (int j=0; j<nQuals; j++)
			{
				strSQL.Format("UPDATE TMDLTableRCHBMP set REDUCE=%s WHERE ControlType=%d AND OUTLET=%d AND RCHID=%d",
					GetValueText(pBMPReduction[i].fReduction_qual[j]),pQual[j].qualid,pBMPReduction[i].nOutletId,pBMPReduction[i].rchid);
				db.ExecuteSQL(LPCSTR(strSQL));
			}

			if (sedfg == 1 || oxfg == 1)
			{
				for (int j=0; j<12; j++)
				{
					strSQL.Format("UPDATE TMDLTableRCHBMP set REDUCE=%s WHERE ControlType=%d AND OUTLET=%d AND RCHID=%d",
						GetValueText(pBMPReduction[i].fReduction_qual[nQuals+j]),101+j,pBMPReduction[i].nOutletId,pBMPReduction[i].rchid);
					db.ExecuteSQL(LPCSTR(strSQL));
				}
			}
		}
	}

	pWnd->m_wndStatusBar.SetPaneText(0, "Updating Database Completed");

	return true;
}

int CLSPCMODEL::GetDefLUID(CDatabase& db, int nGID, int nLUID)
{
	CRecordsetEx rs(&db);
	CString strSQL,strTemp;
	BOOL bRet;
	int nReturn = -1;
	
	
	strSQL.Format("SELECT deluid from landusemap where defid =%d AND LUID=%d",nGID,nLUID);
	bRet = rs.ExecDirect(strSQL);
	if(bRet)
	{
		rs.GetFieldValue((short)0, strTemp);
		nReturn = atoi(LPCSTR(strTemp));
	}
	rs.Close();
	return nReturn;
}

void CLSPCMODEL::UpdateDBParm()
{
	CDatabase db;
	BOOL bCanOpen = FALSE;
	CString strSQL;
	
	try
	{
		strSQL = CLSPCApp::GetMDBDriver();
		if(strSQL.IsEmpty())
		{
			AfxMessageBox("Cannot find the Microsoft Access ODBC driver.");
			Log("Cannot find the Microsoft Access ODBC driver.");
			return;
		}
		bCanOpen = db.OpenEx(strSQL,CDatabase::noOdbcDialog);
		if(!bCanOpen)
		{
			AfxMessageBox("ODBC Error ---Cannot open database for reading.");
			Log("ODBC Error ---Cannot open database for reading.");
			return;
		}
	}
	catch(CException e)
	{
		AfxMessageBox("ODBC Error ---Cannot open database for reading.");
		Log("ODBC Error ---Cannot open database for reading.");
		return;
	}
	
	SaveParm2DB(db);
	db.Close();
}
/*
void CLSPCMODEL::AddNewDefaultGroup()
{
	CDatabase db;
	BOOL bCanOpen = FALSE;
	CString strSQL;
	
	try
	{
		strSQL = CLSPCApp::GetMDBDriver();
		if(strSQL.IsEmpty())
		{
			AfxMessageBox("Cannot find the Microsoft Access ODBC driver.");
			Log("Cannot find the Microsoft Access ODBC driver.");
			return;
		}
		bCanOpen = db.OpenEx(strSQL,CDatabase::noOdbcDialog);
	}
	catch(CException e)
	{
		AfxMessageBox("ODBC Error ---Cannot open database for reading.");
		Log("ODBC Error ---Cannot open database for reading.");
		return;
	}
	if(!bCanOpen)
	{
		AfxMessageBox("ODBC Error ---Cannot open database for reading.");
		Log("ODBC Error ---Cannot open database for reading.");
		return ;
	}
	// find the max group number
	int nMax = 0;
	int nWQMax = 0;
	CString strTemp;
	BOOL bRet;
	int nNumGroup = 0;
	int i;
	
	CRecordsetEx rs(&db);
	strSQL = "select max(defid) from defaultparm";
	bRet = rs.ExecDirect(strSQL);
	if(bRet)
	{
		rs.GetFieldValue((short)0, strTemp);
		nMax = atoi(LPCSTR(strTemp));
	}
	rs.Close();
	//wq
	strSQL = "select max(defid) from defaultparmWQ";
	bRet = rs.ExecDirect(strSQL);
	if(bRet)
	{
		rs.GetFieldValue((short)0, strTemp);
		nWQMax = atoi(LPCSTR(strTemp));
	}
	rs.Close();
	
	// find mapped groups
	CObList mappedList;
	CObList mappedWQList;
	
	strSQL = "select distinct defid from table110 order by defid";
	bRet = rs.ExecDirect(strSQL);
	if(bRet)
	{
		while(!rs.IsEOF())
		{
			DBStruct *pNew = new DBStruct();
			rs.GetFieldValue((short)0, strTemp);
			pNew->nSourceGID = atoi(LPCSTR(strTemp));
			pNew->nDestGID = ++nMax;
			mappedList.AddTail((CObject *)pNew);
			
			DBStruct *pNewWQ = new DBStruct();
			pNewWQ->nSourceGID = pNew->nSourceGID;
			pNewWQ->nDestGID = ++nWQMax;
			mappedWQList.AddTail((CObject *)pNewWQ);
			
			rs.MoveNext();
		}
	}
	rs.Close();
	
	// copy mapped group to new group
	// old group num -> max_group_num+nSelectedGroups+1
	nNumGroup = mappedList.GetCount();
	for(i = 0; i < nNumGroup; ++i)
	{
		POSITION pos = mappedList.FindIndex(i);
		if(pos == NULL)
		{
			TRACE("Error geting object from List.\n");
			Log("Error geting object from List.\n");
			return;
		}
		DBStruct *pNew = (DBStruct *)mappedList.GetAt(pos);
		if(pNew == NULL)
		{
			TRACE("NULL Info.\n");
			Log("NULL Info.\n");
			break;
		}
		strSQL.Format("INSERT INTO defaultparm ( DEFID, DELUID, PARMID, VALUE1, NAME ) "
			"SELECT %d, DELUID, PARMID, VALUE1, NAME "
			"FROM defaultparm "
			"WHERE DEFID = %d",pNew->nDestGID+nNumGroup,pNew->nSourceGID);
		db.ExecuteSQL(LPCSTR(strSQL));
		
		POSITION posWQ = mappedWQList.FindIndex(i);
		if(pos == NULL)
		{
			TRACE("Error geting object from List.\n");
			Log("Error geting object from List.\n");
			return;
		}
		DBStruct *pNewWQ = (DBStruct *)mappedWQList.GetAt(posWQ);
		if(pNewWQ == NULL)
		{
			TRACE("NULL Info.\n");
			Log("NULL Info.\n");
			break;
		}
		strSQL.Format("INSERT INTO defaultparmWQ (DEFID, DELUID, PARMID, VALUE1,NAME, DWQID) "
			"SELECT %d, DELUID, PARMID, VALUE1,NAME, DWQID "
			"FROM defaultparmWQ "
			"WHERE DEFID = %d",pNewWQ->nDestGID+nNumGroup,pNewWQ->nSourceGID);
		db.ExecuteSQL(LPCSTR(strSQL));
	}
	// update the selected groups
	SaveParm2DB(db);
	// old group num -> max_group_num+1
	// change the old one to new
	for(i = 0; i < nNumGroup; ++i)
	{
		POSITION pos = mappedList.FindIndex(i);
		if(pos == NULL)
		{
			TRACE("Error geting object from List.\n");
			Log("Error geting object from List.\n");
			return;
		}
		DBStruct *pNew = (DBStruct *)mappedList.GetAt(pos);
		if(pNew == NULL)
		{
			TRACE("NULL Info.\n");
			Log("NULL Info.\n");
			break;
		}
		strSQL.Format("UPDATE defaultparm SET DEFID=%d WHERE DEFID = %d",
			pNew->nDestGID,pNew->nSourceGID);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparm SET DEFID=%d WHERE DEFID = %d",
			pNew->nSourceGID,pNew->nDestGID+nNumGroup);
		db.ExecuteSQL(LPCSTR(strSQL));
		//wq
		POSITION posWQ = mappedWQList.FindIndex(i);
		if(posWQ == NULL)
		{
			TRACE("Error geting object from List.\n");
			Log("Error geting object from List.\n");
			return;
		}
		DBStruct *pNewWQ = (DBStruct *)mappedWQList.GetAt(posWQ);
		if(pNewWQ == NULL)
		{
			TRACE("NULL Info.\n");
			Log("NULL Info.\n");
			break;
		}
		strSQL.Format("UPDATE defaultparmWQ SET DEFID=%d WHERE DEFID = %d",
			pNewWQ->nDestGID,pNewWQ->nSourceGID);
		db.ExecuteSQL(LPCSTR(strSQL));
		strSQL.Format("UPDATE defaultparmWQ SET DEFID=%d WHERE DEFID = %d",
			pNewWQ->nSourceGID,pNewWQ->nDestGID+nNumGroup);
		db.ExecuteSQL(LPCSTR(strSQL));
	}
	// update table "modelmapping"
	// first, read table "selWatershed"
	CString strSet;
	strSQL="SELECT SUBBASIN from selWatershed";
	bRet = rs.ExecDirect(strSQL);
	if(bRet)
	{
		while(!rs.IsEOF())
		{
			rs.GetFieldValue((short)0, strTemp);
			strSet+="'"+strTemp+"',";
			rs.MoveNext();
		}
	}
	// delete the last character ','
	strSet = strSet.Left(strSet.GetLength()-1);
	
	
	for(i = 0; i < nNumGroup; ++i)
	{
		POSITION pos = mappedList.FindIndex(i);
		if(pos == NULL)
		{
			TRACE("Error geting object from List.\n");
			Log("Error geting object from List.\n");
			return;
		}
		DBStruct *pNew = (DBStruct *)mappedList.GetAt(pos);
		if(pNew == NULL)
		{
			TRACE("NULL Info.\n");
			Log("NULL Info.\n");
			break;
		}
		strSQL.Format("UPDATE modelmapping SET DEFID=%d WHERE DEFID=%d AND SUBBASIN IN (%s)",
			pNew->nDestGID,pNew->nSourceGID,strSet);
		db.ExecuteSQL(LPCSTR(strSQL));
	}
	
	db.Close();
	// deallocate memory
	while(!mappedList.IsEmpty())
		delete (DBStruct *)mappedList.RemoveTail();
	mappedList.RemoveAll();
	while(!mappedWQList.IsEmpty())
		delete (DBStruct *)mappedWQList.RemoveTail();
	mappedWQList.RemoveAll();
}
*/
void CLSPCMODEL::UnitConvertion()
{
	double unit1 = 1.0;
	double unit2 = 1.0;

	for(int i=0; i<ngroup; ++i)
	{
		for(int j=0; j<nlandp; ++j)
		{
			for(int n=0; n<nQuals; ++n)
			{
				unit1 = 1.0;
				unit2 = 1.0;
				if(pQual[i*nQuals+n].qunit == "(#/100ml)")
				{
					unit1 = 453592;		// # to lb (1 count (#) = 1 mg)
					unit2 = 1/10.0;		// #/100 ml to mg/l
				}
				else if(pQual[i*nQuals+n].qunit == "(ug/l)")
				{
					unit1 = 1.0;
					unit2 = 1000.0; // mg/l
				}
				// card 260
				if(pQualInput!=NULL)
				{
					pQualInput[i*nQuals*nlandp+n*nlandp+j].sqo		/= unit1;		// mg to lb (1 mg = 1 count)
					pQualInput[i*nQuals*nlandp+n*nlandp+j].potfw	/= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].potfs	/= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].potfc	/= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].acqop	/= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].sqolim	/= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].soqc		/= unit2;			// #/100ml to mg/l
					pQualInput[i*nQuals*nlandp+n*nlandp+j].ioqc		/= unit2;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].aoqc		/= unit2;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].addc		/= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].awdc		/= unit2;
				}
				//card 270
				if(vqofg == 1)
				{
					if(pIMonAccum!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonAccum[i*nQuals*nlandp+n*nlandp+j].fnum[k] /= unit1;
					}
				}
				//card 271
				if(vqofg == 1)
				{
					if(pIMonSQOLIM!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonSQOLIM[i*nQuals*nlandp+n*nlandp+j].fnum[k] /= unit1;
					}
				}
				// card 272
				if(vsqcfg == 1)
				{
					if(pIMonSUROCONC!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonSUROCONC[i*nQuals*nlandp+n*nlandp+j].fnum[k] /= unit2; 
					}
				}
				// card 273
				if(viqcfg == 1)
				{
					if(pIMonINTERCONC!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonINTERCONC[i*nQuals*nlandp+n*nlandp+j].fnum[k] /= unit2; 
					}
				}
				//card 274
				if(vaqcfg == 1)
				{
					if(pIMonGRNDCONC!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonGRNDCONC[i*nQuals*nlandp+n*nlandp+j].fnum[k] /= unit2; 
					}
				}
				//card 275
				if(maddfglnd == 1)
				{
					if(pIMonDRYDEP!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonDRYDEP[i*nQuals*nlandp+n*nlandp+j].fnum[k] /= unit1; 
					}
				}
				//card 276
				if(mawdfglnd == 1)
				{
					if(pIMonWETDEP!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonWETDEP[i*nQuals*nlandp+n*nlandp+j].fnum[k] /= unit2; 
					}
				}
			}
		}
	}

	// card 281
	if(pqalfg == 1 && pQualwq != NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit1 = 1.0;
				unit2 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
				{
					unit1 = 453592;		// # to lb (1 count (#) = 1 mg)
					unit2 = 1/10.0;		// #/100 ml to mg/l
				}
				else if(pQual[j].qunit == "(ug/l)")
				{
					unit1 = 1.0;
					unit2 = 1000.0; // mg/l
				}

				pQualwq[i*nQuals+j].addc /= unit1;
				pQualwq[i*nQuals+j].awdc /= unit2;
				pQualwq[i*nQuals+j].potber /= unit1;
			}
		}
	}

	//card 282
	if(pqalfg == 1 && pMDDrch!=NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit1 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
					unit1 = 453592;		// # to lb (1 count (#) = 1 mg)
				else if(pQual[j].qunit == "(ug/l)")
					unit1 = 1.0;

				for (int k=0; k<12; k++)
					pMDDrch[i*nQuals+j].fnum[k]  /= unit1; 
			}
		}
	}

	//card 283
	if(pqalfg == 1 && pMWDrch!=NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit2 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
					unit2 = 1/10.0;		// #/100 ml to mg/l
				else if(pQual[j].qunit == "(ug/l)")
					unit2 = 1000.0; // mg/l

				for (int k=0; k<12; k++)
					pMWDrch[i*nQuals+j].fnum[k]  /= unit2; 
			}
		}
	}
/*
	//card 286
	if(pqalfg == 1 && pGQ_KD!=NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit2 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
					unit2 = 10;			// 100ml/# to l/mg
				else if(pQual[j].qunit == "(ug/l)")
					unit2 = 1/1000.0;	// l/ug to l/mg

				for (int k=0; k<6; k++)
					pGQ_KD[i*nQuals+j].adpm[k] /= unit2;
			}
		}
	}
*/
	//card 289
	if(pqalfg == 1 && pGQ_SEDCONC!=NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit2 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
					unit2 = 1;			// # to mg
				else if(pQual[j].qunit == "(ug/l)")
					unit2 = 1000.0;		// ug to mg

				for (int k=0; k<6; k++)
					pGQ_SEDCONC[i*nQuals+j].sqal[k] /= unit2;
			}
		}
	}

	// card 610

	// card 685
	if (ncrch > 0 && pBMPLimit != NULL)
	{
		for(int i=0; i<nch; ++i)
		{
			if (pReachInfo[i].lkfg > 10)
			{
				for (int j1=0; j1<ncrchOutlets; j1++)
				{
					if (pChannelInfo[i].rchid == pBMPLimit[j1].rchid)
					{
						for (int j2 =0; j2<pChannelInfo[i].nDSchan; j2++)
						{
							for (int k=0; k<nQuals; k++)
							{
								unit2 = 1.0;
								if(pQual[k].qunit == "(#/100ml)")	// 1 count = 1 mg
									unit2 = 1/10.0;
								else if(pQual[k].qunit == "(ug/l)")
									unit2 = 1000.0;

								pBMPLimit[j1+j2].fLimit_qual[k] /= unit2;
							}
						}
						break;
					}
				}
			}
		}
	}

	//POINT SOURCE
	if(pPSData != NULL)
	{
		for (int i=0; i<nPtSource; ++i)
		{
			for (int j=0; j<pPSData[i].nRecord; ++j)
			{
				for (int k=0; k<nPtQuals; ++k)
				{
					for (int l=0; l<nQuals; ++l)
					{
						unit1 = 453592;
						if(pQual[l].qualid == pPtQual[k].qualid && pQual[l].qunit == "(#/100ml)")
							pPSData[i].pData[j].pPollutant[k] /= unit1;
					}
				}
			}
		}
	}
}

void CLSPCMODEL::ReverseUnitConvertion()
{
	double unit1 = 1.0;
	double unit2 = 1.0;

	for(int i=0; i<ngroup; ++i)
	{
		for(int j=0; j<nlandp; ++j)
		{
			for(int n=0; n<nQuals; ++n)
			{
				unit1 = 1.0;
				unit2 = 1.0;
				if(pQual[i*nQuals+n].qunit == "(#/100ml)")
				{
					unit1 = 453592;
					unit2 = 1/10.0;
				}
				else if(pQual[i*nQuals+n].qunit == "(ug/l)")
				{
					unit1 = 1.0;
					unit2 = 1000.0;
				}
				// card 260
				if(pQualInput!=NULL)
				{
					pQualInput[i*nQuals*nlandp+n*nlandp+j].sqo		*= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].potfw	*= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].potfs	*= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].potfc	*= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].acqop	*= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].sqolim	*= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].soqc		*= unit2;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].ioqc		*= unit2;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].aoqc		*= unit2;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].addc		*= unit1;
					pQualInput[i*nQuals*nlandp+n*nlandp+j].awdc		*= unit2;
				}
				//card 270
				if(vqofg == 1)
				{
					if(pIMonAccum!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonAccum[i*nQuals*nlandp+n*nlandp+j].fnum[k] *= unit1;
					}
				}
				//card 271
				if(vqofg == 1)
				{
					if(pIMonSQOLIM!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonSQOLIM[i*nQuals*nlandp+n*nlandp+j].fnum[k] *= unit1;
					}
				}
				// card 272
				if(vsqcfg == 1)
				{
					if(pIMonSUROCONC!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonSUROCONC[i*nQuals*nlandp+n*nlandp+j].fnum[k] *= unit2; 
					}
				}
				// card 273
				if(viqcfg == 1)
				{
					if(pIMonINTERCONC!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonINTERCONC[i*nQuals*nlandp+n*nlandp+j].fnum[k] *= unit2; 
					}
				}
				//card 274
				if(vaqcfg  == 1)
				{
					if(pIMonGRNDCONC!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonGRNDCONC[i*nQuals*nlandp+n*nlandp+j].fnum[k] *= unit2; 
					}
				}
				//card 275
				if(maddfglnd  == 1)
				{
					if(pIMonDRYDEP!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonDRYDEP[i*nQuals*nlandp+n*nlandp+j].fnum[k] *= unit1; 
					}
				}
				//card 276
				if(mawdfglnd  == 1)
				{
					if(pIMonWETDEP!=NULL)
					{
						for (int k=0; k<12; k++)
							pIMonWETDEP[i*nQuals*nlandp+n*nlandp+j].fnum[k] *= unit2; 
					}
				}
			}
		}
	}

	// card 281
	if(pqalfg == 1 && pQualwq != NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit1 = 1.0;
				unit2 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
				{
					unit1 = 453592;
					unit2 = 1/10.0;
				}
				else if(pQual[j].qunit == "(ug/l)")
				{
					unit1 = 1.0;
					unit2 = 1000.0;
				}

				pQualwq[i*nQuals+j].addc   *= unit1;
				pQualwq[i*nQuals+j].awdc   *= unit2;
				pQualwq[i*nQuals+j].potber *= unit1;
			}
		}
	}

	//card 282
	if(pqalfg == 1 && pMDDrch != NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit1 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
					unit1 = 453592;
				else if(pQual[j].qunit == "(ug/l)")
					unit1 = 1.0;

				for (int k=0; k<12; k++)
					pMDDrch[i*nQuals+j].fnum[k] *= unit1; 
			}
		}
	}

	//card 283
	if(pqalfg == 1 && pMWDrch!=NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit2 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
					unit2 = 1/10.0;
				else if(pQual[j].qunit == "(ug/l)")
					unit2 = 1000.0;

				for (int k=0; k<12; k++)
					pMWDrch[i*nQuals+j].fnum[k] *= unit2; 
			}
		}
	}
/*
	//card 286
	if(pqalfg == 1 && pGQ_KD!=NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit2 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
					unit2 = 10;	 
				else if(pQual[j].qunit == "(ug/l)")
					unit2 = 1/1000.0;  

				for (int k=0; k<6; k++)
					pGQ_KD[i*nQuals+j].adpm[k] *= unit2;
			}
		}
	}
*/
	//card 289
	if(pqalfg == 1 && pGQ_SEDCONC!=NULL)
	{
		for(int i=0; i<nrgroup; ++i)
		{
			for (int j=0; j<nQuals; ++j)
			{
				unit2 = 1.0;
				if(pQual[j].qunit == "(#/100ml)")
					unit2 = 1;		
				else if(pQual[j].qunit == "(ug/l)")
					unit2 = 1000.0; 

				for (int k=0; k<6; k++)
					pGQ_SEDCONC[i*nQuals+j].sqal[k] *= unit2;
			}
		}
	}

	// card 610

	// card 685
	if (ncrch > 0 && pBMPLimit != NULL)
	{
		for(int i=0; i<nch; ++i)
		{
			if (pReachInfo[i].lkfg > 10)
			{
				for (int j1=0; j1<ncrchOutlets; j1++)
				{
					if (pChannelInfo[i].rchid == pBMPLimit[j1].rchid)
					{
						for (int j2 =0; j2<pChannelInfo[i].nDSchan; j2++)
						{
							for (int k=0; k<nQuals; k++)
							{
								unit2 = 1.0;
								if(pQual[k].qunit == "(#/100ml)")
									unit2 = 1/10.0;
								else if(pQual[k].qunit == "(ug/l)")
									unit2 = 1000.0;

								pBMPLimit[j1+j2].fLimit_qual[k] *= unit2;
							}
						}
						break;
					}
				}
			}
		}
	}

	//POINT SOURCE
	if(pPSData != NULL)
	{
		for (int i=0; i<nPtSource; ++i)
		{
			for (int j=0; j<pPSData[i].nRecord; ++j)
			{
				for (int k=0; k<nPtQuals; ++k)
				{
					for (int l=0; l<nQuals; ++l)
					{
						unit1 = 453592;
						if(pQual[l].qualid == pPtQual[k].qualid && pQual[l].qunit == "(#/100ml)")
							pPSData[i].pData[j].pPollutant[k] *= unit1;
					}
				}
			}
		}
	}
}

void CLSPCMODEL::ReadDBPointSource()
{
	if(pPSData != NULL)
	{
		delete []pPSData;
		pPSData = NULL;
	}

	if(nPtSource <= 0 || pPSReduction == NULL)
		return;

	CDatabase db;
	BOOL bCanOpen = FALSE;
	CString strSQL;
	
	try
	{
		strSQL = CLSPCApp::GetMDBDriver();
		if(strSQL.IsEmpty())
		{
			AfxMessageBox("Cannot find the Microsoft Access ODBC driver.");
			Log("Cannot find the Microsoft Access ODBC driver.");
			return;
		}
		// update point source file path
		CLSPCApp *pApp = (CLSPCApp *) AfxGetApp();
		CString strFileName = pApp->strLocation;

		int nIndex = strFileName.ReverseFind('\\');
		if(nIndex != -1)
		{
			strPointFilePath = strFileName.Left(nIndex+1);
			strPointFileName = strFileName.Right(strFileName.GetLength() - nIndex - 1);
			m_strPSDataLocation = strFileName;
		}

		if (bRunNIMS == true)
			return;

		bCanOpen = db.OpenEx(strSQL,CDatabase::noOdbcDialog);
	}
	catch(CException e)
	{
		AfxMessageBox("ODBC Error ---Cannot open database for reading.");
		Log("ODBC Error ---Cannot open database for reading.");
		return;
	}
	if(!bCanOpen)
	{
		AfxMessageBox("ODBC Error ---Cannot open  database for reading.");
		Log("ODBC Error ---Cannot open  database for reading.");
		return;
	}

	// allocate new space
	pPSData = new PSData[nPtSource];

	int i,j;
	int nNum = nPtQuals;
	CString strErrorMsg;
	CString strCard = "";
	
 	int *pPSRecords = NULL;		
	pPSRecords = new int[nPtSource];
	for (i=0; i<nPtSource; ++i)
		pPSRecords[i] = 0;

 	double *pfNew = NULL;
	if (nNum > 0)
	{
		pfNew = new double[nNum];
		for (i=0; i<nNum; ++i)
			pfNew[i] = 0.0;
	}

	TRY
	{
		CRecordset rs(&db);
		CString strTemp;
		
		// as MS-Access cannot support COUNT DISTINCT Column,
		// we have to reserve more space than required
		strSQL = "select * from PS_RECORDS";
		strCard = "Table PS_RECORDS";
		rs.Open(CRecordset::snapshot, strSQL, CRecordset::readOnly);

		int nSection = -1;
		int nPSRecords = 0;
		while(!rs.IsEOF())
		{
			rs.GetFieldValue((short)0, strTemp);
			int subbasin = atoi(LPCSTR(strTemp));
			rs.GetFieldValue((short)1, strTemp);
			CString strPermit = strTemp;
			rs.GetFieldValue((short)2, strTemp);
			CString strPipe = strTemp;
			rs.GetFieldValue((short)3, strTemp);
			int nRecord = atoi(LPCSTR(strTemp));

			// find the PSindex from the table 660
			nSection = GetPSIndex(subbasin,strPermit,strPipe);
			if(nSection == -1)
			{
				CString strErrorMsg;
				strErrorMsg.Format("\n subbasin:%d, strPermit:%s, strPipe:%s \n",
					subbasin,strPermit,strPipe);
				AfxMessageBox("Point source ID: "+strErrorMsg+" does not exist in the table 660");
				Log("Point source ID: "+strErrorMsg+" does not exist in the table 660");
				TRACE("Point source ID: "+strErrorMsg+" does not exist in the table 660");
		
				//release the memory
 				if (pPSRecords != NULL)		delete []pPSRecords;
 				if (pfNew != NULL)			delete []pfNew;
				rs.Close();
				db.Close();
				return;
			}

			pPSData[nSection].rchid = subbasin;
			pPSData[nSection].strPermit = strPermit;
			pPSData[nSection].strPipe = strPipe;
			pPSData[nSection].nRecord = nRecord;
			pPSRecords[nSection] = nRecord;

			//allocate memory
			pPSData[nSection].pData = new PSREALDATA[nRecord+2];	
			if (nNum > 0)
			{
				for(i=0; i<nRecord+2; ++i)
					pPSData[nSection].pData[i].pPollutant = new double[nNum];
			}
			
			++nPSRecords;

			if (nPSRecords > nPtSource)
			{
				AfxMessageBox("Number of PSRecords in "+strCard+" are greater than the number of point sources");
				Log("Number of PSRecords in "+strCard+" are greater than the number of point sources");
				TRACE("Number of PSRecords in "+strCard+" are greater than the number of point sources");
				
				//release the memory
 				if (pPSRecords != NULL)		delete []pPSRecords;
 				if (pfNew != NULL)			delete []pfNew;
				rs.Close();
				db.Close();
				return;
			}
			rs.MoveNext();
		}
		rs.Close();

		//check if any point source is missing! 
		for (i=0; i<nPtSource; i++)
		{
			bool bPSexists = false;
			for (j=0; j<nPtSource; j++)
			{
				if(pPSReduction[i].rchid == pPSData[j].rchid &&
				   pPSReduction[i].strPermitName.CompareNoCase(pPSData[j].strPermit) == 0 &&
				   pPSReduction[i].strPipeName.CompareNoCase(pPSData[j].strPipe) == 0)
				{
					bPSexists = true;
					break;
				}
			}
			if (bPSexists == false)
			{
				CString strErrorMsg;
				strErrorMsg.Format("\n subbasin:%d, strPermit:%s, strPipe:%s \n",
					pPSReduction[i].rchid,pPSReduction[i].strPermitName,
					pPSReduction[i].strPipeName);
				AfxMessageBox("Point source data is missing for: "+strErrorMsg+" ");
				Log("Point source data is missing for: "+strErrorMsg+" ");
				TRACE("Point source data is missing for: "+strErrorMsg+" ");
				
				//release the memory
 				if (pPSRecords != NULL)		delete []pPSRecords;
 				if (pfNew != NULL)			delete []pfNew;
				rs.Close();
				db.Close();
				return;
			}
		}

		// read point source flow
		strSQL = "select * from PS_FLOW";
		strCard = "Table PS_FLOW";			
		rs.Open(CRecordset::snapshot, strSQL, CRecordset::readOnly);

		int subbasin = -1;
		CString strPermit = "";
		CString strPipe = "";
		CDBVariant dbVar;
		COleDateTime dtOld = COleDateTime(1900,1,1,0,0,0);
		
		nSection = -1;
		while(!rs.IsEOF())
		{
			rs.GetFieldValue("SUBBASIN", strTemp);
			rs.GetFieldValue("PERMIT", strPermit);
			rs.GetFieldValue("PIPE", strPipe);
			subbasin = atoi(LPCSTR(strTemp));

			nSection = GetPSIndex(subbasin,strPermit,strPipe);
			if(nSection == -1)
			{
				CString strErrorMsg;
				strErrorMsg.Format("\n subbasin:%d, strPermit:%s, strPipe:%s \n",
					subbasin,strPermit,strPipe);
				AfxMessageBox("Point source ID: "+strErrorMsg+" does not exist in the table 660");
				Log("Point source ID: "+strErrorMsg+" does not exist in the table 660");
				TRACE("Point source ID: "+strErrorMsg+" does not exist in the table 660");
				
				//release the memory
 				if (pPSRecords != NULL)		delete []pPSRecords;
 				if (pfNew != NULL)			delete []pfNew;
				rs.Close();
				db.Close();
				return;
			}

			pPSData[nSection].rchid = subbasin;
			pPSData[nSection].strPermit = strPermit;
			pPSData[nSection].strPipe = strPipe;

			int nRecords = pPSRecords[nSection];
			pPSData[nSection].nRecord = 0;
			
			for (i=0; i<nRecords; ++i)
			{
				rs.GetFieldValue("DATE", dbVar, SQL_C_TIMESTAMP);
				int nYear = dbVar.m_pdate->year;
				int nMonth = dbVar.m_pdate->month;
				int nDay = dbVar.m_pdate->day;
				int nHour = dbVar.m_pdate->hour;
				int nMinute = 	dbVar.m_pdate->minute;
				COleDateTime dtNew = COleDateTime(nYear,nMonth,nDay,nHour,nMinute,0);
				rs.GetFieldValue("PS_FLOW", dbVar, SQL_C_DOUBLE);
				double fFlow = dbVar.m_dblVal;
				rs.GetFieldValue("WITHDRAWAL", dbVar, SQL_C_DOUBLE);
				double fWithdrawal = dbVar.m_dblVal;
				
				if(pPSData[nSection].nRecord == 0)
				{
					//if the first record time is not start time,
					// add an additional record to the top
					if(tStart < dtNew)
					{
						pPSData[nSection].pData[pPSData[nSection].nRecord].flow = fFlow;
						pPSData[nSection].pData[pPSData[nSection].nRecord].withdrawal = fWithdrawal;
						// update date/time
						pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  tStart - COleDateTimeSpan(0,0,deltm,0);		
						++pPSData[nSection].nRecord;
					}

					//update flow
					pPSData[nSection].pData[pPSData[nSection].nRecord].flow = fFlow;
					pPSData[nSection].pData[pPSData[nSection].nRecord].withdrawal = fWithdrawal;
					
					// update date/time
					pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  dtNew;
					++pPSData[nSection].nRecord;
				}
				else // not the first record
				{
					if(dtNew == pPSData[nSection].pData[pPSData[nSection].nRecord-1].tTime) //update the current record
					{
						pPSData[nSection].pData[pPSData[nSection].nRecord-1].flow += fFlow;
						pPSData[nSection].pData[pPSData[nSection].nRecord-1].withdrawal += fWithdrawal;
					}
					else // new time series
					{
						pPSData[nSection].pData[pPSData[nSection].nRecord].flow = fFlow;
						pPSData[nSection].pData[pPSData[nSection].nRecord].withdrawal = fWithdrawal;
						
						// update date/time
						pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  dtNew;
						++pPSData[nSection].nRecord;
					}
				}
				rs.MoveNext();
			}
			//if the last record time is not end time,
			// add an additional record to the end
			if(pPSData[nSection].pData[pPSData[nSection].nRecord-1].tTime  <  tEnd)		
			{
				pPSData[nSection].pData[pPSData[nSection].nRecord].flow = 
					pPSData[nSection].pData[pPSData[nSection].nRecord-1].flow;
				pPSData[nSection].pData[pPSData[nSection].nRecord].withdrawal = 
					pPSData[nSection].pData[pPSData[nSection].nRecord-1].withdrawal;
				// update date/time
				pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  tEnd;		
			}
		}
		rs.Close();

		// read point sources QUAL
		if(nNum > 0)
		{
			strSQL = "select * from PS_QUAL";
			strCard = "Table PS_QUAL";			
			rs.Open(CRecordset::snapshot, strSQL, CRecordset::readOnly);

			nSection = -1;
			while(!rs.IsEOF())
			{
				rs.GetFieldValue("SUBBASIN", strTemp);
				rs.GetFieldValue("PERMIT", strPermit);
				rs.GetFieldValue("PIPE", strPipe);
				subbasin = atoi(LPCSTR(strTemp));
				nSection = GetPSIndex(subbasin,strPermit,strPipe);
				if(nSection == -1)
				{
					CString strErrorMsg;
					strErrorMsg.Format("\n subbasin:%d, strPermit:%s, strPipe:%s \n",
						subbasin,strPermit,strPipe);
					AfxMessageBox("Point source ID: "+strErrorMsg+" does not exist in the table 660");
					Log("Point source ID: "+strErrorMsg+" does not exist in the table 660");
					TRACE("Point source ID: "+strErrorMsg+" does not exist in the table 660");
					
					//release the memory
 					if (pPSRecords != NULL)		delete []pPSRecords;
 					if (pfNew != NULL)			delete []pfNew;
					rs.Close();
					db.Close();
					return;
				}

				pPSData[nSection].rchid = subbasin;
				pPSData[nSection].strPermit = strPermit;
				pPSData[nSection].strPipe = strPipe;

				int nRecords = pPSRecords[nSection];
				pPSData[nSection].nRecord = 0;
				
				for (i=0; i<nRecords; ++i)
				{
					rs.GetFieldValue("DATE", dbVar, SQL_C_TIMESTAMP);
					int nYear   = dbVar.m_pdate->year;
					int nMonth  = dbVar.m_pdate->month;
					int nDay    = dbVar.m_pdate->day;
					int nHour   = dbVar.m_pdate->hour;
					int nMinute = dbVar.m_pdate->minute;
					COleDateTime dtNew = COleDateTime(nYear,nMonth,nDay,nHour,nMinute,0);
					for(int i=0; i<nNum; i++)
					{
						CString temp;
						temp.Format("%d",pPtQual[i].qualid);
						rs.GetFieldValue(temp, dbVar, SQL_C_DOUBLE);
						pfNew[i] = dbVar.m_dblVal;
					}
					if(pPSData[nSection].nRecord == 0)
					{
						//if the first record time is not start time,
						// add an additional record to the top
						if(tStart < dtNew)
						{
							//update pollutants
 							for(int i=0; i<nNum; i++)
 								pPSData[nSection].pData[pPSData[nSection].nRecord].pPollutant[i] = pfNew[i];
							// update date/time
							pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  tStart - COleDateTimeSpan(0,0,deltm,0);		
							++pPSData[nSection].nRecord;
						}

						//update pollutants
 						for(int i=0; i<nNum; i++)
 							pPSData[nSection].pData[pPSData[nSection].nRecord].pPollutant[i] = pfNew[i];
						// update date/time
						pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  dtNew;
						++pPSData[nSection].nRecord;
					}
					else // not the first record
					{
						if(dtNew == pPSData[nSection].pData[pPSData[nSection].nRecord-1].tTime) 
						{
							//update pollutants
 							for(int i=0; i<nNum; i++)
 								pPSData[nSection].pData[pPSData[nSection].nRecord-1].pPollutant[i] += pfNew[i];
						}
						else // new time series
						{
							//update pollutants
 							for(int i=0; i<nNum; i++)
 								pPSData[nSection].pData[pPSData[nSection].nRecord].pPollutant[i] = pfNew[i];
							// update date/time
							pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  dtNew;
							++pPSData[nSection].nRecord;
						}
					}
					rs.MoveNext();
				}
				//if the last record time is not end time,
				// add an additional record to the end
				if(pPSData[nSection].pData[pPSData[nSection].nRecord-1].tTime  <  tEnd)		
				{
					//update pollutants
 					for(int i=0; i<nNum; i++)
 						pPSData[nSection].pData[pPSData[nSection].nRecord].pPollutant[i] = 
 						pPSData[nSection].pData[pPSData[nSection].nRecord-1].pPollutant[i];
					// update date/time
					pPSData[nSection].pData[pPSData[nSection].nRecord].tTime =  tEnd;		
				}
			}
			rs.Close();
		}

		db.Close();

		//release the memory
 		if (pPSRecords != NULL)		delete []pPSRecords;
		if (pfNew != NULL)			delete []pfNew;
	}
	CATCH(CException, e)
	{
		db.Close();

		//release the memory
 		if (pPSRecords != NULL)		delete []pPSRecords;
 		if (pfNew != NULL)			delete []pfNew;
		
		AfxMessageBox("Error reading "+strCard+" point source data from the database.");
		Log("Error reading point source data from the database.");
		return;
	}
	END_CATCH;
}

void CLSPCMODEL::WritePointSource(CString strFileName)
{
	if(pPSData == NULL || nPtSource <= 0)
		return;
	//
	FILE *fpin = NULL;
	
	// open the file for writing
	fpin = fopen (strFileName, "wt");
	if(fpin == NULL)
	{
		AfxMessageBox("Cannot open file "+strFileName+" for writing");
		Log("Cannot open file "+strFileName+" for writing");
		return;
	}
	CString strOut;
	CString strTemp;
	CString str;
    str.Format("c %s\n",LSPC_VERSION);

    fputs("c-----------------------------------------------------------------------------------------\n",fpin);
	fputs("c LSPC -- Loading Simulation Program, C++\n",fpin);
    fputs(LPCSTR(str),fpin);
	fputs("c\n",fpin);
	fputs("c Designed and maintained by:\n",fpin);
	fputs("c     Tetra Tech, Inc.\n",fpin);
	fputs("c     10306 Eaton Place, Suite 340\n",fpin);
	fputs("c     Fairfax, VA 22030\n",fpin);
	fputs("c     (703) 385-6000\n",fpin);
    fputs("c-----------------------------------------------------------------------------------------\n",fpin);
	fputs("c LSPC MODEL POINT SOURCE INPUT FILE\n", fpin);

    SYSTEMTIME tm;
	GetLocalTime(&tm);

    str.Format("c This input file was created at %02d:%02d:%02d%s on %02d/%02d/%04d\n",(tm.wHour>12)?tm.wHour-12:tm.wHour,tm.wMinute,tm.wSecond,(tm.wHour>=12)?"pm":"am",tm.wMonth,tm.wDay,tm.wYear);
    fputs(LPCSTR(str),fpin);
	fputs("c-----------------------------------------------------------------------------------------\n",fpin);
	
	fputs("c\n",fpin);										
	fputs("c     NPT:       Total	Number	of	time	series	records			\n",fpin);
	fputs("c     FUNIT:     Unit	to	convert	flow	to	cfs					\n",fpin);
	fputs("c     WUNIT:     Unit	to	convert	water	quality	to	Lb/hour		\n",fpin);
	fputs("c     PID:       Point	Source	ID	(number	for	notation)			\n",fpin);
	fputs("c     SUBBASIN:  Subbasin ID\n",fpin);
	fputs("c     PERMIT:    Point Source Index (level1)\n",fpin);
	fputs("c     PIPE:      Point Source Index Qualifier (level2)\n",fpin);
	fputs("c\n",fpin);
	fputs("c     Year  Month  Day  Hour  Minute  Flow  WithDrawal  WQ1  WQ2  WQ3  WQ4  WQ5  WQ6  WQn\n",fpin);
	fputs("c     NPT	FUNUIT	WUNIT	PID	 SUBBASIN  PERMIT  PIPE\n",fpin);

	int Num = nPtQuals;
	for(int i=0; i<nPtSource; ++i)
	{
		if(pPSData[i].nRecord != 0)
		{
			strOut.Format("%d\t1\t1\t%d\t%d\t%s\t%s\n",pPSData[i].nRecord,i+1,pPSData[i].rchid,pPSData[i].strPermit,pPSData[i].strPipe);
			fputs(strOut,fpin);
			for(int j=0;j<pPSData[i].nRecord;++j)
			{
				//date/time
				strOut.Format("%d\t%d\t%d\t%d\t%d\t%12.12e\t%12.12e\t",
					pPSData[i].pData[j].tTime.GetYear(),
					pPSData[i].pData[j].tTime.GetMonth(),
					pPSData[i].pData[j].tTime.GetDay(),
					pPSData[i].pData[j].tTime.GetHour(),
					pPSData[i].pData[j].tTime.GetMinute(),
					pPSData[i].pData[j].flow,
					pPSData[i].pData[j].withdrawal);
				//pollutants
				if (Num > 0)
					for(int m=0; m<Num; m++)
					{
						strTemp.Format("%12.12e\t",pPSData[i].pData[j].pPollutant[m]);
						strOut += strTemp;
					}
				strOut +="\n";
				fputs(strOut,fpin);
			}
		}
	}
	
	//11323	1	1	1						
	//1970	1	2	383	0	0	0	0	0	0
	fclose(fpin);
}

int CLSPCMODEL::GetPSIndex(int subbasin,CString strPermit,CString strPipe)
{
	if(pPSReduction == NULL)
		return -1;
	for(int i=0; i<nPtSource; ++i)
	{
		if(pPSReduction[i].rchid == subbasin &&
			pPSReduction[i].strPermitName.CompareNoCase(LPCSTR(strPermit)) == 0 &&
			pPSReduction[i].strPipeName.CompareNoCase(LPCSTR(strPipe)) == 0)
			return i;
	}
	return -1;
}

void CLSPCMODEL::Log(LPCTSTR lpszFormat, ...)
{
	CLSPCApp *pApp = (CLSPCApp*)AfxGetApp();
	va_list args;
	va_start(args, lpszFormat);
	
	int nBuf;
	TCHAR szBuffer[1024];
	
	nBuf = _vsntprintf(szBuffer, 1024, lpszFormat, args);
	pApp->Log(szBuffer);
	
	va_end(args);
}

/*     + + + PURPOSE + + + */
/*     Estimate albedo from dullness index.  The equation used depends */
/*     on the season, which is a function of time of year and hemisphere */
/*     - positive latitude is n hemisphere. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     MON    - month of year */
/*     LAT    - latitude */
/*     DULL   - dullness index of snow pack */
/*     ALBEDO - albedo of snow pack */

/*     + + +   + + + */

/*     + + + FUNCTIONS + + + */

/*     + + + INTRINSICS + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::albed(int *mon, double *lat, double *dull, double *albedo)
{
    static int eqn;
	
    if (*mon <= 3 || *mon >= 10) 
	{
		/*       winter time */
		if (*lat >= 0.0) 
		{
			eqn = 1;
		} 
		else 
		{
			eqn = 2;
		}
    } 
	else 
	{
		/*       summer time */
		if (*lat >= 0.0) 
		{
			eqn = 2;
		} 
		else 
		{
			eqn = 1;
		}
    }
	
	/*     estimate albedo of snow pack from dullness index */
    if (eqn == 1) 
	{
		*albedo = 0.85 - sqrt(*dull / 24.0) * 0.07;
		if (*albedo < 0.6) 
		{
			*albedo = 0.6;
		}
    } 
	else 
	{
		*albedo = 0.8 - sqrt(*dull / 24.0) * 0.1;
		if (*albedo < 0.45) 
		{
			*albedo = 0.45;
		}
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate compaction of the pack. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     IREGFG - irreqular calc needed flag */
/*     DELT60 - simulation time interval in hours */  
/*     PACKF  - content of snowpack */
/*     PDEPTH - ??? */
/*     COMPCT - ??? */

/*     + + +   + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::compac(int *iregfg, double *delt60, double *packf, double *pdepth, double *compct)
{
    static double rdenpf;
	
	/*     recalculation of the rate of compaction is done each hour, */
	/*     as long as a pack exists */
    if (*iregfg == 1) 
	{
		/*       find rate of change of depth */
		rdenpf = *packf / *pdepth;
		if (rdenpf < 0.55)
			*compct = 1.0 - *delt60 * 2e-5 * *pdepth * (0.55 - rdenpf);
		else
			*compct = 1.0;
    }
	
	/*     compact the pack - done each interval */
    if (*compct < 1.0) 
	{
		*pdepth *= *compct;
    } 
	else 
	{
		/*       no further compaction */
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate loss of heat from the pack. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     IREGFG - irreqular calc needed flag */
/*     AIRTMP - ??? */
/*     PACKF  - content of snowpack */
/*     PAKTMP - ??? */
/*     DELT60 - simulation time interval in hours */     
/*     SUMHT  - ??? */
/*     MNEGHS - ??? */
/*     NEGHT  - ??? */
/*     NEGHTS - ??? */

/*     + + +   + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::cooler(int *iregfg, double *airtmp, double *packf, double *paktmp, double *delt60, double *sumht, 
					double *mneghs, double *neght, double *neghts)
{
    static double reltmp;
	
	/*     set maximum negative heat storage - done irregularly */
	/*     units in inches of water with equiv latent heat */
    if (*iregfg == 1) 
	{
		reltmp = *airtmp - 32.0;
		if (reltmp > 0.0) 
		{
			*mneghs = 0.0;
		} 
		else 
		{
			*mneghs = *packf / 2.0 * 0.00695 * (-reltmp);
		}
		
		/*       find rate of increase of negative heat storage - in/ivl */
		if (*paktmp > *airtmp) 
		{
			*neght = (*paktmp - *airtmp) * 7e-4 * *delt60;
		} 
		else 
		{
			*neght = 0.0;
		}
    }
	
	/*     cool the pack if it is warmer than the air - */
	/*     done every interval */
    if (*sumht < 0.0) 
	{
		if (*paktmp > *airtmp) 
		{
			*neghts += *neght;
			if (*neghts > *mneghs) 
			{
				*neghts = *mneghs;
			}
		}
		
		/*       assume heat loss has been accounted for. sumht is */
		/*       set to zero to ensure that later subroutines function */
		/*       correctly */
		*sumht = 0.0;
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Determine the effect of precipitation on the pack. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     SNOFFG - snowing flag - 1:yes */
/*     SNOWF  - ??? */
/*     RAINFG - raining flag - 1:yes */
/*     RAINF  - ??? */
/*     RDNSN  - ??? */
/*     COVIND - ??? */
/*     DELT60 - simulation time interval in hours */                
/*     SNOCOV - ??? */
/*     COVINX - ??? */
/*     PACKF  - content of snowpack */
/*     PDEPTH - ??? */
/*     DULL   - ??? */
/*     PRAIN  - ??? */

/*     + + +   + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::effprc(int *snoffg, double *snowf, int *rainfg, double *rainf, double *rdnsn, double *covind, 
					double *delt60, double *snocov, double *covinx, double *packf, double *pdepth, double *dull, double *prain)
{
    static double dummy;
	
	
    if (*snoffg == 1) 
	{
		/*       it is snowing - add to the pack and find new depth */
		*packf += *snowf;
		*pdepth += *snowf / *rdnsn;
		/*       adjust the current value of packf required to ensure */
		/*       complete areal cover (covinx) */
		if (*packf > *covinx) 
		{
			if (*packf > *covind) 
			{
				/*           packf is more than the maximum needed to ensure */
				/*           complete snow cover of the land segment */
				*covinx = *covind;
			} 
			else 
			{
				*covinx = *packf;
			}
		}
		
		/*       adjust the dullness index for snowpack - */
		/*       used later to estimate albedo */
		dummy = *snowf * 1e3;
		if (dummy >= *dull)
			*dull = 0.0;
		else
			*dull -= dummy;
		
		/*       rain entering pack */
		*prain = 0.0;
    }
	else 
	{
		/*       it is not snowing */
		if (*rainfg == 1) 
		{
			/*         it is raining - find out how much rain actually */
			/*         enters the pack */
			*prain = *rainf * *snocov;
		} 
		else 
		{
			*prain = 0.0;
		}
		
    }
	
	/*     augment the dullness index */
    if (*dull < 800.0) 
	{
		/*       surface can get duller */
		*dull += *delt60;
    } 
	else 
	{
		/*       no further dulling of the pack */
    }
	
    return 0;
}

//     + + + PURPOSE + + +  
//     Melt the pack using heat from the ground.  

//     + + + DUMMY ARGUMENTS + + +  

//     + + + ARGUMENT DEFINITIONS + + +  
//     IREGFG - irreqular calc needed flag  
//     PAKTMP - ???  
//     MGMELT - ???  
//     PACKF  - content of snowpack  
//     WYIELD - ??? 
//     PACKW  - ??? 
//     PDEPTH - ??? 
//     PACKI  - ??? 
//     GMELTR - ??? 
//     NEGHTS - ??? 

//     + + + END SPECIFICATIONS + + +  

int CLSPCMODEL::gmelt(int *iregfg, double *paktmp, double *mgmelt, double *packf, double *wyield, double *packw, 
				   double *pdepth, double *packi, double *gmeltr, double *neghts)
{
    static double dummy;
	
    if (*iregfg == 1) 
	{
		/*       estimate the capacity for ground melt - depends on the */
		/*       temperature of the pack */
		if (*paktmp >= 32.0) 
		{
			*gmeltr = *mgmelt;
		} 
		else 
		{
			if (*paktmp > 5.0) 
			{
				*gmeltr = *mgmelt * (1.0 - (32.0 - *paktmp) * 0.03);
			} 
			else 
			{
				/*           ground melt is at its minimum value if paktmp is <= 5 deg f */
				*gmeltr = *mgmelt * 0.19;
			}
		}
    } 
	else 
	{
		/*       ground melt rate is unchanged */
    }
	
	/*     melt the pack */
    if (*packf <= *gmeltr) 
	{
		/*       the whole pack will melt */
		/* thj        MELT  = MELT + PACKF */
		*wyield = *wyield + *packf + *packw;
		*packf = 0.0;
		*packi = 0.0;
		*packw = 0.0;
		*pdepth = 0.0;
		*neghts = 0.0;
    } 
	else 
	{
		/*       part of the pack will melt */
		/* thj        MELT  = MELT + GMELTR */
		*packw += *gmeltr;
		/*       update depth, negative heat storage, and water equivalent */
		/*       of the frozen pack to account for ground melt */
		dummy = 1.0 - *gmeltr / *packf;
		*pdepth *= dummy;
		*neghts *= dummy;
		*packf -= *gmeltr;
		/*       ground melt takes ice storage first */
		if (*packi > *gmeltr) 
		{
			*packi -= *gmeltr;
		} 
		else 
		{
			*packi = 0.0;
		}
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Estimate rate of heat exchange (except components supplied */
/*     by ground melt and rain heat).  Units are inches of water */
/*     with equivalent latent heat/ivl.  At this stage we act as though */
/*     snow covers the entire segment.  Correction for areal */
/*     extent of snow cover is done later.  These calculations are */
/*     done intermittently. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     CCFACT - ??? */
/*     WINMOV - ??? */
/*     VAP    - ??? */
/*     AIRTMP - ??? */
/*     MELEV  - ??? */
/*     MON    - calendar month */
/*     LAT    - ??? */
/*     DULL   - ??? */
/*     SOLRAD - ??? */
/*     SHADE  - ??? */
/*     DELT60 - simulation time interval in hours */        
/*     SKYCLR - ??? */
/*     MOSTHT - ??? */
/*     ALBEDO - ??? */

/*     + + +   + + + */

/*     + + + EXTERNALS + + + */

/*     + + + END SPECIFICATIONS + + + */

int CLSPCMODEL::hexchr(double *ccfact, double *winmov, double *vap, double *airtmp, double *melev, int *mon, double *lat, 
					double *dull, double *solrad, double *shade, double *delt60, double *skyclr, double *mostht, double *albedo)
{
    static double longwave;
    static double factr, radht, dummy, shortwave, condht, convht, reltmp;
	
	
	/*     Calculate factor used below, from wind data and from */
	/*     adjustment parameter for field conditions */
    factr = *ccfact * 2.6e-4 * *winmov;
	
	/*     heat supplied by condensation */
    if (*vap > 6.108) {
		/*       air is moist enough to condense */
		dummy = (*vap - 6.108) * 8.59;
		condht = dummy * factr;
    } else {
		condht = 0.0;
    }
	
	/*     heat supplied by convection */
    if (*airtmp > 32.0) {
		/*       convection heating can occur */
		dummy = (*airtmp - 32.0) * (1.0 - *melev * 0.3 / 1e4);
		convht = dummy * factr;
    } else {
		convht = 0.0;
    }
	
	/*     find albedo based on dullness index */
    albed(mon, lat, dull, albedo);
	
	/*     heat supplied by shortwave radiation */
	/*     estimate shortwave energy - langleys/ivl */
    shortwave = *solrad * (1.0 - *albedo) * (1.0 - *shade);
	
	/*     estimate longwave energy - langleys/ivl */
    reltmp = *airtmp - 32.0;
    if (reltmp > 0.0)
		longwave = (*shade * 0.26 * reltmp + (1.0 - *shade) * (reltmp * 0.2 - 6.6)) * *delt60;
    else
		longwave = (*shade * 0.2 * reltmp + (1.0 - *shade) * (reltmp * 0.17 - 6.6)) * *delt60;
	
	/*     reduce longwave radiation to account for back radiation */
	/*     from clouds, if net heat transfer was outwards from pack */
    if (longwave < 0.0)
		longwave *= *skyclr;
	
	/*     find total radiative heat transfer and convert to units: */
	/*     inches water equiv latent heat */
    radht = (shortwave + longwave) / 203.2;
	/*     mostht is the total heat available, except for */
	/*     rain and ground heat */
    *mostht = radht + convht + condht;
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Simulate the occurrence of frozen ground - ice (PACKI) is regarded */
/*     as part of the pack. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     HR     - ??? */
/*     SNOCOV - ??? */
/*     AIRTMP - ??? */
/*     HR6FG  - ??? */
/*     XLNMLT - ??? */
/*     WYIELD - ??? */
/*     PACKF  - content of snowpack */
/*     PACKI  - ??? */
/*     PDEPTH - ??? */

/*     + + +   + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::icing(int *hr, double *snocov, double *airtmp, int *hr6fg, double *xlnmlt, double *wyield, double *packf, 
				   double *packi, double *pdepth)
{
    static double xlnem, freeze, reltmp;
	
	/*     once per day, at approx 6 AM, update the possible increment */
	/*     to frozen ground */
    if (*hr >= 7) 
	{
		if (*hr6fg != 0) 
		{
			/*         update the possible increment */
			if (*snocov < 1.0) 
			{
				/*           land segment is not completely covered, so */
				/*           the water freezing capacity can increase */
				reltmp = *airtmp - 32.0;
				/*           compute new potential increment to ice storage */
				xlnem = -reltmp * 0.01;
				
				/*           use the larger value --  only a positive value will */
				/*           mean that there is capacity */
				if (xlnem > *xlnmlt) 
				{
					*xlnmlt = xlnem;
				}
			} 
			else 
			{
				/*           completely covered ground will keep the current value */
				/*           for freezing capacity - no further increment */
			}
			
			*hr6fg = 0;
		}
    } 
	else 
	{
		/*       set the flag so that the freezing capacity will be updated */
		/*       next time 6 am is passed */
		*hr6fg = 1;
    }
	
	/*     check whether any water yielded by the pack is to be frozen */
	/*     in this interval */
//    if (*wyield > 0.0 && *xlnmlt > 0.0) 
    if (*wyield > 0.0) 
	{
		/*       water is available and there is some remaining freezing */
		/*       capacity */
		if (*wyield < *xlnmlt) 
		{
			/*         all water available will be frozen */
			freeze = *wyield;
			/*         reduce remaining freezing capacity */
			*xlnmlt -= *wyield;
			*wyield = 0.0;
		} 
		else 
		{
			/*         some of the yield will be frozen */
			freeze = *xlnmlt;
			*wyield -= *xlnmlt;
			/*         freezing capacity is exhausted */
			*xlnmlt = 0.0;
		}
		
		/*       update the pack */
		*packf += freeze;
		*packi += freeze;
		/*       assume ice has relative density= 1 */
		*pdepth += freeze;
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Handle liquid water in the pack. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     IREGFG - irreqular calc needed flag */
/*     PDEPTH - ??? */
/*     MWATER - ??? */
/*     PACKF  - content of snowpack */
/*     MELT   - ??? */
/*     PRAIN  - ??? */
/*     RNFRZ  - ??? */
/*     DELT60 - simulation time interval in hours */        
/*     PACKW  - ??? */
/*     PACKWC - ??? */
/*     WYIELD - ??? */

/*     + + +   + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::liquid(int *iregfg, double *pdepth, double *mwater, double *packf, double *melt, double *prain, 
					double *rnfrz, double *delt60, double *packw, double *packwc, double *wyield)
{
    static double mpws, dummy, rdenpf, pwsupy;
	
    if (*iregfg == 1) 
	{
		/*       compute the liquid water holding capacity (packwc) of the */
		/*       pack - units are in inches of water equivalent */
		if (*packf > 0.0) 
		{
			/*         first find the relative density of the */
			/*         frozen contents of the pack */
			rdenpf = *packf / *pdepth;
			if (rdenpf <= 0.6) 
			{
				/*           liquid water holding capacity is at its maximum */
				*packwc = *mwater;
			} 
			else 
			{
				/*           determine the less than maximum water holding capacity */
				dummy = 3.0 - rdenpf * 3.33;
				if (dummy >= 0.0) 
				{
					*packwc = *mwater * dummy;
				}
				else 
				{
					*packwc = 0.0;
				}
			}
		}
    }
	
	/*     compare available liquid water with storage capacity of pack */

	/*     find the available water */
    pwsupy = *packw + *melt + *prain - *rnfrz;
	/*     compute the storage capacity - units are inches */
    mpws = *packwc * *packf;
    if ((pwsupy - mpws) > (*delt60 * 0.01)) 
	{
		/*       supply exceeds storage capacity by more than tolerance, so */
		/*       water is yielded and the liquid water is held at capacity */
		*wyield = pwsupy - mpws;
		*packw = mpws;
    } 
	else 
	{
		/*       liquid water supply does not exceed capacity by more than */
		/*       tolerance, so there is no moisture leaving the pack */
		*packw = pwsupy;
		*wyield = 0.0;
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Use any remainder of SUMHT to melt the pack. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     SUMHT  - ??? */
/*     PACKF  - content of snowpack */
/*     PACKI  - ??? */
/*     PDEPTH - ??? */
/*     MELT   - ??? */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::melter(double *sumht, double *packf, double *packi, double *pdepth, double *melt)
{
    if (*sumht >= *packf) 
	{
		/*       there is enough to melt the whole pack */
		*melt = *packf;
		*packf = 0.0;
		*pdepth = 0.0;
		*packi = 0.0;
    } 
	else 
	{
		if (*sumht > 0.0) 
		{
			/*         can melt part of the pack */
			*melt = *sumht;
			*pdepth *= 1.0 - *melt / *packf;
			*packf -= *melt;
			/*         ice is melted after snow has gone */
			if (*packi > *packf) 
			{
				*packi = *packf;
			}
		} 
		else 
		{
			/*         no melting */
			*melt = 0.0;
		}
		
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Estimate meteorological conditions. */
/*     air temp has been done in module section atemp. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     PREC   - ??? */
/*     HRFG   - ??? */
/*     AIRTMP - ??? */
/*     TSNOW  - ??? */
/*     DTMPG  - ??? */
/*     SNOWCF - ??? */
/*     RDCSN  - ??? */
/*     DELT   - simulation time interval in minutes */							// corrected by   (09-03)
/*     CCFP   - ??? */
/*     IVL1   - ??? */
/*     SNOTMP - ??? */
/*     DRYFG  - ??? */
/*     SKYCLR - ??? */
/*     DEWTMP - ??? */
/*     SNOFFG - snowing flag - 1:yes */
/*     SNOWF  - ??? */
/*     RAINFG - raining flag - 1:yes */
/*     RAINF  - ??? */
/*     RDNSN  - ??? */

/*     + + + COMMON BLOCKS + + + */
/*    FROM CMDUM.COM */
/*    AREA RESERVED FOR OSVS: */

/*     + + + PARAMETERS + + + */

/*     SPECIAL COMMON SCRTCH */

/*     + + + PARAMETERS + + + */


/*     + + +   + + + */
/*     from CMPAD.INC */
/*     scratch pad is the entire common block */



/*     + + + END SPECIFICATIONS + + + */
/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::meteor(double *prec, int *hrfg, double *airtmp, double *tsnow, double *dtmpg, double *snowcf, double *rdcsn, 
					int *delt, int *ccfp, double *snotmp, int *dryfg, double *skyclr, double *dewtmp, int *snoffg, double *snowf, 
					int *rainfg, double *rainf, double *rdnsn,double *cloud)
{
    double r1;
	
    static int fprfg;
    static double dtsnow;
	
	/*     determine whether this is the first interval with precipitation */
	/*     after a dry period */
    if (*prec > 0.0) 
	{
		/*       there is precipitation */
		if (*dryfg != 0) 
		{
			/*         this is the first interval with precipitation after */
			/*         one or more with none */
			fprfg = 1;
			*dryfg = 0;
		} 
		else 
		{
			/*         this is not the first precipitation interval */
			fprfg = 0;
		}
    } 
	else 
	{
		/*       there is no precipitation */
		*dryfg = 1;
		fprfg = 0;
    }
	
    if (*hrfg != 0) 
	{
		/*       it is time to estimate the dewpoint */
		if (*prec > 0.0 && *airtmp > *tsnow) 
		{
			/*         adjust the dewpoint since it will not be meaningfull */
			/*         when used in the equation if higher than air temperature */
			*dewtmp = *airtmp;
		} 
		else 
		{
			if (*dtmpg > *airtmp) 
			{
				/*           adjust dewpoint since it cannot be higher than air temp */
				*dewtmp = *airtmp;
			} 
			else 
			{
				/*           gage dewpoint is ok */
				*dewtmp = *dtmpg;
			}
		}
    }
	
	/*     find the temperature which divides snow from rain, and compute */
	/*     the quantity of snow or rain fall */
    if (*prec > 0.0) 
	{
		/*       there is precipitation */
		if (*hrfg != 0 || fprfg != 0) 
		{
			/*         compute the air temperature below which precipitation */
			/*         will be snow (snotmp) */
			/*         account for the effect of humidity on snowfall temperature */
			dtsnow = (*airtmp - *dewtmp) * (*airtmp * 0.008 + 0.12);
			/*         restrict increase to 1 deg f */
			if (dtsnow < 1.0)
				*snotmp = *tsnow + dtsnow;
			else
				*snotmp = *tsnow + 1.0;
		}
		
		/*       there is maximum cloud cover */
		*skyclr = 0.15;
		
		if (*airtmp < *snotmp) 
		{
			/*         it is snowing */
			*snoffg = 1;
			*snowf = *snowcf * *prec;
			*rainf = 0.0;
			*rainfg = 0;

			if (*hrfg != 0 || fprfg != 0) 
			{
				/*           estimate the relative density of the new snow */
				if (*airtmp > 0.0) // 0 degree F (it is correct)
				{			
					/*             adjust */
					/* Computing 2nd power */
					r1 = *airtmp / 100.0;
					*rdnsn = *rdcsn + r1 * r1;
				} 
				else 
				{
					/*             use value for really cold snow */
					*rdnsn = *rdcsn;
				}
			}
		} 
		else 
		{
			/*         it is raining */
			*rainfg = 1;
			*rainf = *prec;
			*snoffg = 0;
			*snowf = 0.0;
		}
    } 
	else 
	{
		/*       it is clear, or clearing */
		*rainf = 0.0;
		*rainfg = 0;
		*snoffg = 0;
		*snowf = 0.0;
		if (*skyclr < 1.0) 
		{
			*skyclr += *delt * 4e-4;
			if (*skyclr > 1.0) 		*skyclr = 1.0;
			if (*skyclr < 0.15)		*skyclr = 0.15;
		}
    }
	/*     use cloud cover time series if available */
//    if (*ccfp >= 0)															//   (11-03)
    if (*ccfp > 0) 
	{
		//Rewrite the following statement Jian Ouyang!!!
		*skyclr = 1.0 - *cloud/10;
		//*skyclr = 1.0 - pad[*ccfp + *ivl1 - 1] / 10.0;
		if (*skyclr < 0.15)
			*skyclr = 0.15;
    }
	
    return 0;
}


/*     + + + PURPOSE + + + */
/*     Reset state variables when snowpack disappears. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     COVIND - ??? */
/*     HR6FG  - ??? */
/*     PACKF  - content of snowpack */
/*     PACKW  - ??? */
/*     PACKI  - ??? */
/*     PACK   - ??? */
/*     PDEPTH - ??? */
/*     RDENPF - ??? */
/*     COVINX - ??? */
/*     SNOCOV - ??? */
/*     DULL   - ??? */
/*     ALBEDO - ??? */
/*     XLNMLT - ??? */
/*     MNEGHS - ??? */
/*     PAKTMP - ??? */
/*     NEGHTS - ??? */
/*     PACKWC - ??? */
/*     NEGHT  - ??? */
/*     GMELTR - ??? */
/*     COMPCT - ??? */
/*     SNOWEP - ??? */
/*     MOSTHT - ??? */
/*     VAP    - ??? */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::nopack(double *covind, int *hr6fg, double *packf, double *packi, double *packw, double *pack, double *pdepth,
					double *rdenpf, double *covinx, double *snocov, double *dull, double *albedo, double *xlnmlt, double *mneghs, double *paktmp, double *neghts,
					double *packwc, double *neght, double *gmeltr, double *compct, double *snowep, double *mostht, double *vap)
{
    *hr6fg = 1;
    *packf = 0.0;
    *packi = 0.0;
    *packw = 0.0;
    *pack = 0.0;
    *pdepth = 0.0;
    *rdenpf = -1e30;
    *covinx = *covind * 0.1;
    *snocov = 0.0;
    *dull = -1e30;
    *xlnmlt = 0.0;
    *albedo = -1e30;
    *mneghs = -1e30;
    *paktmp = 32.0;                            // temp (F) 
    *neghts = 0.0;
    *packwc = -1e30;
    *neght = -1e30;
    *gmeltr = -1e30;
    *compct = -1e30;
    *snowep = -1e30;
    *mostht = -1e30;
    *vap = -1e30;
	
    return 0;
}


/*     + + + PURPOSE + + + */
/*     Estimate vapor pressures and rate of evaporation from snow. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     IREGFG - irreqular calc needed flag */
/*     SVP    - ??? */
/*     DEWTMP - ??? */
/*     AIRTMP - ??? */
/*     SNOCOV - ??? */
/*     SNOEVP - ??? */
/*     WINMOV - ??? */
/*     LSNO   - line number in the opn sequence block of uci */
/*     MESSU  - ftn unit no. to be used for printout of messages */
/*     MSGFL  - fortran unit number of error message file */
/*     SNOWEP - ??? */
/*     PACKF  - content of snowpack */
/*     PDEPTH - ??? */
/*     PACKI  - ??? */
/*     ECNT1  - ??? */
/*     SNOWE  - ??? */
/*     VAP    - ??? */
/*     DATIM  - date and time of day */

/*     + + +   + + + */

/*     + + + EXTERNALS + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::snowev(int *iregfg, double *svp, double *dewtmp, double *airtmp, double *snocov, double *snoevp, 
					double *winmov, /*int *lsno, int *messu, int *msgfl, int *datim,*/ double *snowep, double *packf, double *pdepth, double *packi, 
					/*int *ecnt1,*/ double *snowe, double *vap)
{
    static double dummy, satvap;
	
    if (*iregfg == 1) 
	{
		/*       it is time to estimate - vapor press is in millibars */
//		vapor(&svp[0], dewtmp, /*lsno, messu, msgfl, &datim[0], ecnt1, */vap);
		vapor(svp, dewtmp, /*lsno, messu, msgfl, &datim[0], ecnt1, */vap);
		
//		vapor(&svp[0], airtmp, /*lsno, messu, msgfl, &datim[0], ecnt1, */&satvap);
		vapor(svp, airtmp, /*lsno, messu, msgfl, &datim[0], ecnt1, */&satvap);
		
		/*       estimate rate of evap from pack - inches water equiv/ivl */
		if (*vap >= 6.108) 
		{
			/*         snow will not evaporate */
			/*         snowep is the potential rate of evap */
			*snowep = 0.0;
		} 
		else 
		{
			/*         evaportion is possible so calculate potential rate */
			dummy = (satvap - *vap) * *snocov;
			*snowep = *snoevp * 2e-4 * *winmov * dummy;
		}
		
    }
	
	/*     subtract snow evap from the pack */
    if (*snowep >= *packf) 
	{
		/*       the pack is gone - all liquid water will be released in */
		/*       module liquid, but may be refrozen by module icing */
		*snowe = *packf;
		*pdepth = 0.0;
		*packi = 0.0;
		*packf = 0.0;
    } 
	else 
	{
		/*       subtract evaporation from the pack and continue calculations */
		*pdepth *= 1.0 - *snowep / *packf;
		*packf -= *snowep;
		*snowe = *snowep;
		if (*packi > *packf)
			*packi = *packf;
    }
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Calculate the saturation vapor pressure (millibars) */
/*     for the given temperature (deg F). */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     SVP    - ??? */
/*     TMP    - ??? */
/*     LSNO   - line number in the opn sequence block of uci */
/*     MESSU  - ftn unit no. to be used for printout of messages */
/*     MSGFL  - fortran unit number of HSPF message file */
/*     ECNT1  - ??? */
/*     VAP    - ??? */
/*     DATIM  - date and time of day */

/*     + + +   + + + */

/*     + + + INTRINSICS + + + */

/*     + + + EXTERNALS + + + */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::vapor(double *svp, double *tmp, /*int *lsno, int *messu, int *msgfl, int *datim, int *ecnt1,*/ double *vap)
{
    static int sclu, sgrp;
    static double index;
    static int lower, upper;
    static double remain;
	
    sclu = 302;
	/*     find the elements of SVP(*) which bracket this temperature */
    index = (*tmp + 100.0) * 0.2;
    lower = (int) index;
    if (lower < 1) 
	{
		sgrp = 2;
		TRACE("Array Index out of boundary");
		return 0;
    }
	
    upper = lower + 1;
    if (upper > 40) {
		/*       saturation vapor pressure array is out of bounds */
		sgrp = 2;
		TRACE("Array Index out of boundary");
		return 0;
    }
	
    remain = index - lower;
	
	/*     do linear interpolation */
    *vap = svp[lower-1] + remain * (svp[upper-1] - svp[lower-1]);
	
    return 0;
}

/*     + + + PURPOSE + + + */
/*     Warm the pack to as much as 32 deg F, if possible */
/*     neghts is the negative heat storage in the pack. */

/*     + + + DUMMY ARGUMENTS + + + */

/*     + + + ARGUMENT DEFINITIONS + + + */
/*     PRAIN  - ??? */
/*     SUMHT  - ??? */
/*     NEGHTS - ??? */
/*     PDEPTH - ??? */
/*     PACKF  - content of snowpack */
/*     RNFRZ  - ??? */

/*     + + + END SPECIFICATIONS + + + */
int CLSPCMODEL::warmup(double *prain, double *sumht, double *neghts, double *pdepth, double *packf, double *rnfrz)
{
	
	
    if (*sumht > 0.0) 
	{
		/*       there is heat available to warm the pack */
		if (*sumht > *neghts) 
		{
			/*         there is more than enough heat to get to 32 deg f */
			*sumht -= *neghts;
			*neghts = 0.0;
		} 
		else 
		{
			/*         there is not enough */
			*neghts -= *sumht;
			*sumht = 0.0;
		}
    }
	
	/*     use up some or all of the latent heat of rain. */
	/*     since negative heat is considered in inches of water to melt the */
	/*     frozen contents of the snowpack, the heat energy released */
	/*     in freezing (the latent heat of fusion) is subtractable */
	/*     without any conversion. */
    if (*prain > 0.0) 
	{
		/*       there is rain entering the pack */
		if (*prain > *neghts) 
		{
			/*         there is more than enough heat to get to 32 deg f */
			/*         rnfrz is the amount of rain which freezes */
			*rnfrz = *neghts;
			*packf += *rnfrz;
			*neghts = 0.0;
		} 
		else 
		{
			/*         there is not enough latent heat to get to 32 deg f */
			/*         all rain entering pack will freeze */
			*rnfrz = *prain;
			*neghts -= *prain;
			*packf += *prain;
		}
		
		/*       assume freezing rain does not increase depth */
		/*       of pack, unless relative density is >= 1.0 */
		if (*packf > *pdepth)
			*pdepth = *packf;
    } 
	else 
	{
		/*       no addition of rain to the pack means no freezing of rain */
		*rnfrz = 0.0;
    }
	
    return 0;
}

void CLSPCMODEL::WriteCardComments(FILE *fpin, int nSection)
{
	if(!strComments[nSection].IsEmpty())
	{
		CStringToken strToken(strComments[nSection], "\r\n");
		while(strToken.HasMoreTokens())
		{
			CString str = strToken.NextToken();
			if(str[str.GetLength()-1] == '\r')
				str = str.Left(str.GetLength()-1) + "\n";
			if(str[str.GetLength()-1] != '\n')
				str = str + "\n";

			str = "cc " + str;
			fputs(str, fpin);
		}
	}
}

void ReachInfo::BuildPoly(CPolygon* polynew)
{
	int nCount = poly.pointList.GetCount();
	
	if(nCount < 3)
		return;
	if(polynew == NULL)
		return;
	
	// preparing for affine transform
	double minx,miny,maxx,maxy;
	for (int i = 0; i < nCount; i++) 
	{
		POSITION pos = poly.pointList.FindIndex(i);
		Point *pti = (Point *)poly.pointList.GetAt(pos);
		if(i == 0)
		{
			minx = maxx = pti->x;
			miny = maxy = pti->y;
		}
		else
		{
			if(pti->x > maxx)
				maxx = pti->x;
			if(pti->x < minx)
				minx = pti->x;
			if(pti->y > maxy)
				maxy = pti->y;
			if(pti->y < miny)
				miny = pti->y;
		}
	}
	if(minx == maxx || miny == maxy)
		return ;

	//apply affine transform for the first and last point
	POSITION pos = poly.pointList.FindIndex(0);
	Point *pt_first = (Point *)poly.pointList.GetAt(pos);
	Point ptFirst;

	ptFirst.x = (pt_first->x-minx)/(maxx-minx)*width;
	if(maxy == pt_first->y)
		ptFirst.y = 0;
	else if(miny == pt_first->y)
		ptFirst.y = depth;
	else
		ptFirst.y = (maxy-pt_first->y)/(maxy-miny)*depth;

	pos = poly.pointList.FindIndex(nCount-1);
	Point *pt_last = (Point *)poly.pointList.GetAt(pos);
	Point ptLast;
	ptLast.x = (pt_last->x-minx)/(maxx-minx)*width;
	if(maxy == pt_last->y)
		ptLast.y = 0;
	else if(miny == pt_last->y)
		ptLast.y = depth;
	else
		ptLast.y = (maxy-pt_last->y)/(maxy-miny)*depth;

	
	// do affine transform and add the transformed data to the new polygon
	//CPolygon* polynew = new CPolygon();
	
	
	Point pt[4];
	
	pt[0].y = (FLOODPLANEDEPTHRATIO+1)*depth;
	pt[0].x = -w1*width/2-(FLOODPLANEDEPTHRATIO*depth-ptFirst.y)/r2;
	
	pt[1].y = ptFirst.y;
	pt[1].x = ptFirst.x-w1*width/2;
	
	
	pt[2].y = ptLast.y;
	pt[2].x = ptLast.x+w1*width/2;
	
	pt[3].y = (FLOODPLANEDEPTHRATIO+1)*depth;
	pt[3].x = width+w1*width/2+(FLOODPLANEDEPTHRATIO*depth-ptLast.y)/r2;
	//add elements to the new list

	Point *ptTemp = new Point();
	ptTemp->x = pt[0].x;
	ptTemp->y = pt[0].y;

	polynew->pointList.AddTail((CObject *)(ptTemp));

	ptTemp = new Point();
	ptTemp->x = pt[1].x;
	ptTemp->y = pt[1].y;

	polynew->pointList.AddTail((CObject *)(ptTemp));
	
	for (i = 0;i < nCount;i++) 
	{
		POSITION pos = poly.pointList.FindIndex(i);
		Point *pti = (Point *)poly.pointList.GetAt(pos);
		Point *ptt = new Point();
		ptt->x = (pti->x-minx)/(maxx-minx)*width;
		// to prevent round up at the bottom and the top
		// do the following instead 
		if(maxy == pti->y)
			ptt->y = 0;
		else if(miny == pti->y)
			ptt->y = depth;
		else
			ptt->y = (maxy-pti->y)/(maxy-miny)*depth;
		polynew->pointList.AddTail((CObject *)ptt);
	}
	
	ptTemp = new Point();
	ptTemp->x = pt[2].x;
	ptTemp->y = pt[2].y;
	polynew->pointList.AddTail((CObject *)(ptTemp));
	ptTemp = new Point();
	ptTemp->x = pt[3].x;
	ptTemp->y = pt[3].y;
	polynew->pointList.AddTail((CObject *)(ptTemp));
	
	// step 2, calculate the flood plane width, calculate
	// the two corner points
	
	// step 3, based on the slope, generate the flood plane
	// with 4*h as the flood plane depth
}

/****************************************
fh -- water depth of the specified layer
fv -- volume
fq -- fq = fv*area // see Manning Equation
qk -- derived parameter from fq and fv
*****************************************/
void ReachInfo::ftable(double *fh, double *fv,double *fq, double *qk,double *fa, double *fp, double *fr, double *fsa)		//   (04-28-04)
{
	// divide the channel(first h) by 20 layers (1/3)
	// divide the flood plane(10*h) by 40 layers (2/3)

	double lfK = 1.49;
	
	CPolygon wholepoly;

	BuildPoly(&wholepoly);
	
	wholepoly.Print();
	
	if(wholepoly.pointList.GetCount() < 3)
	{
		TRACE("Error: ReachInfo::ftable polygon not generated.\n");
		return;
	}
	CPolygon* newpoly = NULL;
	for(int i = 0; i< 20;++i)
	{
		fh[i] = i*depth/19;
	}
	fh[19] = depth;
	for(i = 20; i< 59;++i)
	{
		fh[i] = depth+FLOODPLANEDEPTHRATIO*depth/40*(i-19);
	}
	fh[59] = depth+FLOODPLANEDEPTHRATIO*depth;
	
	fv[0] = 0;
	fq[0] = 0;
	qk[0] = 0;
	fa[0] = 0;
	fp[0] = 0;
	fr[0] = 0;						
	fsa[0] = 0;						
	for(i = 1; i< 60;++i)
	{
		newpoly = wholepoly.GetNewPolygon(fh[i]);
		if(newpoly == NULL)
		{
			TRACE("Cannot generate polygon, check your dataset.\n");
			return;
		}
		double fArea = newpoly->GetArea();
		double fPerimeter = newpoly->GetWettedPerimeter();
		double fTopWidth = newpoly->GetTopWidth();					
		fa[i] = fArea;
		fp[i] = fPerimeter;
		fr[i] = fa[i] / fp[i];										
		fsa[i] = fTopWidth * length * MILE_TO_FEET;	// ft^2				    
		fq[i] = lfK/mann*fArea*pow(fArea/fPerimeter, 0.6666666666666666)*sqrt(slope);
		fv[i] = fArea*length*MILE_TO_FEET;
		
		if (newpoly != NULL)		delete newpoly;
	}
    for (i = 0; i <= 58; ++i)
	{
		qk[i] = (fv[i + 1] - fv[i]) / (fq[i + 1] - fq[i]);
    }
}

void ReachInfo::BuildDefaultPoly()
{
	poly.CPoly_Free();
	
	Point *pt = new Point[4];
	pt[0].x = 0;
	pt[0].y = 0;
	pt[1].x = (1-r1)*width/2.0;
	pt[1].y = depth;
	pt[2].x = width*r1+pt[1].x;
	pt[2].y = depth;
	pt[3].x = width;
	pt[3].y = 0;
	
	Point *ptTemp = new Point();
	ptTemp->x = pt[0].x;
	ptTemp->y = pt[0].y;
	poly.pointList.AddTail((CObject *)(ptTemp));
	ptTemp = new Point();
	ptTemp->x = pt[1].x;
	ptTemp->y = pt[1].y;
	poly.pointList.AddTail((CObject *)(ptTemp));
	ptTemp = new Point();
	ptTemp->x = pt[2].x;
	ptTemp->y = pt[2].y;
	poly.pointList.AddTail((CObject *)(ptTemp));
	ptTemp = new Point();
	ptTemp->x = pt[3].x;
	ptTemp->y = pt[3].y;
	poly.pointList.AddTail((CObject *)(ptTemp));
/*
	poly.pointList.AddTail((CObject*)&pt[0]);
	poly.pointList.AddTail((CObject*)&pt[1]);
	poly.pointList.AddTail((CObject*)&pt[2]);
	poly.pointList.AddTail((CObject*)&pt[3]);
*/
    if (pt != NULL)	delete []pt;
}

int compare (const void *a, const void *b)
{
	return ( *(int*)a - *(int*)b );
}

CString GetValueText(double fNum)
{
	CString str;
	if ((fNum >= 1.0e-6 && fNum < 1.0e+6) || fNum == 0)
		str.Format("%lf",fNum);
	else
		str.Format("%1.3e",fNum);
	return str;
}

double CLSPCMODEL::GetPointSourceWithDrawal(int nIndex,double lfSecs,double *lfVol,
											double *lfConc,COleDateTime tCurrent)
{
	// get the point source withdrawal if targeted to this stream
	double mptwd_target = 0.0;

	if(pPSReduction != NULL && pPtWithDrawal != NULL)
	{
		for (int mm=0; mm<nPtWithDrawal; ++mm)
		{
			int nPSIndex = -1;
			if (pChannelInfo[nIndex].rchid == pPtWithDrawal[mm].targetrchid)
				nPSIndex = GetPSIndex(pPtWithDrawal[mm].wdrawlrchid,pPtWithDrawal[mm].strPermit,pPtWithDrawal[mm].strPipe);

			if (nPSIndex <0)
				continue;

			double wd_vol = - GetTargetWithDrawal(nPSIndex, tCurrent) * lfSecs;	// ft3
			int nRIndex = FindReachIndex(pPtWithDrawal[mm].wdrawlrchid);

			if (wd_vol > lfVol[nRIndex])
				wd_vol = lfVol[nRIndex];

			mptwd_target += lfConc[nRIndex] * wd_vol * FT3_TO_M3;	// g/ivl
		}
	}

	return mptwd_target;
}

bool CLSPCMODEL::GetUpStreamAndUpBypassLoad(int nPolType,int nIndex,double &mup,
											double &mup_bypass)
{
	mup = 0.0;
	mup_bypass = 0.0;

	// upstream routed and bypassed load
	int nNum = pChannelInfo[nIndex].cListUppersOrder.GetSize();
	for(int j2=0; j2<nNum; j2++)
	{
		int nUpperReach = pChannelInfo[nIndex].cListUppersOrder.GetAt(j2);
		if(nUpperReach < 0 || nUpperReach >= nsws)
		{
			AfxMessageBox("Wrong NETWORK");
			return false;
		}
		else
		{
			for (int j3=0; j3<pChannelInfo[nUpperReach].nDSchan; j3++)
			{
				if (pChannelInfo[nIndex].rchid == pChannelInfo[nUpperReach].down_ch[j3])
				{
					switch(nPolType)
					{
					case POLUT_BOD:
						{
							mup += pChannelInfo[nUpperReach].down_bod[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_bod[j3];
						}
						break;
					case POLUT_CO2:
						{
							mup += pChannelInfo[nUpperReach].down_co2[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_co2[j3];
						}
						break;
					case POLUT_DOX:
						{
							mup += pChannelInfo[nUpperReach].down_dox[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_dox[j3];
						}
						break;
					case POLUT_NO2:
						{
							mup += pChannelInfo[nUpperReach].down_no2[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_no2[j3];
						}
						break;
					case POLUT_NO3:
						{
							mup += pChannelInfo[nUpperReach].down_no3[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_no3[j3];
						}
						break;
					case POLUT_ORC:
						{
							mup += pChannelInfo[nUpperReach].down_orc[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_orc[j3];
						}
						break;
					case POLUT_ORN:
						{
							mup += pChannelInfo[nUpperReach].down_orn[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_orn[j3];
						}
						break;
					case POLUT_ORP:
						{
							mup += pChannelInfo[nUpperReach].down_orp[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_orp[j3];
						}
						break;
					case POLUT_PHY:
						{
							mup += pChannelInfo[nUpperReach].down_phy[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_phy[j3];
						}
						break;
					case POLUT_PO4:
						{
							mup += pChannelInfo[nUpperReach].down_po4[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_po4[j3];
						}
						break;
					case POLUT_TAM:
						{
							mup += pChannelInfo[nUpperReach].down_tam[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_tam[j3];
						}
						break;
					case POLUT_TIC:
						{
							mup += pChannelInfo[nUpperReach].down_tic[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_tic[j3];
						}
						break;
					case POLUT_ZOO:
						{
							mup += pChannelInfo[nUpperReach].down_zoo[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_zoo[j3];
						}
						break;
					case POLUT_TEMP:
						{
							mup += pChannelInfo[nUpperReach].down_temp[j3];
							mup_bypass += pChannelInfo[nUpperReach].bypass_temp[j3];
						}
						break;
					default:
						break;
					}
				}
			}
		}
	}
	return true;
}

double CLSPCMODEL::GetBMPReductionLoad(int nPolType,int nQualIndex,int nStreamIndex,
									   int nMonth,double lfSeconds)
{
	double romatsum = 0.0;
	for (int j1=0; j1<ncrchOutlets; j1++)
	{
		if (pChannelInfo[nStreamIndex].rchid == pBMPReduction[j1].rchid)
		{
			for (int j2 =0; j2<pChannelInfo[nStreamIndex].nDSchan; j2++)
			{
				if (pMON_SWITCH[j1+j2].nSwitch[nMonth] == 0)
					continue;

				double limit = pBMPLimit[j1+j2].fLimit_qual[nQualIndex];	// mg/l 
				double fConc = 0.0;

				switch(nPolType)
				{
				case POLUT_BOD:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_bod[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_bod[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_bod[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_bod[j2];
					}
					break;
				case POLUT_DOX:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_dox[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_dox[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_dox[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_dox[j2];
					}
					break;
				case POLUT_NO2:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_no2[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_no2[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_no2[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_no2[j2];
					}
					break;
				case POLUT_NO3:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_no3[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_no3[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_no3[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_no3[j2];
					}
					break;
				case POLUT_ORC:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_orc[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_orc[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_orc[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_orc[j2];
					}
					break;
				case POLUT_ORN:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_orn[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_orn[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_orn[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_orn[j2];
					}
					break;
				case POLUT_ORP:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_orp[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_orp[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_orp[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_orp[j2];
					}
					break;
				case POLUT_PO4:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_po4[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_po4[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_po4[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_po4[j2];
					}
					break;
				case POLUT_TAM:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_tam[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_tam[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_tam[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_tam[j2];
					}
					break;
				case POLUT_TEMP:
					{
						if (pChannelInfo[nStreamIndex].down_flow[j2] > 0)
							fConc = pChannelInfo[nStreamIndex].down_temp[j2]/(pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds);
						if (limit >= 0 &&  fConc > limit)	
							pChannelInfo[nStreamIndex].down_temp[j2] = limit*pChannelInfo[nStreamIndex].down_flow[j2]*FT3_TO_M3*lfSeconds;
						pChannelInfo[nStreamIndex].down_temp[j2] *= (1 - pBMPReduction[j1+j2].fReduction_qual[nQualIndex]);	
						romatsum += pChannelInfo[nStreamIndex].down_temp[j2];
					}
					break;
				default:
					break;
				}
			}
			break;
		}
	}
	return romatsum;
}

bool CLSPCMODEL::ProcessLanduseData()
{
	if(cLU.pLUDATA == NULL || pluinfop == NULL)
		return false;

	for(int i=0; i<cLU.nNumLUchangeRecords; i++)
	{
		for (int j=0; j<nsws*nlandp; j++)
		{
			if (cLU.pLUDATA[i].nSUBBASIN == pluinfop[j].subbasin && cLU.pLUDATA[i].nDELUID == pluinfop[j].luid)
			{
				pluinfop[j].bLUchange = true;
				if (pluinfop[j].sindex == -1)
					pluinfop[j].sindex = i;
				pluinfop[j].records++;
				break;
			}
		}
	}
	return true;
}

bool CLSPCMODEL::ProcessPointSourceSummaryData()
{
	if(pChannelInfo == NULL)
		return false;

	for(int i=0; i<nch; i++)
	{
		if(!pChannelInfo[i].cListPointSources.IsEmpty())
		{
			POSITION pos = pChannelInfo[i].cListPointSources.GetHeadPosition();
			while (pos != NULL)
			{
				PS_SUMMARY& pPS_SUMMARY = (PS_SUMMARY&) pChannelInfo[i].cListPointSources.GetNext(pos);
				if(nQuals > 0)
				{
					//assign memory
					if(pPS_SUMMARY.pGQual != NULL)
						delete []pPS_SUMMARY.pGQual;
					pPS_SUMMARY.pGQual = new double[nQuals];
					//initialize
					for(int k=0; k<nQuals; k++)
						pPS_SUMMARY.pGQual[k] = 0.;
				}
			}
		}
	}
	return true;
}

bool CLSPCMODEL::CalculateSandSiltClayFractions(double *fr_sand, double *fr_silt, double *fr_clay, double *fr_sand_bs, double *fr_silt_bs, double *fr_clay_bs)
{
	if(fr_sand == NULL || fr_silt == NULL || fr_clay == NULL)
		return false;

	if(fr_sand_bs == NULL || fr_silt_bs == NULL || fr_clay_bs == NULL)
		return false;

	if(rsd_param == NULL || psd_param2 == NULL || pReachInfo == NULL || pswsinfo == NULL)
		return false;

	for (int i=0; i<nsws; i++)
	{
		int lgroup = pswsinfo[i].gindex;
		int rgroup = pReachInfo[i].rgid - 1;  

		for (int j=0; j<nlandp; j++)
		{
			//initialize to zero
			fr_sand[i*nlandp+j] = 0.0;
			fr_silt[i*nlandp+j] = 0.0;
			fr_clay[i*nlandp+j] = 0.0;
			fr_sand_bs[i*nlandp+j] = 0.0;
			fr_silt_bs[i*nlandp+j] = 0.0;
			fr_clay_bs[i*nlandp+j] = 0.0;

			for (int k=0; k<NumSed; k++)
			{
				if (rsd_param[rgroup*NumSed+k].sedflg == 0)//sand
				{
					fr_sand_bs[i*nlandp+j] += psd_param2[lgroup*nlandp+j].sed[k];
				}
				else if (rsd_param[rgroup*NumSed+k].sedflg == 1)//silt
				{
					fr_silt_bs[i*nlandp+j] += psd_param2[lgroup*nlandp+j].sed[k];
				}
				else if (rsd_param[rgroup*NumSed+k].sedflg == 2)//clay
				{
					fr_clay_bs[i*nlandp+j] += psd_param2[lgroup*nlandp+j].sed[k];
				}
			}

			//normalize the fractions
//			double totalsed_fr = fr_sand_bs[i*nlandp+j]+fr_silt_bs[i*nlandp+j]+fr_clay_bs[i*nlandp+j];
//			if (totalsed_fr > 0)
//			{
//				fr_sand[i*nlandp+j] = fr_sand_bs[i*nlandp+j]/totalsed_fr; 
//				fr_silt[i*nlandp+j] = fr_silt_bs[i*nlandp+j]/totalsed_fr; 
//				fr_clay[i*nlandp+j] = fr_clay_bs[i*nlandp+j]/totalsed_fr; 
//			}

			//DO NOT normalize (JR - 2/25/2010)
			fr_sand[i*nlandp+j] = fr_sand_bs[i*nlandp+j]; 
			fr_silt[i*nlandp+j] = fr_silt_bs[i*nlandp+j]; 
			fr_clay[i*nlandp+j] = fr_clay_bs[i*nlandp+j]; 
		}
	}
	return true;
}

bool CLSPCMODEL::ApplyStreamIceMelt(int nIndex,double tw,double wyield,double pdepth,
									double *q2,double *q2_frozen)
{
	if(q2 == NULL || q2_frozen == NULL)
		return false;

	// special case for stream frozen conditions at 0.5 degree C
	if (tw > 0.5)
	{
		//check if there is any ice melt in the reach
		double meltrate = 0.0;
		double icemelt = 0.0;
		
		//check if water yield from snow pack (accumulative) occurs
		if (wyield > 0)
		{
			//check snow pack depth (accumulative)
			if (pdepth > 0)
			{
				meltrate = wyield/pdepth;
				
				if (meltrate > 1)
					meltrate = 1.0;
			}
			else
			{
				meltrate = 1.0;
			}
		}

		//add ice melt from the reach to the stream outflow
		icemelt = meltrate * q2_frozen[nIndex];
		q2[nIndex] += icemelt;

		//update the frozen flow 
		q2_frozen[nIndex] -= icemelt;

		//divide ice melt equally among exits (exit outflow is calculated in ROUTE function)
		for (int j=0; j<pChannelInfo[nIndex].nDSchan; j++)
			pChannelInfo[nIndex].down_flow[j] += (icemelt / pChannelInfo[nIndex].nDSchan);
	}
	else
	{
		//there is no outflow from the reach (frozen condition)
		q2_frozen[nIndex] += q2[nIndex];
		q2[nIndex] = 0.0;

		//no outflow among exits (exit outflow is calculated in ROUTE function)
		for (int j=0; j<pChannelInfo[nIndex].nDSchan; j++)
			pChannelInfo[nIndex].down_flow[j] = 0.0;
	}
	return true;
}

bool FolderExists(CString strFolderPath)
{   
    //return GetFileAttributes(strFolderName) == FILE_ATTRIBUTE_DIRECTORY;  
	bool bRes = false;
	CFileFind ff;
	CString strPath = strFolderPath;
	if(strPath.Right(1) == "\\")
		strPath = strPath.Left(strPath.GetLength()-1);

	//find the one level up folder
	int nPathLength = strPath.GetLength();
	int nFolderLength = nPathLength - strPath.ReverseFind('\\') - 1;
	CString strName = strPath.Right(nFolderLength);
	strPath = strPath.Left(nPathLength - nFolderLength);
	strPath += "*.*";

	BOOL bResult = ff.FindFile(strPath);
	while(bResult)
	{
		bResult = ff.FindNextFile();
		if(ff.IsDirectory()) 
		{
			CString strDirName = ff.GetFileName();
			if(strName.CompareNoCase(strDirName) == 0)
			{
				bRes = true;
				break;
			}
		}
		else
		{
			CString strFileName = ff.GetFileName();
			if(strName.CompareNoCase(strFileName) == 0)
			{
				bRes = true;
				break;
			}
		}
	}
	ff.Close(); 
	return bRes;
}

bool DuplicateExists(int nArraySize, CString* strArray)
{
	bool bRes = false;

	for (int i=0; i<nArraySize; i++)
	{
		int nCount = 0;
		for (int j=0; j<nArraySize; j++)
		{
			if (strArray[i].CompareNoCase(strArray[j]) == 0)
				nCount += 1;
		}
		if (nCount > 1)
		{
			bRes = true;
			break;
		}
	}
	return bRes;
}
